
RoombaCommander_ATmega64.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000020  00800100  00000ce0  00000d74  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000ce0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000063e  00800120  00800120  00000d94  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000d94  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000dc4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000248  00000000  00000000  00000e00  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002a60  00000000  00000000  00001048  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000f85  00000000  00000000  00003aa8  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001810  00000000  00000000  00004a2d  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000614  00000000  00000000  00006240  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000faa  00000000  00000000  00006854  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001f64  00000000  00000000  000077fe  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000260  00000000  00000000  00009762  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 46 00 	jmp	0x8c	; 0x8c <__ctors_end>
   4:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
   8:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
   c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  10:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  14:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  18:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  1c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  20:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  24:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  28:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  2c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  30:	0c 94 46 02 	jmp	0x48c	; 0x48c <__vector_12>
  34:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  38:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  3c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  40:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  44:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  48:	0c 94 48 06 	jmp	0xc90	; 0xc90 <__vector_18>
  4c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  50:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  54:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  58:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  5c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  60:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  64:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  68:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  6c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  70:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  74:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  78:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  7c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  80:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  84:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  88:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>

0000008c <__ctors_end>:
  8c:	11 24       	eor	r1, r1
  8e:	1f be       	out	0x3f, r1	; 63
  90:	cf ef       	ldi	r28, 0xFF	; 255
  92:	d0 e1       	ldi	r29, 0x10	; 16
  94:	de bf       	out	0x3e, r29	; 62
  96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
  98:	11 e0       	ldi	r17, 0x01	; 1
  9a:	a0 e0       	ldi	r26, 0x00	; 0
  9c:	b1 e0       	ldi	r27, 0x01	; 1
  9e:	e0 ee       	ldi	r30, 0xE0	; 224
  a0:	fc e0       	ldi	r31, 0x0C	; 12
  a2:	02 c0       	rjmp	.+4      	; 0xa8 <__do_copy_data+0x10>
  a4:	05 90       	lpm	r0, Z+
  a6:	0d 92       	st	X+, r0
  a8:	a0 32       	cpi	r26, 0x20	; 32
  aa:	b1 07       	cpc	r27, r17
  ac:	d9 f7       	brne	.-10     	; 0xa4 <__do_copy_data+0xc>

000000ae <__do_clear_bss>:
  ae:	27 e0       	ldi	r18, 0x07	; 7
  b0:	a0 e2       	ldi	r26, 0x20	; 32
  b2:	b1 e0       	ldi	r27, 0x01	; 1
  b4:	01 c0       	rjmp	.+2      	; 0xb8 <.do_clear_bss_start>

000000b6 <.do_clear_bss_loop>:
  b6:	1d 92       	st	X+, r1

000000b8 <.do_clear_bss_start>:
  b8:	ae 35       	cpi	r26, 0x5E	; 94
  ba:	b2 07       	cpc	r27, r18
  bc:	e1 f7       	brne	.-8      	; 0xb6 <.do_clear_bss_loop>
  be:	0e 94 21 06 	call	0xc42	; 0xc42 <main>
  c2:	0c 94 6e 06 	jmp	0xcdc	; 0xcdc <_exit>

000000c6 <__bad_interrupt>:
  c6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ca <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
  ca:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
  cc:	03 96       	adiw	r24, 0x03	; 3
  ce:	92 83       	std	Z+2, r25	; 0x02
  d0:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
  d2:	2f ef       	ldi	r18, 0xFF	; 255
  d4:	3f ef       	ldi	r19, 0xFF	; 255
  d6:	34 83       	std	Z+4, r19	; 0x04
  d8:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
  da:	96 83       	std	Z+6, r25	; 0x06
  dc:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
  de:	90 87       	std	Z+8, r25	; 0x08
  e0:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
  e2:	10 82       	st	Z, r1
  e4:	08 95       	ret

000000e6 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
  e6:	fc 01       	movw	r30, r24
  e8:	11 86       	std	Z+9, r1	; 0x09
  ea:	10 86       	std	Z+8, r1	; 0x08
  ec:	08 95       	ret

000000ee <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
  ee:	cf 93       	push	r28
  f0:	df 93       	push	r29
  f2:	9c 01       	movw	r18, r24
  f4:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
  f6:	dc 01       	movw	r26, r24
  f8:	11 96       	adiw	r26, 0x01	; 1
  fa:	cd 91       	ld	r28, X+
  fc:	dc 91       	ld	r29, X
  fe:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 100:	d3 83       	std	Z+3, r29	; 0x03
 102:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 104:	8c 81       	ldd	r24, Y+4	; 0x04
 106:	9d 81       	ldd	r25, Y+5	; 0x05
 108:	95 83       	std	Z+5, r25	; 0x05
 10a:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 10c:	8c 81       	ldd	r24, Y+4	; 0x04
 10e:	9d 81       	ldd	r25, Y+5	; 0x05
 110:	dc 01       	movw	r26, r24
 112:	13 96       	adiw	r26, 0x03	; 3
 114:	7c 93       	st	X, r23
 116:	6e 93       	st	-X, r22
 118:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
 11a:	7d 83       	std	Y+5, r23	; 0x05
 11c:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 11e:	31 87       	std	Z+9, r19	; 0x09
 120:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
 122:	f9 01       	movw	r30, r18
 124:	80 81       	ld	r24, Z
 126:	8f 5f       	subi	r24, 0xFF	; 255
 128:	80 83       	st	Z, r24
}
 12a:	df 91       	pop	r29
 12c:	cf 91       	pop	r28
 12e:	08 95       	ret

00000130 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 130:	cf 93       	push	r28
 132:	df 93       	push	r29
 134:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 136:	48 81       	ld	r20, Y
 138:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 13a:	4f 3f       	cpi	r20, 0xFF	; 255
 13c:	2f ef       	ldi	r18, 0xFF	; 255
 13e:	52 07       	cpc	r21, r18
 140:	21 f4       	brne	.+8      	; 0x14a <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 142:	fc 01       	movw	r30, r24
 144:	a7 81       	ldd	r26, Z+7	; 0x07
 146:	b0 85       	ldd	r27, Z+8	; 0x08
 148:	0d c0       	rjmp	.+26     	; 0x164 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 14a:	dc 01       	movw	r26, r24
 14c:	13 96       	adiw	r26, 0x03	; 3
 14e:	01 c0       	rjmp	.+2      	; 0x152 <vListInsert+0x22>
 150:	df 01       	movw	r26, r30
 152:	12 96       	adiw	r26, 0x02	; 2
 154:	ed 91       	ld	r30, X+
 156:	fc 91       	ld	r31, X
 158:	13 97       	sbiw	r26, 0x03	; 3
 15a:	20 81       	ld	r18, Z
 15c:	31 81       	ldd	r19, Z+1	; 0x01
 15e:	42 17       	cp	r20, r18
 160:	53 07       	cpc	r21, r19
 162:	b0 f7       	brcc	.-20     	; 0x150 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 164:	12 96       	adiw	r26, 0x02	; 2
 166:	ed 91       	ld	r30, X+
 168:	fc 91       	ld	r31, X
 16a:	13 97       	sbiw	r26, 0x03	; 3
 16c:	fb 83       	std	Y+3, r31	; 0x03
 16e:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 170:	d5 83       	std	Z+5, r29	; 0x05
 172:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
 174:	bd 83       	std	Y+5, r27	; 0x05
 176:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
 178:	13 96       	adiw	r26, 0x03	; 3
 17a:	dc 93       	st	X, r29
 17c:	ce 93       	st	-X, r28
 17e:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 180:	99 87       	std	Y+9, r25	; 0x09
 182:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
 184:	fc 01       	movw	r30, r24
 186:	20 81       	ld	r18, Z
 188:	2f 5f       	subi	r18, 0xFF	; 255
 18a:	20 83       	st	Z, r18
}
 18c:	df 91       	pop	r29
 18e:	cf 91       	pop	r28
 190:	08 95       	ret

00000192 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
 192:	cf 93       	push	r28
 194:	df 93       	push	r29
 196:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 198:	a0 85       	ldd	r26, Z+8	; 0x08
 19a:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 19c:	c2 81       	ldd	r28, Z+2	; 0x02
 19e:	d3 81       	ldd	r29, Z+3	; 0x03
 1a0:	84 81       	ldd	r24, Z+4	; 0x04
 1a2:	95 81       	ldd	r25, Z+5	; 0x05
 1a4:	9d 83       	std	Y+5, r25	; 0x05
 1a6:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 1a8:	c4 81       	ldd	r28, Z+4	; 0x04
 1aa:	d5 81       	ldd	r29, Z+5	; 0x05
 1ac:	82 81       	ldd	r24, Z+2	; 0x02
 1ae:	93 81       	ldd	r25, Z+3	; 0x03
 1b0:	9b 83       	std	Y+3, r25	; 0x03
 1b2:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 1b4:	11 96       	adiw	r26, 0x01	; 1
 1b6:	8d 91       	ld	r24, X+
 1b8:	9c 91       	ld	r25, X
 1ba:	12 97       	sbiw	r26, 0x02	; 2
 1bc:	e8 17       	cp	r30, r24
 1be:	f9 07       	cpc	r31, r25
 1c0:	31 f4       	brne	.+12     	; 0x1ce <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 1c2:	84 81       	ldd	r24, Z+4	; 0x04
 1c4:	95 81       	ldd	r25, Z+5	; 0x05
 1c6:	12 96       	adiw	r26, 0x02	; 2
 1c8:	9c 93       	st	X, r25
 1ca:	8e 93       	st	-X, r24
 1cc:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 1ce:	11 86       	std	Z+9, r1	; 0x09
 1d0:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
 1d2:	8c 91       	ld	r24, X
 1d4:	81 50       	subi	r24, 0x01	; 1
 1d6:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
 1d8:	df 91       	pop	r29
 1da:	cf 91       	pop	r28
 1dc:	08 95       	ret

000001de <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
 1de:	31 e1       	ldi	r19, 0x11	; 17
 1e0:	fc 01       	movw	r30, r24
 1e2:	30 83       	st	Z, r19
 1e4:	31 97       	sbiw	r30, 0x01	; 1
 1e6:	22 e2       	ldi	r18, 0x22	; 34
 1e8:	20 83       	st	Z, r18
 1ea:	31 97       	sbiw	r30, 0x01	; 1
 1ec:	a3 e3       	ldi	r26, 0x33	; 51
 1ee:	a0 83       	st	Z, r26
 1f0:	31 97       	sbiw	r30, 0x01	; 1
 1f2:	60 83       	st	Z, r22
 1f4:	31 97       	sbiw	r30, 0x01	; 1
 1f6:	70 83       	st	Z, r23
 1f8:	31 97       	sbiw	r30, 0x01	; 1
 1fa:	10 82       	st	Z, r1
 1fc:	31 97       	sbiw	r30, 0x01	; 1
 1fe:	60 e8       	ldi	r22, 0x80	; 128
 200:	60 83       	st	Z, r22
 202:	31 97       	sbiw	r30, 0x01	; 1
 204:	10 82       	st	Z, r1
 206:	31 97       	sbiw	r30, 0x01	; 1
 208:	62 e0       	ldi	r22, 0x02	; 2
 20a:	60 83       	st	Z, r22
 20c:	31 97       	sbiw	r30, 0x01	; 1
 20e:	63 e0       	ldi	r22, 0x03	; 3
 210:	60 83       	st	Z, r22
 212:	31 97       	sbiw	r30, 0x01	; 1
 214:	64 e0       	ldi	r22, 0x04	; 4
 216:	60 83       	st	Z, r22
 218:	31 97       	sbiw	r30, 0x01	; 1
 21a:	65 e0       	ldi	r22, 0x05	; 5
 21c:	60 83       	st	Z, r22
 21e:	31 97       	sbiw	r30, 0x01	; 1
 220:	66 e0       	ldi	r22, 0x06	; 6
 222:	60 83       	st	Z, r22
 224:	31 97       	sbiw	r30, 0x01	; 1
 226:	67 e0       	ldi	r22, 0x07	; 7
 228:	60 83       	st	Z, r22
 22a:	31 97       	sbiw	r30, 0x01	; 1
 22c:	68 e0       	ldi	r22, 0x08	; 8
 22e:	60 83       	st	Z, r22
 230:	31 97       	sbiw	r30, 0x01	; 1
 232:	69 e0       	ldi	r22, 0x09	; 9
 234:	60 83       	st	Z, r22
 236:	31 97       	sbiw	r30, 0x01	; 1
 238:	60 e1       	ldi	r22, 0x10	; 16
 23a:	60 83       	st	Z, r22
 23c:	31 97       	sbiw	r30, 0x01	; 1
 23e:	30 83       	st	Z, r19
 240:	31 97       	sbiw	r30, 0x01	; 1
 242:	32 e1       	ldi	r19, 0x12	; 18
 244:	30 83       	st	Z, r19
 246:	31 97       	sbiw	r30, 0x01	; 1
 248:	33 e1       	ldi	r19, 0x13	; 19
 24a:	30 83       	st	Z, r19
 24c:	31 97       	sbiw	r30, 0x01	; 1
 24e:	34 e1       	ldi	r19, 0x14	; 20
 250:	30 83       	st	Z, r19
 252:	31 97       	sbiw	r30, 0x01	; 1
 254:	35 e1       	ldi	r19, 0x15	; 21
 256:	30 83       	st	Z, r19
 258:	31 97       	sbiw	r30, 0x01	; 1
 25a:	36 e1       	ldi	r19, 0x16	; 22
 25c:	30 83       	st	Z, r19
 25e:	31 97       	sbiw	r30, 0x01	; 1
 260:	37 e1       	ldi	r19, 0x17	; 23
 262:	30 83       	st	Z, r19
 264:	31 97       	sbiw	r30, 0x01	; 1
 266:	38 e1       	ldi	r19, 0x18	; 24
 268:	30 83       	st	Z, r19
 26a:	31 97       	sbiw	r30, 0x01	; 1
 26c:	39 e1       	ldi	r19, 0x19	; 25
 26e:	30 83       	st	Z, r19
 270:	31 97       	sbiw	r30, 0x01	; 1
 272:	30 e2       	ldi	r19, 0x20	; 32
 274:	30 83       	st	Z, r19
 276:	31 97       	sbiw	r30, 0x01	; 1
 278:	31 e2       	ldi	r19, 0x21	; 33
 27a:	30 83       	st	Z, r19
 27c:	31 97       	sbiw	r30, 0x01	; 1
 27e:	20 83       	st	Z, r18
 280:	31 97       	sbiw	r30, 0x01	; 1
 282:	23 e2       	ldi	r18, 0x23	; 35
 284:	20 83       	st	Z, r18
 286:	31 97       	sbiw	r30, 0x01	; 1
 288:	40 83       	st	Z, r20
 28a:	31 97       	sbiw	r30, 0x01	; 1
 28c:	50 83       	st	Z, r21
 28e:	31 97       	sbiw	r30, 0x01	; 1
 290:	26 e2       	ldi	r18, 0x26	; 38
 292:	20 83       	st	Z, r18
 294:	31 97       	sbiw	r30, 0x01	; 1
 296:	27 e2       	ldi	r18, 0x27	; 39
 298:	20 83       	st	Z, r18
 29a:	31 97       	sbiw	r30, 0x01	; 1
 29c:	28 e2       	ldi	r18, 0x28	; 40
 29e:	20 83       	st	Z, r18
 2a0:	31 97       	sbiw	r30, 0x01	; 1
 2a2:	29 e2       	ldi	r18, 0x29	; 41
 2a4:	20 83       	st	Z, r18
 2a6:	31 97       	sbiw	r30, 0x01	; 1
 2a8:	20 e3       	ldi	r18, 0x30	; 48
 2aa:	20 83       	st	Z, r18
 2ac:	31 97       	sbiw	r30, 0x01	; 1
 2ae:	21 e3       	ldi	r18, 0x31	; 49
 2b0:	20 83       	st	Z, r18
 2b2:	86 97       	sbiw	r24, 0x26	; 38
 2b4:	08 95       	ret

000002b6 <xPortStartScheduler>:
 2b6:	86 e0       	ldi	r24, 0x06	; 6
 2b8:	8b bd       	out	0x2b, r24	; 43
 2ba:	8f eb       	ldi	r24, 0xBF	; 191
 2bc:	8a bd       	out	0x2a, r24	; 42
 2be:	8b e0       	ldi	r24, 0x0B	; 11
 2c0:	8e bd       	out	0x2e, r24	; 46
 2c2:	87 b7       	in	r24, 0x37	; 55
 2c4:	80 61       	ori	r24, 0x10	; 16
 2c6:	87 bf       	out	0x37, r24	; 55
 2c8:	a0 91 5b 07 	lds	r26, 0x075B	; 0x80075b <pxCurrentTCB>
 2cc:	b0 91 5c 07 	lds	r27, 0x075C	; 0x80075c <pxCurrentTCB+0x1>
 2d0:	cd 91       	ld	r28, X+
 2d2:	cd bf       	out	0x3d, r28	; 61
 2d4:	dd 91       	ld	r29, X+
 2d6:	de bf       	out	0x3e, r29	; 62
 2d8:	ff 91       	pop	r31
 2da:	ef 91       	pop	r30
 2dc:	df 91       	pop	r29
 2de:	cf 91       	pop	r28
 2e0:	bf 91       	pop	r27
 2e2:	af 91       	pop	r26
 2e4:	9f 91       	pop	r25
 2e6:	8f 91       	pop	r24
 2e8:	7f 91       	pop	r23
 2ea:	6f 91       	pop	r22
 2ec:	5f 91       	pop	r21
 2ee:	4f 91       	pop	r20
 2f0:	3f 91       	pop	r19
 2f2:	2f 91       	pop	r18
 2f4:	1f 91       	pop	r17
 2f6:	0f 91       	pop	r16
 2f8:	ff 90       	pop	r15
 2fa:	ef 90       	pop	r14
 2fc:	df 90       	pop	r13
 2fe:	cf 90       	pop	r12
 300:	bf 90       	pop	r11
 302:	af 90       	pop	r10
 304:	9f 90       	pop	r9
 306:	8f 90       	pop	r8
 308:	7f 90       	pop	r7
 30a:	6f 90       	pop	r6
 30c:	5f 90       	pop	r5
 30e:	4f 90       	pop	r4
 310:	3f 90       	pop	r3
 312:	2f 90       	pop	r2
 314:	1f 90       	pop	r1
 316:	0f 90       	pop	r0
 318:	0f be       	out	0x3f, r0	; 63
 31a:	0f 90       	pop	r0
 31c:	08 95       	ret
 31e:	81 e0       	ldi	r24, 0x01	; 1
 320:	08 95       	ret

00000322 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
 322:	0f 92       	push	r0
 324:	0f b6       	in	r0, 0x3f	; 63
 326:	f8 94       	cli
 328:	0f 92       	push	r0
 32a:	1f 92       	push	r1
 32c:	11 24       	eor	r1, r1
 32e:	2f 92       	push	r2
 330:	3f 92       	push	r3
 332:	4f 92       	push	r4
 334:	5f 92       	push	r5
 336:	6f 92       	push	r6
 338:	7f 92       	push	r7
 33a:	8f 92       	push	r8
 33c:	9f 92       	push	r9
 33e:	af 92       	push	r10
 340:	bf 92       	push	r11
 342:	cf 92       	push	r12
 344:	df 92       	push	r13
 346:	ef 92       	push	r14
 348:	ff 92       	push	r15
 34a:	0f 93       	push	r16
 34c:	1f 93       	push	r17
 34e:	2f 93       	push	r18
 350:	3f 93       	push	r19
 352:	4f 93       	push	r20
 354:	5f 93       	push	r21
 356:	6f 93       	push	r22
 358:	7f 93       	push	r23
 35a:	8f 93       	push	r24
 35c:	9f 93       	push	r25
 35e:	af 93       	push	r26
 360:	bf 93       	push	r27
 362:	cf 93       	push	r28
 364:	df 93       	push	r29
 366:	ef 93       	push	r30
 368:	ff 93       	push	r31
 36a:	a0 91 5b 07 	lds	r26, 0x075B	; 0x80075b <pxCurrentTCB>
 36e:	b0 91 5c 07 	lds	r27, 0x075C	; 0x80075c <pxCurrentTCB+0x1>
 372:	0d b6       	in	r0, 0x3d	; 61
 374:	0d 92       	st	X+, r0
 376:	0e b6       	in	r0, 0x3e	; 62
 378:	0d 92       	st	X+, r0
	vTaskSwitchContext();
 37a:	0e 94 a5 05 	call	0xb4a	; 0xb4a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
 37e:	a0 91 5b 07 	lds	r26, 0x075B	; 0x80075b <pxCurrentTCB>
 382:	b0 91 5c 07 	lds	r27, 0x075C	; 0x80075c <pxCurrentTCB+0x1>
 386:	cd 91       	ld	r28, X+
 388:	cd bf       	out	0x3d, r28	; 61
 38a:	dd 91       	ld	r29, X+
 38c:	de bf       	out	0x3e, r29	; 62
 38e:	ff 91       	pop	r31
 390:	ef 91       	pop	r30
 392:	df 91       	pop	r29
 394:	cf 91       	pop	r28
 396:	bf 91       	pop	r27
 398:	af 91       	pop	r26
 39a:	9f 91       	pop	r25
 39c:	8f 91       	pop	r24
 39e:	7f 91       	pop	r23
 3a0:	6f 91       	pop	r22
 3a2:	5f 91       	pop	r21
 3a4:	4f 91       	pop	r20
 3a6:	3f 91       	pop	r19
 3a8:	2f 91       	pop	r18
 3aa:	1f 91       	pop	r17
 3ac:	0f 91       	pop	r16
 3ae:	ff 90       	pop	r15
 3b0:	ef 90       	pop	r14
 3b2:	df 90       	pop	r13
 3b4:	cf 90       	pop	r12
 3b6:	bf 90       	pop	r11
 3b8:	af 90       	pop	r10
 3ba:	9f 90       	pop	r9
 3bc:	8f 90       	pop	r8
 3be:	7f 90       	pop	r7
 3c0:	6f 90       	pop	r6
 3c2:	5f 90       	pop	r5
 3c4:	4f 90       	pop	r4
 3c6:	3f 90       	pop	r3
 3c8:	2f 90       	pop	r2
 3ca:	1f 90       	pop	r1
 3cc:	0f 90       	pop	r0
 3ce:	0f be       	out	0x3f, r0	; 63
 3d0:	0f 90       	pop	r0

	asm volatile ( "ret" );
 3d2:	08 95       	ret

000003d4 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
 3d4:	0f 92       	push	r0
 3d6:	0f b6       	in	r0, 0x3f	; 63
 3d8:	f8 94       	cli
 3da:	0f 92       	push	r0
 3dc:	1f 92       	push	r1
 3de:	11 24       	eor	r1, r1
 3e0:	2f 92       	push	r2
 3e2:	3f 92       	push	r3
 3e4:	4f 92       	push	r4
 3e6:	5f 92       	push	r5
 3e8:	6f 92       	push	r6
 3ea:	7f 92       	push	r7
 3ec:	8f 92       	push	r8
 3ee:	9f 92       	push	r9
 3f0:	af 92       	push	r10
 3f2:	bf 92       	push	r11
 3f4:	cf 92       	push	r12
 3f6:	df 92       	push	r13
 3f8:	ef 92       	push	r14
 3fa:	ff 92       	push	r15
 3fc:	0f 93       	push	r16
 3fe:	1f 93       	push	r17
 400:	2f 93       	push	r18
 402:	3f 93       	push	r19
 404:	4f 93       	push	r20
 406:	5f 93       	push	r21
 408:	6f 93       	push	r22
 40a:	7f 93       	push	r23
 40c:	8f 93       	push	r24
 40e:	9f 93       	push	r25
 410:	af 93       	push	r26
 412:	bf 93       	push	r27
 414:	cf 93       	push	r28
 416:	df 93       	push	r29
 418:	ef 93       	push	r30
 41a:	ff 93       	push	r31
 41c:	a0 91 5b 07 	lds	r26, 0x075B	; 0x80075b <pxCurrentTCB>
 420:	b0 91 5c 07 	lds	r27, 0x075C	; 0x80075c <pxCurrentTCB+0x1>
 424:	0d b6       	in	r0, 0x3d	; 61
 426:	0d 92       	st	X+, r0
 428:	0e b6       	in	r0, 0x3e	; 62
 42a:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
 42c:	0e 94 1a 04 	call	0x834	; 0x834 <xTaskIncrementTick>
 430:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
 432:	0e 94 a5 05 	call	0xb4a	; 0xb4a <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
 436:	a0 91 5b 07 	lds	r26, 0x075B	; 0x80075b <pxCurrentTCB>
 43a:	b0 91 5c 07 	lds	r27, 0x075C	; 0x80075c <pxCurrentTCB+0x1>
 43e:	cd 91       	ld	r28, X+
 440:	cd bf       	out	0x3d, r28	; 61
 442:	dd 91       	ld	r29, X+
 444:	de bf       	out	0x3e, r29	; 62
 446:	ff 91       	pop	r31
 448:	ef 91       	pop	r30
 44a:	df 91       	pop	r29
 44c:	cf 91       	pop	r28
 44e:	bf 91       	pop	r27
 450:	af 91       	pop	r26
 452:	9f 91       	pop	r25
 454:	8f 91       	pop	r24
 456:	7f 91       	pop	r23
 458:	6f 91       	pop	r22
 45a:	5f 91       	pop	r21
 45c:	4f 91       	pop	r20
 45e:	3f 91       	pop	r19
 460:	2f 91       	pop	r18
 462:	1f 91       	pop	r17
 464:	0f 91       	pop	r16
 466:	ff 90       	pop	r15
 468:	ef 90       	pop	r14
 46a:	df 90       	pop	r13
 46c:	cf 90       	pop	r12
 46e:	bf 90       	pop	r11
 470:	af 90       	pop	r10
 472:	9f 90       	pop	r9
 474:	8f 90       	pop	r8
 476:	7f 90       	pop	r7
 478:	6f 90       	pop	r6
 47a:	5f 90       	pop	r5
 47c:	4f 90       	pop	r4
 47e:	3f 90       	pop	r3
 480:	2f 90       	pop	r2
 482:	1f 90       	pop	r1
 484:	0f 90       	pop	r0
 486:	0f be       	out	0x3f, r0	; 63
 488:	0f 90       	pop	r0

	asm volatile ( "ret" );
 48a:	08 95       	ret

0000048c <__vector_12>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
 48c:	0e 94 ea 01 	call	0x3d4	; 0x3d4 <vPortYieldFromTick>
		asm volatile ( "reti" );
 490:	18 95       	reti

00000492 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 492:	cf 93       	push	r28
 494:	df 93       	push	r29
 496:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
 498:	0e 94 14 04 	call	0x828	; 0x828 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
 49c:	80 91 20 01 	lds	r24, 0x0120	; 0x800120 <__data_end>
 4a0:	90 91 21 01 	lds	r25, 0x0121	; 0x800121 <__data_end+0x1>
 4a4:	89 2b       	or	r24, r25
 4a6:	31 f4       	brne	.+12     	; 0x4b4 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
 4a8:	85 e2       	ldi	r24, 0x25	; 37
 4aa:	91 e0       	ldi	r25, 0x01	; 1
 4ac:	90 93 21 01 	sts	0x0121, r25	; 0x800121 <__data_end+0x1>
 4b0:	80 93 20 01 	sts	0x0120, r24	; 0x800120 <__data_end>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
 4b4:	20 91 22 01 	lds	r18, 0x0122	; 0x800122 <xNextFreeByte>
 4b8:	30 91 23 01 	lds	r19, 0x0123	; 0x800123 <xNextFreeByte+0x1>
 4bc:	c9 01       	movw	r24, r18
 4be:	8c 0f       	add	r24, r28
 4c0:	9d 1f       	adc	r25, r29
 4c2:	8b 3d       	cpi	r24, 0xDB	; 219
 4c4:	45 e0       	ldi	r20, 0x05	; 5
 4c6:	94 07       	cpc	r25, r20
 4c8:	70 f4       	brcc	.+28     	; 0x4e6 <pvPortMalloc+0x54>
 4ca:	28 17       	cp	r18, r24
 4cc:	39 07       	cpc	r19, r25
 4ce:	70 f4       	brcc	.+28     	; 0x4ec <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
 4d0:	c0 91 20 01 	lds	r28, 0x0120	; 0x800120 <__data_end>
 4d4:	d0 91 21 01 	lds	r29, 0x0121	; 0x800121 <__data_end+0x1>
 4d8:	c2 0f       	add	r28, r18
 4da:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
 4dc:	90 93 23 01 	sts	0x0123, r25	; 0x800123 <xNextFreeByte+0x1>
 4e0:	80 93 22 01 	sts	0x0122, r24	; 0x800122 <xNextFreeByte>
 4e4:	05 c0       	rjmp	.+10     	; 0x4f0 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
 4e6:	c0 e0       	ldi	r28, 0x00	; 0
 4e8:	d0 e0       	ldi	r29, 0x00	; 0
 4ea:	02 c0       	rjmp	.+4      	; 0x4f0 <pvPortMalloc+0x5e>
 4ec:	c0 e0       	ldi	r28, 0x00	; 0
 4ee:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
 4f0:	0e 94 d5 04 	call	0x9aa	; 0x9aa <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
 4f4:	ce 01       	movw	r24, r28
 4f6:	df 91       	pop	r29
 4f8:	cf 91       	pop	r28
 4fa:	08 95       	ret

000004fc <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 4fc:	08 95       	ret

000004fe <prvResetNextTaskUnblockTime>:
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 4fe:	e0 91 23 07 	lds	r30, 0x0723	; 0x800723 <pxDelayedTaskList>
 502:	f0 91 24 07 	lds	r31, 0x0724	; 0x800724 <pxDelayedTaskList+0x1>
 506:	80 81       	ld	r24, Z
 508:	81 11       	cpse	r24, r1
 50a:	07 c0       	rjmp	.+14     	; 0x51a <prvResetNextTaskUnblockTime+0x1c>
 50c:	8f ef       	ldi	r24, 0xFF	; 255
 50e:	9f ef       	ldi	r25, 0xFF	; 255
 510:	90 93 04 07 	sts	0x0704, r25	; 0x800704 <xNextTaskUnblockTime+0x1>
 514:	80 93 03 07 	sts	0x0703, r24	; 0x800703 <xNextTaskUnblockTime>
 518:	08 95       	ret
 51a:	e0 91 23 07 	lds	r30, 0x0723	; 0x800723 <pxDelayedTaskList>
 51e:	f0 91 24 07 	lds	r31, 0x0724	; 0x800724 <pxDelayedTaskList+0x1>
 522:	05 80       	ldd	r0, Z+5	; 0x05
 524:	f6 81       	ldd	r31, Z+6	; 0x06
 526:	e0 2d       	mov	r30, r0
 528:	06 80       	ldd	r0, Z+6	; 0x06
 52a:	f7 81       	ldd	r31, Z+7	; 0x07
 52c:	e0 2d       	mov	r30, r0
 52e:	82 81       	ldd	r24, Z+2	; 0x02
 530:	93 81       	ldd	r25, Z+3	; 0x03
 532:	90 93 04 07 	sts	0x0704, r25	; 0x800704 <xNextTaskUnblockTime+0x1>
 536:	80 93 03 07 	sts	0x0703, r24	; 0x800703 <xNextTaskUnblockTime>
 53a:	08 95       	ret

0000053c <prvAddCurrentTaskToDelayedList>:
 53c:	0f 93       	push	r16
 53e:	1f 93       	push	r17
 540:	cf 93       	push	r28
 542:	df 93       	push	r29
 544:	ec 01       	movw	r28, r24
 546:	00 91 0b 07 	lds	r16, 0x070B	; 0x80070b <xTickCount>
 54a:	10 91 0c 07 	lds	r17, 0x070C	; 0x80070c <xTickCount+0x1>
 54e:	80 91 5b 07 	lds	r24, 0x075B	; 0x80075b <pxCurrentTCB>
 552:	90 91 5c 07 	lds	r25, 0x075C	; 0x80075c <pxCurrentTCB+0x1>
 556:	02 96       	adiw	r24, 0x02	; 2
 558:	0e 94 c9 00 	call	0x192	; 0x192 <uxListRemove>
 55c:	c0 0f       	add	r28, r16
 55e:	d1 1f       	adc	r29, r17
 560:	e0 91 5b 07 	lds	r30, 0x075B	; 0x80075b <pxCurrentTCB>
 564:	f0 91 5c 07 	lds	r31, 0x075C	; 0x80075c <pxCurrentTCB+0x1>
 568:	d3 83       	std	Z+3, r29	; 0x03
 56a:	c2 83       	std	Z+2, r28	; 0x02
 56c:	c0 17       	cp	r28, r16
 56e:	d1 07       	cpc	r29, r17
 570:	68 f4       	brcc	.+26     	; 0x58c <prvAddCurrentTaskToDelayedList+0x50>
 572:	60 91 5b 07 	lds	r22, 0x075B	; 0x80075b <pxCurrentTCB>
 576:	70 91 5c 07 	lds	r23, 0x075C	; 0x80075c <pxCurrentTCB+0x1>
 57a:	80 91 21 07 	lds	r24, 0x0721	; 0x800721 <pxOverflowDelayedTaskList>
 57e:	90 91 22 07 	lds	r25, 0x0722	; 0x800722 <pxOverflowDelayedTaskList+0x1>
 582:	6e 5f       	subi	r22, 0xFE	; 254
 584:	7f 4f       	sbci	r23, 0xFF	; 255
 586:	0e 94 98 00 	call	0x130	; 0x130 <vListInsert>
 58a:	17 c0       	rjmp	.+46     	; 0x5ba <prvAddCurrentTaskToDelayedList+0x7e>
 58c:	60 91 5b 07 	lds	r22, 0x075B	; 0x80075b <pxCurrentTCB>
 590:	70 91 5c 07 	lds	r23, 0x075C	; 0x80075c <pxCurrentTCB+0x1>
 594:	80 91 23 07 	lds	r24, 0x0723	; 0x800723 <pxDelayedTaskList>
 598:	90 91 24 07 	lds	r25, 0x0724	; 0x800724 <pxDelayedTaskList+0x1>
 59c:	6e 5f       	subi	r22, 0xFE	; 254
 59e:	7f 4f       	sbci	r23, 0xFF	; 255
 5a0:	0e 94 98 00 	call	0x130	; 0x130 <vListInsert>
 5a4:	80 91 03 07 	lds	r24, 0x0703	; 0x800703 <xNextTaskUnblockTime>
 5a8:	90 91 04 07 	lds	r25, 0x0704	; 0x800704 <xNextTaskUnblockTime+0x1>
 5ac:	c8 17       	cp	r28, r24
 5ae:	d9 07       	cpc	r29, r25
 5b0:	20 f4       	brcc	.+8      	; 0x5ba <prvAddCurrentTaskToDelayedList+0x7e>
 5b2:	d0 93 04 07 	sts	0x0704, r29	; 0x800704 <xNextTaskUnblockTime+0x1>
 5b6:	c0 93 03 07 	sts	0x0703, r28	; 0x800703 <xNextTaskUnblockTime>
 5ba:	df 91       	pop	r29
 5bc:	cf 91       	pop	r28
 5be:	1f 91       	pop	r17
 5c0:	0f 91       	pop	r16
 5c2:	08 95       	ret

000005c4 <xTaskCreate>:
 5c4:	4f 92       	push	r4
 5c6:	5f 92       	push	r5
 5c8:	6f 92       	push	r6
 5ca:	7f 92       	push	r7
 5cc:	8f 92       	push	r8
 5ce:	9f 92       	push	r9
 5d0:	af 92       	push	r10
 5d2:	bf 92       	push	r11
 5d4:	cf 92       	push	r12
 5d6:	df 92       	push	r13
 5d8:	ef 92       	push	r14
 5da:	ff 92       	push	r15
 5dc:	0f 93       	push	r16
 5de:	cf 93       	push	r28
 5e0:	df 93       	push	r29
 5e2:	4c 01       	movw	r8, r24
 5e4:	6b 01       	movw	r12, r22
 5e6:	5a 01       	movw	r10, r20
 5e8:	29 01       	movw	r4, r18
 5ea:	ca 01       	movw	r24, r20
 5ec:	0e 94 49 02 	call	0x492	; 0x492 <pvPortMalloc>
 5f0:	3c 01       	movw	r6, r24
 5f2:	89 2b       	or	r24, r25
 5f4:	09 f4       	brne	.+2      	; 0x5f8 <xTaskCreate+0x34>
 5f6:	dd c0       	rjmp	.+442    	; 0x7b2 <xTaskCreate+0x1ee>
 5f8:	86 e2       	ldi	r24, 0x26	; 38
 5fa:	90 e0       	ldi	r25, 0x00	; 0
 5fc:	0e 94 49 02 	call	0x492	; 0x492 <pvPortMalloc>
 600:	ec 01       	movw	r28, r24
 602:	89 2b       	or	r24, r25
 604:	71 f0       	breq	.+28     	; 0x622 <xTaskCreate+0x5e>
 606:	78 8e       	std	Y+24, r7	; 0x18
 608:	6f 8a       	std	Y+23, r6	; 0x17
 60a:	81 e0       	ldi	r24, 0x01	; 1
 60c:	a8 1a       	sub	r10, r24
 60e:	b1 08       	sbc	r11, r1
 610:	a6 0c       	add	r10, r6
 612:	b7 1c       	adc	r11, r7
 614:	d6 01       	movw	r26, r12
 616:	8c 91       	ld	r24, X
 618:	89 8f       	std	Y+25, r24	; 0x19
 61a:	8c 91       	ld	r24, X
 61c:	81 11       	cpse	r24, r1
 61e:	05 c0       	rjmp	.+10     	; 0x62a <xTaskCreate+0x66>
 620:	18 c0       	rjmp	.+48     	; 0x652 <xTaskCreate+0x8e>
 622:	c3 01       	movw	r24, r6
 624:	0e 94 7e 02 	call	0x4fc	; 0x4fc <vPortFree>
 628:	c4 c0       	rjmp	.+392    	; 0x7b2 <xTaskCreate+0x1ee>
 62a:	ae 01       	movw	r20, r28
 62c:	46 5e       	subi	r20, 0xE6	; 230
 62e:	5f 4f       	sbci	r21, 0xFF	; 255
 630:	f6 01       	movw	r30, r12
 632:	31 96       	adiw	r30, 0x01	; 1
 634:	b8 e0       	ldi	r27, 0x08	; 8
 636:	cb 0e       	add	r12, r27
 638:	d1 1c       	adc	r13, r1
 63a:	cf 01       	movw	r24, r30
 63c:	21 91       	ld	r18, Z+
 63e:	da 01       	movw	r26, r20
 640:	2d 93       	st	X+, r18
 642:	ad 01       	movw	r20, r26
 644:	dc 01       	movw	r26, r24
 646:	8c 91       	ld	r24, X
 648:	88 23       	and	r24, r24
 64a:	19 f0       	breq	.+6      	; 0x652 <xTaskCreate+0x8e>
 64c:	ec 15       	cp	r30, r12
 64e:	fd 05       	cpc	r31, r13
 650:	a1 f7       	brne	.-24     	; 0x63a <xTaskCreate+0x76>
 652:	18 a2       	std	Y+32, r1	; 0x20
 654:	04 30       	cpi	r16, 0x04	; 4
 656:	08 f0       	brcs	.+2      	; 0x65a <xTaskCreate+0x96>
 658:	03 e0       	ldi	r16, 0x03	; 3
 65a:	0e 8b       	std	Y+22, r16	; 0x16
 65c:	6e 01       	movw	r12, r28
 65e:	b2 e0       	ldi	r27, 0x02	; 2
 660:	cb 0e       	add	r12, r27
 662:	d1 1c       	adc	r13, r1
 664:	c6 01       	movw	r24, r12
 666:	0e 94 73 00 	call	0xe6	; 0xe6 <vListInitialiseItem>
 66a:	ce 01       	movw	r24, r28
 66c:	0c 96       	adiw	r24, 0x0c	; 12
 66e:	0e 94 73 00 	call	0xe6	; 0xe6 <vListInitialiseItem>
 672:	d9 87       	std	Y+9, r29	; 0x09
 674:	c8 87       	std	Y+8, r28	; 0x08
 676:	84 e0       	ldi	r24, 0x04	; 4
 678:	90 e0       	ldi	r25, 0x00	; 0
 67a:	80 1b       	sub	r24, r16
 67c:	91 09       	sbc	r25, r1
 67e:	9d 87       	std	Y+13, r25	; 0x0d
 680:	8c 87       	std	Y+12, r24	; 0x0c
 682:	db 8b       	std	Y+19, r29	; 0x13
 684:	ca 8b       	std	Y+18, r28	; 0x12
 686:	19 a2       	std	Y+33, r1	; 0x21
 688:	1a a2       	std	Y+34, r1	; 0x22
 68a:	1b a2       	std	Y+35, r1	; 0x23
 68c:	1c a2       	std	Y+36, r1	; 0x24
 68e:	1d a2       	std	Y+37, r1	; 0x25
 690:	a2 01       	movw	r20, r4
 692:	b4 01       	movw	r22, r8
 694:	c5 01       	movw	r24, r10
 696:	0e 94 ef 00 	call	0x1de	; 0x1de <pxPortInitialiseStack>
 69a:	99 83       	std	Y+1, r25	; 0x01
 69c:	88 83       	st	Y, r24
 69e:	e1 14       	cp	r14, r1
 6a0:	f1 04       	cpc	r15, r1
 6a2:	19 f0       	breq	.+6      	; 0x6aa <xTaskCreate+0xe6>
 6a4:	f7 01       	movw	r30, r14
 6a6:	d1 83       	std	Z+1, r29	; 0x01
 6a8:	c0 83       	st	Z, r28
 6aa:	0f b6       	in	r0, 0x3f	; 63
 6ac:	f8 94       	cli
 6ae:	0f 92       	push	r0
 6b0:	80 91 0d 07 	lds	r24, 0x070D	; 0x80070d <uxCurrentNumberOfTasks>
 6b4:	8f 5f       	subi	r24, 0xFF	; 255
 6b6:	80 93 0d 07 	sts	0x070D, r24	; 0x80070d <uxCurrentNumberOfTasks>
 6ba:	80 91 5b 07 	lds	r24, 0x075B	; 0x80075b <pxCurrentTCB>
 6be:	90 91 5c 07 	lds	r25, 0x075C	; 0x80075c <pxCurrentTCB+0x1>
 6c2:	89 2b       	or	r24, r25
 6c4:	a9 f5       	brne	.+106    	; 0x730 <xTaskCreate+0x16c>
 6c6:	d0 93 5c 07 	sts	0x075C, r29	; 0x80075c <pxCurrentTCB+0x1>
 6ca:	c0 93 5b 07 	sts	0x075B, r28	; 0x80075b <pxCurrentTCB>
 6ce:	80 91 0d 07 	lds	r24, 0x070D	; 0x80070d <uxCurrentNumberOfTasks>
 6d2:	81 30       	cpi	r24, 0x01	; 1
 6d4:	e9 f5       	brne	.+122    	; 0x750 <xTaskCreate+0x18c>
 6d6:	87 e3       	ldi	r24, 0x37	; 55
 6d8:	97 e0       	ldi	r25, 0x07	; 7
 6da:	0e 94 65 00 	call	0xca	; 0xca <vListInitialise>
 6de:	80 e4       	ldi	r24, 0x40	; 64
 6e0:	97 e0       	ldi	r25, 0x07	; 7
 6e2:	0e 94 65 00 	call	0xca	; 0xca <vListInitialise>
 6e6:	89 e4       	ldi	r24, 0x49	; 73
 6e8:	97 e0       	ldi	r25, 0x07	; 7
 6ea:	0e 94 65 00 	call	0xca	; 0xca <vListInitialise>
 6ee:	82 e5       	ldi	r24, 0x52	; 82
 6f0:	97 e0       	ldi	r25, 0x07	; 7
 6f2:	0e 94 65 00 	call	0xca	; 0xca <vListInitialise>
 6f6:	8e e2       	ldi	r24, 0x2E	; 46
 6f8:	97 e0       	ldi	r25, 0x07	; 7
 6fa:	0e 94 65 00 	call	0xca	; 0xca <vListInitialise>
 6fe:	85 e2       	ldi	r24, 0x25	; 37
 700:	97 e0       	ldi	r25, 0x07	; 7
 702:	0e 94 65 00 	call	0xca	; 0xca <vListInitialise>
 706:	88 e1       	ldi	r24, 0x18	; 24
 708:	97 e0       	ldi	r25, 0x07	; 7
 70a:	0e 94 65 00 	call	0xca	; 0xca <vListInitialise>
 70e:	8f e0       	ldi	r24, 0x0F	; 15
 710:	97 e0       	ldi	r25, 0x07	; 7
 712:	0e 94 65 00 	call	0xca	; 0xca <vListInitialise>
 716:	8e e2       	ldi	r24, 0x2E	; 46
 718:	97 e0       	ldi	r25, 0x07	; 7
 71a:	90 93 24 07 	sts	0x0724, r25	; 0x800724 <pxDelayedTaskList+0x1>
 71e:	80 93 23 07 	sts	0x0723, r24	; 0x800723 <pxDelayedTaskList>
 722:	85 e2       	ldi	r24, 0x25	; 37
 724:	97 e0       	ldi	r25, 0x07	; 7
 726:	90 93 22 07 	sts	0x0722, r25	; 0x800722 <pxOverflowDelayedTaskList+0x1>
 72a:	80 93 21 07 	sts	0x0721, r24	; 0x800721 <pxOverflowDelayedTaskList>
 72e:	10 c0       	rjmp	.+32     	; 0x750 <xTaskCreate+0x18c>
 730:	80 91 09 07 	lds	r24, 0x0709	; 0x800709 <xSchedulerRunning>
 734:	81 11       	cpse	r24, r1
 736:	0c c0       	rjmp	.+24     	; 0x750 <xTaskCreate+0x18c>
 738:	e0 91 5b 07 	lds	r30, 0x075B	; 0x80075b <pxCurrentTCB>
 73c:	f0 91 5c 07 	lds	r31, 0x075C	; 0x80075c <pxCurrentTCB+0x1>
 740:	96 89       	ldd	r25, Z+22	; 0x16
 742:	8e 89       	ldd	r24, Y+22	; 0x16
 744:	89 17       	cp	r24, r25
 746:	20 f0       	brcs	.+8      	; 0x750 <xTaskCreate+0x18c>
 748:	d0 93 5c 07 	sts	0x075C, r29	; 0x80075c <pxCurrentTCB+0x1>
 74c:	c0 93 5b 07 	sts	0x075B, r28	; 0x80075b <pxCurrentTCB>
 750:	80 91 05 07 	lds	r24, 0x0705	; 0x800705 <uxTaskNumber>
 754:	8f 5f       	subi	r24, 0xFF	; 255
 756:	80 93 05 07 	sts	0x0705, r24	; 0x800705 <uxTaskNumber>
 75a:	8e 89       	ldd	r24, Y+22	; 0x16
 75c:	90 91 0a 07 	lds	r25, 0x070A	; 0x80070a <uxTopReadyPriority>
 760:	98 17       	cp	r25, r24
 762:	10 f4       	brcc	.+4      	; 0x768 <xTaskCreate+0x1a4>
 764:	80 93 0a 07 	sts	0x070A, r24	; 0x80070a <uxTopReadyPriority>
 768:	90 e0       	ldi	r25, 0x00	; 0
 76a:	9c 01       	movw	r18, r24
 76c:	22 0f       	add	r18, r18
 76e:	33 1f       	adc	r19, r19
 770:	22 0f       	add	r18, r18
 772:	33 1f       	adc	r19, r19
 774:	22 0f       	add	r18, r18
 776:	33 1f       	adc	r19, r19
 778:	82 0f       	add	r24, r18
 77a:	93 1f       	adc	r25, r19
 77c:	b6 01       	movw	r22, r12
 77e:	89 5c       	subi	r24, 0xC9	; 201
 780:	98 4f       	sbci	r25, 0xF8	; 248
 782:	0e 94 77 00 	call	0xee	; 0xee <vListInsertEnd>
 786:	0f 90       	pop	r0
 788:	0f be       	out	0x3f, r0	; 63
 78a:	80 91 09 07 	lds	r24, 0x0709	; 0x800709 <xSchedulerRunning>
 78e:	88 23       	and	r24, r24
 790:	61 f0       	breq	.+24     	; 0x7aa <xTaskCreate+0x1e6>
 792:	e0 91 5b 07 	lds	r30, 0x075B	; 0x80075b <pxCurrentTCB>
 796:	f0 91 5c 07 	lds	r31, 0x075C	; 0x80075c <pxCurrentTCB+0x1>
 79a:	96 89       	ldd	r25, Z+22	; 0x16
 79c:	8e 89       	ldd	r24, Y+22	; 0x16
 79e:	98 17       	cp	r25, r24
 7a0:	30 f4       	brcc	.+12     	; 0x7ae <xTaskCreate+0x1ea>
 7a2:	0e 94 91 01 	call	0x322	; 0x322 <vPortYield>
 7a6:	81 e0       	ldi	r24, 0x01	; 1
 7a8:	05 c0       	rjmp	.+10     	; 0x7b4 <xTaskCreate+0x1f0>
 7aa:	81 e0       	ldi	r24, 0x01	; 1
 7ac:	03 c0       	rjmp	.+6      	; 0x7b4 <xTaskCreate+0x1f0>
 7ae:	81 e0       	ldi	r24, 0x01	; 1
 7b0:	01 c0       	rjmp	.+2      	; 0x7b4 <xTaskCreate+0x1f0>
 7b2:	8f ef       	ldi	r24, 0xFF	; 255
 7b4:	df 91       	pop	r29
 7b6:	cf 91       	pop	r28
 7b8:	0f 91       	pop	r16
 7ba:	ff 90       	pop	r15
 7bc:	ef 90       	pop	r14
 7be:	df 90       	pop	r13
 7c0:	cf 90       	pop	r12
 7c2:	bf 90       	pop	r11
 7c4:	af 90       	pop	r10
 7c6:	9f 90       	pop	r9
 7c8:	8f 90       	pop	r8
 7ca:	7f 90       	pop	r7
 7cc:	6f 90       	pop	r6
 7ce:	5f 90       	pop	r5
 7d0:	4f 90       	pop	r4
 7d2:	08 95       	ret

000007d4 <vTaskStartScheduler>:
 7d4:	ef 92       	push	r14
 7d6:	ff 92       	push	r15
 7d8:	0f 93       	push	r16
 7da:	0f 2e       	mov	r0, r31
 7dc:	f1 e0       	ldi	r31, 0x01	; 1
 7de:	ef 2e       	mov	r14, r31
 7e0:	f7 e0       	ldi	r31, 0x07	; 7
 7e2:	ff 2e       	mov	r15, r31
 7e4:	f0 2d       	mov	r31, r0
 7e6:	00 e0       	ldi	r16, 0x00	; 0
 7e8:	20 e0       	ldi	r18, 0x00	; 0
 7ea:	30 e0       	ldi	r19, 0x00	; 0
 7ec:	45 e5       	ldi	r20, 0x55	; 85
 7ee:	50 e0       	ldi	r21, 0x00	; 0
 7f0:	68 e0       	ldi	r22, 0x08	; 8
 7f2:	71 e0       	ldi	r23, 0x01	; 1
 7f4:	88 e6       	ldi	r24, 0x68	; 104
 7f6:	95 e0       	ldi	r25, 0x05	; 5
 7f8:	0e 94 e2 02 	call	0x5c4	; 0x5c4 <xTaskCreate>
 7fc:	81 30       	cpi	r24, 0x01	; 1
 7fe:	81 f4       	brne	.+32     	; 0x820 <vTaskStartScheduler+0x4c>
 800:	f8 94       	cli
 802:	8f ef       	ldi	r24, 0xFF	; 255
 804:	9f ef       	ldi	r25, 0xFF	; 255
 806:	90 93 04 07 	sts	0x0704, r25	; 0x800704 <xNextTaskUnblockTime+0x1>
 80a:	80 93 03 07 	sts	0x0703, r24	; 0x800703 <xNextTaskUnblockTime>
 80e:	81 e0       	ldi	r24, 0x01	; 1
 810:	80 93 09 07 	sts	0x0709, r24	; 0x800709 <xSchedulerRunning>
 814:	10 92 0c 07 	sts	0x070C, r1	; 0x80070c <xTickCount+0x1>
 818:	10 92 0b 07 	sts	0x070B, r1	; 0x80070b <xTickCount>
 81c:	0e 94 5b 01 	call	0x2b6	; 0x2b6 <xPortStartScheduler>
 820:	0f 91       	pop	r16
 822:	ff 90       	pop	r15
 824:	ef 90       	pop	r14
 826:	08 95       	ret

00000828 <vTaskSuspendAll>:
 828:	80 91 00 07 	lds	r24, 0x0700	; 0x800700 <uxSchedulerSuspended>
 82c:	8f 5f       	subi	r24, 0xFF	; 255
 82e:	80 93 00 07 	sts	0x0700, r24	; 0x800700 <uxSchedulerSuspended>
 832:	08 95       	ret

00000834 <xTaskIncrementTick>:
 834:	cf 92       	push	r12
 836:	df 92       	push	r13
 838:	ef 92       	push	r14
 83a:	ff 92       	push	r15
 83c:	0f 93       	push	r16
 83e:	1f 93       	push	r17
 840:	cf 93       	push	r28
 842:	df 93       	push	r29
 844:	80 91 00 07 	lds	r24, 0x0700	; 0x800700 <uxSchedulerSuspended>
 848:	81 11       	cpse	r24, r1
 84a:	99 c0       	rjmp	.+306    	; 0x97e <xTaskIncrementTick+0x14a>
 84c:	e0 90 0b 07 	lds	r14, 0x070B	; 0x80070b <xTickCount>
 850:	f0 90 0c 07 	lds	r15, 0x070C	; 0x80070c <xTickCount+0x1>
 854:	8f ef       	ldi	r24, 0xFF	; 255
 856:	e8 1a       	sub	r14, r24
 858:	f8 0a       	sbc	r15, r24
 85a:	f0 92 0c 07 	sts	0x070C, r15	; 0x80070c <xTickCount+0x1>
 85e:	e0 92 0b 07 	sts	0x070B, r14	; 0x80070b <xTickCount>
 862:	e1 14       	cp	r14, r1
 864:	f1 04       	cpc	r15, r1
 866:	b9 f4       	brne	.+46     	; 0x896 <xTaskIncrementTick+0x62>
 868:	80 91 23 07 	lds	r24, 0x0723	; 0x800723 <pxDelayedTaskList>
 86c:	90 91 24 07 	lds	r25, 0x0724	; 0x800724 <pxDelayedTaskList+0x1>
 870:	20 91 21 07 	lds	r18, 0x0721	; 0x800721 <pxOverflowDelayedTaskList>
 874:	30 91 22 07 	lds	r19, 0x0722	; 0x800722 <pxOverflowDelayedTaskList+0x1>
 878:	30 93 24 07 	sts	0x0724, r19	; 0x800724 <pxDelayedTaskList+0x1>
 87c:	20 93 23 07 	sts	0x0723, r18	; 0x800723 <pxDelayedTaskList>
 880:	90 93 22 07 	sts	0x0722, r25	; 0x800722 <pxOverflowDelayedTaskList+0x1>
 884:	80 93 21 07 	sts	0x0721, r24	; 0x800721 <pxOverflowDelayedTaskList>
 888:	80 91 06 07 	lds	r24, 0x0706	; 0x800706 <xNumOfOverflows>
 88c:	8f 5f       	subi	r24, 0xFF	; 255
 88e:	80 93 06 07 	sts	0x0706, r24	; 0x800706 <xNumOfOverflows>
 892:	0e 94 7f 02 	call	0x4fe	; 0x4fe <prvResetNextTaskUnblockTime>
 896:	80 91 03 07 	lds	r24, 0x0703	; 0x800703 <xNextTaskUnblockTime>
 89a:	90 91 04 07 	lds	r25, 0x0704	; 0x800704 <xNextTaskUnblockTime+0x1>
 89e:	e8 16       	cp	r14, r24
 8a0:	f9 06       	cpc	r15, r25
 8a2:	10 f4       	brcc	.+4      	; 0x8a8 <xTaskIncrementTick+0x74>
 8a4:	d1 2c       	mov	r13, r1
 8a6:	53 c0       	rjmp	.+166    	; 0x94e <xTaskIncrementTick+0x11a>
 8a8:	d1 2c       	mov	r13, r1
 8aa:	cc 24       	eor	r12, r12
 8ac:	c3 94       	inc	r12
 8ae:	e0 91 23 07 	lds	r30, 0x0723	; 0x800723 <pxDelayedTaskList>
 8b2:	f0 91 24 07 	lds	r31, 0x0724	; 0x800724 <pxDelayedTaskList+0x1>
 8b6:	80 81       	ld	r24, Z
 8b8:	81 11       	cpse	r24, r1
 8ba:	07 c0       	rjmp	.+14     	; 0x8ca <xTaskIncrementTick+0x96>
 8bc:	8f ef       	ldi	r24, 0xFF	; 255
 8be:	9f ef       	ldi	r25, 0xFF	; 255
 8c0:	90 93 04 07 	sts	0x0704, r25	; 0x800704 <xNextTaskUnblockTime+0x1>
 8c4:	80 93 03 07 	sts	0x0703, r24	; 0x800703 <xNextTaskUnblockTime>
 8c8:	42 c0       	rjmp	.+132    	; 0x94e <xTaskIncrementTick+0x11a>
 8ca:	e0 91 23 07 	lds	r30, 0x0723	; 0x800723 <pxDelayedTaskList>
 8ce:	f0 91 24 07 	lds	r31, 0x0724	; 0x800724 <pxDelayedTaskList+0x1>
 8d2:	05 80       	ldd	r0, Z+5	; 0x05
 8d4:	f6 81       	ldd	r31, Z+6	; 0x06
 8d6:	e0 2d       	mov	r30, r0
 8d8:	c6 81       	ldd	r28, Z+6	; 0x06
 8da:	d7 81       	ldd	r29, Z+7	; 0x07
 8dc:	8a 81       	ldd	r24, Y+2	; 0x02
 8de:	9b 81       	ldd	r25, Y+3	; 0x03
 8e0:	e8 16       	cp	r14, r24
 8e2:	f9 06       	cpc	r15, r25
 8e4:	28 f4       	brcc	.+10     	; 0x8f0 <xTaskIncrementTick+0xbc>
 8e6:	90 93 04 07 	sts	0x0704, r25	; 0x800704 <xNextTaskUnblockTime+0x1>
 8ea:	80 93 03 07 	sts	0x0703, r24	; 0x800703 <xNextTaskUnblockTime>
 8ee:	2f c0       	rjmp	.+94     	; 0x94e <xTaskIncrementTick+0x11a>
 8f0:	8e 01       	movw	r16, r28
 8f2:	0e 5f       	subi	r16, 0xFE	; 254
 8f4:	1f 4f       	sbci	r17, 0xFF	; 255
 8f6:	c8 01       	movw	r24, r16
 8f8:	0e 94 c9 00 	call	0x192	; 0x192 <uxListRemove>
 8fc:	8c 89       	ldd	r24, Y+20	; 0x14
 8fe:	9d 89       	ldd	r25, Y+21	; 0x15
 900:	89 2b       	or	r24, r25
 902:	21 f0       	breq	.+8      	; 0x90c <xTaskIncrementTick+0xd8>
 904:	ce 01       	movw	r24, r28
 906:	0c 96       	adiw	r24, 0x0c	; 12
 908:	0e 94 c9 00 	call	0x192	; 0x192 <uxListRemove>
 90c:	8e 89       	ldd	r24, Y+22	; 0x16
 90e:	90 91 0a 07 	lds	r25, 0x070A	; 0x80070a <uxTopReadyPriority>
 912:	98 17       	cp	r25, r24
 914:	10 f4       	brcc	.+4      	; 0x91a <xTaskIncrementTick+0xe6>
 916:	80 93 0a 07 	sts	0x070A, r24	; 0x80070a <uxTopReadyPriority>
 91a:	90 e0       	ldi	r25, 0x00	; 0
 91c:	9c 01       	movw	r18, r24
 91e:	22 0f       	add	r18, r18
 920:	33 1f       	adc	r19, r19
 922:	22 0f       	add	r18, r18
 924:	33 1f       	adc	r19, r19
 926:	22 0f       	add	r18, r18
 928:	33 1f       	adc	r19, r19
 92a:	82 0f       	add	r24, r18
 92c:	93 1f       	adc	r25, r19
 92e:	b8 01       	movw	r22, r16
 930:	89 5c       	subi	r24, 0xC9	; 201
 932:	98 4f       	sbci	r25, 0xF8	; 248
 934:	0e 94 77 00 	call	0xee	; 0xee <vListInsertEnd>
 938:	e0 91 5b 07 	lds	r30, 0x075B	; 0x80075b <pxCurrentTCB>
 93c:	f0 91 5c 07 	lds	r31, 0x075C	; 0x80075c <pxCurrentTCB+0x1>
 940:	9e 89       	ldd	r25, Y+22	; 0x16
 942:	86 89       	ldd	r24, Z+22	; 0x16
 944:	98 17       	cp	r25, r24
 946:	08 f4       	brcc	.+2      	; 0x94a <xTaskIncrementTick+0x116>
 948:	b2 cf       	rjmp	.-156    	; 0x8ae <xTaskIncrementTick+0x7a>
 94a:	dc 2c       	mov	r13, r12
 94c:	b0 cf       	rjmp	.-160    	; 0x8ae <xTaskIncrementTick+0x7a>
 94e:	e0 91 5b 07 	lds	r30, 0x075B	; 0x80075b <pxCurrentTCB>
 952:	f0 91 5c 07 	lds	r31, 0x075C	; 0x80075c <pxCurrentTCB+0x1>
 956:	86 89       	ldd	r24, Z+22	; 0x16
 958:	90 e0       	ldi	r25, 0x00	; 0
 95a:	fc 01       	movw	r30, r24
 95c:	ee 0f       	add	r30, r30
 95e:	ff 1f       	adc	r31, r31
 960:	ee 0f       	add	r30, r30
 962:	ff 1f       	adc	r31, r31
 964:	ee 0f       	add	r30, r30
 966:	ff 1f       	adc	r31, r31
 968:	8e 0f       	add	r24, r30
 96a:	9f 1f       	adc	r25, r31
 96c:	fc 01       	movw	r30, r24
 96e:	e9 5c       	subi	r30, 0xC9	; 201
 970:	f8 4f       	sbci	r31, 0xF8	; 248
 972:	80 81       	ld	r24, Z
 974:	82 30       	cpi	r24, 0x02	; 2
 976:	48 f0       	brcs	.+18     	; 0x98a <xTaskIncrementTick+0x156>
 978:	dd 24       	eor	r13, r13
 97a:	d3 94       	inc	r13
 97c:	06 c0       	rjmp	.+12     	; 0x98a <xTaskIncrementTick+0x156>
 97e:	80 91 08 07 	lds	r24, 0x0708	; 0x800708 <uxPendedTicks>
 982:	8f 5f       	subi	r24, 0xFF	; 255
 984:	80 93 08 07 	sts	0x0708, r24	; 0x800708 <uxPendedTicks>
 988:	d1 2c       	mov	r13, r1
 98a:	80 91 07 07 	lds	r24, 0x0707	; 0x800707 <xYieldPending>
 98e:	88 23       	and	r24, r24
 990:	11 f0       	breq	.+4      	; 0x996 <xTaskIncrementTick+0x162>
 992:	dd 24       	eor	r13, r13
 994:	d3 94       	inc	r13
 996:	8d 2d       	mov	r24, r13
 998:	df 91       	pop	r29
 99a:	cf 91       	pop	r28
 99c:	1f 91       	pop	r17
 99e:	0f 91       	pop	r16
 9a0:	ff 90       	pop	r15
 9a2:	ef 90       	pop	r14
 9a4:	df 90       	pop	r13
 9a6:	cf 90       	pop	r12
 9a8:	08 95       	ret

000009aa <xTaskResumeAll>:
 9aa:	df 92       	push	r13
 9ac:	ef 92       	push	r14
 9ae:	ff 92       	push	r15
 9b0:	0f 93       	push	r16
 9b2:	1f 93       	push	r17
 9b4:	cf 93       	push	r28
 9b6:	df 93       	push	r29
 9b8:	0f b6       	in	r0, 0x3f	; 63
 9ba:	f8 94       	cli
 9bc:	0f 92       	push	r0
 9be:	80 91 00 07 	lds	r24, 0x0700	; 0x800700 <uxSchedulerSuspended>
 9c2:	81 50       	subi	r24, 0x01	; 1
 9c4:	80 93 00 07 	sts	0x0700, r24	; 0x800700 <uxSchedulerSuspended>
 9c8:	80 91 00 07 	lds	r24, 0x0700	; 0x800700 <uxSchedulerSuspended>
 9cc:	81 11       	cpse	r24, r1
 9ce:	5f c0       	rjmp	.+190    	; 0xa8e <xTaskResumeAll+0xe4>
 9d0:	80 91 0d 07 	lds	r24, 0x070D	; 0x80070d <uxCurrentNumberOfTasks>
 9d4:	81 11       	cpse	r24, r1
 9d6:	33 c0       	rjmp	.+102    	; 0xa3e <xTaskResumeAll+0x94>
 9d8:	5d c0       	rjmp	.+186    	; 0xa94 <xTaskResumeAll+0xea>
 9da:	d7 01       	movw	r26, r14
 9dc:	15 96       	adiw	r26, 0x05	; 5
 9de:	ed 91       	ld	r30, X+
 9e0:	fc 91       	ld	r31, X
 9e2:	16 97       	sbiw	r26, 0x06	; 6
 9e4:	c6 81       	ldd	r28, Z+6	; 0x06
 9e6:	d7 81       	ldd	r29, Z+7	; 0x07
 9e8:	ce 01       	movw	r24, r28
 9ea:	0c 96       	adiw	r24, 0x0c	; 12
 9ec:	0e 94 c9 00 	call	0x192	; 0x192 <uxListRemove>
 9f0:	8e 01       	movw	r16, r28
 9f2:	0e 5f       	subi	r16, 0xFE	; 254
 9f4:	1f 4f       	sbci	r17, 0xFF	; 255
 9f6:	c8 01       	movw	r24, r16
 9f8:	0e 94 c9 00 	call	0x192	; 0x192 <uxListRemove>
 9fc:	8e 89       	ldd	r24, Y+22	; 0x16
 9fe:	90 91 0a 07 	lds	r25, 0x070A	; 0x80070a <uxTopReadyPriority>
 a02:	98 17       	cp	r25, r24
 a04:	10 f4       	brcc	.+4      	; 0xa0a <xTaskResumeAll+0x60>
 a06:	80 93 0a 07 	sts	0x070A, r24	; 0x80070a <uxTopReadyPriority>
 a0a:	90 e0       	ldi	r25, 0x00	; 0
 a0c:	9c 01       	movw	r18, r24
 a0e:	22 0f       	add	r18, r18
 a10:	33 1f       	adc	r19, r19
 a12:	22 0f       	add	r18, r18
 a14:	33 1f       	adc	r19, r19
 a16:	22 0f       	add	r18, r18
 a18:	33 1f       	adc	r19, r19
 a1a:	82 0f       	add	r24, r18
 a1c:	93 1f       	adc	r25, r19
 a1e:	b8 01       	movw	r22, r16
 a20:	89 5c       	subi	r24, 0xC9	; 201
 a22:	98 4f       	sbci	r25, 0xF8	; 248
 a24:	0e 94 77 00 	call	0xee	; 0xee <vListInsertEnd>
 a28:	e0 91 5b 07 	lds	r30, 0x075B	; 0x80075b <pxCurrentTCB>
 a2c:	f0 91 5c 07 	lds	r31, 0x075C	; 0x80075c <pxCurrentTCB+0x1>
 a30:	9e 89       	ldd	r25, Y+22	; 0x16
 a32:	86 89       	ldd	r24, Z+22	; 0x16
 a34:	98 17       	cp	r25, r24
 a36:	68 f0       	brcs	.+26     	; 0xa52 <xTaskResumeAll+0xa8>
 a38:	d0 92 07 07 	sts	0x0707, r13	; 0x800707 <xYieldPending>
 a3c:	0a c0       	rjmp	.+20     	; 0xa52 <xTaskResumeAll+0xa8>
 a3e:	c0 e0       	ldi	r28, 0x00	; 0
 a40:	d0 e0       	ldi	r29, 0x00	; 0
 a42:	0f 2e       	mov	r0, r31
 a44:	f8 e1       	ldi	r31, 0x18	; 24
 a46:	ef 2e       	mov	r14, r31
 a48:	f7 e0       	ldi	r31, 0x07	; 7
 a4a:	ff 2e       	mov	r15, r31
 a4c:	f0 2d       	mov	r31, r0
 a4e:	dd 24       	eor	r13, r13
 a50:	d3 94       	inc	r13
 a52:	f7 01       	movw	r30, r14
 a54:	80 81       	ld	r24, Z
 a56:	81 11       	cpse	r24, r1
 a58:	c0 cf       	rjmp	.-128    	; 0x9da <xTaskResumeAll+0x30>
 a5a:	cd 2b       	or	r28, r29
 a5c:	11 f0       	breq	.+4      	; 0xa62 <xTaskResumeAll+0xb8>
 a5e:	0e 94 7f 02 	call	0x4fe	; 0x4fe <prvResetNextTaskUnblockTime>
 a62:	c0 91 08 07 	lds	r28, 0x0708	; 0x800708 <uxPendedTicks>
 a66:	cc 23       	and	r28, r28
 a68:	51 f0       	breq	.+20     	; 0xa7e <xTaskResumeAll+0xd4>
 a6a:	d1 e0       	ldi	r29, 0x01	; 1
 a6c:	0e 94 1a 04 	call	0x834	; 0x834 <xTaskIncrementTick>
 a70:	81 11       	cpse	r24, r1
 a72:	d0 93 07 07 	sts	0x0707, r29	; 0x800707 <xYieldPending>
 a76:	c1 50       	subi	r28, 0x01	; 1
 a78:	c9 f7       	brne	.-14     	; 0xa6c <xTaskResumeAll+0xc2>
 a7a:	10 92 08 07 	sts	0x0708, r1	; 0x800708 <uxPendedTicks>
 a7e:	80 91 07 07 	lds	r24, 0x0707	; 0x800707 <xYieldPending>
 a82:	88 23       	and	r24, r24
 a84:	31 f0       	breq	.+12     	; 0xa92 <xTaskResumeAll+0xe8>
 a86:	0e 94 91 01 	call	0x322	; 0x322 <vPortYield>
 a8a:	81 e0       	ldi	r24, 0x01	; 1
 a8c:	03 c0       	rjmp	.+6      	; 0xa94 <xTaskResumeAll+0xea>
 a8e:	80 e0       	ldi	r24, 0x00	; 0
 a90:	01 c0       	rjmp	.+2      	; 0xa94 <xTaskResumeAll+0xea>
 a92:	80 e0       	ldi	r24, 0x00	; 0
 a94:	0f 90       	pop	r0
 a96:	0f be       	out	0x3f, r0	; 63
 a98:	df 91       	pop	r29
 a9a:	cf 91       	pop	r28
 a9c:	1f 91       	pop	r17
 a9e:	0f 91       	pop	r16
 aa0:	ff 90       	pop	r15
 aa2:	ef 90       	pop	r14
 aa4:	df 90       	pop	r13
 aa6:	08 95       	ret

00000aa8 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
 aa8:	cf 93       	push	r28
 aaa:	df 93       	push	r29
 aac:	ec 01       	movw	r28, r24
	BaseType_t xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
 aae:	89 2b       	or	r24, r25
 ab0:	51 f0       	breq	.+20     	; 0xac6 <vTaskDelay+0x1e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
 ab2:	0e 94 14 04 	call	0x828	; 0x828 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 ab6:	60 e0       	ldi	r22, 0x00	; 0
 ab8:	ce 01       	movw	r24, r28
 aba:	0e 94 9e 02 	call	0x53c	; 0x53c <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
 abe:	0e 94 d5 04 	call	0x9aa	; 0x9aa <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 ac2:	81 11       	cpse	r24, r1
 ac4:	02 c0       	rjmp	.+4      	; 0xaca <vTaskDelay+0x22>
		{
			portYIELD_WITHIN_API();
 ac6:	0e 94 91 01 	call	0x322	; 0x322 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 aca:	df 91       	pop	r29
 acc:	cf 91       	pop	r28
 ace:	08 95       	ret

00000ad0 <prvIdleTask>:
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 ad0:	0f e0       	ldi	r16, 0x0F	; 15
 ad2:	17 e0       	ldi	r17, 0x07	; 7

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 ad4:	0f 2e       	mov	r0, r31
 ad6:	f7 e3       	ldi	r31, 0x37	; 55
 ad8:	ef 2e       	mov	r14, r31
 ada:	f7 e0       	ldi	r31, 0x07	; 7
 adc:	ff 2e       	mov	r15, r31
 ade:	f0 2d       	mov	r31, r0
 ae0:	29 c0       	rjmp	.+82     	; 0xb34 <prvIdleTask+0x64>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
 ae2:	0e 94 14 04 	call	0x828	; 0x828 <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 ae6:	d8 01       	movw	r26, r16
 ae8:	cc 91       	ld	r28, X
			}
			( void ) xTaskResumeAll();
 aea:	0e 94 d5 04 	call	0x9aa	; 0x9aa <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
 aee:	cc 23       	and	r28, r28
 af0:	09 f1       	breq	.+66     	; 0xb34 <prvIdleTask+0x64>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
 af2:	0f b6       	in	r0, 0x3f	; 63
 af4:	f8 94       	cli
 af6:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 af8:	d8 01       	movw	r26, r16
 afa:	15 96       	adiw	r26, 0x05	; 5
 afc:	ed 91       	ld	r30, X+
 afe:	fc 91       	ld	r31, X
 b00:	16 97       	sbiw	r26, 0x06	; 6
 b02:	c6 81       	ldd	r28, Z+6	; 0x06
 b04:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 b06:	ce 01       	movw	r24, r28
 b08:	02 96       	adiw	r24, 0x02	; 2
 b0a:	0e 94 c9 00 	call	0x192	; 0x192 <uxListRemove>
					--uxCurrentNumberOfTasks;
 b0e:	80 91 0d 07 	lds	r24, 0x070D	; 0x80070d <uxCurrentNumberOfTasks>
 b12:	81 50       	subi	r24, 0x01	; 1
 b14:	80 93 0d 07 	sts	0x070D, r24	; 0x80070d <uxCurrentNumberOfTasks>
					--uxDeletedTasksWaitingCleanUp;
 b18:	80 91 0e 07 	lds	r24, 0x070E	; 0x80070e <uxDeletedTasksWaitingCleanUp>
 b1c:	81 50       	subi	r24, 0x01	; 1
 b1e:	80 93 0e 07 	sts	0x070E, r24	; 0x80070e <uxDeletedTasksWaitingCleanUp>
				}
				taskEXIT_CRITICAL();
 b22:	0f 90       	pop	r0
 b24:	0f be       	out	0x3f, r0	; 63

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
 b26:	8f 89       	ldd	r24, Y+23	; 0x17
 b28:	98 8d       	ldd	r25, Y+24	; 0x18
 b2a:	0e 94 7e 02 	call	0x4fc	; 0x4fc <vPortFree>
			vPortFree( pxTCB );
 b2e:	ce 01       	movw	r24, r28
 b30:	0e 94 7e 02 	call	0x4fc	; 0x4fc <vPortFree>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 b34:	80 91 0e 07 	lds	r24, 0x070E	; 0x80070e <uxDeletedTasksWaitingCleanUp>
 b38:	81 11       	cpse	r24, r1
 b3a:	d3 cf       	rjmp	.-90     	; 0xae2 <prvIdleTask+0x12>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 b3c:	f7 01       	movw	r30, r14
 b3e:	80 81       	ld	r24, Z
 b40:	82 30       	cpi	r24, 0x02	; 2
 b42:	c0 f3       	brcs	.-16     	; 0xb34 <prvIdleTask+0x64>
			{
				taskYIELD();
 b44:	0e 94 91 01 	call	0x322	; 0x322 <vPortYield>
 b48:	f5 cf       	rjmp	.-22     	; 0xb34 <prvIdleTask+0x64>

00000b4a <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 b4a:	80 91 00 07 	lds	r24, 0x0700	; 0x800700 <uxSchedulerSuspended>
 b4e:	88 23       	and	r24, r24
 b50:	21 f0       	breq	.+8      	; 0xb5a <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
 b52:	81 e0       	ldi	r24, 0x01	; 1
 b54:	80 93 07 07 	sts	0x0707, r24	; 0x800707 <xYieldPending>
 b58:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
 b5a:	10 92 07 07 	sts	0x0707, r1	; 0x800707 <xYieldPending>
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
 b5e:	20 91 0a 07 	lds	r18, 0x070A	; 0x80070a <uxTopReadyPriority>
 b62:	82 2f       	mov	r24, r18
 b64:	90 e0       	ldi	r25, 0x00	; 0
 b66:	fc 01       	movw	r30, r24
 b68:	ee 0f       	add	r30, r30
 b6a:	ff 1f       	adc	r31, r31
 b6c:	ee 0f       	add	r30, r30
 b6e:	ff 1f       	adc	r31, r31
 b70:	ee 0f       	add	r30, r30
 b72:	ff 1f       	adc	r31, r31
 b74:	e8 0f       	add	r30, r24
 b76:	f9 1f       	adc	r31, r25
 b78:	e9 5c       	subi	r30, 0xC9	; 201
 b7a:	f8 4f       	sbci	r31, 0xF8	; 248
 b7c:	30 81       	ld	r19, Z
 b7e:	31 11       	cpse	r19, r1
 b80:	11 c0       	rjmp	.+34     	; 0xba4 <vTaskSwitchContext+0x5a>
 b82:	21 50       	subi	r18, 0x01	; 1
 b84:	82 2f       	mov	r24, r18
 b86:	90 e0       	ldi	r25, 0x00	; 0
 b88:	fc 01       	movw	r30, r24
 b8a:	ee 0f       	add	r30, r30
 b8c:	ff 1f       	adc	r31, r31
 b8e:	ee 0f       	add	r30, r30
 b90:	ff 1f       	adc	r31, r31
 b92:	ee 0f       	add	r30, r30
 b94:	ff 1f       	adc	r31, r31
 b96:	e8 0f       	add	r30, r24
 b98:	f9 1f       	adc	r31, r25
 b9a:	e9 5c       	subi	r30, 0xC9	; 201
 b9c:	f8 4f       	sbci	r31, 0xF8	; 248
 b9e:	30 81       	ld	r19, Z
 ba0:	33 23       	and	r19, r19
 ba2:	79 f3       	breq	.-34     	; 0xb82 <vTaskSwitchContext+0x38>
 ba4:	ac 01       	movw	r20, r24
 ba6:	44 0f       	add	r20, r20
 ba8:	55 1f       	adc	r21, r21
 baa:	44 0f       	add	r20, r20
 bac:	55 1f       	adc	r21, r21
 bae:	44 0f       	add	r20, r20
 bb0:	55 1f       	adc	r21, r21
 bb2:	48 0f       	add	r20, r24
 bb4:	59 1f       	adc	r21, r25
 bb6:	da 01       	movw	r26, r20
 bb8:	a9 5c       	subi	r26, 0xC9	; 201
 bba:	b8 4f       	sbci	r27, 0xF8	; 248
 bbc:	11 96       	adiw	r26, 0x01	; 1
 bbe:	ed 91       	ld	r30, X+
 bc0:	fc 91       	ld	r31, X
 bc2:	12 97       	sbiw	r26, 0x02	; 2
 bc4:	02 80       	ldd	r0, Z+2	; 0x02
 bc6:	f3 81       	ldd	r31, Z+3	; 0x03
 bc8:	e0 2d       	mov	r30, r0
 bca:	12 96       	adiw	r26, 0x02	; 2
 bcc:	fc 93       	st	X, r31
 bce:	ee 93       	st	-X, r30
 bd0:	11 97       	sbiw	r26, 0x01	; 1
 bd2:	46 5c       	subi	r20, 0xC6	; 198
 bd4:	58 4f       	sbci	r21, 0xF8	; 248
 bd6:	e4 17       	cp	r30, r20
 bd8:	f5 07       	cpc	r31, r21
 bda:	29 f4       	brne	.+10     	; 0xbe6 <vTaskSwitchContext+0x9c>
 bdc:	42 81       	ldd	r20, Z+2	; 0x02
 bde:	53 81       	ldd	r21, Z+3	; 0x03
 be0:	fd 01       	movw	r30, r26
 be2:	52 83       	std	Z+2, r21	; 0x02
 be4:	41 83       	std	Z+1, r20	; 0x01
 be6:	fc 01       	movw	r30, r24
 be8:	ee 0f       	add	r30, r30
 bea:	ff 1f       	adc	r31, r31
 bec:	ee 0f       	add	r30, r30
 bee:	ff 1f       	adc	r31, r31
 bf0:	ee 0f       	add	r30, r30
 bf2:	ff 1f       	adc	r31, r31
 bf4:	8e 0f       	add	r24, r30
 bf6:	9f 1f       	adc	r25, r31
 bf8:	fc 01       	movw	r30, r24
 bfa:	e9 5c       	subi	r30, 0xC9	; 201
 bfc:	f8 4f       	sbci	r31, 0xF8	; 248
 bfe:	01 80       	ldd	r0, Z+1	; 0x01
 c00:	f2 81       	ldd	r31, Z+2	; 0x02
 c02:	e0 2d       	mov	r30, r0
 c04:	86 81       	ldd	r24, Z+6	; 0x06
 c06:	97 81       	ldd	r25, Z+7	; 0x07
 c08:	90 93 5c 07 	sts	0x075C, r25	; 0x80075c <pxCurrentTCB+0x1>
 c0c:	80 93 5b 07 	sts	0x075B, r24	; 0x80075b <pxCurrentTCB>
 c10:	20 93 0a 07 	sts	0x070A, r18	; 0x80070a <uxTopReadyPriority>
 c14:	08 95       	ret

00000c16 <vRedLED>:

	/* The parameters are not used. */
	( void ) pvParameters;

	for( ;; ) {
		PORTB ^= (1 << PB0);
 c16:	c1 e0       	ldi	r28, 0x01	; 1
 c18:	88 b3       	in	r24, 0x18	; 24
 c1a:	8c 27       	eor	r24, r28
 c1c:	88 bb       	out	0x18, r24	; 24
		/* pdMS_TO_TICKS is not working as expected. 
		   Use formula: (time_ms*configTICK_RATE_HZ)/1000 */
		vTaskDelay( 50 );
 c1e:	82 e3       	ldi	r24, 0x32	; 50
 c20:	90 e0       	ldi	r25, 0x00	; 0
 c22:	0e 94 54 05 	call	0xaa8	; 0xaa8 <vTaskDelay>
 c26:	f8 cf       	rjmp	.-16     	; 0xc18 <vRedLED+0x2>

00000c28 <vGreenLED>:

	/* The parameters are not used. */
	( void ) pvParameters;

	for( ;; ) {
		PORTB ^= (1 << PB1);
 c28:	c2 e0       	ldi	r28, 0x02	; 2
 c2a:	88 b3       	in	r24, 0x18	; 24
 c2c:	8c 27       	eor	r24, r28
 c2e:	88 bb       	out	0x18, r24	; 24
		vTaskDelay( 50 );
 c30:	82 e3       	ldi	r24, 0x32	; 50
 c32:	90 e0       	ldi	r25, 0x00	; 0
 c34:	0e 94 54 05 	call	0xaa8	; 0xaa8 <vTaskDelay>
		USART0_SendString(message);
 c38:	80 e0       	ldi	r24, 0x00	; 0
 c3a:	91 e0       	ldi	r25, 0x01	; 1
 c3c:	0e 94 5e 06 	call	0xcbc	; 0xcbc <USART0_SendString>
 c40:	f4 cf       	rjmp	.-24     	; 0xc2a <vGreenLED+0x2>

00000c42 <main>:

//xComPortHandle serialPort;

unsigned char message[] = "Hello! ";

int main( void ) {
 c42:	ef 92       	push	r14
 c44:	ff 92       	push	r15
 c46:	0f 93       	push	r16

	DDRB |= (1 << PB0);
 c48:	b8 9a       	sbi	0x17, 0	; 23
	DDRB |= (1 << PB1);
 c4a:	b9 9a       	sbi	0x17, 1	; 23

	//serialPort = xSerialPortInitMinimal(115200, 8);
	USART_Init();
 c4c:	0e 94 57 06 	call	0xcae	; 0xcae <USART_Init>

	/* Create the tasks defined within this file. */
	xTaskCreate( vRedLED, "Red LED", configMINIMAL_STACK_SIZE, NULL, mainRED_LED_TASK_PRIORITY, NULL );
 c50:	e1 2c       	mov	r14, r1
 c52:	f1 2c       	mov	r15, r1
 c54:	01 e0       	ldi	r16, 0x01	; 1
 c56:	20 e0       	ldi	r18, 0x00	; 0
 c58:	30 e0       	ldi	r19, 0x00	; 0
 c5a:	45 e5       	ldi	r20, 0x55	; 85
 c5c:	50 e0       	ldi	r21, 0x00	; 0
 c5e:	6d e0       	ldi	r22, 0x0D	; 13
 c60:	71 e0       	ldi	r23, 0x01	; 1
 c62:	8b e0       	ldi	r24, 0x0B	; 11
 c64:	96 e0       	ldi	r25, 0x06	; 6
 c66:	0e 94 e2 02 	call	0x5c4	; 0x5c4 <xTaskCreate>
	xTaskCreate( vGreenLED, "Green LED", configMINIMAL_STACK_SIZE, NULL, mainGREEN_LED_TASK_PRIORITY, NULL );
 c6a:	02 e0       	ldi	r16, 0x02	; 2
 c6c:	20 e0       	ldi	r18, 0x00	; 0
 c6e:	30 e0       	ldi	r19, 0x00	; 0
 c70:	45 e5       	ldi	r20, 0x55	; 85
 c72:	50 e0       	ldi	r21, 0x00	; 0
 c74:	65 e1       	ldi	r22, 0x15	; 21
 c76:	71 e0       	ldi	r23, 0x01	; 1
 c78:	84 e1       	ldi	r24, 0x14	; 20
 c7a:	96 e0       	ldi	r25, 0x06	; 6
 c7c:	0e 94 e2 02 	call	0x5c4	; 0x5c4 <xTaskCreate>
	//xTaskCreate( vPutChar, "Put Char", configMINIMAL_STACK_SIZE, NULL, 3, NULL );

	vTaskStartScheduler();
 c80:	0e 94 ea 03 	call	0x7d4	; 0x7d4 <vTaskStartScheduler>

	return 0;
}
 c84:	80 e0       	ldi	r24, 0x00	; 0
 c86:	90 e0       	ldi	r25, 0x00	; 0
 c88:	0f 91       	pop	r16
 c8a:	ff 90       	pop	r15
 c8c:	ef 90       	pop	r14
 c8e:	08 95       	ret

00000c90 <__vector_18>:

	/* Wait for empty transmit buffer */
	while(!UDRE0);

	/* Put data into buffer, sends the data */
	UDR0 = c;
 c90:	1f 92       	push	r1
 c92:	0f 92       	push	r0
 c94:	0f b6       	in	r0, 0x3f	; 63
 c96:	0f 92       	push	r0
 c98:	11 24       	eor	r1, r1
 c9a:	8f 93       	push	r24
 c9c:	8c b1       	in	r24, 0x0c	; 12
 c9e:	80 93 5d 07 	sts	0x075D, r24	; 0x80075d <value>
 ca2:	8f 91       	pop	r24
 ca4:	0f 90       	pop	r0
 ca6:	0f be       	out	0x3f, r0	; 63
 ca8:	0f 90       	pop	r0
 caa:	1f 90       	pop	r1
 cac:	18 95       	reti

00000cae <USART_Init>:
 cae:	10 92 90 00 	sts	0x0090, r1	; 0x800090 <__TEXT_REGION_LENGTH__+0x7e0090>
 cb2:	87 e4       	ldi	r24, 0x47	; 71
 cb4:	89 b9       	out	0x09, r24	; 9
 cb6:	88 e1       	ldi	r24, 0x18	; 24
 cb8:	8a b9       	out	0x0a, r24	; 10
 cba:	08 95       	ret

00000cbc <USART0_SendString>:
}

// Max 256 characters
void USART0_SendString(unsigned char *str) {
 cbc:	dc 01       	movw	r26, r24

	for(uint8_t i = 0; str[i] != '\0'; ++i) {
 cbe:	9c 91       	ld	r25, X
 cc0:	99 23       	and	r25, r25
 cc2:	59 f0       	breq	.+22     	; 0xcda <USART0_SendString+0x1e>
 cc4:	20 e0       	ldi	r18, 0x00	; 0
		while(!( UCSR0A & (1<<UDRE0)));		// Wait for empty transmit buffer
 cc6:	5d 9b       	sbis	0x0b, 5	; 11
 cc8:	fe cf       	rjmp	.-4      	; 0xcc6 <USART0_SendString+0xa>
		UDR0 = str[i];						// Put character into buffer and send
 cca:	9c b9       	out	0x0c, r25	; 12
}

// Max 256 characters
void USART0_SendString(unsigned char *str) {

	for(uint8_t i = 0; str[i] != '\0'; ++i) {
 ccc:	2f 5f       	subi	r18, 0xFF	; 255
 cce:	fd 01       	movw	r30, r26
 cd0:	e2 0f       	add	r30, r18
 cd2:	f1 1d       	adc	r31, r1
 cd4:	90 81       	ld	r25, Z
 cd6:	91 11       	cpse	r25, r1
 cd8:	f6 cf       	rjmp	.-20     	; 0xcc6 <USART0_SendString+0xa>
 cda:	08 95       	ret

00000cdc <_exit>:
 cdc:	f8 94       	cli

00000cde <__stop_program>:
 cde:	ff cf       	rjmp	.-2      	; 0xcde <__stop_program>
