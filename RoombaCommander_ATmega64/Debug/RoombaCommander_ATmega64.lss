
RoombaCommander_ATmega64.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000001c  00800100  00003c52  00003ce6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00003c52  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000ca0  0080011c  0080011c  00003d02  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00003d02  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00003d34  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000100  00000000  00000000  00003d70  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000326f  00000000  00000000  00003e70  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000010b4  00000000  00000000  000070df  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000027dc  00000000  00000000  00008193  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000d38  00000000  00000000  0000a970  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000015f9  00000000  00000000  0000b6a8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001b64  00000000  00000000  0000cca1  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 46 00 	jmp	0x8c	; 0x8c <__ctors_end>
       4:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
       8:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
       c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      10:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      14:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      18:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      1c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      20:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      24:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      28:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      2c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      30:	0c 94 c8 07 	jmp	0xf90	; 0xf90 <__vector_12>
      34:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      38:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      3c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      40:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      44:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      48:	0c 94 7c 1d 	jmp	0x3af8	; 0x3af8 <__vector_18>
      4c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      50:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      54:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      58:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      5c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      60:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      64:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      68:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      6c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      70:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      74:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      78:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      7c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      80:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      84:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      88:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>

0000008c <__ctors_end>:
      8c:	11 24       	eor	r1, r1
      8e:	1f be       	out	0x3f, r1	; 63
      90:	cf ef       	ldi	r28, 0xFF	; 255
      92:	d0 e1       	ldi	r29, 0x10	; 16
      94:	de bf       	out	0x3e, r29	; 62
      96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
      98:	11 e0       	ldi	r17, 0x01	; 1
      9a:	a0 e0       	ldi	r26, 0x00	; 0
      9c:	b1 e0       	ldi	r27, 0x01	; 1
      9e:	e2 e5       	ldi	r30, 0x52	; 82
      a0:	fc e3       	ldi	r31, 0x3C	; 60
      a2:	02 c0       	rjmp	.+4      	; 0xa8 <__do_copy_data+0x10>
      a4:	05 90       	lpm	r0, Z+
      a6:	0d 92       	st	X+, r0
      a8:	ac 31       	cpi	r26, 0x1C	; 28
      aa:	b1 07       	cpc	r27, r17
      ac:	d9 f7       	brne	.-10     	; 0xa4 <__do_copy_data+0xc>

000000ae <__do_clear_bss>:
      ae:	2d e0       	ldi	r18, 0x0D	; 13
      b0:	ac e1       	ldi	r26, 0x1C	; 28
      b2:	b1 e0       	ldi	r27, 0x01	; 1
      b4:	01 c0       	rjmp	.+2      	; 0xb8 <.do_clear_bss_start>

000000b6 <.do_clear_bss_loop>:
      b6:	1d 92       	st	X+, r1

000000b8 <.do_clear_bss_start>:
      b8:	ac 3b       	cpi	r26, 0xBC	; 188
      ba:	b2 07       	cpc	r27, r18
      bc:	e1 f7       	brne	.-8      	; 0xb6 <.do_clear_bss_loop>
      be:	0e 94 93 1c 	call	0x3926	; 0x3926 <main>
      c2:	0c 94 27 1e 	jmp	0x3c4e	; 0x3c4e <_exit>

000000c6 <__bad_interrupt>:
      c6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ca <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, UBaseType_t uxPriority, UBaseType_t uxIndex )
{
      ca:	cf 93       	push	r28
      cc:	df 93       	push	r29
      ce:	cd b7       	in	r28, 0x3d	; 61
      d0:	de b7       	in	r29, 0x3e	; 62
      d2:	27 97       	sbiw	r28, 0x07	; 7
      d4:	0f b6       	in	r0, 0x3f	; 63
      d6:	f8 94       	cli
      d8:	de bf       	out	0x3e, r29	; 62
      da:	0f be       	out	0x3f, r0	; 63
      dc:	cd bf       	out	0x3d, r28	; 61
      de:	9d 83       	std	Y+5, r25	; 0x05
      e0:	8c 83       	std	Y+4, r24	; 0x04
      e2:	6e 83       	std	Y+6, r22	; 0x06
      e4:	4f 83       	std	Y+7, r20	; 0x07
BaseType_t xReturn;
CRCB_t *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
      e6:	8a e1       	ldi	r24, 0x1A	; 26
      e8:	90 e0       	ldi	r25, 0x00	; 0
      ea:	0e 94 cc 07 	call	0xf98	; 0xf98 <pvPortMalloc>
      ee:	9b 83       	std	Y+3, r25	; 0x03
      f0:	8a 83       	std	Y+2, r24	; 0x02
	if( pxCoRoutine )
      f2:	8a 81       	ldd	r24, Y+2	; 0x02
      f4:	9b 81       	ldd	r25, Y+3	; 0x03
      f6:	89 2b       	or	r24, r25
      f8:	09 f4       	brne	.+2      	; 0xfc <xCoRoutineCreate+0x32>
      fa:	77 c0       	rjmp	.+238    	; 0x1ea <xCoRoutineCreate+0x120>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
      fc:	80 91 1c 01 	lds	r24, 0x011C	; 0x80011c <__data_end>
     100:	90 91 1d 01 	lds	r25, 0x011D	; 0x80011d <__data_end+0x1>
     104:	89 2b       	or	r24, r25
     106:	41 f4       	brne	.+16     	; 0x118 <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
     108:	8a 81       	ldd	r24, Y+2	; 0x02
     10a:	9b 81       	ldd	r25, Y+3	; 0x03
     10c:	90 93 1d 01 	sts	0x011D, r25	; 0x80011d <__data_end+0x1>
     110:	80 93 1c 01 	sts	0x011C, r24	; 0x80011c <__data_end>
			prvInitialiseCoRoutineLists();
     114:	0e 94 ef 02 	call	0x5de	; 0x5de <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
     118:	8e 81       	ldd	r24, Y+6	; 0x06
     11a:	82 30       	cpi	r24, 0x02	; 2
     11c:	10 f0       	brcs	.+4      	; 0x122 <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
     11e:	81 e0       	ldi	r24, 0x01	; 1
     120:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
     122:	8a 81       	ldd	r24, Y+2	; 0x02
     124:	9b 81       	ldd	r25, Y+3	; 0x03
     126:	fc 01       	movw	r30, r24
     128:	11 8e       	std	Z+25, r1	; 0x19
     12a:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
     12c:	8a 81       	ldd	r24, Y+2	; 0x02
     12e:	9b 81       	ldd	r25, Y+3	; 0x03
     130:	2e 81       	ldd	r18, Y+6	; 0x06
     132:	fc 01       	movw	r30, r24
     134:	26 8b       	std	Z+22, r18	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
     136:	8a 81       	ldd	r24, Y+2	; 0x02
     138:	9b 81       	ldd	r25, Y+3	; 0x03
     13a:	2f 81       	ldd	r18, Y+7	; 0x07
     13c:	fc 01       	movw	r30, r24
     13e:	27 8b       	std	Z+23, r18	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     140:	8a 81       	ldd	r24, Y+2	; 0x02
     142:	9b 81       	ldd	r25, Y+3	; 0x03
     144:	2c 81       	ldd	r18, Y+4	; 0x04
     146:	3d 81       	ldd	r19, Y+5	; 0x05
     148:	fc 01       	movw	r30, r24
     14a:	31 83       	std	Z+1, r19	; 0x01
     14c:	20 83       	st	Z, r18

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     14e:	8a 81       	ldd	r24, Y+2	; 0x02
     150:	9b 81       	ldd	r25, Y+3	; 0x03
     152:	02 96       	adiw	r24, 0x02	; 2
     154:	0e 94 98 03 	call	0x730	; 0x730 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     158:	8a 81       	ldd	r24, Y+2	; 0x02
     15a:	9b 81       	ldd	r25, Y+3	; 0x03
     15c:	0c 96       	adiw	r24, 0x0c	; 12
     15e:	0e 94 98 03 	call	0x730	; 0x730 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the ListItem_t.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     162:	8a 81       	ldd	r24, Y+2	; 0x02
     164:	9b 81       	ldd	r25, Y+3	; 0x03
     166:	2a 81       	ldd	r18, Y+2	; 0x02
     168:	3b 81       	ldd	r19, Y+3	; 0x03
     16a:	fc 01       	movw	r30, r24
     16c:	31 87       	std	Z+9, r19	; 0x09
     16e:	20 87       	std	Z+8, r18	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	2a 81       	ldd	r18, Y+2	; 0x02
     176:	3b 81       	ldd	r19, Y+3	; 0x03
     178:	fc 01       	movw	r30, r24
     17a:	33 8b       	std	Z+19, r19	; 0x13
     17c:	22 8b       	std	Z+18, r18	; 0x12

		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
     17e:	8e 81       	ldd	r24, Y+6	; 0x06
     180:	88 2f       	mov	r24, r24
     182:	90 e0       	ldi	r25, 0x00	; 0
     184:	22 e0       	ldi	r18, 0x02	; 2
     186:	30 e0       	ldi	r19, 0x00	; 0
     188:	28 1b       	sub	r18, r24
     18a:	39 0b       	sbc	r19, r25
     18c:	8a 81       	ldd	r24, Y+2	; 0x02
     18e:	9b 81       	ldd	r25, Y+3	; 0x03
     190:	fc 01       	movw	r30, r24
     192:	35 87       	std	Z+13, r19	; 0x0d
     194:	24 87       	std	Z+12, r18	; 0x0c

		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
     196:	8a 81       	ldd	r24, Y+2	; 0x02
     198:	9b 81       	ldd	r25, Y+3	; 0x03
     19a:	fc 01       	movw	r30, r24
     19c:	96 89       	ldd	r25, Z+22	; 0x16
     19e:	80 91 4f 01 	lds	r24, 0x014F	; 0x80014f <uxTopCoRoutineReadyPriority>
     1a2:	89 17       	cp	r24, r25
     1a4:	30 f4       	brcc	.+12     	; 0x1b2 <xCoRoutineCreate+0xe8>
     1a6:	8a 81       	ldd	r24, Y+2	; 0x02
     1a8:	9b 81       	ldd	r25, Y+3	; 0x03
     1aa:	fc 01       	movw	r30, r24
     1ac:	86 89       	ldd	r24, Z+22	; 0x16
     1ae:	80 93 4f 01 	sts	0x014F, r24	; 0x80014f <uxTopCoRoutineReadyPriority>
     1b2:	8a 81       	ldd	r24, Y+2	; 0x02
     1b4:	9b 81       	ldd	r25, Y+3	; 0x03
     1b6:	ac 01       	movw	r20, r24
     1b8:	4e 5f       	subi	r20, 0xFE	; 254
     1ba:	5f 4f       	sbci	r21, 0xFF	; 255
     1bc:	8a 81       	ldd	r24, Y+2	; 0x02
     1be:	9b 81       	ldd	r25, Y+3	; 0x03
     1c0:	fc 01       	movw	r30, r24
     1c2:	86 89       	ldd	r24, Z+22	; 0x16
     1c4:	28 2f       	mov	r18, r24
     1c6:	30 e0       	ldi	r19, 0x00	; 0
     1c8:	c9 01       	movw	r24, r18
     1ca:	88 0f       	add	r24, r24
     1cc:	99 1f       	adc	r25, r25
     1ce:	88 0f       	add	r24, r24
     1d0:	99 1f       	adc	r25, r25
     1d2:	88 0f       	add	r24, r24
     1d4:	99 1f       	adc	r25, r25
     1d6:	82 0f       	add	r24, r18
     1d8:	93 1f       	adc	r25, r19
     1da:	82 5e       	subi	r24, 0xE2	; 226
     1dc:	9e 4f       	sbci	r25, 0xFE	; 254
     1de:	ba 01       	movw	r22, r20
     1e0:	0e 94 aa 03 	call	0x754	; 0x754 <vListInsertEnd>

		xReturn = pdPASS;
     1e4:	81 e0       	ldi	r24, 0x01	; 1
     1e6:	89 83       	std	Y+1, r24	; 0x01
     1e8:	02 c0       	rjmp	.+4      	; 0x1ee <xCoRoutineCreate+0x124>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     1ea:	8f ef       	ldi	r24, 0xFF	; 255
     1ec:	89 83       	std	Y+1, r24	; 0x01
	}

	return xReturn;
     1ee:	89 81       	ldd	r24, Y+1	; 0x01
}
     1f0:	27 96       	adiw	r28, 0x07	; 7
     1f2:	0f b6       	in	r0, 0x3f	; 63
     1f4:	f8 94       	cli
     1f6:	de bf       	out	0x3e, r29	; 62
     1f8:	0f be       	out	0x3f, r0	; 63
     1fa:	cd bf       	out	0x3d, r28	; 61
     1fc:	df 91       	pop	r29
     1fe:	cf 91       	pop	r28
     200:	08 95       	ret

00000202 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay, List_t *pxEventList )
{
     202:	cf 93       	push	r28
     204:	df 93       	push	r29
     206:	00 d0       	rcall	.+0      	; 0x208 <vCoRoutineAddToDelayedList+0x6>
     208:	00 d0       	rcall	.+0      	; 0x20a <vCoRoutineAddToDelayedList+0x8>
     20a:	00 d0       	rcall	.+0      	; 0x20c <vCoRoutineAddToDelayedList+0xa>
     20c:	cd b7       	in	r28, 0x3d	; 61
     20e:	de b7       	in	r29, 0x3e	; 62
     210:	9c 83       	std	Y+4, r25	; 0x04
     212:	8b 83       	std	Y+3, r24	; 0x03
     214:	7e 83       	std	Y+6, r23	; 0x06
     216:	6d 83       	std	Y+5, r22	; 0x05
TickType_t xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     218:	20 91 50 01 	lds	r18, 0x0150	; 0x800150 <xCoRoutineTickCount>
     21c:	30 91 51 01 	lds	r19, 0x0151	; 0x800151 <xCoRoutineTickCount+0x1>
     220:	8b 81       	ldd	r24, Y+3	; 0x03
     222:	9c 81       	ldd	r25, Y+4	; 0x04
     224:	82 0f       	add	r24, r18
     226:	93 1f       	adc	r25, r19
     228:	9a 83       	std	Y+2, r25	; 0x02
     22a:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     22c:	80 91 1c 01 	lds	r24, 0x011C	; 0x80011c <__data_end>
     230:	90 91 1d 01 	lds	r25, 0x011D	; 0x80011d <__data_end+0x1>
     234:	02 96       	adiw	r24, 0x02	; 2
     236:	0e 94 71 04 	call	0x8e2	; 0x8e2 <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     23a:	80 91 1c 01 	lds	r24, 0x011C	; 0x80011c <__data_end>
     23e:	90 91 1d 01 	lds	r25, 0x011D	; 0x80011d <__data_end+0x1>
     242:	29 81       	ldd	r18, Y+1	; 0x01
     244:	3a 81       	ldd	r19, Y+2	; 0x02
     246:	fc 01       	movw	r30, r24
     248:	33 83       	std	Z+3, r19	; 0x03
     24a:	22 83       	std	Z+2, r18	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
     24c:	80 91 50 01 	lds	r24, 0x0150	; 0x800150 <xCoRoutineTickCount>
     250:	90 91 51 01 	lds	r25, 0x0151	; 0x800151 <xCoRoutineTickCount+0x1>
     254:	29 81       	ldd	r18, Y+1	; 0x01
     256:	3a 81       	ldd	r19, Y+2	; 0x02
     258:	28 17       	cp	r18, r24
     25a:	39 07       	cpc	r19, r25
     25c:	78 f4       	brcc	.+30     	; 0x27c <vCoRoutineAddToDelayedList+0x7a>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     25e:	80 91 1c 01 	lds	r24, 0x011C	; 0x80011c <__data_end>
     262:	90 91 1d 01 	lds	r25, 0x011D	; 0x80011d <__data_end+0x1>
     266:	9c 01       	movw	r18, r24
     268:	2e 5f       	subi	r18, 0xFE	; 254
     26a:	3f 4f       	sbci	r19, 0xFF	; 255
     26c:	80 91 44 01 	lds	r24, 0x0144	; 0x800144 <pxOverflowDelayedCoRoutineList>
     270:	90 91 45 01 	lds	r25, 0x0145	; 0x800145 <pxOverflowDelayedCoRoutineList+0x1>
     274:	b9 01       	movw	r22, r18
     276:	0e 94 f9 03 	call	0x7f2	; 0x7f2 <vListInsert>
     27a:	0e c0       	rjmp	.+28     	; 0x298 <vCoRoutineAddToDelayedList+0x96>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     27c:	80 91 1c 01 	lds	r24, 0x011C	; 0x80011c <__data_end>
     280:	90 91 1d 01 	lds	r25, 0x011D	; 0x80011d <__data_end+0x1>
     284:	9c 01       	movw	r18, r24
     286:	2e 5f       	subi	r18, 0xFE	; 254
     288:	3f 4f       	sbci	r19, 0xFF	; 255
     28a:	80 91 42 01 	lds	r24, 0x0142	; 0x800142 <pxDelayedCoRoutineList>
     28e:	90 91 43 01 	lds	r25, 0x0143	; 0x800143 <pxDelayedCoRoutineList+0x1>
     292:	b9 01       	movw	r22, r18
     294:	0e 94 f9 03 	call	0x7f2	; 0x7f2 <vListInsert>
	}

	if( pxEventList )
     298:	8d 81       	ldd	r24, Y+5	; 0x05
     29a:	9e 81       	ldd	r25, Y+6	; 0x06
     29c:	89 2b       	or	r24, r25
     29e:	61 f0       	breq	.+24     	; 0x2b8 <vCoRoutineAddToDelayedList+0xb6>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     2a0:	80 91 1c 01 	lds	r24, 0x011C	; 0x80011c <__data_end>
     2a4:	90 91 1d 01 	lds	r25, 0x011D	; 0x80011d <__data_end+0x1>
     2a8:	9c 01       	movw	r18, r24
     2aa:	24 5f       	subi	r18, 0xF4	; 244
     2ac:	3f 4f       	sbci	r19, 0xFF	; 255
     2ae:	8d 81       	ldd	r24, Y+5	; 0x05
     2b0:	9e 81       	ldd	r25, Y+6	; 0x06
     2b2:	b9 01       	movw	r22, r18
     2b4:	0e 94 f9 03 	call	0x7f2	; 0x7f2 <vListInsert>
	}
}
     2b8:	00 00       	nop
     2ba:	26 96       	adiw	r28, 0x06	; 6
     2bc:	0f b6       	in	r0, 0x3f	; 63
     2be:	f8 94       	cli
     2c0:	de bf       	out	0x3e, r29	; 62
     2c2:	0f be       	out	0x3f, r0	; 63
     2c4:	cd bf       	out	0x3d, r28	; 61
     2c6:	df 91       	pop	r29
     2c8:	cf 91       	pop	r28
     2ca:	08 95       	ret

000002cc <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
     2cc:	cf 93       	push	r28
     2ce:	df 93       	push	r29
     2d0:	00 d0       	rcall	.+0      	; 0x2d2 <prvCheckPendingReadyList+0x6>
     2d2:	cd b7       	in	r28, 0x3d	; 61
     2d4:	de b7       	in	r29, 0x3e	; 62
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     2d6:	3c c0       	rjmp	.+120    	; 0x350 <prvCheckPendingReadyList+0x84>
	{
		CRCB_t *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
     2d8:	f8 94       	cli
		{
			pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
     2da:	80 91 4b 01 	lds	r24, 0x014B	; 0x80014b <xPendingReadyCoRoutineList+0x5>
     2de:	90 91 4c 01 	lds	r25, 0x014C	; 0x80014c <xPendingReadyCoRoutineList+0x6>
     2e2:	fc 01       	movw	r30, r24
     2e4:	86 81       	ldd	r24, Z+6	; 0x06
     2e6:	97 81       	ldd	r25, Z+7	; 0x07
     2e8:	9a 83       	std	Y+2, r25	; 0x02
     2ea:	89 83       	std	Y+1, r24	; 0x01
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     2ec:	89 81       	ldd	r24, Y+1	; 0x01
     2ee:	9a 81       	ldd	r25, Y+2	; 0x02
     2f0:	0c 96       	adiw	r24, 0x0c	; 12
     2f2:	0e 94 71 04 	call	0x8e2	; 0x8e2 <uxListRemove>
		}
		portENABLE_INTERRUPTS();
     2f6:	78 94       	sei

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
     2f8:	89 81       	ldd	r24, Y+1	; 0x01
     2fa:	9a 81       	ldd	r25, Y+2	; 0x02
     2fc:	02 96       	adiw	r24, 0x02	; 2
     2fe:	0e 94 71 04 	call	0x8e2	; 0x8e2 <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
     302:	89 81       	ldd	r24, Y+1	; 0x01
     304:	9a 81       	ldd	r25, Y+2	; 0x02
     306:	fc 01       	movw	r30, r24
     308:	96 89       	ldd	r25, Z+22	; 0x16
     30a:	80 91 4f 01 	lds	r24, 0x014F	; 0x80014f <uxTopCoRoutineReadyPriority>
     30e:	89 17       	cp	r24, r25
     310:	30 f4       	brcc	.+12     	; 0x31e <prvCheckPendingReadyList+0x52>
     312:	89 81       	ldd	r24, Y+1	; 0x01
     314:	9a 81       	ldd	r25, Y+2	; 0x02
     316:	fc 01       	movw	r30, r24
     318:	86 89       	ldd	r24, Z+22	; 0x16
     31a:	80 93 4f 01 	sts	0x014F, r24	; 0x80014f <uxTopCoRoutineReadyPriority>
     31e:	89 81       	ldd	r24, Y+1	; 0x01
     320:	9a 81       	ldd	r25, Y+2	; 0x02
     322:	ac 01       	movw	r20, r24
     324:	4e 5f       	subi	r20, 0xFE	; 254
     326:	5f 4f       	sbci	r21, 0xFF	; 255
     328:	89 81       	ldd	r24, Y+1	; 0x01
     32a:	9a 81       	ldd	r25, Y+2	; 0x02
     32c:	fc 01       	movw	r30, r24
     32e:	86 89       	ldd	r24, Z+22	; 0x16
     330:	28 2f       	mov	r18, r24
     332:	30 e0       	ldi	r19, 0x00	; 0
     334:	c9 01       	movw	r24, r18
     336:	88 0f       	add	r24, r24
     338:	99 1f       	adc	r25, r25
     33a:	88 0f       	add	r24, r24
     33c:	99 1f       	adc	r25, r25
     33e:	88 0f       	add	r24, r24
     340:	99 1f       	adc	r25, r25
     342:	82 0f       	add	r24, r18
     344:	93 1f       	adc	r25, r19
     346:	82 5e       	subi	r24, 0xE2	; 226
     348:	9e 4f       	sbci	r25, 0xFE	; 254
     34a:	ba 01       	movw	r22, r20
     34c:	0e 94 aa 03 	call	0x754	; 0x754 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     350:	80 91 46 01 	lds	r24, 0x0146	; 0x800146 <xPendingReadyCoRoutineList>
     354:	88 23       	and	r24, r24
     356:	09 f0       	breq	.+2      	; 0x35a <prvCheckPendingReadyList+0x8e>
     358:	bf cf       	rjmp	.-130    	; 0x2d8 <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
	}
}
     35a:	00 00       	nop
     35c:	0f 90       	pop	r0
     35e:	0f 90       	pop	r0
     360:	df 91       	pop	r29
     362:	cf 91       	pop	r28
     364:	08 95       	ret

00000366 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
     366:	cf 93       	push	r28
     368:	df 93       	push	r29
     36a:	00 d0       	rcall	.+0      	; 0x36c <prvCheckDelayedList+0x6>
     36c:	00 d0       	rcall	.+0      	; 0x36e <prvCheckDelayedList+0x8>
     36e:	cd b7       	in	r28, 0x3d	; 61
     370:	de b7       	in	r29, 0x3e	; 62
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
     372:	0e 94 f8 13 	call	0x27f0	; 0x27f0 <xTaskGetTickCount>
     376:	9c 01       	movw	r18, r24
     378:	80 91 52 01 	lds	r24, 0x0152	; 0x800152 <xLastTickCount>
     37c:	90 91 53 01 	lds	r25, 0x0153	; 0x800153 <xLastTickCount+0x1>
     380:	a9 01       	movw	r20, r18
     382:	48 1b       	sub	r20, r24
     384:	59 0b       	sbc	r21, r25
     386:	ca 01       	movw	r24, r20
     388:	90 93 55 01 	sts	0x0155, r25	; 0x800155 <xPassedTicks+0x1>
     38c:	80 93 54 01 	sts	0x0154, r24	; 0x800154 <xPassedTicks>
	while( xPassedTicks )
     390:	8a c0       	rjmp	.+276    	; 0x4a6 <__LOCK_REGION_LENGTH__+0xa6>
	{
		xCoRoutineTickCount++;
     392:	80 91 50 01 	lds	r24, 0x0150	; 0x800150 <xCoRoutineTickCount>
     396:	90 91 51 01 	lds	r25, 0x0151	; 0x800151 <xCoRoutineTickCount+0x1>
     39a:	01 96       	adiw	r24, 0x01	; 1
     39c:	90 93 51 01 	sts	0x0151, r25	; 0x800151 <xCoRoutineTickCount+0x1>
     3a0:	80 93 50 01 	sts	0x0150, r24	; 0x800150 <xCoRoutineTickCount>
		xPassedTicks--;
     3a4:	80 91 54 01 	lds	r24, 0x0154	; 0x800154 <xPassedTicks>
     3a8:	90 91 55 01 	lds	r25, 0x0155	; 0x800155 <xPassedTicks+0x1>
     3ac:	01 97       	sbiw	r24, 0x01	; 1
     3ae:	90 93 55 01 	sts	0x0155, r25	; 0x800155 <xPassedTicks+0x1>
     3b2:	80 93 54 01 	sts	0x0154, r24	; 0x800154 <xPassedTicks>

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
     3b6:	80 91 50 01 	lds	r24, 0x0150	; 0x800150 <xCoRoutineTickCount>
     3ba:	90 91 51 01 	lds	r25, 0x0151	; 0x800151 <xCoRoutineTickCount+0x1>
     3be:	89 2b       	or	r24, r25
     3c0:	09 f0       	breq	.+2      	; 0x3c4 <prvCheckDelayedList+0x5e>
     3c2:	68 c0       	rjmp	.+208    	; 0x494 <__LOCK_REGION_LENGTH__+0x94>
		{
			List_t * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
     3c4:	80 91 42 01 	lds	r24, 0x0142	; 0x800142 <pxDelayedCoRoutineList>
     3c8:	90 91 43 01 	lds	r25, 0x0143	; 0x800143 <pxDelayedCoRoutineList+0x1>
     3cc:	9a 83       	std	Y+2, r25	; 0x02
     3ce:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
     3d0:	80 91 44 01 	lds	r24, 0x0144	; 0x800144 <pxOverflowDelayedCoRoutineList>
     3d4:	90 91 45 01 	lds	r25, 0x0145	; 0x800145 <pxOverflowDelayedCoRoutineList+0x1>
     3d8:	90 93 43 01 	sts	0x0143, r25	; 0x800143 <pxDelayedCoRoutineList+0x1>
     3dc:	80 93 42 01 	sts	0x0142, r24	; 0x800142 <pxDelayedCoRoutineList>
			pxOverflowDelayedCoRoutineList = pxTemp;
     3e0:	89 81       	ldd	r24, Y+1	; 0x01
     3e2:	9a 81       	ldd	r25, Y+2	; 0x02
     3e4:	90 93 45 01 	sts	0x0145, r25	; 0x800145 <pxOverflowDelayedCoRoutineList+0x1>
     3e8:	80 93 44 01 	sts	0x0144, r24	; 0x800144 <pxOverflowDelayedCoRoutineList>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     3ec:	53 c0       	rjmp	.+166    	; 0x494 <__LOCK_REGION_LENGTH__+0x94>
		{
			pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     3ee:	80 91 42 01 	lds	r24, 0x0142	; 0x800142 <pxDelayedCoRoutineList>
     3f2:	90 91 43 01 	lds	r25, 0x0143	; 0x800143 <pxDelayedCoRoutineList+0x1>
     3f6:	fc 01       	movw	r30, r24
     3f8:	85 81       	ldd	r24, Z+5	; 0x05
     3fa:	96 81       	ldd	r25, Z+6	; 0x06
     3fc:	fc 01       	movw	r30, r24
     3fe:	86 81       	ldd	r24, Z+6	; 0x06
     400:	97 81       	ldd	r25, Z+7	; 0x07
     402:	9c 83       	std	Y+4, r25	; 0x04
     404:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
     406:	8b 81       	ldd	r24, Y+3	; 0x03
     408:	9c 81       	ldd	r25, Y+4	; 0x04
     40a:	fc 01       	movw	r30, r24
     40c:	22 81       	ldd	r18, Z+2	; 0x02
     40e:	33 81       	ldd	r19, Z+3	; 0x03
     410:	80 91 50 01 	lds	r24, 0x0150	; 0x800150 <xCoRoutineTickCount>
     414:	90 91 51 01 	lds	r25, 0x0151	; 0x800151 <xCoRoutineTickCount+0x1>
     418:	82 17       	cp	r24, r18
     41a:	93 07       	cpc	r25, r19
     41c:	08 f4       	brcc	.+2      	; 0x420 <__LOCK_REGION_LENGTH__+0x20>
			{
				/* Timeout not yet expired. */
				break;
     41e:	43 c0       	rjmp	.+134    	; 0x4a6 <__LOCK_REGION_LENGTH__+0xa6>
			}

			portDISABLE_INTERRUPTS();
     420:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
     422:	8b 81       	ldd	r24, Y+3	; 0x03
     424:	9c 81       	ldd	r25, Y+4	; 0x04
     426:	02 96       	adiw	r24, 0x02	; 2
     428:	0e 94 71 04 	call	0x8e2	; 0x8e2 <uxListRemove>

				/* Is the co-routine waiting on an event also? */
				if( pxCRCB->xEventListItem.pvContainer )
     42c:	8b 81       	ldd	r24, Y+3	; 0x03
     42e:	9c 81       	ldd	r25, Y+4	; 0x04
     430:	fc 01       	movw	r30, r24
     432:	84 89       	ldd	r24, Z+20	; 0x14
     434:	95 89       	ldd	r25, Z+21	; 0x15
     436:	89 2b       	or	r24, r25
     438:	29 f0       	breq	.+10     	; 0x444 <__LOCK_REGION_LENGTH__+0x44>
				{
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
     43a:	8b 81       	ldd	r24, Y+3	; 0x03
     43c:	9c 81       	ldd	r25, Y+4	; 0x04
     43e:	0c 96       	adiw	r24, 0x0c	; 12
     440:	0e 94 71 04 	call	0x8e2	; 0x8e2 <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
     444:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );
     446:	8b 81       	ldd	r24, Y+3	; 0x03
     448:	9c 81       	ldd	r25, Y+4	; 0x04
     44a:	fc 01       	movw	r30, r24
     44c:	96 89       	ldd	r25, Z+22	; 0x16
     44e:	80 91 4f 01 	lds	r24, 0x014F	; 0x80014f <uxTopCoRoutineReadyPriority>
     452:	89 17       	cp	r24, r25
     454:	30 f4       	brcc	.+12     	; 0x462 <__LOCK_REGION_LENGTH__+0x62>
     456:	8b 81       	ldd	r24, Y+3	; 0x03
     458:	9c 81       	ldd	r25, Y+4	; 0x04
     45a:	fc 01       	movw	r30, r24
     45c:	86 89       	ldd	r24, Z+22	; 0x16
     45e:	80 93 4f 01 	sts	0x014F, r24	; 0x80014f <uxTopCoRoutineReadyPriority>
     462:	8b 81       	ldd	r24, Y+3	; 0x03
     464:	9c 81       	ldd	r25, Y+4	; 0x04
     466:	ac 01       	movw	r20, r24
     468:	4e 5f       	subi	r20, 0xFE	; 254
     46a:	5f 4f       	sbci	r21, 0xFF	; 255
     46c:	8b 81       	ldd	r24, Y+3	; 0x03
     46e:	9c 81       	ldd	r25, Y+4	; 0x04
     470:	fc 01       	movw	r30, r24
     472:	86 89       	ldd	r24, Z+22	; 0x16
     474:	28 2f       	mov	r18, r24
     476:	30 e0       	ldi	r19, 0x00	; 0
     478:	c9 01       	movw	r24, r18
     47a:	88 0f       	add	r24, r24
     47c:	99 1f       	adc	r25, r25
     47e:	88 0f       	add	r24, r24
     480:	99 1f       	adc	r25, r25
     482:	88 0f       	add	r24, r24
     484:	99 1f       	adc	r25, r25
     486:	82 0f       	add	r24, r18
     488:	93 1f       	adc	r25, r19
     48a:	82 5e       	subi	r24, 0xE2	; 226
     48c:	9e 4f       	sbci	r25, 0xFE	; 254
     48e:	ba 01       	movw	r22, r20
     490:	0e 94 aa 03 	call	0x754	; 0x754 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     494:	80 91 42 01 	lds	r24, 0x0142	; 0x800142 <pxDelayedCoRoutineList>
     498:	90 91 43 01 	lds	r25, 0x0143	; 0x800143 <pxDelayedCoRoutineList+0x1>
     49c:	fc 01       	movw	r30, r24
     49e:	80 81       	ld	r24, Z
     4a0:	88 23       	and	r24, r24
     4a2:	09 f0       	breq	.+2      	; 0x4a6 <__LOCK_REGION_LENGTH__+0xa6>
     4a4:	a4 cf       	rjmp	.-184    	; 0x3ee <prvCheckDelayedList+0x88>
static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
     4a6:	80 91 54 01 	lds	r24, 0x0154	; 0x800154 <xPassedTicks>
     4aa:	90 91 55 01 	lds	r25, 0x0155	; 0x800155 <xPassedTicks+0x1>
     4ae:	89 2b       	or	r24, r25
     4b0:	09 f0       	breq	.+2      	; 0x4b4 <__LOCK_REGION_LENGTH__+0xb4>
     4b2:	6f cf       	rjmp	.-290    	; 0x392 <prvCheckDelayedList+0x2c>

			prvAddCoRoutineToReadyQueue( pxCRCB );
		}
	}

	xLastTickCount = xCoRoutineTickCount;
     4b4:	80 91 50 01 	lds	r24, 0x0150	; 0x800150 <xCoRoutineTickCount>
     4b8:	90 91 51 01 	lds	r25, 0x0151	; 0x800151 <xCoRoutineTickCount+0x1>
     4bc:	90 93 53 01 	sts	0x0153, r25	; 0x800153 <xLastTickCount+0x1>
     4c0:	80 93 52 01 	sts	0x0152, r24	; 0x800152 <xLastTickCount>
}
     4c4:	00 00       	nop
     4c6:	0f 90       	pop	r0
     4c8:	0f 90       	pop	r0
     4ca:	0f 90       	pop	r0
     4cc:	0f 90       	pop	r0
     4ce:	df 91       	pop	r29
     4d0:	cf 91       	pop	r28
     4d2:	08 95       	ret

000004d4 <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
     4d4:	cf 93       	push	r28
     4d6:	df 93       	push	r29
     4d8:	00 d0       	rcall	.+0      	; 0x4da <vCoRoutineSchedule+0x6>
     4da:	cd b7       	in	r28, 0x3d	; 61
     4dc:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
     4de:	0e 94 66 01 	call	0x2cc	; 0x2cc <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
     4e2:	0e 94 b3 01 	call	0x366	; 0x366 <prvCheckDelayedList>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     4e6:	0a c0       	rjmp	.+20     	; 0x4fc <vCoRoutineSchedule+0x28>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
     4e8:	80 91 4f 01 	lds	r24, 0x014F	; 0x80014f <uxTopCoRoutineReadyPriority>
     4ec:	88 23       	and	r24, r24
     4ee:	09 f4       	brne	.+2      	; 0x4f2 <vCoRoutineSchedule+0x1e>
     4f0:	70 c0       	rjmp	.+224    	; 0x5d2 <vCoRoutineSchedule+0xfe>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
     4f2:	80 91 4f 01 	lds	r24, 0x014F	; 0x80014f <uxTopCoRoutineReadyPriority>
     4f6:	81 50       	subi	r24, 0x01	; 1
     4f8:	80 93 4f 01 	sts	0x014F, r24	; 0x80014f <uxTopCoRoutineReadyPriority>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     4fc:	80 91 4f 01 	lds	r24, 0x014F	; 0x80014f <uxTopCoRoutineReadyPriority>
     500:	28 2f       	mov	r18, r24
     502:	30 e0       	ldi	r19, 0x00	; 0
     504:	c9 01       	movw	r24, r18
     506:	88 0f       	add	r24, r24
     508:	99 1f       	adc	r25, r25
     50a:	88 0f       	add	r24, r24
     50c:	99 1f       	adc	r25, r25
     50e:	88 0f       	add	r24, r24
     510:	99 1f       	adc	r25, r25
     512:	82 0f       	add	r24, r18
     514:	93 1f       	adc	r25, r19
     516:	82 5e       	subi	r24, 0xE2	; 226
     518:	9e 4f       	sbci	r25, 0xFE	; 254
     51a:	fc 01       	movw	r30, r24
     51c:	80 81       	ld	r24, Z
     51e:	88 23       	and	r24, r24
     520:	19 f3       	breq	.-58     	; 0x4e8 <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
     522:	80 91 4f 01 	lds	r24, 0x014F	; 0x80014f <uxTopCoRoutineReadyPriority>
     526:	28 2f       	mov	r18, r24
     528:	30 e0       	ldi	r19, 0x00	; 0
     52a:	c9 01       	movw	r24, r18
     52c:	88 0f       	add	r24, r24
     52e:	99 1f       	adc	r25, r25
     530:	88 0f       	add	r24, r24
     532:	99 1f       	adc	r25, r25
     534:	88 0f       	add	r24, r24
     536:	99 1f       	adc	r25, r25
     538:	82 0f       	add	r24, r18
     53a:	93 1f       	adc	r25, r19
     53c:	82 5e       	subi	r24, 0xE2	; 226
     53e:	9e 4f       	sbci	r25, 0xFE	; 254
     540:	9a 83       	std	Y+2, r25	; 0x02
     542:	89 83       	std	Y+1, r24	; 0x01
     544:	89 81       	ldd	r24, Y+1	; 0x01
     546:	9a 81       	ldd	r25, Y+2	; 0x02
     548:	fc 01       	movw	r30, r24
     54a:	81 81       	ldd	r24, Z+1	; 0x01
     54c:	92 81       	ldd	r25, Z+2	; 0x02
     54e:	fc 01       	movw	r30, r24
     550:	22 81       	ldd	r18, Z+2	; 0x02
     552:	33 81       	ldd	r19, Z+3	; 0x03
     554:	89 81       	ldd	r24, Y+1	; 0x01
     556:	9a 81       	ldd	r25, Y+2	; 0x02
     558:	fc 01       	movw	r30, r24
     55a:	32 83       	std	Z+2, r19	; 0x02
     55c:	21 83       	std	Z+1, r18	; 0x01
     55e:	89 81       	ldd	r24, Y+1	; 0x01
     560:	9a 81       	ldd	r25, Y+2	; 0x02
     562:	fc 01       	movw	r30, r24
     564:	21 81       	ldd	r18, Z+1	; 0x01
     566:	32 81       	ldd	r19, Z+2	; 0x02
     568:	89 81       	ldd	r24, Y+1	; 0x01
     56a:	9a 81       	ldd	r25, Y+2	; 0x02
     56c:	03 96       	adiw	r24, 0x03	; 3
     56e:	28 17       	cp	r18, r24
     570:	39 07       	cpc	r19, r25
     572:	69 f4       	brne	.+26     	; 0x58e <vCoRoutineSchedule+0xba>
     574:	89 81       	ldd	r24, Y+1	; 0x01
     576:	9a 81       	ldd	r25, Y+2	; 0x02
     578:	fc 01       	movw	r30, r24
     57a:	81 81       	ldd	r24, Z+1	; 0x01
     57c:	92 81       	ldd	r25, Z+2	; 0x02
     57e:	fc 01       	movw	r30, r24
     580:	22 81       	ldd	r18, Z+2	; 0x02
     582:	33 81       	ldd	r19, Z+3	; 0x03
     584:	89 81       	ldd	r24, Y+1	; 0x01
     586:	9a 81       	ldd	r25, Y+2	; 0x02
     588:	fc 01       	movw	r30, r24
     58a:	32 83       	std	Z+2, r19	; 0x02
     58c:	21 83       	std	Z+1, r18	; 0x01
     58e:	89 81       	ldd	r24, Y+1	; 0x01
     590:	9a 81       	ldd	r25, Y+2	; 0x02
     592:	fc 01       	movw	r30, r24
     594:	81 81       	ldd	r24, Z+1	; 0x01
     596:	92 81       	ldd	r25, Z+2	; 0x02
     598:	fc 01       	movw	r30, r24
     59a:	86 81       	ldd	r24, Z+6	; 0x06
     59c:	97 81       	ldd	r25, Z+7	; 0x07
     59e:	90 93 1d 01 	sts	0x011D, r25	; 0x80011d <__data_end+0x1>
     5a2:	80 93 1c 01 	sts	0x011C, r24	; 0x80011c <__data_end>

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
     5a6:	80 91 1c 01 	lds	r24, 0x011C	; 0x80011c <__data_end>
     5aa:	90 91 1d 01 	lds	r25, 0x011D	; 0x80011d <__data_end+0x1>
     5ae:	fc 01       	movw	r30, r24
     5b0:	20 81       	ld	r18, Z
     5b2:	31 81       	ldd	r19, Z+1	; 0x01
     5b4:	80 91 1c 01 	lds	r24, 0x011C	; 0x80011c <__data_end>
     5b8:	90 91 1d 01 	lds	r25, 0x011D	; 0x80011d <__data_end+0x1>
     5bc:	fc 01       	movw	r30, r24
     5be:	47 89       	ldd	r20, Z+23	; 0x17
     5c0:	80 91 1c 01 	lds	r24, 0x011C	; 0x80011c <__data_end>
     5c4:	90 91 1d 01 	lds	r25, 0x011D	; 0x80011d <__data_end+0x1>
     5c8:	64 2f       	mov	r22, r20
     5ca:	f9 01       	movw	r30, r18
     5cc:	09 95       	icall

	return;
     5ce:	00 00       	nop
     5d0:	01 c0       	rjmp	.+2      	; 0x5d4 <vCoRoutineSchedule+0x100>
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
		{
			/* No more co-routines to check. */
			return;
     5d2:	00 00       	nop

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );

	return;
}
     5d4:	0f 90       	pop	r0
     5d6:	0f 90       	pop	r0
     5d8:	df 91       	pop	r29
     5da:	cf 91       	pop	r28
     5dc:	08 95       	ret

000005de <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
     5de:	cf 93       	push	r28
     5e0:	df 93       	push	r29
     5e2:	1f 92       	push	r1
     5e4:	cd b7       	in	r28, 0x3d	; 61
     5e6:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
     5e8:	19 82       	std	Y+1, r1	; 0x01
     5ea:	13 c0       	rjmp	.+38     	; 0x612 <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
     5ec:	89 81       	ldd	r24, Y+1	; 0x01
     5ee:	28 2f       	mov	r18, r24
     5f0:	30 e0       	ldi	r19, 0x00	; 0
     5f2:	c9 01       	movw	r24, r18
     5f4:	88 0f       	add	r24, r24
     5f6:	99 1f       	adc	r25, r25
     5f8:	88 0f       	add	r24, r24
     5fa:	99 1f       	adc	r25, r25
     5fc:	88 0f       	add	r24, r24
     5fe:	99 1f       	adc	r25, r25
     600:	82 0f       	add	r24, r18
     602:	93 1f       	adc	r25, r19
     604:	82 5e       	subi	r24, 0xE2	; 226
     606:	9e 4f       	sbci	r25, 0xFE	; 254
     608:	0e 94 62 03 	call	0x6c4	; 0x6c4 <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
     60c:	89 81       	ldd	r24, Y+1	; 0x01
     60e:	8f 5f       	subi	r24, 0xFF	; 255
     610:	89 83       	std	Y+1, r24	; 0x01
     612:	89 81       	ldd	r24, Y+1	; 0x01
     614:	82 30       	cpi	r24, 0x02	; 2
     616:	50 f3       	brcs	.-44     	; 0x5ec <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
     618:	80 e3       	ldi	r24, 0x30	; 48
     61a:	91 e0       	ldi	r25, 0x01	; 1
     61c:	0e 94 62 03 	call	0x6c4	; 0x6c4 <vListInitialise>
	vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
     620:	89 e3       	ldi	r24, 0x39	; 57
     622:	91 e0       	ldi	r25, 0x01	; 1
     624:	0e 94 62 03 	call	0x6c4	; 0x6c4 <vListInitialise>
	vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
     628:	86 e4       	ldi	r24, 0x46	; 70
     62a:	91 e0       	ldi	r25, 0x01	; 1
     62c:	0e 94 62 03 	call	0x6c4	; 0x6c4 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
     630:	80 e3       	ldi	r24, 0x30	; 48
     632:	91 e0       	ldi	r25, 0x01	; 1
     634:	90 93 43 01 	sts	0x0143, r25	; 0x800143 <pxDelayedCoRoutineList+0x1>
     638:	80 93 42 01 	sts	0x0142, r24	; 0x800142 <pxDelayedCoRoutineList>
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
     63c:	89 e3       	ldi	r24, 0x39	; 57
     63e:	91 e0       	ldi	r25, 0x01	; 1
     640:	90 93 45 01 	sts	0x0145, r25	; 0x800145 <pxOverflowDelayedCoRoutineList+0x1>
     644:	80 93 44 01 	sts	0x0144, r24	; 0x800144 <pxOverflowDelayedCoRoutineList>
}
     648:	00 00       	nop
     64a:	0f 90       	pop	r0
     64c:	df 91       	pop	r29
     64e:	cf 91       	pop	r28
     650:	08 95       	ret

00000652 <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

BaseType_t xCoRoutineRemoveFromEventList( const List_t *pxEventList )
{
     652:	cf 93       	push	r28
     654:	df 93       	push	r29
     656:	00 d0       	rcall	.+0      	; 0x658 <xCoRoutineRemoveFromEventList+0x6>
     658:	00 d0       	rcall	.+0      	; 0x65a <xCoRoutineRemoveFromEventList+0x8>
     65a:	1f 92       	push	r1
     65c:	cd b7       	in	r28, 0x3d	; 61
     65e:	de b7       	in	r29, 0x3e	; 62
     660:	9d 83       	std	Y+5, r25	; 0x05
     662:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     664:	8c 81       	ldd	r24, Y+4	; 0x04
     666:	9d 81       	ldd	r25, Y+5	; 0x05
     668:	fc 01       	movw	r30, r24
     66a:	85 81       	ldd	r24, Z+5	; 0x05
     66c:	96 81       	ldd	r25, Z+6	; 0x06
     66e:	fc 01       	movw	r30, r24
     670:	86 81       	ldd	r24, Z+6	; 0x06
     672:	97 81       	ldd	r25, Z+7	; 0x07
     674:	9b 83       	std	Y+3, r25	; 0x03
     676:	8a 83       	std	Y+2, r24	; 0x02
	( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     678:	8a 81       	ldd	r24, Y+2	; 0x02
     67a:	9b 81       	ldd	r25, Y+3	; 0x03
     67c:	0c 96       	adiw	r24, 0x0c	; 12
     67e:	0e 94 71 04 	call	0x8e2	; 0x8e2 <uxListRemove>
	vListInsertEnd( ( List_t * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
     682:	8a 81       	ldd	r24, Y+2	; 0x02
     684:	9b 81       	ldd	r25, Y+3	; 0x03
     686:	0c 96       	adiw	r24, 0x0c	; 12
     688:	bc 01       	movw	r22, r24
     68a:	86 e4       	ldi	r24, 0x46	; 70
     68c:	91 e0       	ldi	r25, 0x01	; 1
     68e:	0e 94 aa 03 	call	0x754	; 0x754 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
     692:	8a 81       	ldd	r24, Y+2	; 0x02
     694:	9b 81       	ldd	r25, Y+3	; 0x03
     696:	fc 01       	movw	r30, r24
     698:	26 89       	ldd	r18, Z+22	; 0x16
     69a:	80 91 1c 01 	lds	r24, 0x011C	; 0x80011c <__data_end>
     69e:	90 91 1d 01 	lds	r25, 0x011D	; 0x80011d <__data_end+0x1>
     6a2:	fc 01       	movw	r30, r24
     6a4:	86 89       	ldd	r24, Z+22	; 0x16
     6a6:	28 17       	cp	r18, r24
     6a8:	18 f0       	brcs	.+6      	; 0x6b0 <xCoRoutineRemoveFromEventList+0x5e>
	{
		xReturn = pdTRUE;
     6aa:	81 e0       	ldi	r24, 0x01	; 1
     6ac:	89 83       	std	Y+1, r24	; 0x01
     6ae:	01 c0       	rjmp	.+2      	; 0x6b2 <xCoRoutineRemoveFromEventList+0x60>
	}
	else
	{
		xReturn = pdFALSE;
     6b0:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
     6b2:	89 81       	ldd	r24, Y+1	; 0x01
}
     6b4:	0f 90       	pop	r0
     6b6:	0f 90       	pop	r0
     6b8:	0f 90       	pop	r0
     6ba:	0f 90       	pop	r0
     6bc:	0f 90       	pop	r0
     6be:	df 91       	pop	r29
     6c0:	cf 91       	pop	r28
     6c2:	08 95       	ret

000006c4 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     6c4:	cf 93       	push	r28
     6c6:	df 93       	push	r29
     6c8:	00 d0       	rcall	.+0      	; 0x6ca <vListInitialise+0x6>
     6ca:	cd b7       	in	r28, 0x3d	; 61
     6cc:	de b7       	in	r29, 0x3e	; 62
     6ce:	9a 83       	std	Y+2, r25	; 0x02
     6d0:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     6d2:	89 81       	ldd	r24, Y+1	; 0x01
     6d4:	9a 81       	ldd	r25, Y+2	; 0x02
     6d6:	9c 01       	movw	r18, r24
     6d8:	2d 5f       	subi	r18, 0xFD	; 253
     6da:	3f 4f       	sbci	r19, 0xFF	; 255
     6dc:	89 81       	ldd	r24, Y+1	; 0x01
     6de:	9a 81       	ldd	r25, Y+2	; 0x02
     6e0:	fc 01       	movw	r30, r24
     6e2:	32 83       	std	Z+2, r19	; 0x02
     6e4:	21 83       	std	Z+1, r18	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     6e6:	89 81       	ldd	r24, Y+1	; 0x01
     6e8:	9a 81       	ldd	r25, Y+2	; 0x02
     6ea:	2f ef       	ldi	r18, 0xFF	; 255
     6ec:	3f ef       	ldi	r19, 0xFF	; 255
     6ee:	fc 01       	movw	r30, r24
     6f0:	34 83       	std	Z+4, r19	; 0x04
     6f2:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     6f4:	89 81       	ldd	r24, Y+1	; 0x01
     6f6:	9a 81       	ldd	r25, Y+2	; 0x02
     6f8:	9c 01       	movw	r18, r24
     6fa:	2d 5f       	subi	r18, 0xFD	; 253
     6fc:	3f 4f       	sbci	r19, 0xFF	; 255
     6fe:	89 81       	ldd	r24, Y+1	; 0x01
     700:	9a 81       	ldd	r25, Y+2	; 0x02
     702:	fc 01       	movw	r30, r24
     704:	36 83       	std	Z+6, r19	; 0x06
     706:	25 83       	std	Z+5, r18	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     708:	89 81       	ldd	r24, Y+1	; 0x01
     70a:	9a 81       	ldd	r25, Y+2	; 0x02
     70c:	9c 01       	movw	r18, r24
     70e:	2d 5f       	subi	r18, 0xFD	; 253
     710:	3f 4f       	sbci	r19, 0xFF	; 255
     712:	89 81       	ldd	r24, Y+1	; 0x01
     714:	9a 81       	ldd	r25, Y+2	; 0x02
     716:	fc 01       	movw	r30, r24
     718:	30 87       	std	Z+8, r19	; 0x08
     71a:	27 83       	std	Z+7, r18	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     71c:	89 81       	ldd	r24, Y+1	; 0x01
     71e:	9a 81       	ldd	r25, Y+2	; 0x02
     720:	fc 01       	movw	r30, r24
     722:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
     724:	00 00       	nop
     726:	0f 90       	pop	r0
     728:	0f 90       	pop	r0
     72a:	df 91       	pop	r29
     72c:	cf 91       	pop	r28
     72e:	08 95       	ret

00000730 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
     730:	cf 93       	push	r28
     732:	df 93       	push	r29
     734:	00 d0       	rcall	.+0      	; 0x736 <vListInitialiseItem+0x6>
     736:	cd b7       	in	r28, 0x3d	; 61
     738:	de b7       	in	r29, 0x3e	; 62
     73a:	9a 83       	std	Y+2, r25	; 0x02
     73c:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     73e:	89 81       	ldd	r24, Y+1	; 0x01
     740:	9a 81       	ldd	r25, Y+2	; 0x02
     742:	fc 01       	movw	r30, r24
     744:	11 86       	std	Z+9, r1	; 0x09
     746:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
     748:	00 00       	nop
     74a:	0f 90       	pop	r0
     74c:	0f 90       	pop	r0
     74e:	df 91       	pop	r29
     750:	cf 91       	pop	r28
     752:	08 95       	ret

00000754 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     754:	cf 93       	push	r28
     756:	df 93       	push	r29
     758:	00 d0       	rcall	.+0      	; 0x75a <vListInsertEnd+0x6>
     75a:	00 d0       	rcall	.+0      	; 0x75c <vListInsertEnd+0x8>
     75c:	00 d0       	rcall	.+0      	; 0x75e <vListInsertEnd+0xa>
     75e:	cd b7       	in	r28, 0x3d	; 61
     760:	de b7       	in	r29, 0x3e	; 62
     762:	9c 83       	std	Y+4, r25	; 0x04
     764:	8b 83       	std	Y+3, r24	; 0x03
     766:	7e 83       	std	Y+6, r23	; 0x06
     768:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
     76a:	8b 81       	ldd	r24, Y+3	; 0x03
     76c:	9c 81       	ldd	r25, Y+4	; 0x04
     76e:	fc 01       	movw	r30, r24
     770:	81 81       	ldd	r24, Z+1	; 0x01
     772:	92 81       	ldd	r25, Z+2	; 0x02
     774:	9a 83       	std	Y+2, r25	; 0x02
     776:	89 83       	std	Y+1, r24	; 0x01
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     778:	8d 81       	ldd	r24, Y+5	; 0x05
     77a:	9e 81       	ldd	r25, Y+6	; 0x06
     77c:	29 81       	ldd	r18, Y+1	; 0x01
     77e:	3a 81       	ldd	r19, Y+2	; 0x02
     780:	fc 01       	movw	r30, r24
     782:	33 83       	std	Z+3, r19	; 0x03
     784:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     786:	89 81       	ldd	r24, Y+1	; 0x01
     788:	9a 81       	ldd	r25, Y+2	; 0x02
     78a:	fc 01       	movw	r30, r24
     78c:	24 81       	ldd	r18, Z+4	; 0x04
     78e:	35 81       	ldd	r19, Z+5	; 0x05
     790:	8d 81       	ldd	r24, Y+5	; 0x05
     792:	9e 81       	ldd	r25, Y+6	; 0x06
     794:	fc 01       	movw	r30, r24
     796:	35 83       	std	Z+5, r19	; 0x05
     798:	24 83       	std	Z+4, r18	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     79a:	89 81       	ldd	r24, Y+1	; 0x01
     79c:	9a 81       	ldd	r25, Y+2	; 0x02
     79e:	fc 01       	movw	r30, r24
     7a0:	84 81       	ldd	r24, Z+4	; 0x04
     7a2:	95 81       	ldd	r25, Z+5	; 0x05
     7a4:	2d 81       	ldd	r18, Y+5	; 0x05
     7a6:	3e 81       	ldd	r19, Y+6	; 0x06
     7a8:	fc 01       	movw	r30, r24
     7aa:	33 83       	std	Z+3, r19	; 0x03
     7ac:	22 83       	std	Z+2, r18	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
     7ae:	89 81       	ldd	r24, Y+1	; 0x01
     7b0:	9a 81       	ldd	r25, Y+2	; 0x02
     7b2:	2d 81       	ldd	r18, Y+5	; 0x05
     7b4:	3e 81       	ldd	r19, Y+6	; 0x06
     7b6:	fc 01       	movw	r30, r24
     7b8:	35 83       	std	Z+5, r19	; 0x05
     7ba:	24 83       	std	Z+4, r18	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     7bc:	8d 81       	ldd	r24, Y+5	; 0x05
     7be:	9e 81       	ldd	r25, Y+6	; 0x06
     7c0:	2b 81       	ldd	r18, Y+3	; 0x03
     7c2:	3c 81       	ldd	r19, Y+4	; 0x04
     7c4:	fc 01       	movw	r30, r24
     7c6:	31 87       	std	Z+9, r19	; 0x09
     7c8:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     7ca:	8b 81       	ldd	r24, Y+3	; 0x03
     7cc:	9c 81       	ldd	r25, Y+4	; 0x04
     7ce:	fc 01       	movw	r30, r24
     7d0:	80 81       	ld	r24, Z
     7d2:	21 e0       	ldi	r18, 0x01	; 1
     7d4:	28 0f       	add	r18, r24
     7d6:	8b 81       	ldd	r24, Y+3	; 0x03
     7d8:	9c 81       	ldd	r25, Y+4	; 0x04
     7da:	fc 01       	movw	r30, r24
     7dc:	20 83       	st	Z, r18
}
     7de:	00 00       	nop
     7e0:	26 96       	adiw	r28, 0x06	; 6
     7e2:	0f b6       	in	r0, 0x3f	; 63
     7e4:	f8 94       	cli
     7e6:	de bf       	out	0x3e, r29	; 62
     7e8:	0f be       	out	0x3f, r0	; 63
     7ea:	cd bf       	out	0x3d, r28	; 61
     7ec:	df 91       	pop	r29
     7ee:	cf 91       	pop	r28
     7f0:	08 95       	ret

000007f2 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     7f2:	cf 93       	push	r28
     7f4:	df 93       	push	r29
     7f6:	cd b7       	in	r28, 0x3d	; 61
     7f8:	de b7       	in	r29, 0x3e	; 62
     7fa:	28 97       	sbiw	r28, 0x08	; 8
     7fc:	0f b6       	in	r0, 0x3f	; 63
     7fe:	f8 94       	cli
     800:	de bf       	out	0x3e, r29	; 62
     802:	0f be       	out	0x3f, r0	; 63
     804:	cd bf       	out	0x3d, r28	; 61
     806:	9e 83       	std	Y+6, r25	; 0x06
     808:	8d 83       	std	Y+5, r24	; 0x05
     80a:	78 87       	std	Y+8, r23	; 0x08
     80c:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     80e:	8f 81       	ldd	r24, Y+7	; 0x07
     810:	98 85       	ldd	r25, Y+8	; 0x08
     812:	fc 01       	movw	r30, r24
     814:	80 81       	ld	r24, Z
     816:	91 81       	ldd	r25, Z+1	; 0x01
     818:	9c 83       	std	Y+4, r25	; 0x04
     81a:	8b 83       	std	Y+3, r24	; 0x03
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     81c:	8b 81       	ldd	r24, Y+3	; 0x03
     81e:	9c 81       	ldd	r25, Y+4	; 0x04
     820:	01 96       	adiw	r24, 0x01	; 1
     822:	41 f4       	brne	.+16     	; 0x834 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     824:	8d 81       	ldd	r24, Y+5	; 0x05
     826:	9e 81       	ldd	r25, Y+6	; 0x06
     828:	fc 01       	movw	r30, r24
     82a:	87 81       	ldd	r24, Z+7	; 0x07
     82c:	90 85       	ldd	r25, Z+8	; 0x08
     82e:	9a 83       	std	Y+2, r25	; 0x02
     830:	89 83       	std	Y+1, r24	; 0x01
     832:	1a c0       	rjmp	.+52     	; 0x868 <vListInsert+0x76>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     834:	8d 81       	ldd	r24, Y+5	; 0x05
     836:	9e 81       	ldd	r25, Y+6	; 0x06
     838:	03 96       	adiw	r24, 0x03	; 3
     83a:	9a 83       	std	Y+2, r25	; 0x02
     83c:	89 83       	std	Y+1, r24	; 0x01
     83e:	07 c0       	rjmp	.+14     	; 0x84e <vListInsert+0x5c>
     840:	89 81       	ldd	r24, Y+1	; 0x01
     842:	9a 81       	ldd	r25, Y+2	; 0x02
     844:	fc 01       	movw	r30, r24
     846:	82 81       	ldd	r24, Z+2	; 0x02
     848:	93 81       	ldd	r25, Z+3	; 0x03
     84a:	9a 83       	std	Y+2, r25	; 0x02
     84c:	89 83       	std	Y+1, r24	; 0x01
     84e:	89 81       	ldd	r24, Y+1	; 0x01
     850:	9a 81       	ldd	r25, Y+2	; 0x02
     852:	fc 01       	movw	r30, r24
     854:	82 81       	ldd	r24, Z+2	; 0x02
     856:	93 81       	ldd	r25, Z+3	; 0x03
     858:	fc 01       	movw	r30, r24
     85a:	20 81       	ld	r18, Z
     85c:	31 81       	ldd	r19, Z+1	; 0x01
     85e:	8b 81       	ldd	r24, Y+3	; 0x03
     860:	9c 81       	ldd	r25, Y+4	; 0x04
     862:	82 17       	cp	r24, r18
     864:	93 07       	cpc	r25, r19
     866:	60 f7       	brcc	.-40     	; 0x840 <vListInsert+0x4e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     868:	89 81       	ldd	r24, Y+1	; 0x01
     86a:	9a 81       	ldd	r25, Y+2	; 0x02
     86c:	fc 01       	movw	r30, r24
     86e:	22 81       	ldd	r18, Z+2	; 0x02
     870:	33 81       	ldd	r19, Z+3	; 0x03
     872:	8f 81       	ldd	r24, Y+7	; 0x07
     874:	98 85       	ldd	r25, Y+8	; 0x08
     876:	fc 01       	movw	r30, r24
     878:	33 83       	std	Z+3, r19	; 0x03
     87a:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     87c:	8f 81       	ldd	r24, Y+7	; 0x07
     87e:	98 85       	ldd	r25, Y+8	; 0x08
     880:	fc 01       	movw	r30, r24
     882:	82 81       	ldd	r24, Z+2	; 0x02
     884:	93 81       	ldd	r25, Z+3	; 0x03
     886:	2f 81       	ldd	r18, Y+7	; 0x07
     888:	38 85       	ldd	r19, Y+8	; 0x08
     88a:	fc 01       	movw	r30, r24
     88c:	35 83       	std	Z+5, r19	; 0x05
     88e:	24 83       	std	Z+4, r18	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     890:	8f 81       	ldd	r24, Y+7	; 0x07
     892:	98 85       	ldd	r25, Y+8	; 0x08
     894:	29 81       	ldd	r18, Y+1	; 0x01
     896:	3a 81       	ldd	r19, Y+2	; 0x02
     898:	fc 01       	movw	r30, r24
     89a:	35 83       	std	Z+5, r19	; 0x05
     89c:	24 83       	std	Z+4, r18	; 0x04
	pxIterator->pxNext = pxNewListItem;
     89e:	89 81       	ldd	r24, Y+1	; 0x01
     8a0:	9a 81       	ldd	r25, Y+2	; 0x02
     8a2:	2f 81       	ldd	r18, Y+7	; 0x07
     8a4:	38 85       	ldd	r19, Y+8	; 0x08
     8a6:	fc 01       	movw	r30, r24
     8a8:	33 83       	std	Z+3, r19	; 0x03
     8aa:	22 83       	std	Z+2, r18	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     8ac:	8f 81       	ldd	r24, Y+7	; 0x07
     8ae:	98 85       	ldd	r25, Y+8	; 0x08
     8b0:	2d 81       	ldd	r18, Y+5	; 0x05
     8b2:	3e 81       	ldd	r19, Y+6	; 0x06
     8b4:	fc 01       	movw	r30, r24
     8b6:	31 87       	std	Z+9, r19	; 0x09
     8b8:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     8ba:	8d 81       	ldd	r24, Y+5	; 0x05
     8bc:	9e 81       	ldd	r25, Y+6	; 0x06
     8be:	fc 01       	movw	r30, r24
     8c0:	80 81       	ld	r24, Z
     8c2:	21 e0       	ldi	r18, 0x01	; 1
     8c4:	28 0f       	add	r18, r24
     8c6:	8d 81       	ldd	r24, Y+5	; 0x05
     8c8:	9e 81       	ldd	r25, Y+6	; 0x06
     8ca:	fc 01       	movw	r30, r24
     8cc:	20 83       	st	Z, r18
}
     8ce:	00 00       	nop
     8d0:	28 96       	adiw	r28, 0x08	; 8
     8d2:	0f b6       	in	r0, 0x3f	; 63
     8d4:	f8 94       	cli
     8d6:	de bf       	out	0x3e, r29	; 62
     8d8:	0f be       	out	0x3f, r0	; 63
     8da:	cd bf       	out	0x3d, r28	; 61
     8dc:	df 91       	pop	r29
     8de:	cf 91       	pop	r28
     8e0:	08 95       	ret

000008e2 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     8e2:	cf 93       	push	r28
     8e4:	df 93       	push	r29
     8e6:	00 d0       	rcall	.+0      	; 0x8e8 <uxListRemove+0x6>
     8e8:	00 d0       	rcall	.+0      	; 0x8ea <uxListRemove+0x8>
     8ea:	cd b7       	in	r28, 0x3d	; 61
     8ec:	de b7       	in	r29, 0x3e	; 62
     8ee:	9c 83       	std	Y+4, r25	; 0x04
     8f0:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     8f2:	8b 81       	ldd	r24, Y+3	; 0x03
     8f4:	9c 81       	ldd	r25, Y+4	; 0x04
     8f6:	fc 01       	movw	r30, r24
     8f8:	80 85       	ldd	r24, Z+8	; 0x08
     8fa:	91 85       	ldd	r25, Z+9	; 0x09
     8fc:	9a 83       	std	Y+2, r25	; 0x02
     8fe:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     900:	8b 81       	ldd	r24, Y+3	; 0x03
     902:	9c 81       	ldd	r25, Y+4	; 0x04
     904:	fc 01       	movw	r30, r24
     906:	82 81       	ldd	r24, Z+2	; 0x02
     908:	93 81       	ldd	r25, Z+3	; 0x03
     90a:	2b 81       	ldd	r18, Y+3	; 0x03
     90c:	3c 81       	ldd	r19, Y+4	; 0x04
     90e:	f9 01       	movw	r30, r18
     910:	24 81       	ldd	r18, Z+4	; 0x04
     912:	35 81       	ldd	r19, Z+5	; 0x05
     914:	fc 01       	movw	r30, r24
     916:	35 83       	std	Z+5, r19	; 0x05
     918:	24 83       	std	Z+4, r18	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     91a:	8b 81       	ldd	r24, Y+3	; 0x03
     91c:	9c 81       	ldd	r25, Y+4	; 0x04
     91e:	fc 01       	movw	r30, r24
     920:	84 81       	ldd	r24, Z+4	; 0x04
     922:	95 81       	ldd	r25, Z+5	; 0x05
     924:	2b 81       	ldd	r18, Y+3	; 0x03
     926:	3c 81       	ldd	r19, Y+4	; 0x04
     928:	f9 01       	movw	r30, r18
     92a:	22 81       	ldd	r18, Z+2	; 0x02
     92c:	33 81       	ldd	r19, Z+3	; 0x03
     92e:	fc 01       	movw	r30, r24
     930:	33 83       	std	Z+3, r19	; 0x03
     932:	22 83       	std	Z+2, r18	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     934:	89 81       	ldd	r24, Y+1	; 0x01
     936:	9a 81       	ldd	r25, Y+2	; 0x02
     938:	fc 01       	movw	r30, r24
     93a:	21 81       	ldd	r18, Z+1	; 0x01
     93c:	32 81       	ldd	r19, Z+2	; 0x02
     93e:	8b 81       	ldd	r24, Y+3	; 0x03
     940:	9c 81       	ldd	r25, Y+4	; 0x04
     942:	28 17       	cp	r18, r24
     944:	39 07       	cpc	r19, r25
     946:	51 f4       	brne	.+20     	; 0x95c <uxListRemove+0x7a>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     948:	8b 81       	ldd	r24, Y+3	; 0x03
     94a:	9c 81       	ldd	r25, Y+4	; 0x04
     94c:	fc 01       	movw	r30, r24
     94e:	24 81       	ldd	r18, Z+4	; 0x04
     950:	35 81       	ldd	r19, Z+5	; 0x05
     952:	89 81       	ldd	r24, Y+1	; 0x01
     954:	9a 81       	ldd	r25, Y+2	; 0x02
     956:	fc 01       	movw	r30, r24
     958:	32 83       	std	Z+2, r19	; 0x02
     95a:	21 83       	std	Z+1, r18	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     95c:	8b 81       	ldd	r24, Y+3	; 0x03
     95e:	9c 81       	ldd	r25, Y+4	; 0x04
     960:	fc 01       	movw	r30, r24
     962:	11 86       	std	Z+9, r1	; 0x09
     964:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     966:	89 81       	ldd	r24, Y+1	; 0x01
     968:	9a 81       	ldd	r25, Y+2	; 0x02
     96a:	fc 01       	movw	r30, r24
     96c:	80 81       	ld	r24, Z
     96e:	2f ef       	ldi	r18, 0xFF	; 255
     970:	28 0f       	add	r18, r24
     972:	89 81       	ldd	r24, Y+1	; 0x01
     974:	9a 81       	ldd	r25, Y+2	; 0x02
     976:	fc 01       	movw	r30, r24
     978:	20 83       	st	Z, r18

	return pxList->uxNumberOfItems;
     97a:	89 81       	ldd	r24, Y+1	; 0x01
     97c:	9a 81       	ldd	r25, Y+2	; 0x02
     97e:	fc 01       	movw	r30, r24
     980:	80 81       	ld	r24, Z
}
     982:	0f 90       	pop	r0
     984:	0f 90       	pop	r0
     986:	0f 90       	pop	r0
     988:	0f 90       	pop	r0
     98a:	df 91       	pop	r29
     98c:	cf 91       	pop	r28
     98e:	08 95       	ret

00000990 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
     990:	cf 93       	push	r28
     992:	df 93       	push	r29
     994:	cd b7       	in	r28, 0x3d	; 61
     996:	de b7       	in	r29, 0x3e	; 62
     998:	28 97       	sbiw	r28, 0x08	; 8
     99a:	0f b6       	in	r0, 0x3f	; 63
     99c:	f8 94       	cli
     99e:	de bf       	out	0x3e, r29	; 62
     9a0:	0f be       	out	0x3f, r0	; 63
     9a2:	cd bf       	out	0x3d, r28	; 61
     9a4:	9c 83       	std	Y+4, r25	; 0x04
     9a6:	8b 83       	std	Y+3, r24	; 0x03
     9a8:	7e 83       	std	Y+6, r23	; 0x06
     9aa:	6d 83       	std	Y+5, r22	; 0x05
     9ac:	58 87       	std	Y+8, r21	; 0x08
     9ae:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     9b0:	8b 81       	ldd	r24, Y+3	; 0x03
     9b2:	9c 81       	ldd	r25, Y+4	; 0x04
     9b4:	21 e1       	ldi	r18, 0x11	; 17
     9b6:	fc 01       	movw	r30, r24
     9b8:	20 83       	st	Z, r18
	pxTopOfStack--;
     9ba:	8b 81       	ldd	r24, Y+3	; 0x03
     9bc:	9c 81       	ldd	r25, Y+4	; 0x04
     9be:	01 97       	sbiw	r24, 0x01	; 1
     9c0:	9c 83       	std	Y+4, r25	; 0x04
     9c2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
     9c4:	8b 81       	ldd	r24, Y+3	; 0x03
     9c6:	9c 81       	ldd	r25, Y+4	; 0x04
     9c8:	22 e2       	ldi	r18, 0x22	; 34
     9ca:	fc 01       	movw	r30, r24
     9cc:	20 83       	st	Z, r18
	pxTopOfStack--;
     9ce:	8b 81       	ldd	r24, Y+3	; 0x03
     9d0:	9c 81       	ldd	r25, Y+4	; 0x04
     9d2:	01 97       	sbiw	r24, 0x01	; 1
     9d4:	9c 83       	std	Y+4, r25	; 0x04
     9d6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
     9d8:	8b 81       	ldd	r24, Y+3	; 0x03
     9da:	9c 81       	ldd	r25, Y+4	; 0x04
     9dc:	23 e3       	ldi	r18, 0x33	; 51
     9de:	fc 01       	movw	r30, r24
     9e0:	20 83       	st	Z, r18
	pxTopOfStack--;
     9e2:	8b 81       	ldd	r24, Y+3	; 0x03
     9e4:	9c 81       	ldd	r25, Y+4	; 0x04
     9e6:	01 97       	sbiw	r24, 0x01	; 1
     9e8:	9c 83       	std	Y+4, r25	; 0x04
     9ea:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
     9ec:	8d 81       	ldd	r24, Y+5	; 0x05
     9ee:	9e 81       	ldd	r25, Y+6	; 0x06
     9f0:	9a 83       	std	Y+2, r25	; 0x02
     9f2:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     9f4:	29 81       	ldd	r18, Y+1	; 0x01
     9f6:	8b 81       	ldd	r24, Y+3	; 0x03
     9f8:	9c 81       	ldd	r25, Y+4	; 0x04
     9fa:	fc 01       	movw	r30, r24
     9fc:	20 83       	st	Z, r18
	pxTopOfStack--;
     9fe:	8b 81       	ldd	r24, Y+3	; 0x03
     a00:	9c 81       	ldd	r25, Y+4	; 0x04
     a02:	01 97       	sbiw	r24, 0x01	; 1
     a04:	9c 83       	std	Y+4, r25	; 0x04
     a06:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     a08:	89 81       	ldd	r24, Y+1	; 0x01
     a0a:	9a 81       	ldd	r25, Y+2	; 0x02
     a0c:	89 2f       	mov	r24, r25
     a0e:	99 27       	eor	r25, r25
     a10:	9a 83       	std	Y+2, r25	; 0x02
     a12:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     a14:	29 81       	ldd	r18, Y+1	; 0x01
     a16:	8b 81       	ldd	r24, Y+3	; 0x03
     a18:	9c 81       	ldd	r25, Y+4	; 0x04
     a1a:	fc 01       	movw	r30, r24
     a1c:	20 83       	st	Z, r18
	pxTopOfStack--;
     a1e:	8b 81       	ldd	r24, Y+3	; 0x03
     a20:	9c 81       	ldd	r25, Y+4	; 0x04
     a22:	01 97       	sbiw	r24, 0x01	; 1
     a24:	9c 83       	std	Y+4, r25	; 0x04
     a26:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
     a28:	8b 81       	ldd	r24, Y+3	; 0x03
     a2a:	9c 81       	ldd	r25, Y+4	; 0x04
     a2c:	fc 01       	movw	r30, r24
     a2e:	10 82       	st	Z, r1
	pxTopOfStack--;
     a30:	8b 81       	ldd	r24, Y+3	; 0x03
     a32:	9c 81       	ldd	r25, Y+4	; 0x04
     a34:	01 97       	sbiw	r24, 0x01	; 1
     a36:	9c 83       	std	Y+4, r25	; 0x04
     a38:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     a3a:	8b 81       	ldd	r24, Y+3	; 0x03
     a3c:	9c 81       	ldd	r25, Y+4	; 0x04
     a3e:	20 e8       	ldi	r18, 0x80	; 128
     a40:	fc 01       	movw	r30, r24
     a42:	20 83       	st	Z, r18
	pxTopOfStack--;
     a44:	8b 81       	ldd	r24, Y+3	; 0x03
     a46:	9c 81       	ldd	r25, Y+4	; 0x04
     a48:	01 97       	sbiw	r24, 0x01	; 1
     a4a:	9c 83       	std	Y+4, r25	; 0x04
     a4c:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
     a4e:	8b 81       	ldd	r24, Y+3	; 0x03
     a50:	9c 81       	ldd	r25, Y+4	; 0x04
     a52:	fc 01       	movw	r30, r24
     a54:	10 82       	st	Z, r1
	pxTopOfStack--;
     a56:	8b 81       	ldd	r24, Y+3	; 0x03
     a58:	9c 81       	ldd	r25, Y+4	; 0x04
     a5a:	01 97       	sbiw	r24, 0x01	; 1
     a5c:	9c 83       	std	Y+4, r25	; 0x04
     a5e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
     a60:	8b 81       	ldd	r24, Y+3	; 0x03
     a62:	9c 81       	ldd	r25, Y+4	; 0x04
     a64:	22 e0       	ldi	r18, 0x02	; 2
     a66:	fc 01       	movw	r30, r24
     a68:	20 83       	st	Z, r18
	pxTopOfStack--;
     a6a:	8b 81       	ldd	r24, Y+3	; 0x03
     a6c:	9c 81       	ldd	r25, Y+4	; 0x04
     a6e:	01 97       	sbiw	r24, 0x01	; 1
     a70:	9c 83       	std	Y+4, r25	; 0x04
     a72:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
     a74:	8b 81       	ldd	r24, Y+3	; 0x03
     a76:	9c 81       	ldd	r25, Y+4	; 0x04
     a78:	23 e0       	ldi	r18, 0x03	; 3
     a7a:	fc 01       	movw	r30, r24
     a7c:	20 83       	st	Z, r18
	pxTopOfStack--;
     a7e:	8b 81       	ldd	r24, Y+3	; 0x03
     a80:	9c 81       	ldd	r25, Y+4	; 0x04
     a82:	01 97       	sbiw	r24, 0x01	; 1
     a84:	9c 83       	std	Y+4, r25	; 0x04
     a86:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
     a88:	8b 81       	ldd	r24, Y+3	; 0x03
     a8a:	9c 81       	ldd	r25, Y+4	; 0x04
     a8c:	24 e0       	ldi	r18, 0x04	; 4
     a8e:	fc 01       	movw	r30, r24
     a90:	20 83       	st	Z, r18
	pxTopOfStack--;
     a92:	8b 81       	ldd	r24, Y+3	; 0x03
     a94:	9c 81       	ldd	r25, Y+4	; 0x04
     a96:	01 97       	sbiw	r24, 0x01	; 1
     a98:	9c 83       	std	Y+4, r25	; 0x04
     a9a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
     a9c:	8b 81       	ldd	r24, Y+3	; 0x03
     a9e:	9c 81       	ldd	r25, Y+4	; 0x04
     aa0:	25 e0       	ldi	r18, 0x05	; 5
     aa2:	fc 01       	movw	r30, r24
     aa4:	20 83       	st	Z, r18
	pxTopOfStack--;
     aa6:	8b 81       	ldd	r24, Y+3	; 0x03
     aa8:	9c 81       	ldd	r25, Y+4	; 0x04
     aaa:	01 97       	sbiw	r24, 0x01	; 1
     aac:	9c 83       	std	Y+4, r25	; 0x04
     aae:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
     ab0:	8b 81       	ldd	r24, Y+3	; 0x03
     ab2:	9c 81       	ldd	r25, Y+4	; 0x04
     ab4:	26 e0       	ldi	r18, 0x06	; 6
     ab6:	fc 01       	movw	r30, r24
     ab8:	20 83       	st	Z, r18
	pxTopOfStack--;
     aba:	8b 81       	ldd	r24, Y+3	; 0x03
     abc:	9c 81       	ldd	r25, Y+4	; 0x04
     abe:	01 97       	sbiw	r24, 0x01	; 1
     ac0:	9c 83       	std	Y+4, r25	; 0x04
     ac2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
     ac4:	8b 81       	ldd	r24, Y+3	; 0x03
     ac6:	9c 81       	ldd	r25, Y+4	; 0x04
     ac8:	27 e0       	ldi	r18, 0x07	; 7
     aca:	fc 01       	movw	r30, r24
     acc:	20 83       	st	Z, r18
	pxTopOfStack--;
     ace:	8b 81       	ldd	r24, Y+3	; 0x03
     ad0:	9c 81       	ldd	r25, Y+4	; 0x04
     ad2:	01 97       	sbiw	r24, 0x01	; 1
     ad4:	9c 83       	std	Y+4, r25	; 0x04
     ad6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
     ad8:	8b 81       	ldd	r24, Y+3	; 0x03
     ada:	9c 81       	ldd	r25, Y+4	; 0x04
     adc:	28 e0       	ldi	r18, 0x08	; 8
     ade:	fc 01       	movw	r30, r24
     ae0:	20 83       	st	Z, r18
	pxTopOfStack--;
     ae2:	8b 81       	ldd	r24, Y+3	; 0x03
     ae4:	9c 81       	ldd	r25, Y+4	; 0x04
     ae6:	01 97       	sbiw	r24, 0x01	; 1
     ae8:	9c 83       	std	Y+4, r25	; 0x04
     aea:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
     aec:	8b 81       	ldd	r24, Y+3	; 0x03
     aee:	9c 81       	ldd	r25, Y+4	; 0x04
     af0:	29 e0       	ldi	r18, 0x09	; 9
     af2:	fc 01       	movw	r30, r24
     af4:	20 83       	st	Z, r18
	pxTopOfStack--;
     af6:	8b 81       	ldd	r24, Y+3	; 0x03
     af8:	9c 81       	ldd	r25, Y+4	; 0x04
     afa:	01 97       	sbiw	r24, 0x01	; 1
     afc:	9c 83       	std	Y+4, r25	; 0x04
     afe:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
     b00:	8b 81       	ldd	r24, Y+3	; 0x03
     b02:	9c 81       	ldd	r25, Y+4	; 0x04
     b04:	20 e1       	ldi	r18, 0x10	; 16
     b06:	fc 01       	movw	r30, r24
     b08:	20 83       	st	Z, r18
	pxTopOfStack--;
     b0a:	8b 81       	ldd	r24, Y+3	; 0x03
     b0c:	9c 81       	ldd	r25, Y+4	; 0x04
     b0e:	01 97       	sbiw	r24, 0x01	; 1
     b10:	9c 83       	std	Y+4, r25	; 0x04
     b12:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
     b14:	8b 81       	ldd	r24, Y+3	; 0x03
     b16:	9c 81       	ldd	r25, Y+4	; 0x04
     b18:	21 e1       	ldi	r18, 0x11	; 17
     b1a:	fc 01       	movw	r30, r24
     b1c:	20 83       	st	Z, r18
	pxTopOfStack--;
     b1e:	8b 81       	ldd	r24, Y+3	; 0x03
     b20:	9c 81       	ldd	r25, Y+4	; 0x04
     b22:	01 97       	sbiw	r24, 0x01	; 1
     b24:	9c 83       	std	Y+4, r25	; 0x04
     b26:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
     b28:	8b 81       	ldd	r24, Y+3	; 0x03
     b2a:	9c 81       	ldd	r25, Y+4	; 0x04
     b2c:	22 e1       	ldi	r18, 0x12	; 18
     b2e:	fc 01       	movw	r30, r24
     b30:	20 83       	st	Z, r18
	pxTopOfStack--;
     b32:	8b 81       	ldd	r24, Y+3	; 0x03
     b34:	9c 81       	ldd	r25, Y+4	; 0x04
     b36:	01 97       	sbiw	r24, 0x01	; 1
     b38:	9c 83       	std	Y+4, r25	; 0x04
     b3a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
     b3c:	8b 81       	ldd	r24, Y+3	; 0x03
     b3e:	9c 81       	ldd	r25, Y+4	; 0x04
     b40:	23 e1       	ldi	r18, 0x13	; 19
     b42:	fc 01       	movw	r30, r24
     b44:	20 83       	st	Z, r18
	pxTopOfStack--;
     b46:	8b 81       	ldd	r24, Y+3	; 0x03
     b48:	9c 81       	ldd	r25, Y+4	; 0x04
     b4a:	01 97       	sbiw	r24, 0x01	; 1
     b4c:	9c 83       	std	Y+4, r25	; 0x04
     b4e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
     b50:	8b 81       	ldd	r24, Y+3	; 0x03
     b52:	9c 81       	ldd	r25, Y+4	; 0x04
     b54:	24 e1       	ldi	r18, 0x14	; 20
     b56:	fc 01       	movw	r30, r24
     b58:	20 83       	st	Z, r18
	pxTopOfStack--;
     b5a:	8b 81       	ldd	r24, Y+3	; 0x03
     b5c:	9c 81       	ldd	r25, Y+4	; 0x04
     b5e:	01 97       	sbiw	r24, 0x01	; 1
     b60:	9c 83       	std	Y+4, r25	; 0x04
     b62:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
     b64:	8b 81       	ldd	r24, Y+3	; 0x03
     b66:	9c 81       	ldd	r25, Y+4	; 0x04
     b68:	25 e1       	ldi	r18, 0x15	; 21
     b6a:	fc 01       	movw	r30, r24
     b6c:	20 83       	st	Z, r18
	pxTopOfStack--;
     b6e:	8b 81       	ldd	r24, Y+3	; 0x03
     b70:	9c 81       	ldd	r25, Y+4	; 0x04
     b72:	01 97       	sbiw	r24, 0x01	; 1
     b74:	9c 83       	std	Y+4, r25	; 0x04
     b76:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
     b78:	8b 81       	ldd	r24, Y+3	; 0x03
     b7a:	9c 81       	ldd	r25, Y+4	; 0x04
     b7c:	26 e1       	ldi	r18, 0x16	; 22
     b7e:	fc 01       	movw	r30, r24
     b80:	20 83       	st	Z, r18
	pxTopOfStack--;
     b82:	8b 81       	ldd	r24, Y+3	; 0x03
     b84:	9c 81       	ldd	r25, Y+4	; 0x04
     b86:	01 97       	sbiw	r24, 0x01	; 1
     b88:	9c 83       	std	Y+4, r25	; 0x04
     b8a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
     b8c:	8b 81       	ldd	r24, Y+3	; 0x03
     b8e:	9c 81       	ldd	r25, Y+4	; 0x04
     b90:	27 e1       	ldi	r18, 0x17	; 23
     b92:	fc 01       	movw	r30, r24
     b94:	20 83       	st	Z, r18
	pxTopOfStack--;
     b96:	8b 81       	ldd	r24, Y+3	; 0x03
     b98:	9c 81       	ldd	r25, Y+4	; 0x04
     b9a:	01 97       	sbiw	r24, 0x01	; 1
     b9c:	9c 83       	std	Y+4, r25	; 0x04
     b9e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
     ba0:	8b 81       	ldd	r24, Y+3	; 0x03
     ba2:	9c 81       	ldd	r25, Y+4	; 0x04
     ba4:	28 e1       	ldi	r18, 0x18	; 24
     ba6:	fc 01       	movw	r30, r24
     ba8:	20 83       	st	Z, r18
	pxTopOfStack--;
     baa:	8b 81       	ldd	r24, Y+3	; 0x03
     bac:	9c 81       	ldd	r25, Y+4	; 0x04
     bae:	01 97       	sbiw	r24, 0x01	; 1
     bb0:	9c 83       	std	Y+4, r25	; 0x04
     bb2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
     bb4:	8b 81       	ldd	r24, Y+3	; 0x03
     bb6:	9c 81       	ldd	r25, Y+4	; 0x04
     bb8:	29 e1       	ldi	r18, 0x19	; 25
     bba:	fc 01       	movw	r30, r24
     bbc:	20 83       	st	Z, r18
	pxTopOfStack--;
     bbe:	8b 81       	ldd	r24, Y+3	; 0x03
     bc0:	9c 81       	ldd	r25, Y+4	; 0x04
     bc2:	01 97       	sbiw	r24, 0x01	; 1
     bc4:	9c 83       	std	Y+4, r25	; 0x04
     bc6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
     bc8:	8b 81       	ldd	r24, Y+3	; 0x03
     bca:	9c 81       	ldd	r25, Y+4	; 0x04
     bcc:	20 e2       	ldi	r18, 0x20	; 32
     bce:	fc 01       	movw	r30, r24
     bd0:	20 83       	st	Z, r18
	pxTopOfStack--;
     bd2:	8b 81       	ldd	r24, Y+3	; 0x03
     bd4:	9c 81       	ldd	r25, Y+4	; 0x04
     bd6:	01 97       	sbiw	r24, 0x01	; 1
     bd8:	9c 83       	std	Y+4, r25	; 0x04
     bda:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
     bdc:	8b 81       	ldd	r24, Y+3	; 0x03
     bde:	9c 81       	ldd	r25, Y+4	; 0x04
     be0:	21 e2       	ldi	r18, 0x21	; 33
     be2:	fc 01       	movw	r30, r24
     be4:	20 83       	st	Z, r18
	pxTopOfStack--;
     be6:	8b 81       	ldd	r24, Y+3	; 0x03
     be8:	9c 81       	ldd	r25, Y+4	; 0x04
     bea:	01 97       	sbiw	r24, 0x01	; 1
     bec:	9c 83       	std	Y+4, r25	; 0x04
     bee:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
     bf0:	8b 81       	ldd	r24, Y+3	; 0x03
     bf2:	9c 81       	ldd	r25, Y+4	; 0x04
     bf4:	22 e2       	ldi	r18, 0x22	; 34
     bf6:	fc 01       	movw	r30, r24
     bf8:	20 83       	st	Z, r18
	pxTopOfStack--;
     bfa:	8b 81       	ldd	r24, Y+3	; 0x03
     bfc:	9c 81       	ldd	r25, Y+4	; 0x04
     bfe:	01 97       	sbiw	r24, 0x01	; 1
     c00:	9c 83       	std	Y+4, r25	; 0x04
     c02:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
     c04:	8b 81       	ldd	r24, Y+3	; 0x03
     c06:	9c 81       	ldd	r25, Y+4	; 0x04
     c08:	23 e2       	ldi	r18, 0x23	; 35
     c0a:	fc 01       	movw	r30, r24
     c0c:	20 83       	st	Z, r18
	pxTopOfStack--;
     c0e:	8b 81       	ldd	r24, Y+3	; 0x03
     c10:	9c 81       	ldd	r25, Y+4	; 0x04
     c12:	01 97       	sbiw	r24, 0x01	; 1
     c14:	9c 83       	std	Y+4, r25	; 0x04
     c16:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
     c18:	8f 81       	ldd	r24, Y+7	; 0x07
     c1a:	98 85       	ldd	r25, Y+8	; 0x08
     c1c:	9a 83       	std	Y+2, r25	; 0x02
     c1e:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     c20:	29 81       	ldd	r18, Y+1	; 0x01
     c22:	8b 81       	ldd	r24, Y+3	; 0x03
     c24:	9c 81       	ldd	r25, Y+4	; 0x04
     c26:	fc 01       	movw	r30, r24
     c28:	20 83       	st	Z, r18
	pxTopOfStack--;
     c2a:	8b 81       	ldd	r24, Y+3	; 0x03
     c2c:	9c 81       	ldd	r25, Y+4	; 0x04
     c2e:	01 97       	sbiw	r24, 0x01	; 1
     c30:	9c 83       	std	Y+4, r25	; 0x04
     c32:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     c34:	89 81       	ldd	r24, Y+1	; 0x01
     c36:	9a 81       	ldd	r25, Y+2	; 0x02
     c38:	89 2f       	mov	r24, r25
     c3a:	99 27       	eor	r25, r25
     c3c:	9a 83       	std	Y+2, r25	; 0x02
     c3e:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     c40:	29 81       	ldd	r18, Y+1	; 0x01
     c42:	8b 81       	ldd	r24, Y+3	; 0x03
     c44:	9c 81       	ldd	r25, Y+4	; 0x04
     c46:	fc 01       	movw	r30, r24
     c48:	20 83       	st	Z, r18
	pxTopOfStack--;
     c4a:	8b 81       	ldd	r24, Y+3	; 0x03
     c4c:	9c 81       	ldd	r25, Y+4	; 0x04
     c4e:	01 97       	sbiw	r24, 0x01	; 1
     c50:	9c 83       	std	Y+4, r25	; 0x04
     c52:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
     c54:	8b 81       	ldd	r24, Y+3	; 0x03
     c56:	9c 81       	ldd	r25, Y+4	; 0x04
     c58:	26 e2       	ldi	r18, 0x26	; 38
     c5a:	fc 01       	movw	r30, r24
     c5c:	20 83       	st	Z, r18
	pxTopOfStack--;
     c5e:	8b 81       	ldd	r24, Y+3	; 0x03
     c60:	9c 81       	ldd	r25, Y+4	; 0x04
     c62:	01 97       	sbiw	r24, 0x01	; 1
     c64:	9c 83       	std	Y+4, r25	; 0x04
     c66:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
     c68:	8b 81       	ldd	r24, Y+3	; 0x03
     c6a:	9c 81       	ldd	r25, Y+4	; 0x04
     c6c:	27 e2       	ldi	r18, 0x27	; 39
     c6e:	fc 01       	movw	r30, r24
     c70:	20 83       	st	Z, r18
	pxTopOfStack--;
     c72:	8b 81       	ldd	r24, Y+3	; 0x03
     c74:	9c 81       	ldd	r25, Y+4	; 0x04
     c76:	01 97       	sbiw	r24, 0x01	; 1
     c78:	9c 83       	std	Y+4, r25	; 0x04
     c7a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
     c7c:	8b 81       	ldd	r24, Y+3	; 0x03
     c7e:	9c 81       	ldd	r25, Y+4	; 0x04
     c80:	28 e2       	ldi	r18, 0x28	; 40
     c82:	fc 01       	movw	r30, r24
     c84:	20 83       	st	Z, r18
	pxTopOfStack--;
     c86:	8b 81       	ldd	r24, Y+3	; 0x03
     c88:	9c 81       	ldd	r25, Y+4	; 0x04
     c8a:	01 97       	sbiw	r24, 0x01	; 1
     c8c:	9c 83       	std	Y+4, r25	; 0x04
     c8e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
     c90:	8b 81       	ldd	r24, Y+3	; 0x03
     c92:	9c 81       	ldd	r25, Y+4	; 0x04
     c94:	29 e2       	ldi	r18, 0x29	; 41
     c96:	fc 01       	movw	r30, r24
     c98:	20 83       	st	Z, r18
	pxTopOfStack--;
     c9a:	8b 81       	ldd	r24, Y+3	; 0x03
     c9c:	9c 81       	ldd	r25, Y+4	; 0x04
     c9e:	01 97       	sbiw	r24, 0x01	; 1
     ca0:	9c 83       	std	Y+4, r25	; 0x04
     ca2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
     ca4:	8b 81       	ldd	r24, Y+3	; 0x03
     ca6:	9c 81       	ldd	r25, Y+4	; 0x04
     ca8:	20 e3       	ldi	r18, 0x30	; 48
     caa:	fc 01       	movw	r30, r24
     cac:	20 83       	st	Z, r18
	pxTopOfStack--;
     cae:	8b 81       	ldd	r24, Y+3	; 0x03
     cb0:	9c 81       	ldd	r25, Y+4	; 0x04
     cb2:	01 97       	sbiw	r24, 0x01	; 1
     cb4:	9c 83       	std	Y+4, r25	; 0x04
     cb6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
     cb8:	8b 81       	ldd	r24, Y+3	; 0x03
     cba:	9c 81       	ldd	r25, Y+4	; 0x04
     cbc:	21 e3       	ldi	r18, 0x31	; 49
     cbe:	fc 01       	movw	r30, r24
     cc0:	20 83       	st	Z, r18
	pxTopOfStack--;
     cc2:	8b 81       	ldd	r24, Y+3	; 0x03
     cc4:	9c 81       	ldd	r25, Y+4	; 0x04
     cc6:	01 97       	sbiw	r24, 0x01	; 1
     cc8:	9c 83       	std	Y+4, r25	; 0x04
     cca:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
     ccc:	8b 81       	ldd	r24, Y+3	; 0x03
     cce:	9c 81       	ldd	r25, Y+4	; 0x04
}
     cd0:	28 96       	adiw	r28, 0x08	; 8
     cd2:	0f b6       	in	r0, 0x3f	; 63
     cd4:	f8 94       	cli
     cd6:	de bf       	out	0x3e, r29	; 62
     cd8:	0f be       	out	0x3f, r0	; 63
     cda:	cd bf       	out	0x3d, r28	; 61
     cdc:	df 91       	pop	r29
     cde:	cf 91       	pop	r28
     ce0:	08 95       	ret

00000ce2 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
     ce2:	cf 93       	push	r28
     ce4:	df 93       	push	r29
     ce6:	cd b7       	in	r28, 0x3d	; 61
     ce8:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
     cea:	0e 94 66 07 	call	0xecc	; 0xecc <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     cee:	a0 91 5a 0d 	lds	r26, 0x0D5A	; 0x800d5a <pxCurrentTCB>
     cf2:	b0 91 5b 0d 	lds	r27, 0x0D5B	; 0x800d5b <pxCurrentTCB+0x1>
     cf6:	cd 91       	ld	r28, X+
     cf8:	cd bf       	out	0x3d, r28	; 61
     cfa:	dd 91       	ld	r29, X+
     cfc:	de bf       	out	0x3e, r29	; 62
     cfe:	ff 91       	pop	r31
     d00:	ef 91       	pop	r30
     d02:	df 91       	pop	r29
     d04:	cf 91       	pop	r28
     d06:	bf 91       	pop	r27
     d08:	af 91       	pop	r26
     d0a:	9f 91       	pop	r25
     d0c:	8f 91       	pop	r24
     d0e:	7f 91       	pop	r23
     d10:	6f 91       	pop	r22
     d12:	5f 91       	pop	r21
     d14:	4f 91       	pop	r20
     d16:	3f 91       	pop	r19
     d18:	2f 91       	pop	r18
     d1a:	1f 91       	pop	r17
     d1c:	0f 91       	pop	r16
     d1e:	ff 90       	pop	r15
     d20:	ef 90       	pop	r14
     d22:	df 90       	pop	r13
     d24:	cf 90       	pop	r12
     d26:	bf 90       	pop	r11
     d28:	af 90       	pop	r10
     d2a:	9f 90       	pop	r9
     d2c:	8f 90       	pop	r8
     d2e:	7f 90       	pop	r7
     d30:	6f 90       	pop	r6
     d32:	5f 90       	pop	r5
     d34:	4f 90       	pop	r4
     d36:	3f 90       	pop	r3
     d38:	2f 90       	pop	r2
     d3a:	1f 90       	pop	r1
     d3c:	0f 90       	pop	r0
     d3e:	0f be       	out	0x3f, r0	; 63
     d40:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     d42:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
     d44:	81 e0       	ldi	r24, 0x01	; 1
}
     d46:	df 91       	pop	r29
     d48:	cf 91       	pop	r28
     d4a:	08 95       	ret

00000d4c <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     d4c:	cf 93       	push	r28
     d4e:	df 93       	push	r29
     d50:	cd b7       	in	r28, 0x3d	; 61
     d52:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
     d54:	00 00       	nop
     d56:	df 91       	pop	r29
     d58:	cf 91       	pop	r28
     d5a:	08 95       	ret

00000d5c <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     d5c:	0f 92       	push	r0
     d5e:	0f b6       	in	r0, 0x3f	; 63
     d60:	f8 94       	cli
     d62:	0f 92       	push	r0
     d64:	1f 92       	push	r1
     d66:	11 24       	eor	r1, r1
     d68:	2f 92       	push	r2
     d6a:	3f 92       	push	r3
     d6c:	4f 92       	push	r4
     d6e:	5f 92       	push	r5
     d70:	6f 92       	push	r6
     d72:	7f 92       	push	r7
     d74:	8f 92       	push	r8
     d76:	9f 92       	push	r9
     d78:	af 92       	push	r10
     d7a:	bf 92       	push	r11
     d7c:	cf 92       	push	r12
     d7e:	df 92       	push	r13
     d80:	ef 92       	push	r14
     d82:	ff 92       	push	r15
     d84:	0f 93       	push	r16
     d86:	1f 93       	push	r17
     d88:	2f 93       	push	r18
     d8a:	3f 93       	push	r19
     d8c:	4f 93       	push	r20
     d8e:	5f 93       	push	r21
     d90:	6f 93       	push	r22
     d92:	7f 93       	push	r23
     d94:	8f 93       	push	r24
     d96:	9f 93       	push	r25
     d98:	af 93       	push	r26
     d9a:	bf 93       	push	r27
     d9c:	cf 93       	push	r28
     d9e:	df 93       	push	r29
     da0:	ef 93       	push	r30
     da2:	ff 93       	push	r31
     da4:	a0 91 5a 0d 	lds	r26, 0x0D5A	; 0x800d5a <pxCurrentTCB>
     da8:	b0 91 5b 0d 	lds	r27, 0x0D5B	; 0x800d5b <pxCurrentTCB+0x1>
     dac:	0d b6       	in	r0, 0x3d	; 61
     dae:	0d 92       	st	X+, r0
     db0:	0e b6       	in	r0, 0x3e	; 62
     db2:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     db4:	0e 94 39 15 	call	0x2a72	; 0x2a72 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     db8:	a0 91 5a 0d 	lds	r26, 0x0D5A	; 0x800d5a <pxCurrentTCB>
     dbc:	b0 91 5b 0d 	lds	r27, 0x0D5B	; 0x800d5b <pxCurrentTCB+0x1>
     dc0:	cd 91       	ld	r28, X+
     dc2:	cd bf       	out	0x3d, r28	; 61
     dc4:	dd 91       	ld	r29, X+
     dc6:	de bf       	out	0x3e, r29	; 62
     dc8:	ff 91       	pop	r31
     dca:	ef 91       	pop	r30
     dcc:	df 91       	pop	r29
     dce:	cf 91       	pop	r28
     dd0:	bf 91       	pop	r27
     dd2:	af 91       	pop	r26
     dd4:	9f 91       	pop	r25
     dd6:	8f 91       	pop	r24
     dd8:	7f 91       	pop	r23
     dda:	6f 91       	pop	r22
     ddc:	5f 91       	pop	r21
     dde:	4f 91       	pop	r20
     de0:	3f 91       	pop	r19
     de2:	2f 91       	pop	r18
     de4:	1f 91       	pop	r17
     de6:	0f 91       	pop	r16
     de8:	ff 90       	pop	r15
     dea:	ef 90       	pop	r14
     dec:	df 90       	pop	r13
     dee:	cf 90       	pop	r12
     df0:	bf 90       	pop	r11
     df2:	af 90       	pop	r10
     df4:	9f 90       	pop	r9
     df6:	8f 90       	pop	r8
     df8:	7f 90       	pop	r7
     dfa:	6f 90       	pop	r6
     dfc:	5f 90       	pop	r5
     dfe:	4f 90       	pop	r4
     e00:	3f 90       	pop	r3
     e02:	2f 90       	pop	r2
     e04:	1f 90       	pop	r1
     e06:	0f 90       	pop	r0
     e08:	0f be       	out	0x3f, r0	; 63
     e0a:	0f 90       	pop	r0

	asm volatile ( "ret" );
     e0c:	08 95       	ret
	...

00000e10 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     e10:	0f 92       	push	r0
     e12:	0f b6       	in	r0, 0x3f	; 63
     e14:	f8 94       	cli
     e16:	0f 92       	push	r0
     e18:	1f 92       	push	r1
     e1a:	11 24       	eor	r1, r1
     e1c:	2f 92       	push	r2
     e1e:	3f 92       	push	r3
     e20:	4f 92       	push	r4
     e22:	5f 92       	push	r5
     e24:	6f 92       	push	r6
     e26:	7f 92       	push	r7
     e28:	8f 92       	push	r8
     e2a:	9f 92       	push	r9
     e2c:	af 92       	push	r10
     e2e:	bf 92       	push	r11
     e30:	cf 92       	push	r12
     e32:	df 92       	push	r13
     e34:	ef 92       	push	r14
     e36:	ff 92       	push	r15
     e38:	0f 93       	push	r16
     e3a:	1f 93       	push	r17
     e3c:	2f 93       	push	r18
     e3e:	3f 93       	push	r19
     e40:	4f 93       	push	r20
     e42:	5f 93       	push	r21
     e44:	6f 93       	push	r22
     e46:	7f 93       	push	r23
     e48:	8f 93       	push	r24
     e4a:	9f 93       	push	r25
     e4c:	af 93       	push	r26
     e4e:	bf 93       	push	r27
     e50:	cf 93       	push	r28
     e52:	df 93       	push	r29
     e54:	ef 93       	push	r30
     e56:	ff 93       	push	r31
     e58:	a0 91 5a 0d 	lds	r26, 0x0D5A	; 0x800d5a <pxCurrentTCB>
     e5c:	b0 91 5b 0d 	lds	r27, 0x0D5B	; 0x800d5b <pxCurrentTCB+0x1>
     e60:	0d b6       	in	r0, 0x3d	; 61
     e62:	0d 92       	st	X+, r0
     e64:	0e b6       	in	r0, 0x3e	; 62
     e66:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     e68:	0e 94 4c 14 	call	0x2898	; 0x2898 <xTaskIncrementTick>
     e6c:	88 23       	and	r24, r24
     e6e:	11 f0       	breq	.+4      	; 0xe74 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
     e70:	0e 94 39 15 	call	0x2a72	; 0x2a72 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     e74:	a0 91 5a 0d 	lds	r26, 0x0D5A	; 0x800d5a <pxCurrentTCB>
     e78:	b0 91 5b 0d 	lds	r27, 0x0D5B	; 0x800d5b <pxCurrentTCB+0x1>
     e7c:	cd 91       	ld	r28, X+
     e7e:	cd bf       	out	0x3d, r28	; 61
     e80:	dd 91       	ld	r29, X+
     e82:	de bf       	out	0x3e, r29	; 62
     e84:	ff 91       	pop	r31
     e86:	ef 91       	pop	r30
     e88:	df 91       	pop	r29
     e8a:	cf 91       	pop	r28
     e8c:	bf 91       	pop	r27
     e8e:	af 91       	pop	r26
     e90:	9f 91       	pop	r25
     e92:	8f 91       	pop	r24
     e94:	7f 91       	pop	r23
     e96:	6f 91       	pop	r22
     e98:	5f 91       	pop	r21
     e9a:	4f 91       	pop	r20
     e9c:	3f 91       	pop	r19
     e9e:	2f 91       	pop	r18
     ea0:	1f 91       	pop	r17
     ea2:	0f 91       	pop	r16
     ea4:	ff 90       	pop	r15
     ea6:	ef 90       	pop	r14
     ea8:	df 90       	pop	r13
     eaa:	cf 90       	pop	r12
     eac:	bf 90       	pop	r11
     eae:	af 90       	pop	r10
     eb0:	9f 90       	pop	r9
     eb2:	8f 90       	pop	r8
     eb4:	7f 90       	pop	r7
     eb6:	6f 90       	pop	r6
     eb8:	5f 90       	pop	r5
     eba:	4f 90       	pop	r4
     ebc:	3f 90       	pop	r3
     ebe:	2f 90       	pop	r2
     ec0:	1f 90       	pop	r1
     ec2:	0f 90       	pop	r0
     ec4:	0f be       	out	0x3f, r0	; 63
     ec6:	0f 90       	pop	r0

	asm volatile ( "ret" );
     ec8:	08 95       	ret
	...

00000ecc <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
     ecc:	cf 93       	push	r28
     ece:	df 93       	push	r29
     ed0:	00 d0       	rcall	.+0      	; 0xed2 <prvSetupTimerInterrupt+0x6>
     ed2:	00 d0       	rcall	.+0      	; 0xed4 <prvSetupTimerInterrupt+0x8>
     ed4:	00 d0       	rcall	.+0      	; 0xed6 <prvSetupTimerInterrupt+0xa>
     ed6:	cd b7       	in	r28, 0x3d	; 61
     ed8:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
     eda:	80 e0       	ldi	r24, 0x00	; 0
     edc:	90 eb       	ldi	r25, 0xB0	; 176
     ede:	a1 e0       	ldi	r26, 0x01	; 1
     ee0:	b0 e0       	ldi	r27, 0x00	; 0
     ee2:	89 83       	std	Y+1, r24	; 0x01
     ee4:	9a 83       	std	Y+2, r25	; 0x02
     ee6:	ab 83       	std	Y+3, r26	; 0x03
     ee8:	bc 83       	std	Y+4, r27	; 0x04

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
     eea:	89 81       	ldd	r24, Y+1	; 0x01
     eec:	9a 81       	ldd	r25, Y+2	; 0x02
     eee:	ab 81       	ldd	r26, Y+3	; 0x03
     ef0:	bc 81       	ldd	r27, Y+4	; 0x04
     ef2:	68 94       	set
     ef4:	15 f8       	bld	r1, 5
     ef6:	b6 95       	lsr	r27
     ef8:	a7 95       	ror	r26
     efa:	97 95       	ror	r25
     efc:	87 95       	ror	r24
     efe:	16 94       	lsr	r1
     f00:	d1 f7       	brne	.-12     	; 0xef6 <prvSetupTimerInterrupt+0x2a>
     f02:	89 83       	std	Y+1, r24	; 0x01
     f04:	9a 83       	std	Y+2, r25	; 0x02
     f06:	ab 83       	std	Y+3, r26	; 0x03
     f08:	bc 83       	std	Y+4, r27	; 0x04

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
     f0a:	89 81       	ldd	r24, Y+1	; 0x01
     f0c:	9a 81       	ldd	r25, Y+2	; 0x02
     f0e:	ab 81       	ldd	r26, Y+3	; 0x03
     f10:	bc 81       	ldd	r27, Y+4	; 0x04
     f12:	01 97       	sbiw	r24, 0x01	; 1
     f14:	a1 09       	sbc	r26, r1
     f16:	b1 09       	sbc	r27, r1
     f18:	89 83       	std	Y+1, r24	; 0x01
     f1a:	9a 83       	std	Y+2, r25	; 0x02
     f1c:	ab 83       	std	Y+3, r26	; 0x03
     f1e:	bc 83       	std	Y+4, r27	; 0x04

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
     f20:	89 81       	ldd	r24, Y+1	; 0x01
     f22:	8d 83       	std	Y+5, r24	; 0x05
	ulCompareMatch >>= 8;
     f24:	89 81       	ldd	r24, Y+1	; 0x01
     f26:	9a 81       	ldd	r25, Y+2	; 0x02
     f28:	ab 81       	ldd	r26, Y+3	; 0x03
     f2a:	bc 81       	ldd	r27, Y+4	; 0x04
     f2c:	89 2f       	mov	r24, r25
     f2e:	9a 2f       	mov	r25, r26
     f30:	ab 2f       	mov	r26, r27
     f32:	bb 27       	eor	r27, r27
     f34:	89 83       	std	Y+1, r24	; 0x01
     f36:	9a 83       	std	Y+2, r25	; 0x02
     f38:	ab 83       	std	Y+3, r26	; 0x03
     f3a:	bc 83       	std	Y+4, r27	; 0x04
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
     f3c:	89 81       	ldd	r24, Y+1	; 0x01
     f3e:	8e 83       	std	Y+6, r24	; 0x06
	OCR1AH = ucHighByte;
     f40:	8b e4       	ldi	r24, 0x4B	; 75
     f42:	90 e0       	ldi	r25, 0x00	; 0
     f44:	2e 81       	ldd	r18, Y+6	; 0x06
     f46:	fc 01       	movw	r30, r24
     f48:	20 83       	st	Z, r18
	OCR1AL = ucLowByte;
     f4a:	8a e4       	ldi	r24, 0x4A	; 74
     f4c:	90 e0       	ldi	r25, 0x00	; 0
     f4e:	2d 81       	ldd	r18, Y+5	; 0x05
     f50:	fc 01       	movw	r30, r24
     f52:	20 83       	st	Z, r18

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
     f54:	8b e0       	ldi	r24, 0x0B	; 11
     f56:	8d 83       	std	Y+5, r24	; 0x05
	TCCR1B = ucLowByte;
     f58:	8e e4       	ldi	r24, 0x4E	; 78
     f5a:	90 e0       	ldi	r25, 0x00	; 0
     f5c:	2d 81       	ldd	r18, Y+5	; 0x05
     f5e:	fc 01       	movw	r30, r24
     f60:	20 83       	st	Z, r18

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
     f62:	87 e5       	ldi	r24, 0x57	; 87
     f64:	90 e0       	ldi	r25, 0x00	; 0
     f66:	fc 01       	movw	r30, r24
     f68:	80 81       	ld	r24, Z
     f6a:	8d 83       	std	Y+5, r24	; 0x05
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     f6c:	8d 81       	ldd	r24, Y+5	; 0x05
     f6e:	80 61       	ori	r24, 0x10	; 16
     f70:	8d 83       	std	Y+5, r24	; 0x05
	TIMSK = ucLowByte;
     f72:	87 e5       	ldi	r24, 0x57	; 87
     f74:	90 e0       	ldi	r25, 0x00	; 0
     f76:	2d 81       	ldd	r18, Y+5	; 0x05
     f78:	fc 01       	movw	r30, r24
     f7a:	20 83       	st	Z, r18
}
     f7c:	00 00       	nop
     f7e:	26 96       	adiw	r28, 0x06	; 6
     f80:	0f b6       	in	r0, 0x3f	; 63
     f82:	f8 94       	cli
     f84:	de bf       	out	0x3e, r29	; 62
     f86:	0f be       	out	0x3f, r0	; 63
     f88:	cd bf       	out	0x3d, r28	; 61
     f8a:	df 91       	pop	r29
     f8c:	cf 91       	pop	r28
     f8e:	08 95       	ret

00000f90 <__vector_12>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     f90:	0e 94 08 07 	call	0xe10	; 0xe10 <vPortYieldFromTick>
		asm volatile ( "reti" );
     f94:	18 95       	reti
	...

00000f98 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     f98:	cf 93       	push	r28
     f9a:	df 93       	push	r29
     f9c:	00 d0       	rcall	.+0      	; 0xf9e <pvPortMalloc+0x6>
     f9e:	00 d0       	rcall	.+0      	; 0xfa0 <pvPortMalloc+0x8>
     fa0:	cd b7       	in	r28, 0x3d	; 61
     fa2:	de b7       	in	r29, 0x3e	; 62
     fa4:	9c 83       	std	Y+4, r25	; 0x04
     fa6:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
     fa8:	1a 82       	std	Y+2, r1	; 0x02
     faa:	19 82       	std	Y+1, r1	; 0x01
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
     fac:	0e 94 54 13 	call	0x26a8	; 0x26a8 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     fb0:	80 91 58 0d 	lds	r24, 0x0D58	; 0x800d58 <pucAlignedHeap.2068>
     fb4:	90 91 59 0d 	lds	r25, 0x0D59	; 0x800d59 <pucAlignedHeap.2068+0x1>
     fb8:	89 2b       	or	r24, r25
     fba:	31 f4       	brne	.+12     	; 0xfc8 <pvPortMalloc+0x30>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     fbc:	87 e5       	ldi	r24, 0x57	; 87
     fbe:	91 e0       	ldi	r25, 0x01	; 1
     fc0:	90 93 59 0d 	sts	0x0D59, r25	; 0x800d59 <pucAlignedHeap.2068+0x1>
     fc4:	80 93 58 0d 	sts	0x0D58, r24	; 0x800d58 <pucAlignedHeap.2068>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     fc8:	20 91 56 0d 	lds	r18, 0x0D56	; 0x800d56 <xNextFreeByte>
     fcc:	30 91 57 0d 	lds	r19, 0x0D57	; 0x800d57 <xNextFreeByte+0x1>
     fd0:	8b 81       	ldd	r24, Y+3	; 0x03
     fd2:	9c 81       	ldd	r25, Y+4	; 0x04
     fd4:	82 0f       	add	r24, r18
     fd6:	93 1f       	adc	r25, r19
     fd8:	8f 3f       	cpi	r24, 0xFF	; 255
     fda:	9b 40       	sbci	r25, 0x0B	; 11
     fdc:	38 f5       	brcc	.+78     	; 0x102c <pvPortMalloc+0x94>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
     fde:	20 91 56 0d 	lds	r18, 0x0D56	; 0x800d56 <xNextFreeByte>
     fe2:	30 91 57 0d 	lds	r19, 0x0D57	; 0x800d57 <xNextFreeByte+0x1>
     fe6:	8b 81       	ldd	r24, Y+3	; 0x03
     fe8:	9c 81       	ldd	r25, Y+4	; 0x04
     fea:	28 0f       	add	r18, r24
     fec:	39 1f       	adc	r19, r25
     fee:	80 91 56 0d 	lds	r24, 0x0D56	; 0x800d56 <xNextFreeByte>
     ff2:	90 91 57 0d 	lds	r25, 0x0D57	; 0x800d57 <xNextFreeByte+0x1>
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     ff6:	82 17       	cp	r24, r18
     ff8:	93 07       	cpc	r25, r19
     ffa:	c0 f4       	brcc	.+48     	; 0x102c <pvPortMalloc+0x94>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     ffc:	20 91 58 0d 	lds	r18, 0x0D58	; 0x800d58 <pucAlignedHeap.2068>
    1000:	30 91 59 0d 	lds	r19, 0x0D59	; 0x800d59 <pucAlignedHeap.2068+0x1>
    1004:	80 91 56 0d 	lds	r24, 0x0D56	; 0x800d56 <xNextFreeByte>
    1008:	90 91 57 0d 	lds	r25, 0x0D57	; 0x800d57 <xNextFreeByte+0x1>
    100c:	82 0f       	add	r24, r18
    100e:	93 1f       	adc	r25, r19
    1010:	9a 83       	std	Y+2, r25	; 0x02
    1012:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
    1014:	20 91 56 0d 	lds	r18, 0x0D56	; 0x800d56 <xNextFreeByte>
    1018:	30 91 57 0d 	lds	r19, 0x0D57	; 0x800d57 <xNextFreeByte+0x1>
    101c:	8b 81       	ldd	r24, Y+3	; 0x03
    101e:	9c 81       	ldd	r25, Y+4	; 0x04
    1020:	82 0f       	add	r24, r18
    1022:	93 1f       	adc	r25, r19
    1024:	90 93 57 0d 	sts	0x0D57, r25	; 0x800d57 <xNextFreeByte+0x1>
    1028:	80 93 56 0d 	sts	0x0D56, r24	; 0x800d56 <xNextFreeByte>
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    102c:	0e 94 61 13 	call	0x26c2	; 0x26c2 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
    1030:	89 81       	ldd	r24, Y+1	; 0x01
    1032:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1034:	0f 90       	pop	r0
    1036:	0f 90       	pop	r0
    1038:	0f 90       	pop	r0
    103a:	0f 90       	pop	r0
    103c:	df 91       	pop	r29
    103e:	cf 91       	pop	r28
    1040:	08 95       	ret

00001042 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1042:	cf 93       	push	r28
    1044:	df 93       	push	r29
    1046:	00 d0       	rcall	.+0      	; 0x1048 <vPortFree+0x6>
    1048:	cd b7       	in	r28, 0x3d	; 61
    104a:	de b7       	in	r29, 0x3e	; 62
    104c:	9a 83       	std	Y+2, r25	; 0x02
    104e:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
    1050:	00 00       	nop
    1052:	0f 90       	pop	r0
    1054:	0f 90       	pop	r0
    1056:	df 91       	pop	r29
    1058:	cf 91       	pop	r28
    105a:	08 95       	ret

0000105c <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    105c:	cf 93       	push	r28
    105e:	df 93       	push	r29
    1060:	cd b7       	in	r28, 0x3d	; 61
    1062:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    1064:	10 92 57 0d 	sts	0x0D57, r1	; 0x800d57 <xNextFreeByte+0x1>
    1068:	10 92 56 0d 	sts	0x0D56, r1	; 0x800d56 <xNextFreeByte>
}
    106c:	00 00       	nop
    106e:	df 91       	pop	r29
    1070:	cf 91       	pop	r28
    1072:	08 95       	ret

00001074 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    1074:	cf 93       	push	r28
    1076:	df 93       	push	r29
    1078:	cd b7       	in	r28, 0x3d	; 61
    107a:	de b7       	in	r29, 0x3e	; 62
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    107c:	80 91 56 0d 	lds	r24, 0x0D56	; 0x800d56 <xNextFreeByte>
    1080:	90 91 57 0d 	lds	r25, 0x0D57	; 0x800d57 <xNextFreeByte+0x1>
    1084:	2f ef       	ldi	r18, 0xFF	; 255
    1086:	3b e0       	ldi	r19, 0x0B	; 11
    1088:	a9 01       	movw	r20, r18
    108a:	48 1b       	sub	r20, r24
    108c:	59 0b       	sbc	r21, r25
    108e:	ca 01       	movw	r24, r20
}
    1090:	df 91       	pop	r29
    1092:	cf 91       	pop	r28
    1094:	08 95       	ret

00001096 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    1096:	cf 93       	push	r28
    1098:	df 93       	push	r29
    109a:	00 d0       	rcall	.+0      	; 0x109c <xQueueGenericReset+0x6>
    109c:	00 d0       	rcall	.+0      	; 0x109e <xQueueGenericReset+0x8>
    109e:	1f 92       	push	r1
    10a0:	cd b7       	in	r28, 0x3d	; 61
    10a2:	de b7       	in	r29, 0x3e	; 62
    10a4:	9c 83       	std	Y+4, r25	; 0x04
    10a6:	8b 83       	std	Y+3, r24	; 0x03
    10a8:	6d 83       	std	Y+5, r22	; 0x05
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    10aa:	8b 81       	ldd	r24, Y+3	; 0x03
    10ac:	9c 81       	ldd	r25, Y+4	; 0x04
    10ae:	9a 83       	std	Y+2, r25	; 0x02
    10b0:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    10b2:	0f b6       	in	r0, 0x3f	; 63
    10b4:	f8 94       	cli
    10b6:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    10b8:	89 81       	ldd	r24, Y+1	; 0x01
    10ba:	9a 81       	ldd	r25, Y+2	; 0x02
    10bc:	fc 01       	movw	r30, r24
    10be:	80 81       	ld	r24, Z
    10c0:	91 81       	ldd	r25, Z+1	; 0x01
    10c2:	29 81       	ldd	r18, Y+1	; 0x01
    10c4:	3a 81       	ldd	r19, Y+2	; 0x02
    10c6:	f9 01       	movw	r30, r18
    10c8:	23 8d       	ldd	r18, Z+27	; 0x1b
    10ca:	42 2f       	mov	r20, r18
    10cc:	50 e0       	ldi	r21, 0x00	; 0
    10ce:	29 81       	ldd	r18, Y+1	; 0x01
    10d0:	3a 81       	ldd	r19, Y+2	; 0x02
    10d2:	f9 01       	movw	r30, r18
    10d4:	24 8d       	ldd	r18, Z+28	; 0x1c
    10d6:	22 2f       	mov	r18, r18
    10d8:	30 e0       	ldi	r19, 0x00	; 0
    10da:	42 9f       	mul	r20, r18
    10dc:	b0 01       	movw	r22, r0
    10de:	43 9f       	mul	r20, r19
    10e0:	70 0d       	add	r23, r0
    10e2:	52 9f       	mul	r21, r18
    10e4:	70 0d       	add	r23, r0
    10e6:	11 24       	eor	r1, r1
    10e8:	9b 01       	movw	r18, r22
    10ea:	28 0f       	add	r18, r24
    10ec:	39 1f       	adc	r19, r25
    10ee:	89 81       	ldd	r24, Y+1	; 0x01
    10f0:	9a 81       	ldd	r25, Y+2	; 0x02
    10f2:	fc 01       	movw	r30, r24
    10f4:	33 83       	std	Z+3, r19	; 0x03
    10f6:	22 83       	std	Z+2, r18	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    10f8:	89 81       	ldd	r24, Y+1	; 0x01
    10fa:	9a 81       	ldd	r25, Y+2	; 0x02
    10fc:	fc 01       	movw	r30, r24
    10fe:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    1100:	89 81       	ldd	r24, Y+1	; 0x01
    1102:	9a 81       	ldd	r25, Y+2	; 0x02
    1104:	fc 01       	movw	r30, r24
    1106:	20 81       	ld	r18, Z
    1108:	31 81       	ldd	r19, Z+1	; 0x01
    110a:	89 81       	ldd	r24, Y+1	; 0x01
    110c:	9a 81       	ldd	r25, Y+2	; 0x02
    110e:	fc 01       	movw	r30, r24
    1110:	35 83       	std	Z+5, r19	; 0x05
    1112:	24 83       	std	Z+4, r18	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    1114:	89 81       	ldd	r24, Y+1	; 0x01
    1116:	9a 81       	ldd	r25, Y+2	; 0x02
    1118:	fc 01       	movw	r30, r24
    111a:	80 81       	ld	r24, Z
    111c:	91 81       	ldd	r25, Z+1	; 0x01
    111e:	29 81       	ldd	r18, Y+1	; 0x01
    1120:	3a 81       	ldd	r19, Y+2	; 0x02
    1122:	f9 01       	movw	r30, r18
    1124:	23 8d       	ldd	r18, Z+27	; 0x1b
    1126:	22 2f       	mov	r18, r18
    1128:	30 e0       	ldi	r19, 0x00	; 0
    112a:	a9 01       	movw	r20, r18
    112c:	41 50       	subi	r20, 0x01	; 1
    112e:	51 09       	sbc	r21, r1
    1130:	29 81       	ldd	r18, Y+1	; 0x01
    1132:	3a 81       	ldd	r19, Y+2	; 0x02
    1134:	f9 01       	movw	r30, r18
    1136:	24 8d       	ldd	r18, Z+28	; 0x1c
    1138:	22 2f       	mov	r18, r18
    113a:	30 e0       	ldi	r19, 0x00	; 0
    113c:	42 9f       	mul	r20, r18
    113e:	b0 01       	movw	r22, r0
    1140:	43 9f       	mul	r20, r19
    1142:	70 0d       	add	r23, r0
    1144:	52 9f       	mul	r21, r18
    1146:	70 0d       	add	r23, r0
    1148:	11 24       	eor	r1, r1
    114a:	9b 01       	movw	r18, r22
    114c:	28 0f       	add	r18, r24
    114e:	39 1f       	adc	r19, r25
    1150:	89 81       	ldd	r24, Y+1	; 0x01
    1152:	9a 81       	ldd	r25, Y+2	; 0x02
    1154:	fc 01       	movw	r30, r24
    1156:	37 83       	std	Z+7, r19	; 0x07
    1158:	26 83       	std	Z+6, r18	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    115a:	89 81       	ldd	r24, Y+1	; 0x01
    115c:	9a 81       	ldd	r25, Y+2	; 0x02
    115e:	2f ef       	ldi	r18, 0xFF	; 255
    1160:	fc 01       	movw	r30, r24
    1162:	25 8f       	std	Z+29, r18	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    1164:	89 81       	ldd	r24, Y+1	; 0x01
    1166:	9a 81       	ldd	r25, Y+2	; 0x02
    1168:	2f ef       	ldi	r18, 0xFF	; 255
    116a:	fc 01       	movw	r30, r24
    116c:	26 8f       	std	Z+30, r18	; 0x1e

		if( xNewQueue == pdFALSE )
    116e:	8d 81       	ldd	r24, Y+5	; 0x05
    1170:	88 23       	and	r24, r24
    1172:	81 f4       	brne	.+32     	; 0x1194 <__stack+0x95>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1174:	89 81       	ldd	r24, Y+1	; 0x01
    1176:	9a 81       	ldd	r25, Y+2	; 0x02
    1178:	fc 01       	movw	r30, r24
    117a:	80 85       	ldd	r24, Z+8	; 0x08
    117c:	88 23       	and	r24, r24
    117e:	a1 f0       	breq	.+40     	; 0x11a8 <__stack+0xa9>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1180:	89 81       	ldd	r24, Y+1	; 0x01
    1182:	9a 81       	ldd	r25, Y+2	; 0x02
    1184:	08 96       	adiw	r24, 0x08	; 8
    1186:	0e 94 02 16 	call	0x2c04	; 0x2c04 <xTaskRemoveFromEventList>
    118a:	88 23       	and	r24, r24
    118c:	69 f0       	breq	.+26     	; 0x11a8 <__stack+0xa9>
				{
					queueYIELD_IF_USING_PREEMPTION();
    118e:	0e 94 ae 06 	call	0xd5c	; 0xd5c <vPortYield>
    1192:	0a c0       	rjmp	.+20     	; 0x11a8 <__stack+0xa9>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1194:	89 81       	ldd	r24, Y+1	; 0x01
    1196:	9a 81       	ldd	r25, Y+2	; 0x02
    1198:	08 96       	adiw	r24, 0x08	; 8
    119a:	0e 94 62 03 	call	0x6c4	; 0x6c4 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    119e:	89 81       	ldd	r24, Y+1	; 0x01
    11a0:	9a 81       	ldd	r25, Y+2	; 0x02
    11a2:	41 96       	adiw	r24, 0x11	; 17
    11a4:	0e 94 62 03 	call	0x6c4	; 0x6c4 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    11a8:	0f 90       	pop	r0
    11aa:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    11ac:	81 e0       	ldi	r24, 0x01	; 1
}
    11ae:	0f 90       	pop	r0
    11b0:	0f 90       	pop	r0
    11b2:	0f 90       	pop	r0
    11b4:	0f 90       	pop	r0
    11b6:	0f 90       	pop	r0
    11b8:	df 91       	pop	r29
    11ba:	cf 91       	pop	r28
    11bc:	08 95       	ret

000011be <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    11be:	0f 93       	push	r16
    11c0:	1f 93       	push	r17
    11c2:	cf 93       	push	r28
    11c4:	df 93       	push	r29
    11c6:	cd b7       	in	r28, 0x3d	; 61
    11c8:	de b7       	in	r29, 0x3e	; 62
    11ca:	29 97       	sbiw	r28, 0x09	; 9
    11cc:	0f b6       	in	r0, 0x3f	; 63
    11ce:	f8 94       	cli
    11d0:	de bf       	out	0x3e, r29	; 62
    11d2:	0f be       	out	0x3f, r0	; 63
    11d4:	cd bf       	out	0x3d, r28	; 61
    11d6:	8f 83       	std	Y+7, r24	; 0x07
    11d8:	68 87       	std	Y+8, r22	; 0x08
    11da:	49 87       	std	Y+9, r20	; 0x09
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    11dc:	88 85       	ldd	r24, Y+8	; 0x08
    11de:	88 23       	and	r24, r24
    11e0:	19 f4       	brne	.+6      	; 0x11e8 <xQueueGenericCreate+0x2a>
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    11e2:	1a 82       	std	Y+2, r1	; 0x02
    11e4:	19 82       	std	Y+1, r1	; 0x01
    11e6:	0f c0       	rjmp	.+30     	; 0x1206 <xQueueGenericCreate+0x48>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    11e8:	8f 81       	ldd	r24, Y+7	; 0x07
    11ea:	48 2f       	mov	r20, r24
    11ec:	50 e0       	ldi	r21, 0x00	; 0
    11ee:	88 85       	ldd	r24, Y+8	; 0x08
    11f0:	28 2f       	mov	r18, r24
    11f2:	30 e0       	ldi	r19, 0x00	; 0
    11f4:	42 9f       	mul	r20, r18
    11f6:	c0 01       	movw	r24, r0
    11f8:	43 9f       	mul	r20, r19
    11fa:	90 0d       	add	r25, r0
    11fc:	52 9f       	mul	r21, r18
    11fe:	90 0d       	add	r25, r0
    1200:	11 24       	eor	r1, r1
    1202:	9a 83       	std	Y+2, r25	; 0x02
    1204:	89 83       	std	Y+1, r24	; 0x01
		}

		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
    1206:	89 81       	ldd	r24, Y+1	; 0x01
    1208:	9a 81       	ldd	r25, Y+2	; 0x02
    120a:	4f 96       	adiw	r24, 0x1f	; 31
    120c:	0e 94 cc 07 	call	0xf98	; 0xf98 <pvPortMalloc>
    1210:	9c 83       	std	Y+4, r25	; 0x04
    1212:	8b 83       	std	Y+3, r24	; 0x03

		if( pxNewQueue != NULL )
    1214:	8b 81       	ldd	r24, Y+3	; 0x03
    1216:	9c 81       	ldd	r25, Y+4	; 0x04
    1218:	89 2b       	or	r24, r25
    121a:	81 f0       	breq	.+32     	; 0x123c <xQueueGenericCreate+0x7e>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
    121c:	8b 81       	ldd	r24, Y+3	; 0x03
    121e:	9c 81       	ldd	r25, Y+4	; 0x04
    1220:	4f 96       	adiw	r24, 0x1f	; 31
    1222:	9e 83       	std	Y+6, r25	; 0x06
    1224:	8d 83       	std	Y+5, r24	; 0x05
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    1226:	2b 81       	ldd	r18, Y+3	; 0x03
    1228:	3c 81       	ldd	r19, Y+4	; 0x04
    122a:	8d 81       	ldd	r24, Y+5	; 0x05
    122c:	9e 81       	ldd	r25, Y+6	; 0x06
    122e:	89 01       	movw	r16, r18
    1230:	29 85       	ldd	r18, Y+9	; 0x09
    1232:	ac 01       	movw	r20, r24
    1234:	68 85       	ldd	r22, Y+8	; 0x08
    1236:	8f 81       	ldd	r24, Y+7	; 0x07
    1238:	0e 94 2b 09 	call	0x1256	; 0x1256 <prvInitialiseNewQueue>
		}

		return pxNewQueue;
    123c:	8b 81       	ldd	r24, Y+3	; 0x03
    123e:	9c 81       	ldd	r25, Y+4	; 0x04
	}
    1240:	29 96       	adiw	r28, 0x09	; 9
    1242:	0f b6       	in	r0, 0x3f	; 63
    1244:	f8 94       	cli
    1246:	de bf       	out	0x3e, r29	; 62
    1248:	0f be       	out	0x3f, r0	; 63
    124a:	cd bf       	out	0x3d, r28	; 61
    124c:	df 91       	pop	r29
    124e:	cf 91       	pop	r28
    1250:	1f 91       	pop	r17
    1252:	0f 91       	pop	r16
    1254:	08 95       	ret

00001256 <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
    1256:	0f 93       	push	r16
    1258:	1f 93       	push	r17
    125a:	cf 93       	push	r28
    125c:	df 93       	push	r29
    125e:	cd b7       	in	r28, 0x3d	; 61
    1260:	de b7       	in	r29, 0x3e	; 62
    1262:	27 97       	sbiw	r28, 0x07	; 7
    1264:	0f b6       	in	r0, 0x3f	; 63
    1266:	f8 94       	cli
    1268:	de bf       	out	0x3e, r29	; 62
    126a:	0f be       	out	0x3f, r0	; 63
    126c:	cd bf       	out	0x3d, r28	; 61
    126e:	89 83       	std	Y+1, r24	; 0x01
    1270:	6a 83       	std	Y+2, r22	; 0x02
    1272:	5c 83       	std	Y+4, r21	; 0x04
    1274:	4b 83       	std	Y+3, r20	; 0x03
    1276:	2d 83       	std	Y+5, r18	; 0x05
    1278:	1f 83       	std	Y+7, r17	; 0x07
    127a:	0e 83       	std	Y+6, r16	; 0x06
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    127c:	8a 81       	ldd	r24, Y+2	; 0x02
    127e:	88 23       	and	r24, r24
    1280:	41 f4       	brne	.+16     	; 0x1292 <prvInitialiseNewQueue+0x3c>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    1282:	8e 81       	ldd	r24, Y+6	; 0x06
    1284:	9f 81       	ldd	r25, Y+7	; 0x07
    1286:	2e 81       	ldd	r18, Y+6	; 0x06
    1288:	3f 81       	ldd	r19, Y+7	; 0x07
    128a:	fc 01       	movw	r30, r24
    128c:	31 83       	std	Z+1, r19	; 0x01
    128e:	20 83       	st	Z, r18
    1290:	07 c0       	rjmp	.+14     	; 0x12a0 <prvInitialiseNewQueue+0x4a>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    1292:	8e 81       	ldd	r24, Y+6	; 0x06
    1294:	9f 81       	ldd	r25, Y+7	; 0x07
    1296:	2b 81       	ldd	r18, Y+3	; 0x03
    1298:	3c 81       	ldd	r19, Y+4	; 0x04
    129a:	fc 01       	movw	r30, r24
    129c:	31 83       	std	Z+1, r19	; 0x01
    129e:	20 83       	st	Z, r18
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    12a0:	8e 81       	ldd	r24, Y+6	; 0x06
    12a2:	9f 81       	ldd	r25, Y+7	; 0x07
    12a4:	29 81       	ldd	r18, Y+1	; 0x01
    12a6:	fc 01       	movw	r30, r24
    12a8:	23 8f       	std	Z+27, r18	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    12aa:	8e 81       	ldd	r24, Y+6	; 0x06
    12ac:	9f 81       	ldd	r25, Y+7	; 0x07
    12ae:	2a 81       	ldd	r18, Y+2	; 0x02
    12b0:	fc 01       	movw	r30, r24
    12b2:	24 8f       	std	Z+28, r18	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    12b4:	8e 81       	ldd	r24, Y+6	; 0x06
    12b6:	9f 81       	ldd	r25, Y+7	; 0x07
    12b8:	61 e0       	ldi	r22, 0x01	; 1
    12ba:	0e 94 4b 08 	call	0x1096	; 0x1096 <xQueueGenericReset>
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
    12be:	00 00       	nop
    12c0:	27 96       	adiw	r28, 0x07	; 7
    12c2:	0f b6       	in	r0, 0x3f	; 63
    12c4:	f8 94       	cli
    12c6:	de bf       	out	0x3e, r29	; 62
    12c8:	0f be       	out	0x3f, r0	; 63
    12ca:	cd bf       	out	0x3d, r28	; 61
    12cc:	df 91       	pop	r29
    12ce:	cf 91       	pop	r28
    12d0:	1f 91       	pop	r17
    12d2:	0f 91       	pop	r16
    12d4:	08 95       	ret

000012d6 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    12d6:	cf 93       	push	r28
    12d8:	df 93       	push	r29
    12da:	cd b7       	in	r28, 0x3d	; 61
    12dc:	de b7       	in	r29, 0x3e	; 62
    12de:	2e 97       	sbiw	r28, 0x0e	; 14
    12e0:	0f b6       	in	r0, 0x3f	; 63
    12e2:	f8 94       	cli
    12e4:	de bf       	out	0x3e, r29	; 62
    12e6:	0f be       	out	0x3f, r0	; 63
    12e8:	cd bf       	out	0x3d, r28	; 61
    12ea:	99 87       	std	Y+9, r25	; 0x09
    12ec:	88 87       	std	Y+8, r24	; 0x08
    12ee:	7b 87       	std	Y+11, r23	; 0x0b
    12f0:	6a 87       	std	Y+10, r22	; 0x0a
    12f2:	5d 87       	std	Y+13, r21	; 0x0d
    12f4:	4c 87       	std	Y+12, r20	; 0x0c
    12f6:	2e 87       	std	Y+14, r18	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    12f8:	19 82       	std	Y+1, r1	; 0x01
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    12fa:	88 85       	ldd	r24, Y+8	; 0x08
    12fc:	99 85       	ldd	r25, Y+9	; 0x09
    12fe:	9b 83       	std	Y+3, r25	; 0x03
    1300:	8a 83       	std	Y+2, r24	; 0x02
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1302:	0f b6       	in	r0, 0x3f	; 63
    1304:	f8 94       	cli
    1306:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1308:	8a 81       	ldd	r24, Y+2	; 0x02
    130a:	9b 81       	ldd	r25, Y+3	; 0x03
    130c:	fc 01       	movw	r30, r24
    130e:	22 8d       	ldd	r18, Z+26	; 0x1a
    1310:	8a 81       	ldd	r24, Y+2	; 0x02
    1312:	9b 81       	ldd	r25, Y+3	; 0x03
    1314:	fc 01       	movw	r30, r24
    1316:	83 8d       	ldd	r24, Z+27	; 0x1b
    1318:	28 17       	cp	r18, r24
    131a:	18 f0       	brcs	.+6      	; 0x1322 <xQueueGenericSend+0x4c>
    131c:	8e 85       	ldd	r24, Y+14	; 0x0e
    131e:	82 30       	cpi	r24, 0x02	; 2
    1320:	11 f5       	brne	.+68     	; 0x1366 <xQueueGenericSend+0x90>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1322:	2a 85       	ldd	r18, Y+10	; 0x0a
    1324:	3b 85       	ldd	r19, Y+11	; 0x0b
    1326:	8a 81       	ldd	r24, Y+2	; 0x02
    1328:	9b 81       	ldd	r25, Y+3	; 0x03
    132a:	4e 85       	ldd	r20, Y+14	; 0x0e
    132c:	b9 01       	movw	r22, r18
    132e:	0e 94 b0 0c 	call	0x1960	; 0x1960 <prvCopyDataToQueue>
    1332:	8c 83       	std	Y+4, r24	; 0x04
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1334:	8a 81       	ldd	r24, Y+2	; 0x02
    1336:	9b 81       	ldd	r25, Y+3	; 0x03
    1338:	fc 01       	movw	r30, r24
    133a:	81 89       	ldd	r24, Z+17	; 0x11
    133c:	88 23       	and	r24, r24
    133e:	51 f0       	breq	.+20     	; 0x1354 <xQueueGenericSend+0x7e>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1340:	8a 81       	ldd	r24, Y+2	; 0x02
    1342:	9b 81       	ldd	r25, Y+3	; 0x03
    1344:	41 96       	adiw	r24, 0x11	; 17
    1346:	0e 94 02 16 	call	0x2c04	; 0x2c04 <xTaskRemoveFromEventList>
    134a:	88 23       	and	r24, r24
    134c:	41 f0       	breq	.+16     	; 0x135e <xQueueGenericSend+0x88>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    134e:	0e 94 ae 06 	call	0xd5c	; 0xd5c <vPortYield>
    1352:	05 c0       	rjmp	.+10     	; 0x135e <xQueueGenericSend+0x88>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    1354:	8c 81       	ldd	r24, Y+4	; 0x04
    1356:	88 23       	and	r24, r24
    1358:	11 f0       	breq	.+4      	; 0x135e <xQueueGenericSend+0x88>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    135a:	0e 94 ae 06 	call	0xd5c	; 0xd5c <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    135e:	0f 90       	pop	r0
    1360:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1362:	81 e0       	ldi	r24, 0x01	; 1
    1364:	60 c0       	rjmp	.+192    	; 0x1426 <xQueueGenericSend+0x150>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1366:	8c 85       	ldd	r24, Y+12	; 0x0c
    1368:	9d 85       	ldd	r25, Y+13	; 0x0d
    136a:	89 2b       	or	r24, r25
    136c:	21 f4       	brne	.+8      	; 0x1376 <xQueueGenericSend+0xa0>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    136e:	0f 90       	pop	r0
    1370:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1372:	80 e0       	ldi	r24, 0x00	; 0
    1374:	58 c0       	rjmp	.+176    	; 0x1426 <xQueueGenericSend+0x150>
				}
				else if( xEntryTimeSet == pdFALSE )
    1376:	89 81       	ldd	r24, Y+1	; 0x01
    1378:	88 23       	and	r24, r24
    137a:	31 f4       	brne	.+12     	; 0x1388 <xQueueGenericSend+0xb2>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    137c:	ce 01       	movw	r24, r28
    137e:	05 96       	adiw	r24, 0x05	; 5
    1380:	0e 94 da 16 	call	0x2db4	; 0x2db4 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1384:	81 e0       	ldi	r24, 0x01	; 1
    1386:	89 83       	std	Y+1, r24	; 0x01
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1388:	0f 90       	pop	r0
    138a:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    138c:	0e 94 54 13 	call	0x26a8	; 0x26a8 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1390:	0f b6       	in	r0, 0x3f	; 63
    1392:	f8 94       	cli
    1394:	0f 92       	push	r0
    1396:	8a 81       	ldd	r24, Y+2	; 0x02
    1398:	9b 81       	ldd	r25, Y+3	; 0x03
    139a:	fc 01       	movw	r30, r24
    139c:	85 8d       	ldd	r24, Z+29	; 0x1d
    139e:	8f 3f       	cpi	r24, 0xFF	; 255
    13a0:	21 f4       	brne	.+8      	; 0x13aa <xQueueGenericSend+0xd4>
    13a2:	8a 81       	ldd	r24, Y+2	; 0x02
    13a4:	9b 81       	ldd	r25, Y+3	; 0x03
    13a6:	fc 01       	movw	r30, r24
    13a8:	15 8e       	std	Z+29, r1	; 0x1d
    13aa:	8a 81       	ldd	r24, Y+2	; 0x02
    13ac:	9b 81       	ldd	r25, Y+3	; 0x03
    13ae:	fc 01       	movw	r30, r24
    13b0:	86 8d       	ldd	r24, Z+30	; 0x1e
    13b2:	8f 3f       	cpi	r24, 0xFF	; 255
    13b4:	21 f4       	brne	.+8      	; 0x13be <xQueueGenericSend+0xe8>
    13b6:	8a 81       	ldd	r24, Y+2	; 0x02
    13b8:	9b 81       	ldd	r25, Y+3	; 0x03
    13ba:	fc 01       	movw	r30, r24
    13bc:	16 8e       	std	Z+30, r1	; 0x1e
    13be:	0f 90       	pop	r0
    13c0:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    13c2:	9e 01       	movw	r18, r28
    13c4:	24 5f       	subi	r18, 0xF4	; 244
    13c6:	3f 4f       	sbci	r19, 0xFF	; 255
    13c8:	ce 01       	movw	r24, r28
    13ca:	05 96       	adiw	r24, 0x05	; 5
    13cc:	b9 01       	movw	r22, r18
    13ce:	0e 94 f6 16 	call	0x2dec	; 0x2dec <xTaskCheckForTimeOut>
    13d2:	88 23       	and	r24, r24
    13d4:	09 f5       	brne	.+66     	; 0x1418 <xQueueGenericSend+0x142>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    13d6:	8a 81       	ldd	r24, Y+2	; 0x02
    13d8:	9b 81       	ldd	r25, Y+3	; 0x03
    13da:	0e 94 51 0e 	call	0x1ca2	; 0x1ca2 <prvIsQueueFull>
    13de:	88 23       	and	r24, r24
    13e0:	a1 f0       	breq	.+40     	; 0x140a <xQueueGenericSend+0x134>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    13e2:	2c 85       	ldd	r18, Y+12	; 0x0c
    13e4:	3d 85       	ldd	r19, Y+13	; 0x0d
    13e6:	8a 81       	ldd	r24, Y+2	; 0x02
    13e8:	9b 81       	ldd	r25, Y+3	; 0x03
    13ea:	08 96       	adiw	r24, 0x08	; 8
    13ec:	b9 01       	movw	r22, r18
    13ee:	0e 94 ad 15 	call	0x2b5a	; 0x2b5a <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    13f2:	8a 81       	ldd	r24, Y+2	; 0x02
    13f4:	9b 81       	ldd	r25, Y+3	; 0x03
    13f6:	0e 94 bc 0d 	call	0x1b78	; 0x1b78 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    13fa:	0e 94 61 13 	call	0x26c2	; 0x26c2 <xTaskResumeAll>
    13fe:	88 23       	and	r24, r24
    1400:	09 f0       	breq	.+2      	; 0x1404 <xQueueGenericSend+0x12e>
    1402:	7f cf       	rjmp	.-258    	; 0x1302 <xQueueGenericSend+0x2c>
				{
					portYIELD_WITHIN_API();
    1404:	0e 94 ae 06 	call	0xd5c	; 0xd5c <vPortYield>
    1408:	7c cf       	rjmp	.-264    	; 0x1302 <xQueueGenericSend+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    140a:	8a 81       	ldd	r24, Y+2	; 0x02
    140c:	9b 81       	ldd	r25, Y+3	; 0x03
    140e:	0e 94 bc 0d 	call	0x1b78	; 0x1b78 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1412:	0e 94 61 13 	call	0x26c2	; 0x26c2 <xTaskResumeAll>
    1416:	75 cf       	rjmp	.-278    	; 0x1302 <xQueueGenericSend+0x2c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1418:	8a 81       	ldd	r24, Y+2	; 0x02
    141a:	9b 81       	ldd	r25, Y+3	; 0x03
    141c:	0e 94 bc 0d 	call	0x1b78	; 0x1b78 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1420:	0e 94 61 13 	call	0x26c2	; 0x26c2 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1424:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    1426:	2e 96       	adiw	r28, 0x0e	; 14
    1428:	0f b6       	in	r0, 0x3f	; 63
    142a:	f8 94       	cli
    142c:	de bf       	out	0x3e, r29	; 62
    142e:	0f be       	out	0x3f, r0	; 63
    1430:	cd bf       	out	0x3d, r28	; 61
    1432:	df 91       	pop	r29
    1434:	cf 91       	pop	r28
    1436:	08 95       	ret

00001438 <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    1438:	cf 93       	push	r28
    143a:	df 93       	push	r29
    143c:	cd b7       	in	r28, 0x3d	; 61
    143e:	de b7       	in	r29, 0x3e	; 62
    1440:	2c 97       	sbiw	r28, 0x0c	; 12
    1442:	0f b6       	in	r0, 0x3f	; 63
    1444:	f8 94       	cli
    1446:	de bf       	out	0x3e, r29	; 62
    1448:	0f be       	out	0x3f, r0	; 63
    144a:	cd bf       	out	0x3d, r28	; 61
    144c:	9f 83       	std	Y+7, r25	; 0x07
    144e:	8e 83       	std	Y+6, r24	; 0x06
    1450:	79 87       	std	Y+9, r23	; 0x09
    1452:	68 87       	std	Y+8, r22	; 0x08
    1454:	5b 87       	std	Y+11, r21	; 0x0b
    1456:	4a 87       	std	Y+10, r20	; 0x0a
    1458:	2c 87       	std	Y+12, r18	; 0x0c
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    145a:	8e 81       	ldd	r24, Y+6	; 0x06
    145c:	9f 81       	ldd	r25, Y+7	; 0x07
    145e:	9b 83       	std	Y+3, r25	; 0x03
    1460:	8a 83       	std	Y+2, r24	; 0x02
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1462:	1c 82       	std	Y+4, r1	; 0x04
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1464:	8a 81       	ldd	r24, Y+2	; 0x02
    1466:	9b 81       	ldd	r25, Y+3	; 0x03
    1468:	fc 01       	movw	r30, r24
    146a:	22 8d       	ldd	r18, Z+26	; 0x1a
    146c:	8a 81       	ldd	r24, Y+2	; 0x02
    146e:	9b 81       	ldd	r25, Y+3	; 0x03
    1470:	fc 01       	movw	r30, r24
    1472:	83 8d       	ldd	r24, Z+27	; 0x1b
    1474:	28 17       	cp	r18, r24
    1476:	18 f0       	brcs	.+6      	; 0x147e <xQueueGenericSendFromISR+0x46>
    1478:	8c 85       	ldd	r24, Y+12	; 0x0c
    147a:	82 30       	cpi	r24, 0x02	; 2
    147c:	89 f5       	brne	.+98     	; 0x14e0 <xQueueGenericSendFromISR+0xa8>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    147e:	8a 81       	ldd	r24, Y+2	; 0x02
    1480:	9b 81       	ldd	r25, Y+3	; 0x03
    1482:	fc 01       	movw	r30, r24
    1484:	86 8d       	ldd	r24, Z+30	; 0x1e
    1486:	8d 83       	std	Y+5, r24	; 0x05
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1488:	28 85       	ldd	r18, Y+8	; 0x08
    148a:	39 85       	ldd	r19, Y+9	; 0x09
    148c:	8a 81       	ldd	r24, Y+2	; 0x02
    148e:	9b 81       	ldd	r25, Y+3	; 0x03
    1490:	4c 85       	ldd	r20, Y+12	; 0x0c
    1492:	b9 01       	movw	r22, r18
    1494:	0e 94 b0 0c 	call	0x1960	; 0x1960 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    1498:	8d 81       	ldd	r24, Y+5	; 0x05
    149a:	8f 3f       	cpi	r24, 0xFF	; 255
    149c:	b9 f4       	brne	.+46     	; 0x14cc <xQueueGenericSendFromISR+0x94>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    149e:	8a 81       	ldd	r24, Y+2	; 0x02
    14a0:	9b 81       	ldd	r25, Y+3	; 0x03
    14a2:	fc 01       	movw	r30, r24
    14a4:	81 89       	ldd	r24, Z+17	; 0x11
    14a6:	88 23       	and	r24, r24
    14a8:	c1 f0       	breq	.+48     	; 0x14da <xQueueGenericSendFromISR+0xa2>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    14aa:	8a 81       	ldd	r24, Y+2	; 0x02
    14ac:	9b 81       	ldd	r25, Y+3	; 0x03
    14ae:	41 96       	adiw	r24, 0x11	; 17
    14b0:	0e 94 02 16 	call	0x2c04	; 0x2c04 <xTaskRemoveFromEventList>
    14b4:	88 23       	and	r24, r24
    14b6:	89 f0       	breq	.+34     	; 0x14da <xQueueGenericSendFromISR+0xa2>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    14b8:	8a 85       	ldd	r24, Y+10	; 0x0a
    14ba:	9b 85       	ldd	r25, Y+11	; 0x0b
    14bc:	89 2b       	or	r24, r25
    14be:	69 f0       	breq	.+26     	; 0x14da <xQueueGenericSendFromISR+0xa2>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    14c0:	8a 85       	ldd	r24, Y+10	; 0x0a
    14c2:	9b 85       	ldd	r25, Y+11	; 0x0b
    14c4:	21 e0       	ldi	r18, 0x01	; 1
    14c6:	fc 01       	movw	r30, r24
    14c8:	20 83       	st	Z, r18
    14ca:	07 c0       	rjmp	.+14     	; 0x14da <xQueueGenericSendFromISR+0xa2>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    14cc:	8d 81       	ldd	r24, Y+5	; 0x05
    14ce:	8f 5f       	subi	r24, 0xFF	; 255
    14d0:	28 2f       	mov	r18, r24
    14d2:	8a 81       	ldd	r24, Y+2	; 0x02
    14d4:	9b 81       	ldd	r25, Y+3	; 0x03
    14d6:	fc 01       	movw	r30, r24
    14d8:	26 8f       	std	Z+30, r18	; 0x1e
			}

			xReturn = pdPASS;
    14da:	81 e0       	ldi	r24, 0x01	; 1
    14dc:	89 83       	std	Y+1, r24	; 0x01
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
		{
    14de:	01 c0       	rjmp	.+2      	; 0x14e2 <xQueueGenericSendFromISR+0xaa>
			xReturn = pdPASS;
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    14e0:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    14e2:	89 81       	ldd	r24, Y+1	; 0x01
}
    14e4:	2c 96       	adiw	r28, 0x0c	; 12
    14e6:	0f b6       	in	r0, 0x3f	; 63
    14e8:	f8 94       	cli
    14ea:	de bf       	out	0x3e, r29	; 62
    14ec:	0f be       	out	0x3f, r0	; 63
    14ee:	cd bf       	out	0x3d, r28	; 61
    14f0:	df 91       	pop	r29
    14f2:	cf 91       	pop	r28
    14f4:	08 95       	ret

000014f6 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    14f6:	cf 93       	push	r28
    14f8:	df 93       	push	r29
    14fa:	cd b7       	in	r28, 0x3d	; 61
    14fc:	de b7       	in	r29, 0x3e	; 62
    14fe:	2a 97       	sbiw	r28, 0x0a	; 10
    1500:	0f b6       	in	r0, 0x3f	; 63
    1502:	f8 94       	cli
    1504:	de bf       	out	0x3e, r29	; 62
    1506:	0f be       	out	0x3f, r0	; 63
    1508:	cd bf       	out	0x3d, r28	; 61
    150a:	98 87       	std	Y+8, r25	; 0x08
    150c:	8f 83       	std	Y+7, r24	; 0x07
    150e:	7a 87       	std	Y+10, r23	; 0x0a
    1510:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    1512:	8f 81       	ldd	r24, Y+7	; 0x07
    1514:	98 85       	ldd	r25, Y+8	; 0x08
    1516:	9b 83       	std	Y+3, r25	; 0x03
    1518:	8a 83       	std	Y+2, r24	; 0x02
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    151a:	1c 82       	std	Y+4, r1	; 0x04
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    151c:	8a 81       	ldd	r24, Y+2	; 0x02
    151e:	9b 81       	ldd	r25, Y+3	; 0x03
    1520:	fc 01       	movw	r30, r24
    1522:	82 8d       	ldd	r24, Z+26	; 0x1a
    1524:	8d 83       	std	Y+5, r24	; 0x05

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    1526:	8a 81       	ldd	r24, Y+2	; 0x02
    1528:	9b 81       	ldd	r25, Y+3	; 0x03
    152a:	fc 01       	movw	r30, r24
    152c:	93 8d       	ldd	r25, Z+27	; 0x1b
    152e:	8d 81       	ldd	r24, Y+5	; 0x05
    1530:	89 17       	cp	r24, r25
    1532:	80 f5       	brcc	.+96     	; 0x1594 <xQueueGiveFromISR+0x9e>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    1534:	8a 81       	ldd	r24, Y+2	; 0x02
    1536:	9b 81       	ldd	r25, Y+3	; 0x03
    1538:	fc 01       	movw	r30, r24
    153a:	86 8d       	ldd	r24, Z+30	; 0x1e
    153c:	8e 83       	std	Y+6, r24	; 0x06
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
    153e:	8d 81       	ldd	r24, Y+5	; 0x05
    1540:	21 e0       	ldi	r18, 0x01	; 1
    1542:	28 0f       	add	r18, r24
    1544:	8a 81       	ldd	r24, Y+2	; 0x02
    1546:	9b 81       	ldd	r25, Y+3	; 0x03
    1548:	fc 01       	movw	r30, r24
    154a:	22 8f       	std	Z+26, r18	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    154c:	8e 81       	ldd	r24, Y+6	; 0x06
    154e:	8f 3f       	cpi	r24, 0xFF	; 255
    1550:	b9 f4       	brne	.+46     	; 0x1580 <xQueueGiveFromISR+0x8a>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1552:	8a 81       	ldd	r24, Y+2	; 0x02
    1554:	9b 81       	ldd	r25, Y+3	; 0x03
    1556:	fc 01       	movw	r30, r24
    1558:	81 89       	ldd	r24, Z+17	; 0x11
    155a:	88 23       	and	r24, r24
    155c:	c1 f0       	breq	.+48     	; 0x158e <xQueueGiveFromISR+0x98>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    155e:	8a 81       	ldd	r24, Y+2	; 0x02
    1560:	9b 81       	ldd	r25, Y+3	; 0x03
    1562:	41 96       	adiw	r24, 0x11	; 17
    1564:	0e 94 02 16 	call	0x2c04	; 0x2c04 <xTaskRemoveFromEventList>
    1568:	88 23       	and	r24, r24
    156a:	89 f0       	breq	.+34     	; 0x158e <xQueueGiveFromISR+0x98>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    156c:	89 85       	ldd	r24, Y+9	; 0x09
    156e:	9a 85       	ldd	r25, Y+10	; 0x0a
    1570:	89 2b       	or	r24, r25
    1572:	69 f0       	breq	.+26     	; 0x158e <xQueueGiveFromISR+0x98>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1574:	89 85       	ldd	r24, Y+9	; 0x09
    1576:	9a 85       	ldd	r25, Y+10	; 0x0a
    1578:	21 e0       	ldi	r18, 0x01	; 1
    157a:	fc 01       	movw	r30, r24
    157c:	20 83       	st	Z, r18
    157e:	07 c0       	rjmp	.+14     	; 0x158e <xQueueGiveFromISR+0x98>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    1580:	8e 81       	ldd	r24, Y+6	; 0x06
    1582:	8f 5f       	subi	r24, 0xFF	; 255
    1584:	28 2f       	mov	r18, r24
    1586:	8a 81       	ldd	r24, Y+2	; 0x02
    1588:	9b 81       	ldd	r25, Y+3	; 0x03
    158a:	fc 01       	movw	r30, r24
    158c:	26 8f       	std	Z+30, r18	; 0x1e
			}

			xReturn = pdPASS;
    158e:	81 e0       	ldi	r24, 0x01	; 1
    1590:	89 83       	std	Y+1, r24	; 0x01
    1592:	01 c0       	rjmp	.+2      	; 0x1596 <xQueueGiveFromISR+0xa0>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1594:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1596:	89 81       	ldd	r24, Y+1	; 0x01
}
    1598:	2a 96       	adiw	r28, 0x0a	; 10
    159a:	0f b6       	in	r0, 0x3f	; 63
    159c:	f8 94       	cli
    159e:	de bf       	out	0x3e, r29	; 62
    15a0:	0f be       	out	0x3f, r0	; 63
    15a2:	cd bf       	out	0x3d, r28	; 61
    15a4:	df 91       	pop	r29
    15a6:	cf 91       	pop	r28
    15a8:	08 95       	ret

000015aa <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    15aa:	cf 93       	push	r28
    15ac:	df 93       	push	r29
    15ae:	cd b7       	in	r28, 0x3d	; 61
    15b0:	de b7       	in	r29, 0x3e	; 62
    15b2:	60 97       	sbiw	r28, 0x10	; 16
    15b4:	0f b6       	in	r0, 0x3f	; 63
    15b6:	f8 94       	cli
    15b8:	de bf       	out	0x3e, r29	; 62
    15ba:	0f be       	out	0x3f, r0	; 63
    15bc:	cd bf       	out	0x3d, r28	; 61
    15be:	9b 87       	std	Y+11, r25	; 0x0b
    15c0:	8a 87       	std	Y+10, r24	; 0x0a
    15c2:	7d 87       	std	Y+13, r23	; 0x0d
    15c4:	6c 87       	std	Y+12, r22	; 0x0c
    15c6:	5f 87       	std	Y+15, r21	; 0x0f
    15c8:	4e 87       	std	Y+14, r20	; 0x0e
    15ca:	28 8b       	std	Y+16, r18	; 0x10
BaseType_t xEntryTimeSet = pdFALSE;
    15cc:	19 82       	std	Y+1, r1	; 0x01
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    15ce:	8a 85       	ldd	r24, Y+10	; 0x0a
    15d0:	9b 85       	ldd	r25, Y+11	; 0x0b
    15d2:	9b 83       	std	Y+3, r25	; 0x03
    15d4:	8a 83       	std	Y+2, r24	; 0x02
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    15d6:	0f b6       	in	r0, 0x3f	; 63
    15d8:	f8 94       	cli
    15da:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    15dc:	8a 81       	ldd	r24, Y+2	; 0x02
    15de:	9b 81       	ldd	r25, Y+3	; 0x03
    15e0:	fc 01       	movw	r30, r24
    15e2:	82 8d       	ldd	r24, Z+26	; 0x1a
    15e4:	8c 83       	std	Y+4, r24	; 0x04

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    15e6:	8c 81       	ldd	r24, Y+4	; 0x04
    15e8:	88 23       	and	r24, r24
    15ea:	09 f4       	brne	.+2      	; 0x15ee <xQueueGenericReceive+0x44>
    15ec:	42 c0       	rjmp	.+132    	; 0x1672 <xQueueGenericReceive+0xc8>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    15ee:	8a 81       	ldd	r24, Y+2	; 0x02
    15f0:	9b 81       	ldd	r25, Y+3	; 0x03
    15f2:	fc 01       	movw	r30, r24
    15f4:	86 81       	ldd	r24, Z+6	; 0x06
    15f6:	97 81       	ldd	r25, Z+7	; 0x07
    15f8:	9e 83       	std	Y+6, r25	; 0x06
    15fa:	8d 83       	std	Y+5, r24	; 0x05

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    15fc:	2c 85       	ldd	r18, Y+12	; 0x0c
    15fe:	3d 85       	ldd	r19, Y+13	; 0x0d
    1600:	8a 81       	ldd	r24, Y+2	; 0x02
    1602:	9b 81       	ldd	r25, Y+3	; 0x03
    1604:	b9 01       	movw	r22, r18
    1606:	0e 94 6b 0d 	call	0x1ad6	; 0x1ad6 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    160a:	88 89       	ldd	r24, Y+16	; 0x10
    160c:	88 23       	and	r24, r24
    160e:	b9 f4       	brne	.+46     	; 0x163e <xQueueGenericReceive+0x94>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
    1610:	8c 81       	ldd	r24, Y+4	; 0x04
    1612:	2f ef       	ldi	r18, 0xFF	; 255
    1614:	28 0f       	add	r18, r24
    1616:	8a 81       	ldd	r24, Y+2	; 0x02
    1618:	9b 81       	ldd	r25, Y+3	; 0x03
    161a:	fc 01       	movw	r30, r24
    161c:	22 8f       	std	Z+26, r18	; 0x1a
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    161e:	8a 81       	ldd	r24, Y+2	; 0x02
    1620:	9b 81       	ldd	r25, Y+3	; 0x03
    1622:	fc 01       	movw	r30, r24
    1624:	80 85       	ldd	r24, Z+8	; 0x08
    1626:	88 23       	and	r24, r24
    1628:	01 f1       	breq	.+64     	; 0x166a <xQueueGenericReceive+0xc0>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    162a:	8a 81       	ldd	r24, Y+2	; 0x02
    162c:	9b 81       	ldd	r25, Y+3	; 0x03
    162e:	08 96       	adiw	r24, 0x08	; 8
    1630:	0e 94 02 16 	call	0x2c04	; 0x2c04 <xTaskRemoveFromEventList>
    1634:	88 23       	and	r24, r24
    1636:	c9 f0       	breq	.+50     	; 0x166a <xQueueGenericReceive+0xc0>
						{
							queueYIELD_IF_USING_PREEMPTION();
    1638:	0e 94 ae 06 	call	0xd5c	; 0xd5c <vPortYield>
    163c:	16 c0       	rjmp	.+44     	; 0x166a <xQueueGenericReceive+0xc0>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    163e:	8a 81       	ldd	r24, Y+2	; 0x02
    1640:	9b 81       	ldd	r25, Y+3	; 0x03
    1642:	2d 81       	ldd	r18, Y+5	; 0x05
    1644:	3e 81       	ldd	r19, Y+6	; 0x06
    1646:	fc 01       	movw	r30, r24
    1648:	37 83       	std	Z+7, r19	; 0x07
    164a:	26 83       	std	Z+6, r18	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    164c:	8a 81       	ldd	r24, Y+2	; 0x02
    164e:	9b 81       	ldd	r25, Y+3	; 0x03
    1650:	fc 01       	movw	r30, r24
    1652:	81 89       	ldd	r24, Z+17	; 0x11
    1654:	88 23       	and	r24, r24
    1656:	49 f0       	breq	.+18     	; 0x166a <xQueueGenericReceive+0xc0>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1658:	8a 81       	ldd	r24, Y+2	; 0x02
    165a:	9b 81       	ldd	r25, Y+3	; 0x03
    165c:	41 96       	adiw	r24, 0x11	; 17
    165e:	0e 94 02 16 	call	0x2c04	; 0x2c04 <xTaskRemoveFromEventList>
    1662:	88 23       	and	r24, r24
    1664:	11 f0       	breq	.+4      	; 0x166a <xQueueGenericReceive+0xc0>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    1666:	0e 94 ae 06 	call	0xd5c	; 0xd5c <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    166a:	0f 90       	pop	r0
    166c:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    166e:	81 e0       	ldi	r24, 0x01	; 1
    1670:	67 c0       	rjmp	.+206    	; 0x1740 <xQueueGenericReceive+0x196>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1672:	8e 85       	ldd	r24, Y+14	; 0x0e
    1674:	9f 85       	ldd	r25, Y+15	; 0x0f
    1676:	89 2b       	or	r24, r25
    1678:	21 f4       	brne	.+8      	; 0x1682 <xQueueGenericReceive+0xd8>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    167a:	0f 90       	pop	r0
    167c:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    167e:	80 e0       	ldi	r24, 0x00	; 0
    1680:	5f c0       	rjmp	.+190    	; 0x1740 <xQueueGenericReceive+0x196>
				}
				else if( xEntryTimeSet == pdFALSE )
    1682:	89 81       	ldd	r24, Y+1	; 0x01
    1684:	88 23       	and	r24, r24
    1686:	31 f4       	brne	.+12     	; 0x1694 <xQueueGenericReceive+0xea>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1688:	ce 01       	movw	r24, r28
    168a:	07 96       	adiw	r24, 0x07	; 7
    168c:	0e 94 da 16 	call	0x2db4	; 0x2db4 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1690:	81 e0       	ldi	r24, 0x01	; 1
    1692:	89 83       	std	Y+1, r24	; 0x01
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1694:	0f 90       	pop	r0
    1696:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1698:	0e 94 54 13 	call	0x26a8	; 0x26a8 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    169c:	0f b6       	in	r0, 0x3f	; 63
    169e:	f8 94       	cli
    16a0:	0f 92       	push	r0
    16a2:	8a 81       	ldd	r24, Y+2	; 0x02
    16a4:	9b 81       	ldd	r25, Y+3	; 0x03
    16a6:	fc 01       	movw	r30, r24
    16a8:	85 8d       	ldd	r24, Z+29	; 0x1d
    16aa:	8f 3f       	cpi	r24, 0xFF	; 255
    16ac:	21 f4       	brne	.+8      	; 0x16b6 <xQueueGenericReceive+0x10c>
    16ae:	8a 81       	ldd	r24, Y+2	; 0x02
    16b0:	9b 81       	ldd	r25, Y+3	; 0x03
    16b2:	fc 01       	movw	r30, r24
    16b4:	15 8e       	std	Z+29, r1	; 0x1d
    16b6:	8a 81       	ldd	r24, Y+2	; 0x02
    16b8:	9b 81       	ldd	r25, Y+3	; 0x03
    16ba:	fc 01       	movw	r30, r24
    16bc:	86 8d       	ldd	r24, Z+30	; 0x1e
    16be:	8f 3f       	cpi	r24, 0xFF	; 255
    16c0:	21 f4       	brne	.+8      	; 0x16ca <xQueueGenericReceive+0x120>
    16c2:	8a 81       	ldd	r24, Y+2	; 0x02
    16c4:	9b 81       	ldd	r25, Y+3	; 0x03
    16c6:	fc 01       	movw	r30, r24
    16c8:	16 8e       	std	Z+30, r1	; 0x1e
    16ca:	0f 90       	pop	r0
    16cc:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    16ce:	9e 01       	movw	r18, r28
    16d0:	22 5f       	subi	r18, 0xF2	; 242
    16d2:	3f 4f       	sbci	r19, 0xFF	; 255
    16d4:	ce 01       	movw	r24, r28
    16d6:	07 96       	adiw	r24, 0x07	; 7
    16d8:	b9 01       	movw	r22, r18
    16da:	0e 94 f6 16 	call	0x2dec	; 0x2dec <xTaskCheckForTimeOut>
    16de:	88 23       	and	r24, r24
    16e0:	09 f5       	brne	.+66     	; 0x1724 <xQueueGenericReceive+0x17a>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    16e2:	8a 81       	ldd	r24, Y+2	; 0x02
    16e4:	9b 81       	ldd	r25, Y+3	; 0x03
    16e6:	0e 94 1a 0e 	call	0x1c34	; 0x1c34 <prvIsQueueEmpty>
    16ea:	88 23       	and	r24, r24
    16ec:	a1 f0       	breq	.+40     	; 0x1716 <xQueueGenericReceive+0x16c>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    16ee:	2e 85       	ldd	r18, Y+14	; 0x0e
    16f0:	3f 85       	ldd	r19, Y+15	; 0x0f
    16f2:	8a 81       	ldd	r24, Y+2	; 0x02
    16f4:	9b 81       	ldd	r25, Y+3	; 0x03
    16f6:	41 96       	adiw	r24, 0x11	; 17
    16f8:	b9 01       	movw	r22, r18
    16fa:	0e 94 ad 15 	call	0x2b5a	; 0x2b5a <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    16fe:	8a 81       	ldd	r24, Y+2	; 0x02
    1700:	9b 81       	ldd	r25, Y+3	; 0x03
    1702:	0e 94 bc 0d 	call	0x1b78	; 0x1b78 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1706:	0e 94 61 13 	call	0x26c2	; 0x26c2 <xTaskResumeAll>
    170a:	88 23       	and	r24, r24
    170c:	09 f0       	breq	.+2      	; 0x1710 <xQueueGenericReceive+0x166>
    170e:	63 cf       	rjmp	.-314    	; 0x15d6 <xQueueGenericReceive+0x2c>
				{
					portYIELD_WITHIN_API();
    1710:	0e 94 ae 06 	call	0xd5c	; 0xd5c <vPortYield>
    1714:	60 cf       	rjmp	.-320    	; 0x15d6 <xQueueGenericReceive+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1716:	8a 81       	ldd	r24, Y+2	; 0x02
    1718:	9b 81       	ldd	r25, Y+3	; 0x03
    171a:	0e 94 bc 0d 	call	0x1b78	; 0x1b78 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    171e:	0e 94 61 13 	call	0x26c2	; 0x26c2 <xTaskResumeAll>
    1722:	59 cf       	rjmp	.-334    	; 0x15d6 <xQueueGenericReceive+0x2c>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1724:	8a 81       	ldd	r24, Y+2	; 0x02
    1726:	9b 81       	ldd	r25, Y+3	; 0x03
    1728:	0e 94 bc 0d 	call	0x1b78	; 0x1b78 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    172c:	0e 94 61 13 	call	0x26c2	; 0x26c2 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1730:	8a 81       	ldd	r24, Y+2	; 0x02
    1732:	9b 81       	ldd	r25, Y+3	; 0x03
    1734:	0e 94 1a 0e 	call	0x1c34	; 0x1c34 <prvIsQueueEmpty>
    1738:	88 23       	and	r24, r24
    173a:	09 f4       	brne	.+2      	; 0x173e <xQueueGenericReceive+0x194>
    173c:	4c cf       	rjmp	.-360    	; 0x15d6 <xQueueGenericReceive+0x2c>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    173e:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
    1740:	60 96       	adiw	r28, 0x10	; 16
    1742:	0f b6       	in	r0, 0x3f	; 63
    1744:	f8 94       	cli
    1746:	de bf       	out	0x3e, r29	; 62
    1748:	0f be       	out	0x3f, r0	; 63
    174a:	cd bf       	out	0x3d, r28	; 61
    174c:	df 91       	pop	r29
    174e:	cf 91       	pop	r28
    1750:	08 95       	ret

00001752 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1752:	cf 93       	push	r28
    1754:	df 93       	push	r29
    1756:	cd b7       	in	r28, 0x3d	; 61
    1758:	de b7       	in	r29, 0x3e	; 62
    175a:	2c 97       	sbiw	r28, 0x0c	; 12
    175c:	0f b6       	in	r0, 0x3f	; 63
    175e:	f8 94       	cli
    1760:	de bf       	out	0x3e, r29	; 62
    1762:	0f be       	out	0x3f, r0	; 63
    1764:	cd bf       	out	0x3d, r28	; 61
    1766:	98 87       	std	Y+8, r25	; 0x08
    1768:	8f 83       	std	Y+7, r24	; 0x07
    176a:	7a 87       	std	Y+10, r23	; 0x0a
    176c:	69 87       	std	Y+9, r22	; 0x09
    176e:	5c 87       	std	Y+12, r21	; 0x0c
    1770:	4b 87       	std	Y+11, r20	; 0x0b
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    1772:	8f 81       	ldd	r24, Y+7	; 0x07
    1774:	98 85       	ldd	r25, Y+8	; 0x08
    1776:	9b 83       	std	Y+3, r25	; 0x03
    1778:	8a 83       	std	Y+2, r24	; 0x02
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    177a:	1c 82       	std	Y+4, r1	; 0x04
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    177c:	8a 81       	ldd	r24, Y+2	; 0x02
    177e:	9b 81       	ldd	r25, Y+3	; 0x03
    1780:	fc 01       	movw	r30, r24
    1782:	82 8d       	ldd	r24, Z+26	; 0x1a
    1784:	8d 83       	std	Y+5, r24	; 0x05

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1786:	8d 81       	ldd	r24, Y+5	; 0x05
    1788:	88 23       	and	r24, r24
    178a:	b9 f1       	breq	.+110    	; 0x17fa <xQueueReceiveFromISR+0xa8>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    178c:	8a 81       	ldd	r24, Y+2	; 0x02
    178e:	9b 81       	ldd	r25, Y+3	; 0x03
    1790:	fc 01       	movw	r30, r24
    1792:	85 8d       	ldd	r24, Z+29	; 0x1d
    1794:	8e 83       	std	Y+6, r24	; 0x06

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1796:	29 85       	ldd	r18, Y+9	; 0x09
    1798:	3a 85       	ldd	r19, Y+10	; 0x0a
    179a:	8a 81       	ldd	r24, Y+2	; 0x02
    179c:	9b 81       	ldd	r25, Y+3	; 0x03
    179e:	b9 01       	movw	r22, r18
    17a0:	0e 94 6b 0d 	call	0x1ad6	; 0x1ad6 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
    17a4:	8d 81       	ldd	r24, Y+5	; 0x05
    17a6:	2f ef       	ldi	r18, 0xFF	; 255
    17a8:	28 0f       	add	r18, r24
    17aa:	8a 81       	ldd	r24, Y+2	; 0x02
    17ac:	9b 81       	ldd	r25, Y+3	; 0x03
    17ae:	fc 01       	movw	r30, r24
    17b0:	22 8f       	std	Z+26, r18	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    17b2:	8e 81       	ldd	r24, Y+6	; 0x06
    17b4:	8f 3f       	cpi	r24, 0xFF	; 255
    17b6:	b9 f4       	brne	.+46     	; 0x17e6 <xQueueReceiveFromISR+0x94>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    17b8:	8a 81       	ldd	r24, Y+2	; 0x02
    17ba:	9b 81       	ldd	r25, Y+3	; 0x03
    17bc:	fc 01       	movw	r30, r24
    17be:	80 85       	ldd	r24, Z+8	; 0x08
    17c0:	88 23       	and	r24, r24
    17c2:	c1 f0       	breq	.+48     	; 0x17f4 <xQueueReceiveFromISR+0xa2>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    17c4:	8a 81       	ldd	r24, Y+2	; 0x02
    17c6:	9b 81       	ldd	r25, Y+3	; 0x03
    17c8:	08 96       	adiw	r24, 0x08	; 8
    17ca:	0e 94 02 16 	call	0x2c04	; 0x2c04 <xTaskRemoveFromEventList>
    17ce:	88 23       	and	r24, r24
    17d0:	89 f0       	breq	.+34     	; 0x17f4 <xQueueReceiveFromISR+0xa2>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    17d2:	8b 85       	ldd	r24, Y+11	; 0x0b
    17d4:	9c 85       	ldd	r25, Y+12	; 0x0c
    17d6:	89 2b       	or	r24, r25
    17d8:	69 f0       	breq	.+26     	; 0x17f4 <xQueueReceiveFromISR+0xa2>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    17da:	8b 85       	ldd	r24, Y+11	; 0x0b
    17dc:	9c 85       	ldd	r25, Y+12	; 0x0c
    17de:	21 e0       	ldi	r18, 0x01	; 1
    17e0:	fc 01       	movw	r30, r24
    17e2:	20 83       	st	Z, r18
    17e4:	07 c0       	rjmp	.+14     	; 0x17f4 <xQueueReceiveFromISR+0xa2>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    17e6:	8e 81       	ldd	r24, Y+6	; 0x06
    17e8:	8f 5f       	subi	r24, 0xFF	; 255
    17ea:	28 2f       	mov	r18, r24
    17ec:	8a 81       	ldd	r24, Y+2	; 0x02
    17ee:	9b 81       	ldd	r25, Y+3	; 0x03
    17f0:	fc 01       	movw	r30, r24
    17f2:	25 8f       	std	Z+29, r18	; 0x1d
			}

			xReturn = pdPASS;
    17f4:	81 e0       	ldi	r24, 0x01	; 1
    17f6:	89 83       	std	Y+1, r24	; 0x01
    17f8:	01 c0       	rjmp	.+2      	; 0x17fc <xQueueReceiveFromISR+0xaa>
		}
		else
		{
			xReturn = pdFAIL;
    17fa:	19 82       	std	Y+1, r1	; 0x01
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    17fc:	89 81       	ldd	r24, Y+1	; 0x01
}
    17fe:	2c 96       	adiw	r28, 0x0c	; 12
    1800:	0f b6       	in	r0, 0x3f	; 63
    1802:	f8 94       	cli
    1804:	de bf       	out	0x3e, r29	; 62
    1806:	0f be       	out	0x3f, r0	; 63
    1808:	cd bf       	out	0x3d, r28	; 61
    180a:	df 91       	pop	r29
    180c:	cf 91       	pop	r28
    180e:	08 95       	ret

00001810 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    1810:	cf 93       	push	r28
    1812:	df 93       	push	r29
    1814:	cd b7       	in	r28, 0x3d	; 61
    1816:	de b7       	in	r29, 0x3e	; 62
    1818:	2a 97       	sbiw	r28, 0x0a	; 10
    181a:	0f b6       	in	r0, 0x3f	; 63
    181c:	f8 94       	cli
    181e:	de bf       	out	0x3e, r29	; 62
    1820:	0f be       	out	0x3f, r0	; 63
    1822:	cd bf       	out	0x3d, r28	; 61
    1824:	98 87       	std	Y+8, r25	; 0x08
    1826:	8f 83       	std	Y+7, r24	; 0x07
    1828:	7a 87       	std	Y+10, r23	; 0x0a
    182a:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    182c:	8f 81       	ldd	r24, Y+7	; 0x07
    182e:	98 85       	ldd	r25, Y+8	; 0x08
    1830:	9b 83       	std	Y+3, r25	; 0x03
    1832:	8a 83       	std	Y+2, r24	; 0x02
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1834:	1c 82       	std	Y+4, r1	; 0x04
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1836:	8a 81       	ldd	r24, Y+2	; 0x02
    1838:	9b 81       	ldd	r25, Y+3	; 0x03
    183a:	fc 01       	movw	r30, r24
    183c:	82 8d       	ldd	r24, Z+26	; 0x1a
    183e:	88 23       	and	r24, r24
    1840:	c1 f0       	breq	.+48     	; 0x1872 <xQueuePeekFromISR+0x62>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    1842:	8a 81       	ldd	r24, Y+2	; 0x02
    1844:	9b 81       	ldd	r25, Y+3	; 0x03
    1846:	fc 01       	movw	r30, r24
    1848:	86 81       	ldd	r24, Z+6	; 0x06
    184a:	97 81       	ldd	r25, Z+7	; 0x07
    184c:	9e 83       	std	Y+6, r25	; 0x06
    184e:	8d 83       	std	Y+5, r24	; 0x05
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1850:	29 85       	ldd	r18, Y+9	; 0x09
    1852:	3a 85       	ldd	r19, Y+10	; 0x0a
    1854:	8a 81       	ldd	r24, Y+2	; 0x02
    1856:	9b 81       	ldd	r25, Y+3	; 0x03
    1858:	b9 01       	movw	r22, r18
    185a:	0e 94 6b 0d 	call	0x1ad6	; 0x1ad6 <prvCopyDataFromQueue>
			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    185e:	8a 81       	ldd	r24, Y+2	; 0x02
    1860:	9b 81       	ldd	r25, Y+3	; 0x03
    1862:	2d 81       	ldd	r18, Y+5	; 0x05
    1864:	3e 81       	ldd	r19, Y+6	; 0x06
    1866:	fc 01       	movw	r30, r24
    1868:	37 83       	std	Z+7, r19	; 0x07
    186a:	26 83       	std	Z+6, r18	; 0x06

			xReturn = pdPASS;
    186c:	81 e0       	ldi	r24, 0x01	; 1
    186e:	89 83       	std	Y+1, r24	; 0x01
    1870:	01 c0       	rjmp	.+2      	; 0x1874 <xQueuePeekFromISR+0x64>
		}
		else
		{
			xReturn = pdFAIL;
    1872:	19 82       	std	Y+1, r1	; 0x01
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1874:	89 81       	ldd	r24, Y+1	; 0x01
}
    1876:	2a 96       	adiw	r28, 0x0a	; 10
    1878:	0f b6       	in	r0, 0x3f	; 63
    187a:	f8 94       	cli
    187c:	de bf       	out	0x3e, r29	; 62
    187e:	0f be       	out	0x3f, r0	; 63
    1880:	cd bf       	out	0x3d, r28	; 61
    1882:	df 91       	pop	r29
    1884:	cf 91       	pop	r28
    1886:	08 95       	ret

00001888 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    1888:	cf 93       	push	r28
    188a:	df 93       	push	r29
    188c:	00 d0       	rcall	.+0      	; 0x188e <uxQueueMessagesWaiting+0x6>
    188e:	1f 92       	push	r1
    1890:	cd b7       	in	r28, 0x3d	; 61
    1892:	de b7       	in	r29, 0x3e	; 62
    1894:	9b 83       	std	Y+3, r25	; 0x03
    1896:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    1898:	0f b6       	in	r0, 0x3f	; 63
    189a:	f8 94       	cli
    189c:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    189e:	8a 81       	ldd	r24, Y+2	; 0x02
    18a0:	9b 81       	ldd	r25, Y+3	; 0x03
    18a2:	fc 01       	movw	r30, r24
    18a4:	82 8d       	ldd	r24, Z+26	; 0x1a
    18a6:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    18a8:	0f 90       	pop	r0
    18aa:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    18ac:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    18ae:	0f 90       	pop	r0
    18b0:	0f 90       	pop	r0
    18b2:	0f 90       	pop	r0
    18b4:	df 91       	pop	r29
    18b6:	cf 91       	pop	r28
    18b8:	08 95       	ret

000018ba <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    18ba:	cf 93       	push	r28
    18bc:	df 93       	push	r29
    18be:	00 d0       	rcall	.+0      	; 0x18c0 <uxQueueSpacesAvailable+0x6>
    18c0:	00 d0       	rcall	.+0      	; 0x18c2 <uxQueueSpacesAvailable+0x8>
    18c2:	1f 92       	push	r1
    18c4:	cd b7       	in	r28, 0x3d	; 61
    18c6:	de b7       	in	r29, 0x3e	; 62
    18c8:	9d 83       	std	Y+5, r25	; 0x05
    18ca:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t *pxQueue;

	pxQueue = ( Queue_t * ) xQueue;
    18cc:	8c 81       	ldd	r24, Y+4	; 0x04
    18ce:	9d 81       	ldd	r25, Y+5	; 0x05
    18d0:	9a 83       	std	Y+2, r25	; 0x02
    18d2:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    18d4:	0f b6       	in	r0, 0x3f	; 63
    18d6:	f8 94       	cli
    18d8:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    18da:	89 81       	ldd	r24, Y+1	; 0x01
    18dc:	9a 81       	ldd	r25, Y+2	; 0x02
    18de:	fc 01       	movw	r30, r24
    18e0:	23 8d       	ldd	r18, Z+27	; 0x1b
    18e2:	89 81       	ldd	r24, Y+1	; 0x01
    18e4:	9a 81       	ldd	r25, Y+2	; 0x02
    18e6:	fc 01       	movw	r30, r24
    18e8:	82 8d       	ldd	r24, Z+26	; 0x1a
    18ea:	f2 2f       	mov	r31, r18
    18ec:	f8 1b       	sub	r31, r24
    18ee:	8f 2f       	mov	r24, r31
    18f0:	8b 83       	std	Y+3, r24	; 0x03
	}
	taskEXIT_CRITICAL();
    18f2:	0f 90       	pop	r0
    18f4:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    18f6:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    18f8:	0f 90       	pop	r0
    18fa:	0f 90       	pop	r0
    18fc:	0f 90       	pop	r0
    18fe:	0f 90       	pop	r0
    1900:	0f 90       	pop	r0
    1902:	df 91       	pop	r29
    1904:	cf 91       	pop	r28
    1906:	08 95       	ret

00001908 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    1908:	cf 93       	push	r28
    190a:	df 93       	push	r29
    190c:	00 d0       	rcall	.+0      	; 0x190e <uxQueueMessagesWaitingFromISR+0x6>
    190e:	1f 92       	push	r1
    1910:	cd b7       	in	r28, 0x3d	; 61
    1912:	de b7       	in	r29, 0x3e	; 62
    1914:	9b 83       	std	Y+3, r25	; 0x03
    1916:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    1918:	8a 81       	ldd	r24, Y+2	; 0x02
    191a:	9b 81       	ldd	r25, Y+3	; 0x03
    191c:	fc 01       	movw	r30, r24
    191e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1920:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    1922:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1924:	0f 90       	pop	r0
    1926:	0f 90       	pop	r0
    1928:	0f 90       	pop	r0
    192a:	df 91       	pop	r29
    192c:	cf 91       	pop	r28
    192e:	08 95       	ret

00001930 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    1930:	cf 93       	push	r28
    1932:	df 93       	push	r29
    1934:	00 d0       	rcall	.+0      	; 0x1936 <vQueueDelete+0x6>
    1936:	00 d0       	rcall	.+0      	; 0x1938 <vQueueDelete+0x8>
    1938:	cd b7       	in	r28, 0x3d	; 61
    193a:	de b7       	in	r29, 0x3e	; 62
    193c:	9c 83       	std	Y+4, r25	; 0x04
    193e:	8b 83       	std	Y+3, r24	; 0x03
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    1940:	8b 81       	ldd	r24, Y+3	; 0x03
    1942:	9c 81       	ldd	r25, Y+4	; 0x04
    1944:	9a 83       	std	Y+2, r25	; 0x02
    1946:	89 83       	std	Y+1, r24	; 0x01

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    1948:	89 81       	ldd	r24, Y+1	; 0x01
    194a:	9a 81       	ldd	r25, Y+2	; 0x02
    194c:	0e 94 21 08 	call	0x1042	; 0x1042 <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    1950:	00 00       	nop
    1952:	0f 90       	pop	r0
    1954:	0f 90       	pop	r0
    1956:	0f 90       	pop	r0
    1958:	0f 90       	pop	r0
    195a:	df 91       	pop	r29
    195c:	cf 91       	pop	r28
    195e:	08 95       	ret

00001960 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    1960:	cf 93       	push	r28
    1962:	df 93       	push	r29
    1964:	cd b7       	in	r28, 0x3d	; 61
    1966:	de b7       	in	r29, 0x3e	; 62
    1968:	27 97       	sbiw	r28, 0x07	; 7
    196a:	0f b6       	in	r0, 0x3f	; 63
    196c:	f8 94       	cli
    196e:	de bf       	out	0x3e, r29	; 62
    1970:	0f be       	out	0x3f, r0	; 63
    1972:	cd bf       	out	0x3d, r28	; 61
    1974:	9c 83       	std	Y+4, r25	; 0x04
    1976:	8b 83       	std	Y+3, r24	; 0x03
    1978:	7e 83       	std	Y+6, r23	; 0x06
    197a:	6d 83       	std	Y+5, r22	; 0x05
    197c:	4f 83       	std	Y+7, r20	; 0x07
BaseType_t xReturn = pdFALSE;
    197e:	1a 82       	std	Y+2, r1	; 0x02
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1980:	8b 81       	ldd	r24, Y+3	; 0x03
    1982:	9c 81       	ldd	r25, Y+4	; 0x04
    1984:	fc 01       	movw	r30, r24
    1986:	82 8d       	ldd	r24, Z+26	; 0x1a
    1988:	89 83       	std	Y+1, r24	; 0x01

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    198a:	8b 81       	ldd	r24, Y+3	; 0x03
    198c:	9c 81       	ldd	r25, Y+4	; 0x04
    198e:	fc 01       	movw	r30, r24
    1990:	84 8d       	ldd	r24, Z+28	; 0x1c
    1992:	88 23       	and	r24, r24
    1994:	09 f4       	brne	.+2      	; 0x1998 <prvCopyDataToQueue+0x38>
    1996:	8e c0       	rjmp	.+284    	; 0x1ab4 <prvCopyDataToQueue+0x154>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    1998:	8f 81       	ldd	r24, Y+7	; 0x07
    199a:	88 23       	and	r24, r24
    199c:	d9 f5       	brne	.+118    	; 0x1a14 <prvCopyDataToQueue+0xb4>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    199e:	8b 81       	ldd	r24, Y+3	; 0x03
    19a0:	9c 81       	ldd	r25, Y+4	; 0x04
    19a2:	fc 01       	movw	r30, r24
    19a4:	84 8d       	ldd	r24, Z+28	; 0x1c
    19a6:	48 2f       	mov	r20, r24
    19a8:	50 e0       	ldi	r21, 0x00	; 0
    19aa:	8b 81       	ldd	r24, Y+3	; 0x03
    19ac:	9c 81       	ldd	r25, Y+4	; 0x04
    19ae:	fc 01       	movw	r30, r24
    19b0:	84 81       	ldd	r24, Z+4	; 0x04
    19b2:	95 81       	ldd	r25, Z+5	; 0x05
    19b4:	2d 81       	ldd	r18, Y+5	; 0x05
    19b6:	3e 81       	ldd	r19, Y+6	; 0x06
    19b8:	b9 01       	movw	r22, r18
    19ba:	0e 94 1e 1e 	call	0x3c3c	; 0x3c3c <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    19be:	8b 81       	ldd	r24, Y+3	; 0x03
    19c0:	9c 81       	ldd	r25, Y+4	; 0x04
    19c2:	fc 01       	movw	r30, r24
    19c4:	24 81       	ldd	r18, Z+4	; 0x04
    19c6:	35 81       	ldd	r19, Z+5	; 0x05
    19c8:	8b 81       	ldd	r24, Y+3	; 0x03
    19ca:	9c 81       	ldd	r25, Y+4	; 0x04
    19cc:	fc 01       	movw	r30, r24
    19ce:	84 8d       	ldd	r24, Z+28	; 0x1c
    19d0:	88 2f       	mov	r24, r24
    19d2:	90 e0       	ldi	r25, 0x00	; 0
    19d4:	28 0f       	add	r18, r24
    19d6:	39 1f       	adc	r19, r25
    19d8:	8b 81       	ldd	r24, Y+3	; 0x03
    19da:	9c 81       	ldd	r25, Y+4	; 0x04
    19dc:	fc 01       	movw	r30, r24
    19de:	35 83       	std	Z+5, r19	; 0x05
    19e0:	24 83       	std	Z+4, r18	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    19e2:	8b 81       	ldd	r24, Y+3	; 0x03
    19e4:	9c 81       	ldd	r25, Y+4	; 0x04
    19e6:	fc 01       	movw	r30, r24
    19e8:	24 81       	ldd	r18, Z+4	; 0x04
    19ea:	35 81       	ldd	r19, Z+5	; 0x05
    19ec:	8b 81       	ldd	r24, Y+3	; 0x03
    19ee:	9c 81       	ldd	r25, Y+4	; 0x04
    19f0:	fc 01       	movw	r30, r24
    19f2:	82 81       	ldd	r24, Z+2	; 0x02
    19f4:	93 81       	ldd	r25, Z+3	; 0x03
    19f6:	28 17       	cp	r18, r24
    19f8:	39 07       	cpc	r19, r25
    19fa:	08 f4       	brcc	.+2      	; 0x19fe <prvCopyDataToQueue+0x9e>
    19fc:	5b c0       	rjmp	.+182    	; 0x1ab4 <prvCopyDataToQueue+0x154>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    19fe:	8b 81       	ldd	r24, Y+3	; 0x03
    1a00:	9c 81       	ldd	r25, Y+4	; 0x04
    1a02:	fc 01       	movw	r30, r24
    1a04:	20 81       	ld	r18, Z
    1a06:	31 81       	ldd	r19, Z+1	; 0x01
    1a08:	8b 81       	ldd	r24, Y+3	; 0x03
    1a0a:	9c 81       	ldd	r25, Y+4	; 0x04
    1a0c:	fc 01       	movw	r30, r24
    1a0e:	35 83       	std	Z+5, r19	; 0x05
    1a10:	24 83       	std	Z+4, r18	; 0x04
    1a12:	50 c0       	rjmp	.+160    	; 0x1ab4 <prvCopyDataToQueue+0x154>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1a14:	8b 81       	ldd	r24, Y+3	; 0x03
    1a16:	9c 81       	ldd	r25, Y+4	; 0x04
    1a18:	fc 01       	movw	r30, r24
    1a1a:	84 8d       	ldd	r24, Z+28	; 0x1c
    1a1c:	48 2f       	mov	r20, r24
    1a1e:	50 e0       	ldi	r21, 0x00	; 0
    1a20:	8b 81       	ldd	r24, Y+3	; 0x03
    1a22:	9c 81       	ldd	r25, Y+4	; 0x04
    1a24:	fc 01       	movw	r30, r24
    1a26:	86 81       	ldd	r24, Z+6	; 0x06
    1a28:	97 81       	ldd	r25, Z+7	; 0x07
    1a2a:	2d 81       	ldd	r18, Y+5	; 0x05
    1a2c:	3e 81       	ldd	r19, Y+6	; 0x06
    1a2e:	b9 01       	movw	r22, r18
    1a30:	0e 94 1e 1e 	call	0x3c3c	; 0x3c3c <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    1a34:	8b 81       	ldd	r24, Y+3	; 0x03
    1a36:	9c 81       	ldd	r25, Y+4	; 0x04
    1a38:	fc 01       	movw	r30, r24
    1a3a:	26 81       	ldd	r18, Z+6	; 0x06
    1a3c:	37 81       	ldd	r19, Z+7	; 0x07
    1a3e:	8b 81       	ldd	r24, Y+3	; 0x03
    1a40:	9c 81       	ldd	r25, Y+4	; 0x04
    1a42:	fc 01       	movw	r30, r24
    1a44:	84 8d       	ldd	r24, Z+28	; 0x1c
    1a46:	88 2f       	mov	r24, r24
    1a48:	90 e0       	ldi	r25, 0x00	; 0
    1a4a:	91 95       	neg	r25
    1a4c:	81 95       	neg	r24
    1a4e:	91 09       	sbc	r25, r1
    1a50:	28 0f       	add	r18, r24
    1a52:	39 1f       	adc	r19, r25
    1a54:	8b 81       	ldd	r24, Y+3	; 0x03
    1a56:	9c 81       	ldd	r25, Y+4	; 0x04
    1a58:	fc 01       	movw	r30, r24
    1a5a:	37 83       	std	Z+7, r19	; 0x07
    1a5c:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1a5e:	8b 81       	ldd	r24, Y+3	; 0x03
    1a60:	9c 81       	ldd	r25, Y+4	; 0x04
    1a62:	fc 01       	movw	r30, r24
    1a64:	26 81       	ldd	r18, Z+6	; 0x06
    1a66:	37 81       	ldd	r19, Z+7	; 0x07
    1a68:	8b 81       	ldd	r24, Y+3	; 0x03
    1a6a:	9c 81       	ldd	r25, Y+4	; 0x04
    1a6c:	fc 01       	movw	r30, r24
    1a6e:	80 81       	ld	r24, Z
    1a70:	91 81       	ldd	r25, Z+1	; 0x01
    1a72:	28 17       	cp	r18, r24
    1a74:	39 07       	cpc	r19, r25
    1a76:	a8 f4       	brcc	.+42     	; 0x1aa2 <prvCopyDataToQueue+0x142>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    1a78:	8b 81       	ldd	r24, Y+3	; 0x03
    1a7a:	9c 81       	ldd	r25, Y+4	; 0x04
    1a7c:	fc 01       	movw	r30, r24
    1a7e:	22 81       	ldd	r18, Z+2	; 0x02
    1a80:	33 81       	ldd	r19, Z+3	; 0x03
    1a82:	8b 81       	ldd	r24, Y+3	; 0x03
    1a84:	9c 81       	ldd	r25, Y+4	; 0x04
    1a86:	fc 01       	movw	r30, r24
    1a88:	84 8d       	ldd	r24, Z+28	; 0x1c
    1a8a:	88 2f       	mov	r24, r24
    1a8c:	90 e0       	ldi	r25, 0x00	; 0
    1a8e:	91 95       	neg	r25
    1a90:	81 95       	neg	r24
    1a92:	91 09       	sbc	r25, r1
    1a94:	28 0f       	add	r18, r24
    1a96:	39 1f       	adc	r19, r25
    1a98:	8b 81       	ldd	r24, Y+3	; 0x03
    1a9a:	9c 81       	ldd	r25, Y+4	; 0x04
    1a9c:	fc 01       	movw	r30, r24
    1a9e:	37 83       	std	Z+7, r19	; 0x07
    1aa0:	26 83       	std	Z+6, r18	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    1aa2:	8f 81       	ldd	r24, Y+7	; 0x07
    1aa4:	82 30       	cpi	r24, 0x02	; 2
    1aa6:	31 f4       	brne	.+12     	; 0x1ab4 <prvCopyDataToQueue+0x154>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1aa8:	89 81       	ldd	r24, Y+1	; 0x01
    1aaa:	88 23       	and	r24, r24
    1aac:	19 f0       	breq	.+6      	; 0x1ab4 <prvCopyDataToQueue+0x154>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    1aae:	89 81       	ldd	r24, Y+1	; 0x01
    1ab0:	81 50       	subi	r24, 0x01	; 1
    1ab2:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
    1ab4:	89 81       	ldd	r24, Y+1	; 0x01
    1ab6:	21 e0       	ldi	r18, 0x01	; 1
    1ab8:	28 0f       	add	r18, r24
    1aba:	8b 81       	ldd	r24, Y+3	; 0x03
    1abc:	9c 81       	ldd	r25, Y+4	; 0x04
    1abe:	fc 01       	movw	r30, r24
    1ac0:	22 8f       	std	Z+26, r18	; 0x1a

	return xReturn;
    1ac2:	8a 81       	ldd	r24, Y+2	; 0x02
}
    1ac4:	27 96       	adiw	r28, 0x07	; 7
    1ac6:	0f b6       	in	r0, 0x3f	; 63
    1ac8:	f8 94       	cli
    1aca:	de bf       	out	0x3e, r29	; 62
    1acc:	0f be       	out	0x3f, r0	; 63
    1ace:	cd bf       	out	0x3d, r28	; 61
    1ad0:	df 91       	pop	r29
    1ad2:	cf 91       	pop	r28
    1ad4:	08 95       	ret

00001ad6 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    1ad6:	cf 93       	push	r28
    1ad8:	df 93       	push	r29
    1ada:	00 d0       	rcall	.+0      	; 0x1adc <prvCopyDataFromQueue+0x6>
    1adc:	00 d0       	rcall	.+0      	; 0x1ade <prvCopyDataFromQueue+0x8>
    1ade:	cd b7       	in	r28, 0x3d	; 61
    1ae0:	de b7       	in	r29, 0x3e	; 62
    1ae2:	9a 83       	std	Y+2, r25	; 0x02
    1ae4:	89 83       	std	Y+1, r24	; 0x01
    1ae6:	7c 83       	std	Y+4, r23	; 0x04
    1ae8:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    1aea:	89 81       	ldd	r24, Y+1	; 0x01
    1aec:	9a 81       	ldd	r25, Y+2	; 0x02
    1aee:	fc 01       	movw	r30, r24
    1af0:	84 8d       	ldd	r24, Z+28	; 0x1c
    1af2:	88 23       	and	r24, r24
    1af4:	c9 f1       	breq	.+114    	; 0x1b68 <prvCopyDataFromQueue+0x92>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    1af6:	89 81       	ldd	r24, Y+1	; 0x01
    1af8:	9a 81       	ldd	r25, Y+2	; 0x02
    1afa:	fc 01       	movw	r30, r24
    1afc:	26 81       	ldd	r18, Z+6	; 0x06
    1afe:	37 81       	ldd	r19, Z+7	; 0x07
    1b00:	89 81       	ldd	r24, Y+1	; 0x01
    1b02:	9a 81       	ldd	r25, Y+2	; 0x02
    1b04:	fc 01       	movw	r30, r24
    1b06:	84 8d       	ldd	r24, Z+28	; 0x1c
    1b08:	88 2f       	mov	r24, r24
    1b0a:	90 e0       	ldi	r25, 0x00	; 0
    1b0c:	28 0f       	add	r18, r24
    1b0e:	39 1f       	adc	r19, r25
    1b10:	89 81       	ldd	r24, Y+1	; 0x01
    1b12:	9a 81       	ldd	r25, Y+2	; 0x02
    1b14:	fc 01       	movw	r30, r24
    1b16:	37 83       	std	Z+7, r19	; 0x07
    1b18:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    1b1a:	89 81       	ldd	r24, Y+1	; 0x01
    1b1c:	9a 81       	ldd	r25, Y+2	; 0x02
    1b1e:	fc 01       	movw	r30, r24
    1b20:	26 81       	ldd	r18, Z+6	; 0x06
    1b22:	37 81       	ldd	r19, Z+7	; 0x07
    1b24:	89 81       	ldd	r24, Y+1	; 0x01
    1b26:	9a 81       	ldd	r25, Y+2	; 0x02
    1b28:	fc 01       	movw	r30, r24
    1b2a:	82 81       	ldd	r24, Z+2	; 0x02
    1b2c:	93 81       	ldd	r25, Z+3	; 0x03
    1b2e:	28 17       	cp	r18, r24
    1b30:	39 07       	cpc	r19, r25
    1b32:	50 f0       	brcs	.+20     	; 0x1b48 <prvCopyDataFromQueue+0x72>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    1b34:	89 81       	ldd	r24, Y+1	; 0x01
    1b36:	9a 81       	ldd	r25, Y+2	; 0x02
    1b38:	fc 01       	movw	r30, r24
    1b3a:	20 81       	ld	r18, Z
    1b3c:	31 81       	ldd	r19, Z+1	; 0x01
    1b3e:	89 81       	ldd	r24, Y+1	; 0x01
    1b40:	9a 81       	ldd	r25, Y+2	; 0x02
    1b42:	fc 01       	movw	r30, r24
    1b44:	37 83       	std	Z+7, r19	; 0x07
    1b46:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    1b48:	89 81       	ldd	r24, Y+1	; 0x01
    1b4a:	9a 81       	ldd	r25, Y+2	; 0x02
    1b4c:	fc 01       	movw	r30, r24
    1b4e:	84 8d       	ldd	r24, Z+28	; 0x1c
    1b50:	48 2f       	mov	r20, r24
    1b52:	50 e0       	ldi	r21, 0x00	; 0
    1b54:	89 81       	ldd	r24, Y+1	; 0x01
    1b56:	9a 81       	ldd	r25, Y+2	; 0x02
    1b58:	fc 01       	movw	r30, r24
    1b5a:	26 81       	ldd	r18, Z+6	; 0x06
    1b5c:	37 81       	ldd	r19, Z+7	; 0x07
    1b5e:	8b 81       	ldd	r24, Y+3	; 0x03
    1b60:	9c 81       	ldd	r25, Y+4	; 0x04
    1b62:	b9 01       	movw	r22, r18
    1b64:	0e 94 1e 1e 	call	0x3c3c	; 0x3c3c <memcpy>
	}
}
    1b68:	00 00       	nop
    1b6a:	0f 90       	pop	r0
    1b6c:	0f 90       	pop	r0
    1b6e:	0f 90       	pop	r0
    1b70:	0f 90       	pop	r0
    1b72:	df 91       	pop	r29
    1b74:	cf 91       	pop	r28
    1b76:	08 95       	ret

00001b78 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    1b78:	cf 93       	push	r28
    1b7a:	df 93       	push	r29
    1b7c:	00 d0       	rcall	.+0      	; 0x1b7e <prvUnlockQueue+0x6>
    1b7e:	00 d0       	rcall	.+0      	; 0x1b80 <prvUnlockQueue+0x8>
    1b80:	cd b7       	in	r28, 0x3d	; 61
    1b82:	de b7       	in	r29, 0x3e	; 62
    1b84:	9c 83       	std	Y+4, r25	; 0x04
    1b86:	8b 83       	std	Y+3, r24	; 0x03

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    1b88:	0f b6       	in	r0, 0x3f	; 63
    1b8a:	f8 94       	cli
    1b8c:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    1b8e:	8b 81       	ldd	r24, Y+3	; 0x03
    1b90:	9c 81       	ldd	r25, Y+4	; 0x04
    1b92:	fc 01       	movw	r30, r24
    1b94:	86 8d       	ldd	r24, Z+30	; 0x1e
    1b96:	89 83       	std	Y+1, r24	; 0x01

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    1b98:	12 c0       	rjmp	.+36     	; 0x1bbe <prvUnlockQueue+0x46>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1b9a:	8b 81       	ldd	r24, Y+3	; 0x03
    1b9c:	9c 81       	ldd	r25, Y+4	; 0x04
    1b9e:	fc 01       	movw	r30, r24
    1ba0:	81 89       	ldd	r24, Z+17	; 0x11
    1ba2:	88 23       	and	r24, r24
    1ba4:	81 f0       	breq	.+32     	; 0x1bc6 <prvUnlockQueue+0x4e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1ba6:	8b 81       	ldd	r24, Y+3	; 0x03
    1ba8:	9c 81       	ldd	r25, Y+4	; 0x04
    1baa:	41 96       	adiw	r24, 0x11	; 17
    1bac:	0e 94 02 16 	call	0x2c04	; 0x2c04 <xTaskRemoveFromEventList>
    1bb0:	88 23       	and	r24, r24
    1bb2:	11 f0       	breq	.+4      	; 0x1bb8 <prvUnlockQueue+0x40>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    1bb4:	0e 94 5e 17 	call	0x2ebc	; 0x2ebc <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
    1bb8:	89 81       	ldd	r24, Y+1	; 0x01
    1bba:	81 50       	subi	r24, 0x01	; 1
    1bbc:	89 83       	std	Y+1, r24	; 0x01
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    1bbe:	89 81       	ldd	r24, Y+1	; 0x01
    1bc0:	18 16       	cp	r1, r24
    1bc2:	5c f3       	brlt	.-42     	; 0x1b9a <prvUnlockQueue+0x22>
    1bc4:	01 c0       	rjmp	.+2      	; 0x1bc8 <prvUnlockQueue+0x50>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				else
				{
					break;
    1bc6:	00 00       	nop
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    1bc8:	8b 81       	ldd	r24, Y+3	; 0x03
    1bca:	9c 81       	ldd	r25, Y+4	; 0x04
    1bcc:	2f ef       	ldi	r18, 0xFF	; 255
    1bce:	fc 01       	movw	r30, r24
    1bd0:	26 8f       	std	Z+30, r18	; 0x1e
	}
	taskEXIT_CRITICAL();
    1bd2:	0f 90       	pop	r0
    1bd4:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    1bd6:	0f b6       	in	r0, 0x3f	; 63
    1bd8:	f8 94       	cli
    1bda:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    1bdc:	8b 81       	ldd	r24, Y+3	; 0x03
    1bde:	9c 81       	ldd	r25, Y+4	; 0x04
    1be0:	fc 01       	movw	r30, r24
    1be2:	85 8d       	ldd	r24, Z+29	; 0x1d
    1be4:	8a 83       	std	Y+2, r24	; 0x02

		while( cRxLock > queueLOCKED_UNMODIFIED )
    1be6:	12 c0       	rjmp	.+36     	; 0x1c0c <prvUnlockQueue+0x94>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1be8:	8b 81       	ldd	r24, Y+3	; 0x03
    1bea:	9c 81       	ldd	r25, Y+4	; 0x04
    1bec:	fc 01       	movw	r30, r24
    1bee:	80 85       	ldd	r24, Z+8	; 0x08
    1bf0:	88 23       	and	r24, r24
    1bf2:	81 f0       	breq	.+32     	; 0x1c14 <prvUnlockQueue+0x9c>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1bf4:	8b 81       	ldd	r24, Y+3	; 0x03
    1bf6:	9c 81       	ldd	r25, Y+4	; 0x04
    1bf8:	08 96       	adiw	r24, 0x08	; 8
    1bfa:	0e 94 02 16 	call	0x2c04	; 0x2c04 <xTaskRemoveFromEventList>
    1bfe:	88 23       	and	r24, r24
    1c00:	11 f0       	breq	.+4      	; 0x1c06 <prvUnlockQueue+0x8e>
				{
					vTaskMissedYield();
    1c02:	0e 94 5e 17 	call	0x2ebc	; 0x2ebc <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
    1c06:	8a 81       	ldd	r24, Y+2	; 0x02
    1c08:	81 50       	subi	r24, 0x01	; 1
    1c0a:	8a 83       	std	Y+2, r24	; 0x02
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    1c0c:	8a 81       	ldd	r24, Y+2	; 0x02
    1c0e:	18 16       	cp	r1, r24
    1c10:	5c f3       	brlt	.-42     	; 0x1be8 <prvUnlockQueue+0x70>
    1c12:	01 c0       	rjmp	.+2      	; 0x1c16 <prvUnlockQueue+0x9e>

				--cRxLock;
			}
			else
			{
				break;
    1c14:	00 00       	nop
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    1c16:	8b 81       	ldd	r24, Y+3	; 0x03
    1c18:	9c 81       	ldd	r25, Y+4	; 0x04
    1c1a:	2f ef       	ldi	r18, 0xFF	; 255
    1c1c:	fc 01       	movw	r30, r24
    1c1e:	25 8f       	std	Z+29, r18	; 0x1d
	}
	taskEXIT_CRITICAL();
    1c20:	0f 90       	pop	r0
    1c22:	0f be       	out	0x3f, r0	; 63
}
    1c24:	00 00       	nop
    1c26:	0f 90       	pop	r0
    1c28:	0f 90       	pop	r0
    1c2a:	0f 90       	pop	r0
    1c2c:	0f 90       	pop	r0
    1c2e:	df 91       	pop	r29
    1c30:	cf 91       	pop	r28
    1c32:	08 95       	ret

00001c34 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    1c34:	cf 93       	push	r28
    1c36:	df 93       	push	r29
    1c38:	00 d0       	rcall	.+0      	; 0x1c3a <prvIsQueueEmpty+0x6>
    1c3a:	1f 92       	push	r1
    1c3c:	cd b7       	in	r28, 0x3d	; 61
    1c3e:	de b7       	in	r29, 0x3e	; 62
    1c40:	9b 83       	std	Y+3, r25	; 0x03
    1c42:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1c44:	0f b6       	in	r0, 0x3f	; 63
    1c46:	f8 94       	cli
    1c48:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    1c4a:	8a 81       	ldd	r24, Y+2	; 0x02
    1c4c:	9b 81       	ldd	r25, Y+3	; 0x03
    1c4e:	fc 01       	movw	r30, r24
    1c50:	82 8d       	ldd	r24, Z+26	; 0x1a
    1c52:	88 23       	and	r24, r24
    1c54:	19 f4       	brne	.+6      	; 0x1c5c <prvIsQueueEmpty+0x28>
		{
			xReturn = pdTRUE;
    1c56:	81 e0       	ldi	r24, 0x01	; 1
    1c58:	89 83       	std	Y+1, r24	; 0x01
    1c5a:	01 c0       	rjmp	.+2      	; 0x1c5e <prvIsQueueEmpty+0x2a>
		}
		else
		{
			xReturn = pdFALSE;
    1c5c:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    1c5e:	0f 90       	pop	r0
    1c60:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    1c62:	89 81       	ldd	r24, Y+1	; 0x01
}
    1c64:	0f 90       	pop	r0
    1c66:	0f 90       	pop	r0
    1c68:	0f 90       	pop	r0
    1c6a:	df 91       	pop	r29
    1c6c:	cf 91       	pop	r28
    1c6e:	08 95       	ret

00001c70 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    1c70:	cf 93       	push	r28
    1c72:	df 93       	push	r29
    1c74:	00 d0       	rcall	.+0      	; 0x1c76 <xQueueIsQueueEmptyFromISR+0x6>
    1c76:	1f 92       	push	r1
    1c78:	cd b7       	in	r28, 0x3d	; 61
    1c7a:	de b7       	in	r29, 0x3e	; 62
    1c7c:	9b 83       	std	Y+3, r25	; 0x03
    1c7e:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1c80:	8a 81       	ldd	r24, Y+2	; 0x02
    1c82:	9b 81       	ldd	r25, Y+3	; 0x03
    1c84:	fc 01       	movw	r30, r24
    1c86:	82 8d       	ldd	r24, Z+26	; 0x1a
    1c88:	88 23       	and	r24, r24
    1c8a:	19 f4       	brne	.+6      	; 0x1c92 <xQueueIsQueueEmptyFromISR+0x22>
	{
		xReturn = pdTRUE;
    1c8c:	81 e0       	ldi	r24, 0x01	; 1
    1c8e:	89 83       	std	Y+1, r24	; 0x01
    1c90:	01 c0       	rjmp	.+2      	; 0x1c94 <xQueueIsQueueEmptyFromISR+0x24>
	}
	else
	{
		xReturn = pdFALSE;
    1c92:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    1c94:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1c96:	0f 90       	pop	r0
    1c98:	0f 90       	pop	r0
    1c9a:	0f 90       	pop	r0
    1c9c:	df 91       	pop	r29
    1c9e:	cf 91       	pop	r28
    1ca0:	08 95       	ret

00001ca2 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    1ca2:	cf 93       	push	r28
    1ca4:	df 93       	push	r29
    1ca6:	00 d0       	rcall	.+0      	; 0x1ca8 <prvIsQueueFull+0x6>
    1ca8:	1f 92       	push	r1
    1caa:	cd b7       	in	r28, 0x3d	; 61
    1cac:	de b7       	in	r29, 0x3e	; 62
    1cae:	9b 83       	std	Y+3, r25	; 0x03
    1cb0:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1cb2:	0f b6       	in	r0, 0x3f	; 63
    1cb4:	f8 94       	cli
    1cb6:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1cb8:	8a 81       	ldd	r24, Y+2	; 0x02
    1cba:	9b 81       	ldd	r25, Y+3	; 0x03
    1cbc:	fc 01       	movw	r30, r24
    1cbe:	22 8d       	ldd	r18, Z+26	; 0x1a
    1cc0:	8a 81       	ldd	r24, Y+2	; 0x02
    1cc2:	9b 81       	ldd	r25, Y+3	; 0x03
    1cc4:	fc 01       	movw	r30, r24
    1cc6:	83 8d       	ldd	r24, Z+27	; 0x1b
    1cc8:	28 17       	cp	r18, r24
    1cca:	19 f4       	brne	.+6      	; 0x1cd2 <prvIsQueueFull+0x30>
		{
			xReturn = pdTRUE;
    1ccc:	81 e0       	ldi	r24, 0x01	; 1
    1cce:	89 83       	std	Y+1, r24	; 0x01
    1cd0:	01 c0       	rjmp	.+2      	; 0x1cd4 <prvIsQueueFull+0x32>
		}
		else
		{
			xReturn = pdFALSE;
    1cd2:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    1cd4:	0f 90       	pop	r0
    1cd6:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    1cd8:	89 81       	ldd	r24, Y+1	; 0x01
}
    1cda:	0f 90       	pop	r0
    1cdc:	0f 90       	pop	r0
    1cde:	0f 90       	pop	r0
    1ce0:	df 91       	pop	r29
    1ce2:	cf 91       	pop	r28
    1ce4:	08 95       	ret

00001ce6 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    1ce6:	cf 93       	push	r28
    1ce8:	df 93       	push	r29
    1cea:	00 d0       	rcall	.+0      	; 0x1cec <xQueueIsQueueFullFromISR+0x6>
    1cec:	1f 92       	push	r1
    1cee:	cd b7       	in	r28, 0x3d	; 61
    1cf0:	de b7       	in	r29, 0x3e	; 62
    1cf2:	9b 83       	std	Y+3, r25	; 0x03
    1cf4:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
    1cf6:	8a 81       	ldd	r24, Y+2	; 0x02
    1cf8:	9b 81       	ldd	r25, Y+3	; 0x03
    1cfa:	fc 01       	movw	r30, r24
    1cfc:	22 8d       	ldd	r18, Z+26	; 0x1a
    1cfe:	8a 81       	ldd	r24, Y+2	; 0x02
    1d00:	9b 81       	ldd	r25, Y+3	; 0x03
    1d02:	fc 01       	movw	r30, r24
    1d04:	83 8d       	ldd	r24, Z+27	; 0x1b
    1d06:	28 17       	cp	r18, r24
    1d08:	19 f4       	brne	.+6      	; 0x1d10 <xQueueIsQueueFullFromISR+0x2a>
	{
		xReturn = pdTRUE;
    1d0a:	81 e0       	ldi	r24, 0x01	; 1
    1d0c:	89 83       	std	Y+1, r24	; 0x01
    1d0e:	01 c0       	rjmp	.+2      	; 0x1d12 <xQueueIsQueueFullFromISR+0x2c>
	}
	else
	{
		xReturn = pdFALSE;
    1d10:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    1d12:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1d14:	0f 90       	pop	r0
    1d16:	0f 90       	pop	r0
    1d18:	0f 90       	pop	r0
    1d1a:	df 91       	pop	r29
    1d1c:	cf 91       	pop	r28
    1d1e:	08 95       	ret

00001d20 <xQueueCRSend>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait )
	{
    1d20:	cf 93       	push	r28
    1d22:	df 93       	push	r29
    1d24:	cd b7       	in	r28, 0x3d	; 61
    1d26:	de b7       	in	r29, 0x3e	; 62
    1d28:	29 97       	sbiw	r28, 0x09	; 9
    1d2a:	0f b6       	in	r0, 0x3f	; 63
    1d2c:	f8 94       	cli
    1d2e:	de bf       	out	0x3e, r29	; 62
    1d30:	0f be       	out	0x3f, r0	; 63
    1d32:	cd bf       	out	0x3d, r28	; 61
    1d34:	9d 83       	std	Y+5, r25	; 0x05
    1d36:	8c 83       	std	Y+4, r24	; 0x04
    1d38:	7f 83       	std	Y+7, r23	; 0x07
    1d3a:	6e 83       	std	Y+6, r22	; 0x06
    1d3c:	59 87       	std	Y+9, r21	; 0x09
    1d3e:	48 87       	std	Y+8, r20	; 0x08
	BaseType_t xReturn;
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    1d40:	8c 81       	ldd	r24, Y+4	; 0x04
    1d42:	9d 81       	ldd	r25, Y+5	; 0x05
    1d44:	9b 83       	std	Y+3, r25	; 0x03
    1d46:	8a 83       	std	Y+2, r24	; 0x02

		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    1d48:	f8 94       	cli
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1d4a:	8a 81       	ldd	r24, Y+2	; 0x02
    1d4c:	9b 81       	ldd	r25, Y+3	; 0x03
    1d4e:	0e 94 51 0e 	call	0x1ca2	; 0x1ca2 <prvIsQueueFull>
    1d52:	88 23       	and	r24, r24
    1d54:	a1 f0       	breq	.+40     	; 0x1d7e <xQueueCRSend+0x5e>
			{
				/* The queue is full - do we want to block or just leave without
				posting? */
				if( xTicksToWait > ( TickType_t ) 0 )
    1d56:	88 85       	ldd	r24, Y+8	; 0x08
    1d58:	99 85       	ldd	r25, Y+9	; 0x09
    1d5a:	89 2b       	or	r24, r25
    1d5c:	69 f0       	breq	.+26     	; 0x1d78 <xQueueCRSend+0x58>
				{
					/* As this is called from a coroutine we cannot block directly, but
					return indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    1d5e:	8a 81       	ldd	r24, Y+2	; 0x02
    1d60:	9b 81       	ldd	r25, Y+3	; 0x03
    1d62:	9c 01       	movw	r18, r24
    1d64:	28 5f       	subi	r18, 0xF8	; 248
    1d66:	3f 4f       	sbci	r19, 0xFF	; 255
    1d68:	88 85       	ldd	r24, Y+8	; 0x08
    1d6a:	99 85       	ldd	r25, Y+9	; 0x09
    1d6c:	b9 01       	movw	r22, r18
    1d6e:	0e 94 01 01 	call	0x202	; 0x202 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    1d72:	78 94       	sei
					return errQUEUE_BLOCKED;
    1d74:	8c ef       	ldi	r24, 0xFC	; 252
    1d76:	2c c0       	rjmp	.+88     	; 0x1dd0 <xQueueCRSend+0xb0>
				}
				else
				{
					portENABLE_INTERRUPTS();
    1d78:	78 94       	sei
					return errQUEUE_FULL;
    1d7a:	80 e0       	ldi	r24, 0x00	; 0
    1d7c:	29 c0       	rjmp	.+82     	; 0x1dd0 <xQueueCRSend+0xb0>
				}
			}
		}
		portENABLE_INTERRUPTS();
    1d7e:	78 94       	sei

		portDISABLE_INTERRUPTS();
    1d80:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1d82:	8a 81       	ldd	r24, Y+2	; 0x02
    1d84:	9b 81       	ldd	r25, Y+3	; 0x03
    1d86:	fc 01       	movw	r30, r24
    1d88:	22 8d       	ldd	r18, Z+26	; 0x1a
    1d8a:	8a 81       	ldd	r24, Y+2	; 0x02
    1d8c:	9b 81       	ldd	r25, Y+3	; 0x03
    1d8e:	fc 01       	movw	r30, r24
    1d90:	83 8d       	ldd	r24, Z+27	; 0x1b
    1d92:	28 17       	cp	r18, r24
    1d94:	d0 f4       	brcc	.+52     	; 0x1dca <xQueueCRSend+0xaa>
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    1d96:	2e 81       	ldd	r18, Y+6	; 0x06
    1d98:	3f 81       	ldd	r19, Y+7	; 0x07
    1d9a:	8a 81       	ldd	r24, Y+2	; 0x02
    1d9c:	9b 81       	ldd	r25, Y+3	; 0x03
    1d9e:	40 e0       	ldi	r20, 0x00	; 0
    1da0:	b9 01       	movw	r22, r18
    1da2:	0e 94 b0 0c 	call	0x1960	; 0x1960 <prvCopyDataToQueue>
				xReturn = pdPASS;
    1da6:	81 e0       	ldi	r24, 0x01	; 1
    1da8:	89 83       	std	Y+1, r24	; 0x01

				/* Were any co-routines waiting for data to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1daa:	8a 81       	ldd	r24, Y+2	; 0x02
    1dac:	9b 81       	ldd	r25, Y+3	; 0x03
    1dae:	fc 01       	movw	r30, r24
    1db0:	81 89       	ldd	r24, Z+17	; 0x11
    1db2:	88 23       	and	r24, r24
    1db4:	59 f0       	breq	.+22     	; 0x1dcc <xQueueCRSend+0xac>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1db6:	8a 81       	ldd	r24, Y+2	; 0x02
    1db8:	9b 81       	ldd	r25, Y+3	; 0x03
    1dba:	41 96       	adiw	r24, 0x11	; 17
    1dbc:	0e 94 29 03 	call	0x652	; 0x652 <xCoRoutineRemoveFromEventList>
    1dc0:	88 23       	and	r24, r24
    1dc2:	21 f0       	breq	.+8      	; 0x1dcc <xQueueCRSend+0xac>
					{
						/* The co-routine waiting has a higher priority so record
						that a yield might be appropriate. */
						xReturn = errQUEUE_YIELD;
    1dc4:	8b ef       	ldi	r24, 0xFB	; 251
    1dc6:	89 83       	std	Y+1, r24	; 0x01
    1dc8:	01 c0       	rjmp	.+2      	; 0x1dcc <xQueueCRSend+0xac>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = errQUEUE_FULL;
    1dca:	19 82       	std	Y+1, r1	; 0x01
			}
		}
		portENABLE_INTERRUPTS();
    1dcc:	78 94       	sei

		return xReturn;
    1dce:	89 81       	ldd	r24, Y+1	; 0x01
	}
    1dd0:	29 96       	adiw	r28, 0x09	; 9
    1dd2:	0f b6       	in	r0, 0x3f	; 63
    1dd4:	f8 94       	cli
    1dd6:	de bf       	out	0x3e, r29	; 62
    1dd8:	0f be       	out	0x3f, r0	; 63
    1dda:	cd bf       	out	0x3d, r28	; 61
    1ddc:	df 91       	pop	r29
    1dde:	cf 91       	pop	r28
    1de0:	08 95       	ret

00001de2 <xQueueCRReceive>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
	{
    1de2:	cf 93       	push	r28
    1de4:	df 93       	push	r29
    1de6:	cd b7       	in	r28, 0x3d	; 61
    1de8:	de b7       	in	r29, 0x3e	; 62
    1dea:	29 97       	sbiw	r28, 0x09	; 9
    1dec:	0f b6       	in	r0, 0x3f	; 63
    1dee:	f8 94       	cli
    1df0:	de bf       	out	0x3e, r29	; 62
    1df2:	0f be       	out	0x3f, r0	; 63
    1df4:	cd bf       	out	0x3d, r28	; 61
    1df6:	9d 83       	std	Y+5, r25	; 0x05
    1df8:	8c 83       	std	Y+4, r24	; 0x04
    1dfa:	7f 83       	std	Y+7, r23	; 0x07
    1dfc:	6e 83       	std	Y+6, r22	; 0x06
    1dfe:	59 87       	std	Y+9, r21	; 0x09
    1e00:	48 87       	std	Y+8, r20	; 0x08
	BaseType_t xReturn;
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    1e02:	8c 81       	ldd	r24, Y+4	; 0x04
    1e04:	9d 81       	ldd	r25, Y+5	; 0x05
    1e06:	9b 83       	std	Y+3, r25	; 0x03
    1e08:	8a 83       	std	Y+2, r24	; 0x02

		/* If the queue is already empty we may have to block.  A critical section
		is required to prevent an interrupt adding something to the queue
		between the check to see if the queue is empty and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    1e0a:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1e0c:	8a 81       	ldd	r24, Y+2	; 0x02
    1e0e:	9b 81       	ldd	r25, Y+3	; 0x03
    1e10:	fc 01       	movw	r30, r24
    1e12:	82 8d       	ldd	r24, Z+26	; 0x1a
    1e14:	88 23       	and	r24, r24
    1e16:	a1 f4       	brne	.+40     	; 0x1e40 <xQueueCRReceive+0x5e>
			{
				/* There are no messages in the queue, do we want to block or just
				leave with nothing? */
				if( xTicksToWait > ( TickType_t ) 0 )
    1e18:	88 85       	ldd	r24, Y+8	; 0x08
    1e1a:	99 85       	ldd	r25, Y+9	; 0x09
    1e1c:	89 2b       	or	r24, r25
    1e1e:	69 f0       	breq	.+26     	; 0x1e3a <xQueueCRReceive+0x58>
				{
					/* As this is a co-routine we cannot block directly, but return
					indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    1e20:	8a 81       	ldd	r24, Y+2	; 0x02
    1e22:	9b 81       	ldd	r25, Y+3	; 0x03
    1e24:	9c 01       	movw	r18, r24
    1e26:	2f 5e       	subi	r18, 0xEF	; 239
    1e28:	3f 4f       	sbci	r19, 0xFF	; 255
    1e2a:	88 85       	ldd	r24, Y+8	; 0x08
    1e2c:	99 85       	ldd	r25, Y+9	; 0x09
    1e2e:	b9 01       	movw	r22, r18
    1e30:	0e 94 01 01 	call	0x202	; 0x202 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    1e34:	78 94       	sei
					return errQUEUE_BLOCKED;
    1e36:	8c ef       	ldi	r24, 0xFC	; 252
    1e38:	64 c0       	rjmp	.+200    	; 0x1f02 <xQueueCRReceive+0x120>
				}
				else
				{
					portENABLE_INTERRUPTS();
    1e3a:	78 94       	sei
					return errQUEUE_FULL;
    1e3c:	80 e0       	ldi	r24, 0x00	; 0
    1e3e:	61 c0       	rjmp	.+194    	; 0x1f02 <xQueueCRReceive+0x120>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portENABLE_INTERRUPTS();
    1e40:	78 94       	sei

		portDISABLE_INTERRUPTS();
    1e42:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1e44:	8a 81       	ldd	r24, Y+2	; 0x02
    1e46:	9b 81       	ldd	r25, Y+3	; 0x03
    1e48:	fc 01       	movw	r30, r24
    1e4a:	82 8d       	ldd	r24, Z+26	; 0x1a
    1e4c:	88 23       	and	r24, r24
    1e4e:	09 f4       	brne	.+2      	; 0x1e52 <xQueueCRReceive+0x70>
    1e50:	55 c0       	rjmp	.+170    	; 0x1efc <xQueueCRReceive+0x11a>
			{
				/* Data is available from the queue. */
				pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    1e52:	8a 81       	ldd	r24, Y+2	; 0x02
    1e54:	9b 81       	ldd	r25, Y+3	; 0x03
    1e56:	fc 01       	movw	r30, r24
    1e58:	26 81       	ldd	r18, Z+6	; 0x06
    1e5a:	37 81       	ldd	r19, Z+7	; 0x07
    1e5c:	8a 81       	ldd	r24, Y+2	; 0x02
    1e5e:	9b 81       	ldd	r25, Y+3	; 0x03
    1e60:	fc 01       	movw	r30, r24
    1e62:	84 8d       	ldd	r24, Z+28	; 0x1c
    1e64:	88 2f       	mov	r24, r24
    1e66:	90 e0       	ldi	r25, 0x00	; 0
    1e68:	28 0f       	add	r18, r24
    1e6a:	39 1f       	adc	r19, r25
    1e6c:	8a 81       	ldd	r24, Y+2	; 0x02
    1e6e:	9b 81       	ldd	r25, Y+3	; 0x03
    1e70:	fc 01       	movw	r30, r24
    1e72:	37 83       	std	Z+7, r19	; 0x07
    1e74:	26 83       	std	Z+6, r18	; 0x06
				if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
    1e76:	8a 81       	ldd	r24, Y+2	; 0x02
    1e78:	9b 81       	ldd	r25, Y+3	; 0x03
    1e7a:	fc 01       	movw	r30, r24
    1e7c:	26 81       	ldd	r18, Z+6	; 0x06
    1e7e:	37 81       	ldd	r19, Z+7	; 0x07
    1e80:	8a 81       	ldd	r24, Y+2	; 0x02
    1e82:	9b 81       	ldd	r25, Y+3	; 0x03
    1e84:	fc 01       	movw	r30, r24
    1e86:	82 81       	ldd	r24, Z+2	; 0x02
    1e88:	93 81       	ldd	r25, Z+3	; 0x03
    1e8a:	28 17       	cp	r18, r24
    1e8c:	39 07       	cpc	r19, r25
    1e8e:	50 f0       	brcs	.+20     	; 0x1ea4 <xQueueCRReceive+0xc2>
				{
					pxQueue->u.pcReadFrom = pxQueue->pcHead;
    1e90:	8a 81       	ldd	r24, Y+2	; 0x02
    1e92:	9b 81       	ldd	r25, Y+3	; 0x03
    1e94:	fc 01       	movw	r30, r24
    1e96:	20 81       	ld	r18, Z
    1e98:	31 81       	ldd	r19, Z+1	; 0x01
    1e9a:	8a 81       	ldd	r24, Y+2	; 0x02
    1e9c:	9b 81       	ldd	r25, Y+3	; 0x03
    1e9e:	fc 01       	movw	r30, r24
    1ea0:	37 83       	std	Z+7, r19	; 0x07
    1ea2:	26 83       	std	Z+6, r18	; 0x06
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
    1ea4:	8a 81       	ldd	r24, Y+2	; 0x02
    1ea6:	9b 81       	ldd	r25, Y+3	; 0x03
    1ea8:	fc 01       	movw	r30, r24
    1eaa:	82 8d       	ldd	r24, Z+26	; 0x1a
    1eac:	2f ef       	ldi	r18, 0xFF	; 255
    1eae:	28 0f       	add	r18, r24
    1eb0:	8a 81       	ldd	r24, Y+2	; 0x02
    1eb2:	9b 81       	ldd	r25, Y+3	; 0x03
    1eb4:	fc 01       	movw	r30, r24
    1eb6:	22 8f       	std	Z+26, r18	; 0x1a
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1eb8:	8a 81       	ldd	r24, Y+2	; 0x02
    1eba:	9b 81       	ldd	r25, Y+3	; 0x03
    1ebc:	fc 01       	movw	r30, r24
    1ebe:	84 8d       	ldd	r24, Z+28	; 0x1c
    1ec0:	48 2f       	mov	r20, r24
    1ec2:	50 e0       	ldi	r21, 0x00	; 0
    1ec4:	8a 81       	ldd	r24, Y+2	; 0x02
    1ec6:	9b 81       	ldd	r25, Y+3	; 0x03
    1ec8:	fc 01       	movw	r30, r24
    1eca:	26 81       	ldd	r18, Z+6	; 0x06
    1ecc:	37 81       	ldd	r19, Z+7	; 0x07
    1ece:	8e 81       	ldd	r24, Y+6	; 0x06
    1ed0:	9f 81       	ldd	r25, Y+7	; 0x07
    1ed2:	b9 01       	movw	r22, r18
    1ed4:	0e 94 1e 1e 	call	0x3c3c	; 0x3c3c <memcpy>

				xReturn = pdPASS;
    1ed8:	81 e0       	ldi	r24, 0x01	; 1
    1eda:	89 83       	std	Y+1, r24	; 0x01

				/* Were any co-routines waiting for space to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1edc:	8a 81       	ldd	r24, Y+2	; 0x02
    1ede:	9b 81       	ldd	r25, Y+3	; 0x03
    1ee0:	fc 01       	movw	r30, r24
    1ee2:	80 85       	ldd	r24, Z+8	; 0x08
    1ee4:	88 23       	and	r24, r24
    1ee6:	59 f0       	breq	.+22     	; 0x1efe <xQueueCRReceive+0x11c>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1ee8:	8a 81       	ldd	r24, Y+2	; 0x02
    1eea:	9b 81       	ldd	r25, Y+3	; 0x03
    1eec:	08 96       	adiw	r24, 0x08	; 8
    1eee:	0e 94 29 03 	call	0x652	; 0x652 <xCoRoutineRemoveFromEventList>
    1ef2:	88 23       	and	r24, r24
    1ef4:	21 f0       	breq	.+8      	; 0x1efe <xQueueCRReceive+0x11c>
					{
						xReturn = errQUEUE_YIELD;
    1ef6:	8b ef       	ldi	r24, 0xFB	; 251
    1ef8:	89 83       	std	Y+1, r24	; 0x01
    1efa:	01 c0       	rjmp	.+2      	; 0x1efe <xQueueCRReceive+0x11c>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = pdFAIL;
    1efc:	19 82       	std	Y+1, r1	; 0x01
			}
		}
		portENABLE_INTERRUPTS();
    1efe:	78 94       	sei

		return xReturn;
    1f00:	89 81       	ldd	r24, Y+1	; 0x01
	}
    1f02:	29 96       	adiw	r28, 0x09	; 9
    1f04:	0f b6       	in	r0, 0x3f	; 63
    1f06:	f8 94       	cli
    1f08:	de bf       	out	0x3e, r29	; 62
    1f0a:	0f be       	out	0x3f, r0	; 63
    1f0c:	cd bf       	out	0x3d, r28	; 61
    1f0e:	df 91       	pop	r29
    1f10:	cf 91       	pop	r28
    1f12:	08 95       	ret

00001f14 <xQueueCRSendFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken )
	{
    1f14:	cf 93       	push	r28
    1f16:	df 93       	push	r29
    1f18:	cd b7       	in	r28, 0x3d	; 61
    1f1a:	de b7       	in	r29, 0x3e	; 62
    1f1c:	27 97       	sbiw	r28, 0x07	; 7
    1f1e:	0f b6       	in	r0, 0x3f	; 63
    1f20:	f8 94       	cli
    1f22:	de bf       	out	0x3e, r29	; 62
    1f24:	0f be       	out	0x3f, r0	; 63
    1f26:	cd bf       	out	0x3d, r28	; 61
    1f28:	9c 83       	std	Y+4, r25	; 0x04
    1f2a:	8b 83       	std	Y+3, r24	; 0x03
    1f2c:	7e 83       	std	Y+6, r23	; 0x06
    1f2e:	6d 83       	std	Y+5, r22	; 0x05
    1f30:	4f 83       	std	Y+7, r20	; 0x07
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    1f32:	8b 81       	ldd	r24, Y+3	; 0x03
    1f34:	9c 81       	ldd	r25, Y+4	; 0x04
    1f36:	9a 83       	std	Y+2, r25	; 0x02
    1f38:	89 83       	std	Y+1, r24	; 0x01

		/* Cannot block within an ISR so if there is no space on the queue then
		exit without doing anything. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1f3a:	89 81       	ldd	r24, Y+1	; 0x01
    1f3c:	9a 81       	ldd	r25, Y+2	; 0x02
    1f3e:	fc 01       	movw	r30, r24
    1f40:	22 8d       	ldd	r18, Z+26	; 0x1a
    1f42:	89 81       	ldd	r24, Y+1	; 0x01
    1f44:	9a 81       	ldd	r25, Y+2	; 0x02
    1f46:	fc 01       	movw	r30, r24
    1f48:	83 8d       	ldd	r24, Z+27	; 0x1b
    1f4a:	28 17       	cp	r18, r24
    1f4c:	d0 f4       	brcc	.+52     	; 0x1f82 <xQueueCRSendFromISR+0x6e>
		{
			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    1f4e:	2d 81       	ldd	r18, Y+5	; 0x05
    1f50:	3e 81       	ldd	r19, Y+6	; 0x06
    1f52:	89 81       	ldd	r24, Y+1	; 0x01
    1f54:	9a 81       	ldd	r25, Y+2	; 0x02
    1f56:	40 e0       	ldi	r20, 0x00	; 0
    1f58:	b9 01       	movw	r22, r18
    1f5a:	0e 94 b0 0c 	call	0x1960	; 0x1960 <prvCopyDataToQueue>

			/* We only want to wake one co-routine per ISR, so check that a
			co-routine has not already been woken. */
			if( xCoRoutinePreviouslyWoken == pdFALSE )
    1f5e:	8f 81       	ldd	r24, Y+7	; 0x07
    1f60:	88 23       	and	r24, r24
    1f62:	79 f4       	brne	.+30     	; 0x1f82 <xQueueCRSendFromISR+0x6e>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1f64:	89 81       	ldd	r24, Y+1	; 0x01
    1f66:	9a 81       	ldd	r25, Y+2	; 0x02
    1f68:	fc 01       	movw	r30, r24
    1f6a:	81 89       	ldd	r24, Z+17	; 0x11
    1f6c:	88 23       	and	r24, r24
    1f6e:	49 f0       	breq	.+18     	; 0x1f82 <xQueueCRSendFromISR+0x6e>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1f70:	89 81       	ldd	r24, Y+1	; 0x01
    1f72:	9a 81       	ldd	r25, Y+2	; 0x02
    1f74:	41 96       	adiw	r24, 0x11	; 17
    1f76:	0e 94 29 03 	call	0x652	; 0x652 <xCoRoutineRemoveFromEventList>
    1f7a:	88 23       	and	r24, r24
    1f7c:	11 f0       	breq	.+4      	; 0x1f82 <xQueueCRSendFromISR+0x6e>
					{
						return pdTRUE;
    1f7e:	81 e0       	ldi	r24, 0x01	; 1
    1f80:	01 c0       	rjmp	.+2      	; 0x1f84 <xQueueCRSendFromISR+0x70>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xCoRoutinePreviouslyWoken;
    1f82:	8f 81       	ldd	r24, Y+7	; 0x07
	}
    1f84:	27 96       	adiw	r28, 0x07	; 7
    1f86:	0f b6       	in	r0, 0x3f	; 63
    1f88:	f8 94       	cli
    1f8a:	de bf       	out	0x3e, r29	; 62
    1f8c:	0f be       	out	0x3f, r0	; 63
    1f8e:	cd bf       	out	0x3d, r28	; 61
    1f90:	df 91       	pop	r29
    1f92:	cf 91       	pop	r28
    1f94:	08 95       	ret

00001f96 <xQueueCRReceiveFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWoken )
	{
    1f96:	cf 93       	push	r28
    1f98:	df 93       	push	r29
    1f9a:	cd b7       	in	r28, 0x3d	; 61
    1f9c:	de b7       	in	r29, 0x3e	; 62
    1f9e:	29 97       	sbiw	r28, 0x09	; 9
    1fa0:	0f b6       	in	r0, 0x3f	; 63
    1fa2:	f8 94       	cli
    1fa4:	de bf       	out	0x3e, r29	; 62
    1fa6:	0f be       	out	0x3f, r0	; 63
    1fa8:	cd bf       	out	0x3d, r28	; 61
    1faa:	9d 83       	std	Y+5, r25	; 0x05
    1fac:	8c 83       	std	Y+4, r24	; 0x04
    1fae:	7f 83       	std	Y+7, r23	; 0x07
    1fb0:	6e 83       	std	Y+6, r22	; 0x06
    1fb2:	59 87       	std	Y+9, r21	; 0x09
    1fb4:	48 87       	std	Y+8, r20	; 0x08
	BaseType_t xReturn;
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    1fb6:	8c 81       	ldd	r24, Y+4	; 0x04
    1fb8:	9d 81       	ldd	r25, Y+5	; 0x05
    1fba:	9b 83       	std	Y+3, r25	; 0x03
    1fbc:	8a 83       	std	Y+2, r24	; 0x02

		/* We cannot block from an ISR, so check there is data available. If
		not then just leave without doing anything. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1fbe:	8a 81       	ldd	r24, Y+2	; 0x02
    1fc0:	9b 81       	ldd	r25, Y+3	; 0x03
    1fc2:	fc 01       	movw	r30, r24
    1fc4:	82 8d       	ldd	r24, Z+26	; 0x1a
    1fc6:	88 23       	and	r24, r24
    1fc8:	09 f4       	brne	.+2      	; 0x1fcc <xQueueCRReceiveFromISR+0x36>
    1fca:	5e c0       	rjmp	.+188    	; 0x2088 <xQueueCRReceiveFromISR+0xf2>
		{
			/* Copy the data from the queue. */
			pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    1fcc:	8a 81       	ldd	r24, Y+2	; 0x02
    1fce:	9b 81       	ldd	r25, Y+3	; 0x03
    1fd0:	fc 01       	movw	r30, r24
    1fd2:	26 81       	ldd	r18, Z+6	; 0x06
    1fd4:	37 81       	ldd	r19, Z+7	; 0x07
    1fd6:	8a 81       	ldd	r24, Y+2	; 0x02
    1fd8:	9b 81       	ldd	r25, Y+3	; 0x03
    1fda:	fc 01       	movw	r30, r24
    1fdc:	84 8d       	ldd	r24, Z+28	; 0x1c
    1fde:	88 2f       	mov	r24, r24
    1fe0:	90 e0       	ldi	r25, 0x00	; 0
    1fe2:	28 0f       	add	r18, r24
    1fe4:	39 1f       	adc	r19, r25
    1fe6:	8a 81       	ldd	r24, Y+2	; 0x02
    1fe8:	9b 81       	ldd	r25, Y+3	; 0x03
    1fea:	fc 01       	movw	r30, r24
    1fec:	37 83       	std	Z+7, r19	; 0x07
    1fee:	26 83       	std	Z+6, r18	; 0x06
			if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
    1ff0:	8a 81       	ldd	r24, Y+2	; 0x02
    1ff2:	9b 81       	ldd	r25, Y+3	; 0x03
    1ff4:	fc 01       	movw	r30, r24
    1ff6:	26 81       	ldd	r18, Z+6	; 0x06
    1ff8:	37 81       	ldd	r19, Z+7	; 0x07
    1ffa:	8a 81       	ldd	r24, Y+2	; 0x02
    1ffc:	9b 81       	ldd	r25, Y+3	; 0x03
    1ffe:	fc 01       	movw	r30, r24
    2000:	82 81       	ldd	r24, Z+2	; 0x02
    2002:	93 81       	ldd	r25, Z+3	; 0x03
    2004:	28 17       	cp	r18, r24
    2006:	39 07       	cpc	r19, r25
    2008:	50 f0       	brcs	.+20     	; 0x201e <xQueueCRReceiveFromISR+0x88>
			{
				pxQueue->u.pcReadFrom = pxQueue->pcHead;
    200a:	8a 81       	ldd	r24, Y+2	; 0x02
    200c:	9b 81       	ldd	r25, Y+3	; 0x03
    200e:	fc 01       	movw	r30, r24
    2010:	20 81       	ld	r18, Z
    2012:	31 81       	ldd	r19, Z+1	; 0x01
    2014:	8a 81       	ldd	r24, Y+2	; 0x02
    2016:	9b 81       	ldd	r25, Y+3	; 0x03
    2018:	fc 01       	movw	r30, r24
    201a:	37 83       	std	Z+7, r19	; 0x07
    201c:	26 83       	std	Z+6, r18	; 0x06
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
			--( pxQueue->uxMessagesWaiting );
    201e:	8a 81       	ldd	r24, Y+2	; 0x02
    2020:	9b 81       	ldd	r25, Y+3	; 0x03
    2022:	fc 01       	movw	r30, r24
    2024:	82 8d       	ldd	r24, Z+26	; 0x1a
    2026:	2f ef       	ldi	r18, 0xFF	; 255
    2028:	28 0f       	add	r18, r24
    202a:	8a 81       	ldd	r24, Y+2	; 0x02
    202c:	9b 81       	ldd	r25, Y+3	; 0x03
    202e:	fc 01       	movw	r30, r24
    2030:	22 8f       	std	Z+26, r18	; 0x1a
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    2032:	8a 81       	ldd	r24, Y+2	; 0x02
    2034:	9b 81       	ldd	r25, Y+3	; 0x03
    2036:	fc 01       	movw	r30, r24
    2038:	84 8d       	ldd	r24, Z+28	; 0x1c
    203a:	48 2f       	mov	r20, r24
    203c:	50 e0       	ldi	r21, 0x00	; 0
    203e:	8a 81       	ldd	r24, Y+2	; 0x02
    2040:	9b 81       	ldd	r25, Y+3	; 0x03
    2042:	fc 01       	movw	r30, r24
    2044:	26 81       	ldd	r18, Z+6	; 0x06
    2046:	37 81       	ldd	r19, Z+7	; 0x07
    2048:	8e 81       	ldd	r24, Y+6	; 0x06
    204a:	9f 81       	ldd	r25, Y+7	; 0x07
    204c:	b9 01       	movw	r22, r18
    204e:	0e 94 1e 1e 	call	0x3c3c	; 0x3c3c <memcpy>

			if( ( *pxCoRoutineWoken ) == pdFALSE )
    2052:	88 85       	ldd	r24, Y+8	; 0x08
    2054:	99 85       	ldd	r25, Y+9	; 0x09
    2056:	fc 01       	movw	r30, r24
    2058:	80 81       	ld	r24, Z
    205a:	88 23       	and	r24, r24
    205c:	91 f4       	brne	.+36     	; 0x2082 <xQueueCRReceiveFromISR+0xec>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    205e:	8a 81       	ldd	r24, Y+2	; 0x02
    2060:	9b 81       	ldd	r25, Y+3	; 0x03
    2062:	fc 01       	movw	r30, r24
    2064:	80 85       	ldd	r24, Z+8	; 0x08
    2066:	88 23       	and	r24, r24
    2068:	61 f0       	breq	.+24     	; 0x2082 <xQueueCRReceiveFromISR+0xec>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    206a:	8a 81       	ldd	r24, Y+2	; 0x02
    206c:	9b 81       	ldd	r25, Y+3	; 0x03
    206e:	08 96       	adiw	r24, 0x08	; 8
    2070:	0e 94 29 03 	call	0x652	; 0x652 <xCoRoutineRemoveFromEventList>
    2074:	88 23       	and	r24, r24
    2076:	29 f0       	breq	.+10     	; 0x2082 <xQueueCRReceiveFromISR+0xec>
					{
						*pxCoRoutineWoken = pdTRUE;
    2078:	88 85       	ldd	r24, Y+8	; 0x08
    207a:	99 85       	ldd	r25, Y+9	; 0x09
    207c:	21 e0       	ldi	r18, 0x01	; 1
    207e:	fc 01       	movw	r30, r24
    2080:	20 83       	st	Z, r18
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			xReturn = pdPASS;
    2082:	81 e0       	ldi	r24, 0x01	; 1
    2084:	89 83       	std	Y+1, r24	; 0x01
    2086:	01 c0       	rjmp	.+2      	; 0x208a <xQueueCRReceiveFromISR+0xf4>
		}
		else
		{
			xReturn = pdFAIL;
    2088:	19 82       	std	Y+1, r1	; 0x01
		}

		return xReturn;
    208a:	89 81       	ldd	r24, Y+1	; 0x01
	}
    208c:	29 96       	adiw	r28, 0x09	; 9
    208e:	0f b6       	in	r0, 0x3f	; 63
    2090:	f8 94       	cli
    2092:	de bf       	out	0x3e, r29	; 62
    2094:	0f be       	out	0x3f, r0	; 63
    2096:	cd bf       	out	0x3d, r28	; 61
    2098:	df 91       	pop	r29
    209a:	cf 91       	pop	r28
    209c:	08 95       	ret

0000209e <xTaskCreate>:
							const char * const pcName,
							const uint16_t usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
    209e:	8f 92       	push	r8
    20a0:	9f 92       	push	r9
    20a2:	af 92       	push	r10
    20a4:	bf 92       	push	r11
    20a6:	cf 92       	push	r12
    20a8:	df 92       	push	r13
    20aa:	ef 92       	push	r14
    20ac:	ff 92       	push	r15
    20ae:	0f 93       	push	r16
    20b0:	1f 93       	push	r17
    20b2:	cf 93       	push	r28
    20b4:	df 93       	push	r29
    20b6:	cd b7       	in	r28, 0x3d	; 61
    20b8:	de b7       	in	r29, 0x3e	; 62
    20ba:	60 97       	sbiw	r28, 0x10	; 16
    20bc:	0f b6       	in	r0, 0x3f	; 63
    20be:	f8 94       	cli
    20c0:	de bf       	out	0x3e, r29	; 62
    20c2:	0f be       	out	0x3f, r0	; 63
    20c4:	cd bf       	out	0x3d, r28	; 61
    20c6:	9f 83       	std	Y+7, r25	; 0x07
    20c8:	8e 83       	std	Y+6, r24	; 0x06
    20ca:	79 87       	std	Y+9, r23	; 0x09
    20cc:	68 87       	std	Y+8, r22	; 0x08
    20ce:	5b 87       	std	Y+11, r21	; 0x0b
    20d0:	4a 87       	std	Y+10, r20	; 0x0a
    20d2:	3d 87       	std	Y+13, r19	; 0x0d
    20d4:	2c 87       	std	Y+12, r18	; 0x0c
    20d6:	0e 87       	std	Y+14, r16	; 0x0e
    20d8:	f8 8a       	std	Y+16, r15	; 0x10
    20da:	ef 86       	std	Y+15, r14	; 0x0f
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    20dc:	8a 85       	ldd	r24, Y+10	; 0x0a
    20de:	9b 85       	ldd	r25, Y+11	; 0x0b
    20e0:	0e 94 cc 07 	call	0xf98	; 0xf98 <pvPortMalloc>
    20e4:	9d 83       	std	Y+5, r25	; 0x05
    20e6:	8c 83       	std	Y+4, r24	; 0x04

			if( pxStack != NULL )
    20e8:	8c 81       	ldd	r24, Y+4	; 0x04
    20ea:	9d 81       	ldd	r25, Y+5	; 0x05
    20ec:	89 2b       	or	r24, r25
    20ee:	b9 f0       	breq	.+46     	; 0x211e <xTaskCreate+0x80>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
    20f0:	86 e2       	ldi	r24, 0x26	; 38
    20f2:	90 e0       	ldi	r25, 0x00	; 0
    20f4:	0e 94 cc 07 	call	0xf98	; 0xf98 <pvPortMalloc>
    20f8:	9a 83       	std	Y+2, r25	; 0x02
    20fa:	89 83       	std	Y+1, r24	; 0x01

				if( pxNewTCB != NULL )
    20fc:	89 81       	ldd	r24, Y+1	; 0x01
    20fe:	9a 81       	ldd	r25, Y+2	; 0x02
    2100:	89 2b       	or	r24, r25
    2102:	41 f0       	breq	.+16     	; 0x2114 <xTaskCreate+0x76>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    2104:	89 81       	ldd	r24, Y+1	; 0x01
    2106:	9a 81       	ldd	r25, Y+2	; 0x02
    2108:	2c 81       	ldd	r18, Y+4	; 0x04
    210a:	3d 81       	ldd	r19, Y+5	; 0x05
    210c:	fc 01       	movw	r30, r24
    210e:	30 8f       	std	Z+24, r19	; 0x18
    2110:	27 8b       	std	Z+23, r18	; 0x17
    2112:	07 c0       	rjmp	.+14     	; 0x2122 <xTaskCreate+0x84>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    2114:	8c 81       	ldd	r24, Y+4	; 0x04
    2116:	9d 81       	ldd	r25, Y+5	; 0x05
    2118:	0e 94 21 08 	call	0x1042	; 0x1042 <vPortFree>
    211c:	02 c0       	rjmp	.+4      	; 0x2122 <xTaskCreate+0x84>
				}
			}
			else
			{
				pxNewTCB = NULL;
    211e:	1a 82       	std	Y+2, r1	; 0x02
    2120:	19 82       	std	Y+1, r1	; 0x01
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
    2122:	89 81       	ldd	r24, Y+1	; 0x01
    2124:	9a 81       	ldd	r25, Y+2	; 0x02
    2126:	89 2b       	or	r24, r25
    2128:	09 f1       	breq	.+66     	; 0x216c <xTaskCreate+0xce>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    212a:	8a 85       	ldd	r24, Y+10	; 0x0a
    212c:	9b 85       	ldd	r25, Y+11	; 0x0b
    212e:	cc 01       	movw	r24, r24
    2130:	a0 e0       	ldi	r26, 0x00	; 0
    2132:	b0 e0       	ldi	r27, 0x00	; 0
    2134:	09 81       	ldd	r16, Y+1	; 0x01
    2136:	1a 81       	ldd	r17, Y+2	; 0x02
    2138:	4f 85       	ldd	r20, Y+15	; 0x0f
    213a:	58 89       	ldd	r21, Y+16	; 0x10
    213c:	2c 85       	ldd	r18, Y+12	; 0x0c
    213e:	3d 85       	ldd	r19, Y+13	; 0x0d
    2140:	68 85       	ldd	r22, Y+8	; 0x08
    2142:	79 85       	ldd	r23, Y+9	; 0x09
    2144:	ee 81       	ldd	r30, Y+6	; 0x06
    2146:	ff 81       	ldd	r31, Y+7	; 0x07
    2148:	81 2c       	mov	r8, r1
    214a:	91 2c       	mov	r9, r1
    214c:	58 01       	movw	r10, r16
    214e:	6a 01       	movw	r12, r20
    2150:	ee 84       	ldd	r14, Y+14	; 0x0e
    2152:	89 01       	movw	r16, r18
    2154:	9c 01       	movw	r18, r24
    2156:	ad 01       	movw	r20, r26
    2158:	cf 01       	movw	r24, r30
    215a:	0e 94 cc 10 	call	0x2198	; 0x2198 <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
    215e:	89 81       	ldd	r24, Y+1	; 0x01
    2160:	9a 81       	ldd	r25, Y+2	; 0x02
    2162:	0e 94 8e 11 	call	0x231c	; 0x231c <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
    2166:	81 e0       	ldi	r24, 0x01	; 1
    2168:	8b 83       	std	Y+3, r24	; 0x03
    216a:	02 c0       	rjmp	.+4      	; 0x2170 <xTaskCreate+0xd2>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    216c:	8f ef       	ldi	r24, 0xFF	; 255
    216e:	8b 83       	std	Y+3, r24	; 0x03
		}

		return xReturn;
    2170:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    2172:	60 96       	adiw	r28, 0x10	; 16
    2174:	0f b6       	in	r0, 0x3f	; 63
    2176:	f8 94       	cli
    2178:	de bf       	out	0x3e, r29	; 62
    217a:	0f be       	out	0x3f, r0	; 63
    217c:	cd bf       	out	0x3d, r28	; 61
    217e:	df 91       	pop	r29
    2180:	cf 91       	pop	r28
    2182:	1f 91       	pop	r17
    2184:	0f 91       	pop	r16
    2186:	ff 90       	pop	r15
    2188:	ef 90       	pop	r14
    218a:	df 90       	pop	r13
    218c:	cf 90       	pop	r12
    218e:	bf 90       	pop	r11
    2190:	af 90       	pop	r10
    2192:	9f 90       	pop	r9
    2194:	8f 90       	pop	r8
    2196:	08 95       	ret

00002198 <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    2198:	8f 92       	push	r8
    219a:	9f 92       	push	r9
    219c:	af 92       	push	r10
    219e:	bf 92       	push	r11
    21a0:	cf 92       	push	r12
    21a2:	df 92       	push	r13
    21a4:	ef 92       	push	r14
    21a6:	0f 93       	push	r16
    21a8:	1f 93       	push	r17
    21aa:	cf 93       	push	r28
    21ac:	df 93       	push	r29
    21ae:	cd b7       	in	r28, 0x3d	; 61
    21b0:	de b7       	in	r29, 0x3e	; 62
    21b2:	64 97       	sbiw	r28, 0x14	; 20
    21b4:	0f b6       	in	r0, 0x3f	; 63
    21b6:	f8 94       	cli
    21b8:	de bf       	out	0x3e, r29	; 62
    21ba:	0f be       	out	0x3f, r0	; 63
    21bc:	cd bf       	out	0x3d, r28	; 61
    21be:	9d 83       	std	Y+5, r25	; 0x05
    21c0:	8c 83       	std	Y+4, r24	; 0x04
    21c2:	7f 83       	std	Y+7, r23	; 0x07
    21c4:	6e 83       	std	Y+6, r22	; 0x06
    21c6:	28 87       	std	Y+8, r18	; 0x08
    21c8:	39 87       	std	Y+9, r19	; 0x09
    21ca:	4a 87       	std	Y+10, r20	; 0x0a
    21cc:	5b 87       	std	Y+11, r21	; 0x0b
    21ce:	1d 87       	std	Y+13, r17	; 0x0d
    21d0:	0c 87       	std	Y+12, r16	; 0x0c
    21d2:	ee 86       	std	Y+14, r14	; 0x0e
    21d4:	d8 8a       	std	Y+16, r13	; 0x10
    21d6:	cf 86       	std	Y+15, r12	; 0x0f
    21d8:	ba 8a       	std	Y+18, r11	; 0x12
    21da:	a9 8a       	std	Y+17, r10	; 0x11
    21dc:	9c 8a       	std	Y+20, r9	; 0x14
    21de:	8b 8a       	std	Y+19, r8	; 0x13
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
    21e0:	89 89       	ldd	r24, Y+17	; 0x11
    21e2:	9a 89       	ldd	r25, Y+18	; 0x12
    21e4:	fc 01       	movw	r30, r24
    21e6:	27 89       	ldd	r18, Z+23	; 0x17
    21e8:	30 8d       	ldd	r19, Z+24	; 0x18
    21ea:	88 85       	ldd	r24, Y+8	; 0x08
    21ec:	99 85       	ldd	r25, Y+9	; 0x09
    21ee:	01 97       	sbiw	r24, 0x01	; 1
    21f0:	82 0f       	add	r24, r18
    21f2:	93 1f       	adc	r25, r19
    21f4:	9b 83       	std	Y+3, r25	; 0x03
    21f6:	8a 83       	std	Y+2, r24	; 0x02
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    21f8:	19 82       	std	Y+1, r1	; 0x01
    21fa:	21 c0       	rjmp	.+66     	; 0x223e <prvInitialiseNewTask+0xa6>
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    21fc:	89 81       	ldd	r24, Y+1	; 0x01
    21fe:	88 2f       	mov	r24, r24
    2200:	90 e0       	ldi	r25, 0x00	; 0
    2202:	29 81       	ldd	r18, Y+1	; 0x01
    2204:	22 2f       	mov	r18, r18
    2206:	30 e0       	ldi	r19, 0x00	; 0
    2208:	4e 81       	ldd	r20, Y+6	; 0x06
    220a:	5f 81       	ldd	r21, Y+7	; 0x07
    220c:	24 0f       	add	r18, r20
    220e:	35 1f       	adc	r19, r21
    2210:	f9 01       	movw	r30, r18
    2212:	40 81       	ld	r20, Z
    2214:	29 89       	ldd	r18, Y+17	; 0x11
    2216:	3a 89       	ldd	r19, Y+18	; 0x12
    2218:	82 0f       	add	r24, r18
    221a:	93 1f       	adc	r25, r19
    221c:	49 96       	adiw	r24, 0x19	; 25
    221e:	fc 01       	movw	r30, r24
    2220:	40 83       	st	Z, r20

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    2222:	89 81       	ldd	r24, Y+1	; 0x01
    2224:	88 2f       	mov	r24, r24
    2226:	90 e0       	ldi	r25, 0x00	; 0
    2228:	2e 81       	ldd	r18, Y+6	; 0x06
    222a:	3f 81       	ldd	r19, Y+7	; 0x07
    222c:	82 0f       	add	r24, r18
    222e:	93 1f       	adc	r25, r19
    2230:	fc 01       	movw	r30, r24
    2232:	80 81       	ld	r24, Z
    2234:	88 23       	and	r24, r24
    2236:	39 f0       	breq	.+14     	; 0x2246 <prvInitialiseNewTask+0xae>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    2238:	89 81       	ldd	r24, Y+1	; 0x01
    223a:	8f 5f       	subi	r24, 0xFF	; 255
    223c:	89 83       	std	Y+1, r24	; 0x01
    223e:	89 81       	ldd	r24, Y+1	; 0x01
    2240:	88 30       	cpi	r24, 0x08	; 8
    2242:	e0 f2       	brcs	.-72     	; 0x21fc <prvInitialiseNewTask+0x64>
    2244:	01 c0       	rjmp	.+2      	; 0x2248 <prvInitialiseNewTask+0xb0>
		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
		{
			break;
    2246:	00 00       	nop
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    2248:	89 89       	ldd	r24, Y+17	; 0x11
    224a:	9a 89       	ldd	r25, Y+18	; 0x12
    224c:	fc 01       	movw	r30, r24
    224e:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    2250:	8e 85       	ldd	r24, Y+14	; 0x0e
    2252:	84 30       	cpi	r24, 0x04	; 4
    2254:	10 f0       	brcs	.+4      	; 0x225a <prvInitialiseNewTask+0xc2>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    2256:	83 e0       	ldi	r24, 0x03	; 3
    2258:	8e 87       	std	Y+14, r24	; 0x0e
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    225a:	89 89       	ldd	r24, Y+17	; 0x11
    225c:	9a 89       	ldd	r25, Y+18	; 0x12
    225e:	2e 85       	ldd	r18, Y+14	; 0x0e
    2260:	fc 01       	movw	r30, r24
    2262:	26 8b       	std	Z+22, r18	; 0x16
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    2264:	89 89       	ldd	r24, Y+17	; 0x11
    2266:	9a 89       	ldd	r25, Y+18	; 0x12
    2268:	02 96       	adiw	r24, 0x02	; 2
    226a:	0e 94 98 03 	call	0x730	; 0x730 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    226e:	89 89       	ldd	r24, Y+17	; 0x11
    2270:	9a 89       	ldd	r25, Y+18	; 0x12
    2272:	0c 96       	adiw	r24, 0x0c	; 12
    2274:	0e 94 98 03 	call	0x730	; 0x730 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    2278:	89 89       	ldd	r24, Y+17	; 0x11
    227a:	9a 89       	ldd	r25, Y+18	; 0x12
    227c:	29 89       	ldd	r18, Y+17	; 0x11
    227e:	3a 89       	ldd	r19, Y+18	; 0x12
    2280:	fc 01       	movw	r30, r24
    2282:	31 87       	std	Z+9, r19	; 0x09
    2284:	20 87       	std	Z+8, r18	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2286:	8e 85       	ldd	r24, Y+14	; 0x0e
    2288:	88 2f       	mov	r24, r24
    228a:	90 e0       	ldi	r25, 0x00	; 0
    228c:	24 e0       	ldi	r18, 0x04	; 4
    228e:	30 e0       	ldi	r19, 0x00	; 0
    2290:	28 1b       	sub	r18, r24
    2292:	39 0b       	sbc	r19, r25
    2294:	89 89       	ldd	r24, Y+17	; 0x11
    2296:	9a 89       	ldd	r25, Y+18	; 0x12
    2298:	fc 01       	movw	r30, r24
    229a:	35 87       	std	Z+13, r19	; 0x0d
    229c:	24 87       	std	Z+12, r18	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    229e:	89 89       	ldd	r24, Y+17	; 0x11
    22a0:	9a 89       	ldd	r25, Y+18	; 0x12
    22a2:	29 89       	ldd	r18, Y+17	; 0x11
    22a4:	3a 89       	ldd	r19, Y+18	; 0x12
    22a6:	fc 01       	movw	r30, r24
    22a8:	33 8b       	std	Z+19, r19	; 0x13
    22aa:	22 8b       	std	Z+18, r18	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    22ac:	89 89       	ldd	r24, Y+17	; 0x11
    22ae:	9a 89       	ldd	r25, Y+18	; 0x12
    22b0:	fc 01       	movw	r30, r24
    22b2:	11 a2       	std	Z+33, r1	; 0x21
    22b4:	12 a2       	std	Z+34, r1	; 0x22
    22b6:	13 a2       	std	Z+35, r1	; 0x23
    22b8:	14 a2       	std	Z+36, r1	; 0x24
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    22ba:	89 89       	ldd	r24, Y+17	; 0x11
    22bc:	9a 89       	ldd	r25, Y+18	; 0x12
    22be:	fc 01       	movw	r30, r24
    22c0:	15 a2       	std	Z+37, r1	; 0x25
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    22c2:	4c 85       	ldd	r20, Y+12	; 0x0c
    22c4:	5d 85       	ldd	r21, Y+13	; 0x0d
    22c6:	2c 81       	ldd	r18, Y+4	; 0x04
    22c8:	3d 81       	ldd	r19, Y+5	; 0x05
    22ca:	8a 81       	ldd	r24, Y+2	; 0x02
    22cc:	9b 81       	ldd	r25, Y+3	; 0x03
    22ce:	b9 01       	movw	r22, r18
    22d0:	0e 94 c8 04 	call	0x990	; 0x990 <pxPortInitialiseStack>
    22d4:	9c 01       	movw	r18, r24
    22d6:	89 89       	ldd	r24, Y+17	; 0x11
    22d8:	9a 89       	ldd	r25, Y+18	; 0x12
    22da:	fc 01       	movw	r30, r24
    22dc:	31 83       	std	Z+1, r19	; 0x01
    22de:	20 83       	st	Z, r18
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( ( void * ) pxCreatedTask != NULL )
    22e0:	8f 85       	ldd	r24, Y+15	; 0x0f
    22e2:	98 89       	ldd	r25, Y+16	; 0x10
    22e4:	89 2b       	or	r24, r25
    22e6:	39 f0       	breq	.+14     	; 0x22f6 <prvInitialiseNewTask+0x15e>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    22e8:	8f 85       	ldd	r24, Y+15	; 0x0f
    22ea:	98 89       	ldd	r25, Y+16	; 0x10
    22ec:	29 89       	ldd	r18, Y+17	; 0x11
    22ee:	3a 89       	ldd	r19, Y+18	; 0x12
    22f0:	fc 01       	movw	r30, r24
    22f2:	31 83       	std	Z+1, r19	; 0x01
    22f4:	20 83       	st	Z, r18
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    22f6:	00 00       	nop
    22f8:	64 96       	adiw	r28, 0x14	; 20
    22fa:	0f b6       	in	r0, 0x3f	; 63
    22fc:	f8 94       	cli
    22fe:	de bf       	out	0x3e, r29	; 62
    2300:	0f be       	out	0x3f, r0	; 63
    2302:	cd bf       	out	0x3d, r28	; 61
    2304:	df 91       	pop	r29
    2306:	cf 91       	pop	r28
    2308:	1f 91       	pop	r17
    230a:	0f 91       	pop	r16
    230c:	ef 90       	pop	r14
    230e:	df 90       	pop	r13
    2310:	cf 90       	pop	r12
    2312:	bf 90       	pop	r11
    2314:	af 90       	pop	r10
    2316:	9f 90       	pop	r9
    2318:	8f 90       	pop	r8
    231a:	08 95       	ret

0000231c <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
    231c:	cf 93       	push	r28
    231e:	df 93       	push	r29
    2320:	00 d0       	rcall	.+0      	; 0x2322 <prvAddNewTaskToReadyList+0x6>
    2322:	cd b7       	in	r28, 0x3d	; 61
    2324:	de b7       	in	r29, 0x3e	; 62
    2326:	9a 83       	std	Y+2, r25	; 0x02
    2328:	89 83       	std	Y+1, r24	; 0x01
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    232a:	0f b6       	in	r0, 0x3f	; 63
    232c:	f8 94       	cli
    232e:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    2330:	80 91 a9 0d 	lds	r24, 0x0DA9	; 0x800da9 <uxCurrentNumberOfTasks>
    2334:	8f 5f       	subi	r24, 0xFF	; 255
    2336:	80 93 a9 0d 	sts	0x0DA9, r24	; 0x800da9 <uxCurrentNumberOfTasks>
		if( pxCurrentTCB == NULL )
    233a:	80 91 5a 0d 	lds	r24, 0x0D5A	; 0x800d5a <pxCurrentTCB>
    233e:	90 91 5b 0d 	lds	r25, 0x0D5B	; 0x800d5b <pxCurrentTCB+0x1>
    2342:	89 2b       	or	r24, r25
    2344:	69 f4       	brne	.+26     	; 0x2360 <prvAddNewTaskToReadyList+0x44>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    2346:	89 81       	ldd	r24, Y+1	; 0x01
    2348:	9a 81       	ldd	r25, Y+2	; 0x02
    234a:	90 93 5b 0d 	sts	0x0D5B, r25	; 0x800d5b <pxCurrentTCB+0x1>
    234e:	80 93 5a 0d 	sts	0x0D5A, r24	; 0x800d5a <pxCurrentTCB>

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    2352:	80 91 a9 0d 	lds	r24, 0x0DA9	; 0x800da9 <uxCurrentNumberOfTasks>
    2356:	81 30       	cpi	r24, 0x01	; 1
    2358:	c9 f4       	brne	.+50     	; 0x238c <prvAddNewTaskToReadyList+0x70>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
    235a:	0e 94 7b 17 	call	0x2ef6	; 0x2ef6 <prvInitialiseTaskLists>
    235e:	16 c0       	rjmp	.+44     	; 0x238c <prvAddNewTaskToReadyList+0x70>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    2360:	80 91 ad 0d 	lds	r24, 0x0DAD	; 0x800dad <xSchedulerRunning>
    2364:	88 23       	and	r24, r24
    2366:	91 f4       	brne	.+36     	; 0x238c <prvAddNewTaskToReadyList+0x70>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    2368:	80 91 5a 0d 	lds	r24, 0x0D5A	; 0x800d5a <pxCurrentTCB>
    236c:	90 91 5b 0d 	lds	r25, 0x0D5B	; 0x800d5b <pxCurrentTCB+0x1>
    2370:	fc 01       	movw	r30, r24
    2372:	26 89       	ldd	r18, Z+22	; 0x16
    2374:	89 81       	ldd	r24, Y+1	; 0x01
    2376:	9a 81       	ldd	r25, Y+2	; 0x02
    2378:	fc 01       	movw	r30, r24
    237a:	86 89       	ldd	r24, Z+22	; 0x16
    237c:	82 17       	cp	r24, r18
    237e:	30 f0       	brcs	.+12     	; 0x238c <prvAddNewTaskToReadyList+0x70>
				{
					pxCurrentTCB = pxNewTCB;
    2380:	89 81       	ldd	r24, Y+1	; 0x01
    2382:	9a 81       	ldd	r25, Y+2	; 0x02
    2384:	90 93 5b 0d 	sts	0x0D5B, r25	; 0x800d5b <pxCurrentTCB+0x1>
    2388:	80 93 5a 0d 	sts	0x0D5A, r24	; 0x800d5a <pxCurrentTCB>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    238c:	80 91 b1 0d 	lds	r24, 0x0DB1	; 0x800db1 <uxTaskNumber>
    2390:	8f 5f       	subi	r24, 0xFF	; 255
    2392:	80 93 b1 0d 	sts	0x0DB1, r24	; 0x800db1 <uxTaskNumber>
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    2396:	89 81       	ldd	r24, Y+1	; 0x01
    2398:	9a 81       	ldd	r25, Y+2	; 0x02
    239a:	fc 01       	movw	r30, r24
    239c:	96 89       	ldd	r25, Z+22	; 0x16
    239e:	80 91 ac 0d 	lds	r24, 0x0DAC	; 0x800dac <uxTopReadyPriority>
    23a2:	89 17       	cp	r24, r25
    23a4:	30 f4       	brcc	.+12     	; 0x23b2 <prvAddNewTaskToReadyList+0x96>
    23a6:	89 81       	ldd	r24, Y+1	; 0x01
    23a8:	9a 81       	ldd	r25, Y+2	; 0x02
    23aa:	fc 01       	movw	r30, r24
    23ac:	86 89       	ldd	r24, Z+22	; 0x16
    23ae:	80 93 ac 0d 	sts	0x0DAC, r24	; 0x800dac <uxTopReadyPriority>
    23b2:	89 81       	ldd	r24, Y+1	; 0x01
    23b4:	9a 81       	ldd	r25, Y+2	; 0x02
    23b6:	ac 01       	movw	r20, r24
    23b8:	4e 5f       	subi	r20, 0xFE	; 254
    23ba:	5f 4f       	sbci	r21, 0xFF	; 255
    23bc:	89 81       	ldd	r24, Y+1	; 0x01
    23be:	9a 81       	ldd	r25, Y+2	; 0x02
    23c0:	fc 01       	movw	r30, r24
    23c2:	86 89       	ldd	r24, Z+22	; 0x16
    23c4:	28 2f       	mov	r18, r24
    23c6:	30 e0       	ldi	r19, 0x00	; 0
    23c8:	c9 01       	movw	r24, r18
    23ca:	88 0f       	add	r24, r24
    23cc:	99 1f       	adc	r25, r25
    23ce:	88 0f       	add	r24, r24
    23d0:	99 1f       	adc	r25, r25
    23d2:	88 0f       	add	r24, r24
    23d4:	99 1f       	adc	r25, r25
    23d6:	82 0f       	add	r24, r18
    23d8:	93 1f       	adc	r25, r19
    23da:	84 5a       	subi	r24, 0xA4	; 164
    23dc:	92 4f       	sbci	r25, 0xF2	; 242
    23de:	ba 01       	movw	r22, r20
    23e0:	0e 94 aa 03 	call	0x754	; 0x754 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    23e4:	0f 90       	pop	r0
    23e6:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    23e8:	80 91 ad 0d 	lds	r24, 0x0DAD	; 0x800dad <xSchedulerRunning>
    23ec:	88 23       	and	r24, r24
    23ee:	71 f0       	breq	.+28     	; 0x240c <prvAddNewTaskToReadyList+0xf0>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    23f0:	80 91 5a 0d 	lds	r24, 0x0D5A	; 0x800d5a <pxCurrentTCB>
    23f4:	90 91 5b 0d 	lds	r25, 0x0D5B	; 0x800d5b <pxCurrentTCB+0x1>
    23f8:	fc 01       	movw	r30, r24
    23fa:	26 89       	ldd	r18, Z+22	; 0x16
    23fc:	89 81       	ldd	r24, Y+1	; 0x01
    23fe:	9a 81       	ldd	r25, Y+2	; 0x02
    2400:	fc 01       	movw	r30, r24
    2402:	86 89       	ldd	r24, Z+22	; 0x16
    2404:	28 17       	cp	r18, r24
    2406:	10 f4       	brcc	.+4      	; 0x240c <prvAddNewTaskToReadyList+0xf0>
		{
			taskYIELD_IF_USING_PREEMPTION();
    2408:	0e 94 ae 06 	call	0xd5c	; 0xd5c <vPortYield>
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    240c:	00 00       	nop
    240e:	0f 90       	pop	r0
    2410:	0f 90       	pop	r0
    2412:	df 91       	pop	r29
    2414:	cf 91       	pop	r28
    2416:	08 95       	ret

00002418 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    2418:	cf 93       	push	r28
    241a:	df 93       	push	r29
    241c:	00 d0       	rcall	.+0      	; 0x241e <vTaskDelete+0x6>
    241e:	00 d0       	rcall	.+0      	; 0x2420 <vTaskDelete+0x8>
    2420:	cd b7       	in	r28, 0x3d	; 61
    2422:	de b7       	in	r29, 0x3e	; 62
    2424:	9c 83       	std	Y+4, r25	; 0x04
    2426:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    2428:	0f b6       	in	r0, 0x3f	; 63
    242a:	f8 94       	cli
    242c:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    242e:	8b 81       	ldd	r24, Y+3	; 0x03
    2430:	9c 81       	ldd	r25, Y+4	; 0x04
    2432:	89 2b       	or	r24, r25
    2434:	29 f4       	brne	.+10     	; 0x2440 <vTaskDelete+0x28>
    2436:	80 91 5a 0d 	lds	r24, 0x0D5A	; 0x800d5a <pxCurrentTCB>
    243a:	90 91 5b 0d 	lds	r25, 0x0D5B	; 0x800d5b <pxCurrentTCB+0x1>
    243e:	02 c0       	rjmp	.+4      	; 0x2444 <vTaskDelete+0x2c>
    2440:	8b 81       	ldd	r24, Y+3	; 0x03
    2442:	9c 81       	ldd	r25, Y+4	; 0x04
    2444:	9a 83       	std	Y+2, r25	; 0x02
    2446:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    2448:	89 81       	ldd	r24, Y+1	; 0x01
    244a:	9a 81       	ldd	r25, Y+2	; 0x02
    244c:	02 96       	adiw	r24, 0x02	; 2
    244e:	0e 94 71 04 	call	0x8e2	; 0x8e2 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    2452:	89 81       	ldd	r24, Y+1	; 0x01
    2454:	9a 81       	ldd	r25, Y+2	; 0x02
    2456:	fc 01       	movw	r30, r24
    2458:	84 89       	ldd	r24, Z+20	; 0x14
    245a:	95 89       	ldd	r25, Z+21	; 0x15
    245c:	89 2b       	or	r24, r25
    245e:	29 f0       	breq	.+10     	; 0x246a <vTaskDelete+0x52>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    2460:	89 81       	ldd	r24, Y+1	; 0x01
    2462:	9a 81       	ldd	r25, Y+2	; 0x02
    2464:	0c 96       	adiw	r24, 0x0c	; 12
    2466:	0e 94 71 04 	call	0x8e2	; 0x8e2 <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
    246a:	80 91 b1 0d 	lds	r24, 0x0DB1	; 0x800db1 <uxTaskNumber>
    246e:	8f 5f       	subi	r24, 0xFF	; 255
    2470:	80 93 b1 0d 	sts	0x0DB1, r24	; 0x800db1 <uxTaskNumber>

			if( pxTCB == pxCurrentTCB )
    2474:	80 91 5a 0d 	lds	r24, 0x0D5A	; 0x800d5a <pxCurrentTCB>
    2478:	90 91 5b 0d 	lds	r25, 0x0D5B	; 0x800d5b <pxCurrentTCB+0x1>
    247c:	29 81       	ldd	r18, Y+1	; 0x01
    247e:	3a 81       	ldd	r19, Y+2	; 0x02
    2480:	28 17       	cp	r18, r24
    2482:	39 07       	cpc	r19, r25
    2484:	71 f4       	brne	.+28     	; 0x24a2 <vTaskDelete+0x8a>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    2486:	89 81       	ldd	r24, Y+1	; 0x01
    2488:	9a 81       	ldd	r25, Y+2	; 0x02
    248a:	02 96       	adiw	r24, 0x02	; 2
    248c:	bc 01       	movw	r22, r24
    248e:	8f e9       	ldi	r24, 0x9F	; 159
    2490:	9d e0       	ldi	r25, 0x0D	; 13
    2492:	0e 94 aa 03 	call	0x754	; 0x754 <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
    2496:	80 91 a8 0d 	lds	r24, 0x0DA8	; 0x800da8 <uxDeletedTasksWaitingCleanUp>
    249a:	8f 5f       	subi	r24, 0xFF	; 255
    249c:	80 93 a8 0d 	sts	0x0DA8, r24	; 0x800da8 <uxDeletedTasksWaitingCleanUp>
    24a0:	0b c0       	rjmp	.+22     	; 0x24b8 <vTaskDelete+0xa0>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
    24a2:	80 91 a9 0d 	lds	r24, 0x0DA9	; 0x800da9 <uxCurrentNumberOfTasks>
    24a6:	81 50       	subi	r24, 0x01	; 1
    24a8:	80 93 a9 0d 	sts	0x0DA9, r24	; 0x800da9 <uxCurrentNumberOfTasks>
				prvDeleteTCB( pxTCB );
    24ac:	89 81       	ldd	r24, Y+1	; 0x01
    24ae:	9a 81       	ldd	r25, Y+2	; 0x02
    24b0:	0e 94 fa 17 	call	0x2ff4	; 0x2ff4 <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
    24b4:	0e 94 12 18 	call	0x3024	; 0x3024 <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    24b8:	0f 90       	pop	r0
    24ba:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    24bc:	80 91 ad 0d 	lds	r24, 0x0DAD	; 0x800dad <xSchedulerRunning>
    24c0:	88 23       	and	r24, r24
    24c2:	59 f0       	breq	.+22     	; 0x24da <vTaskDelete+0xc2>
		{
			if( pxTCB == pxCurrentTCB )
    24c4:	80 91 5a 0d 	lds	r24, 0x0D5A	; 0x800d5a <pxCurrentTCB>
    24c8:	90 91 5b 0d 	lds	r25, 0x0D5B	; 0x800d5b <pxCurrentTCB+0x1>
    24cc:	29 81       	ldd	r18, Y+1	; 0x01
    24ce:	3a 81       	ldd	r19, Y+2	; 0x02
    24d0:	28 17       	cp	r18, r24
    24d2:	39 07       	cpc	r19, r25
    24d4:	11 f4       	brne	.+4      	; 0x24da <vTaskDelete+0xc2>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    24d6:	0e 94 ae 06 	call	0xd5c	; 0xd5c <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    24da:	00 00       	nop
    24dc:	0f 90       	pop	r0
    24de:	0f 90       	pop	r0
    24e0:	0f 90       	pop	r0
    24e2:	0f 90       	pop	r0
    24e4:	df 91       	pop	r29
    24e6:	cf 91       	pop	r28
    24e8:	08 95       	ret

000024ea <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    24ea:	cf 93       	push	r28
    24ec:	df 93       	push	r29
    24ee:	cd b7       	in	r28, 0x3d	; 61
    24f0:	de b7       	in	r29, 0x3e	; 62
    24f2:	2a 97       	sbiw	r28, 0x0a	; 10
    24f4:	0f b6       	in	r0, 0x3f	; 63
    24f6:	f8 94       	cli
    24f8:	de bf       	out	0x3e, r29	; 62
    24fa:	0f be       	out	0x3f, r0	; 63
    24fc:	cd bf       	out	0x3d, r28	; 61
    24fe:	98 87       	std	Y+8, r25	; 0x08
    2500:	8f 83       	std	Y+7, r24	; 0x07
    2502:	7a 87       	std	Y+10, r23	; 0x0a
    2504:	69 87       	std	Y+9, r22	; 0x09
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    2506:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    2508:	0e 94 54 13 	call	0x26a8	; 0x26a8 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    250c:	80 91 aa 0d 	lds	r24, 0x0DAA	; 0x800daa <xTickCount>
    2510:	90 91 ab 0d 	lds	r25, 0x0DAB	; 0x800dab <xTickCount+0x1>
    2514:	9b 83       	std	Y+3, r25	; 0x03
    2516:	8a 83       	std	Y+2, r24	; 0x02

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    2518:	8f 81       	ldd	r24, Y+7	; 0x07
    251a:	98 85       	ldd	r25, Y+8	; 0x08
    251c:	fc 01       	movw	r30, r24
    251e:	20 81       	ld	r18, Z
    2520:	31 81       	ldd	r19, Z+1	; 0x01
    2522:	89 85       	ldd	r24, Y+9	; 0x09
    2524:	9a 85       	ldd	r25, Y+10	; 0x0a
    2526:	82 0f       	add	r24, r18
    2528:	93 1f       	adc	r25, r19
    252a:	9d 83       	std	Y+5, r25	; 0x05
    252c:	8c 83       	std	Y+4, r24	; 0x04

			if( xConstTickCount < *pxPreviousWakeTime )
    252e:	8f 81       	ldd	r24, Y+7	; 0x07
    2530:	98 85       	ldd	r25, Y+8	; 0x08
    2532:	fc 01       	movw	r30, r24
    2534:	20 81       	ld	r18, Z
    2536:	31 81       	ldd	r19, Z+1	; 0x01
    2538:	8a 81       	ldd	r24, Y+2	; 0x02
    253a:	9b 81       	ldd	r25, Y+3	; 0x03
    253c:	82 17       	cp	r24, r18
    253e:	93 07       	cpc	r25, r19
    2540:	a0 f4       	brcc	.+40     	; 0x256a <vTaskDelayUntil+0x80>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    2542:	8f 81       	ldd	r24, Y+7	; 0x07
    2544:	98 85       	ldd	r25, Y+8	; 0x08
    2546:	fc 01       	movw	r30, r24
    2548:	20 81       	ld	r18, Z
    254a:	31 81       	ldd	r19, Z+1	; 0x01
    254c:	8c 81       	ldd	r24, Y+4	; 0x04
    254e:	9d 81       	ldd	r25, Y+5	; 0x05
    2550:	82 17       	cp	r24, r18
    2552:	93 07       	cpc	r25, r19
    2554:	e8 f4       	brcc	.+58     	; 0x2590 <vTaskDelayUntil+0xa6>
    2556:	2c 81       	ldd	r18, Y+4	; 0x04
    2558:	3d 81       	ldd	r19, Y+5	; 0x05
    255a:	8a 81       	ldd	r24, Y+2	; 0x02
    255c:	9b 81       	ldd	r25, Y+3	; 0x03
    255e:	82 17       	cp	r24, r18
    2560:	93 07       	cpc	r25, r19
    2562:	b0 f4       	brcc	.+44     	; 0x2590 <vTaskDelayUntil+0xa6>
				{
					xShouldDelay = pdTRUE;
    2564:	81 e0       	ldi	r24, 0x01	; 1
    2566:	89 83       	std	Y+1, r24	; 0x01
    2568:	13 c0       	rjmp	.+38     	; 0x2590 <vTaskDelayUntil+0xa6>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    256a:	8f 81       	ldd	r24, Y+7	; 0x07
    256c:	98 85       	ldd	r25, Y+8	; 0x08
    256e:	fc 01       	movw	r30, r24
    2570:	20 81       	ld	r18, Z
    2572:	31 81       	ldd	r19, Z+1	; 0x01
    2574:	8c 81       	ldd	r24, Y+4	; 0x04
    2576:	9d 81       	ldd	r25, Y+5	; 0x05
    2578:	82 17       	cp	r24, r18
    257a:	93 07       	cpc	r25, r19
    257c:	38 f0       	brcs	.+14     	; 0x258c <vTaskDelayUntil+0xa2>
    257e:	2c 81       	ldd	r18, Y+4	; 0x04
    2580:	3d 81       	ldd	r19, Y+5	; 0x05
    2582:	8a 81       	ldd	r24, Y+2	; 0x02
    2584:	9b 81       	ldd	r25, Y+3	; 0x03
    2586:	82 17       	cp	r24, r18
    2588:	93 07       	cpc	r25, r19
    258a:	10 f4       	brcc	.+4      	; 0x2590 <vTaskDelayUntil+0xa6>
				{
					xShouldDelay = pdTRUE;
    258c:	81 e0       	ldi	r24, 0x01	; 1
    258e:	89 83       	std	Y+1, r24	; 0x01
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2590:	8f 81       	ldd	r24, Y+7	; 0x07
    2592:	98 85       	ldd	r25, Y+8	; 0x08
    2594:	2c 81       	ldd	r18, Y+4	; 0x04
    2596:	3d 81       	ldd	r19, Y+5	; 0x05
    2598:	fc 01       	movw	r30, r24
    259a:	31 83       	std	Z+1, r19	; 0x01
    259c:	20 83       	st	Z, r18

			if( xShouldDelay != pdFALSE )
    259e:	89 81       	ldd	r24, Y+1	; 0x01
    25a0:	88 23       	and	r24, r24
    25a2:	59 f0       	breq	.+22     	; 0x25ba <vTaskDelayUntil+0xd0>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    25a4:	2c 81       	ldd	r18, Y+4	; 0x04
    25a6:	3d 81       	ldd	r19, Y+5	; 0x05
    25a8:	8a 81       	ldd	r24, Y+2	; 0x02
    25aa:	9b 81       	ldd	r25, Y+3	; 0x03
    25ac:	a9 01       	movw	r20, r18
    25ae:	48 1b       	sub	r20, r24
    25b0:	59 0b       	sbc	r21, r25
    25b2:	ca 01       	movw	r24, r20
    25b4:	60 e0       	ldi	r22, 0x00	; 0
    25b6:	0e 94 2b 1c 	call	0x3856	; 0x3856 <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    25ba:	0e 94 61 13 	call	0x26c2	; 0x26c2 <xTaskResumeAll>
    25be:	8e 83       	std	Y+6, r24	; 0x06

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    25c0:	8e 81       	ldd	r24, Y+6	; 0x06
    25c2:	88 23       	and	r24, r24
    25c4:	11 f4       	brne	.+4      	; 0x25ca <vTaskDelayUntil+0xe0>
		{
			portYIELD_WITHIN_API();
    25c6:	0e 94 ae 06 	call	0xd5c	; 0xd5c <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    25ca:	00 00       	nop
    25cc:	2a 96       	adiw	r28, 0x0a	; 10
    25ce:	0f b6       	in	r0, 0x3f	; 63
    25d0:	f8 94       	cli
    25d2:	de bf       	out	0x3e, r29	; 62
    25d4:	0f be       	out	0x3f, r0	; 63
    25d6:	cd bf       	out	0x3d, r28	; 61
    25d8:	df 91       	pop	r29
    25da:	cf 91       	pop	r28
    25dc:	08 95       	ret

000025de <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    25de:	cf 93       	push	r28
    25e0:	df 93       	push	r29
    25e2:	00 d0       	rcall	.+0      	; 0x25e4 <vTaskDelay+0x6>
    25e4:	1f 92       	push	r1
    25e6:	cd b7       	in	r28, 0x3d	; 61
    25e8:	de b7       	in	r29, 0x3e	; 62
    25ea:	9b 83       	std	Y+3, r25	; 0x03
    25ec:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xAlreadyYielded = pdFALSE;
    25ee:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    25f0:	8a 81       	ldd	r24, Y+2	; 0x02
    25f2:	9b 81       	ldd	r25, Y+3	; 0x03
    25f4:	89 2b       	or	r24, r25
    25f6:	51 f0       	breq	.+20     	; 0x260c <vTaskDelay+0x2e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    25f8:	0e 94 54 13 	call	0x26a8	; 0x26a8 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    25fc:	8a 81       	ldd	r24, Y+2	; 0x02
    25fe:	9b 81       	ldd	r25, Y+3	; 0x03
    2600:	60 e0       	ldi	r22, 0x00	; 0
    2602:	0e 94 2b 1c 	call	0x3856	; 0x3856 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    2606:	0e 94 61 13 	call	0x26c2	; 0x26c2 <xTaskResumeAll>
    260a:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    260c:	89 81       	ldd	r24, Y+1	; 0x01
    260e:	88 23       	and	r24, r24
    2610:	11 f4       	brne	.+4      	; 0x2616 <vTaskDelay+0x38>
		{
			portYIELD_WITHIN_API();
    2612:	0e 94 ae 06 	call	0xd5c	; 0xd5c <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    2616:	00 00       	nop
    2618:	0f 90       	pop	r0
    261a:	0f 90       	pop	r0
    261c:	0f 90       	pop	r0
    261e:	df 91       	pop	r29
    2620:	cf 91       	pop	r28
    2622:	08 95       	ret

00002624 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    2624:	ef 92       	push	r14
    2626:	ff 92       	push	r15
    2628:	0f 93       	push	r16
    262a:	cf 93       	push	r28
    262c:	df 93       	push	r29
    262e:	1f 92       	push	r1
    2630:	cd b7       	in	r28, 0x3d	; 61
    2632:	de b7       	in	r29, 0x3e	; 62
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    2634:	0f 2e       	mov	r0, r31
    2636:	f4 eb       	ldi	r31, 0xB4	; 180
    2638:	ef 2e       	mov	r14, r31
    263a:	fd e0       	ldi	r31, 0x0D	; 13
    263c:	ff 2e       	mov	r15, r31
    263e:	f0 2d       	mov	r31, r0
    2640:	00 e0       	ldi	r16, 0x00	; 0
    2642:	20 e0       	ldi	r18, 0x00	; 0
    2644:	30 e0       	ldi	r19, 0x00	; 0
    2646:	45 e5       	ldi	r20, 0x55	; 85
    2648:	50 e0       	ldi	r21, 0x00	; 0
    264a:	68 e0       	ldi	r22, 0x08	; 8
    264c:	71 e0       	ldi	r23, 0x01	; 1
    264e:	89 e6       	ldi	r24, 0x69	; 105
    2650:	97 e1       	ldi	r25, 0x17	; 23
    2652:	0e 94 4f 10 	call	0x209e	; 0x209e <xTaskCreate>
    2656:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    2658:	89 81       	ldd	r24, Y+1	; 0x01
    265a:	81 30       	cpi	r24, 0x01	; 1
    265c:	81 f4       	brne	.+32     	; 0x267e <vTaskStartScheduler+0x5a>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    265e:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    2660:	8f ef       	ldi	r24, 0xFF	; 255
    2662:	9f ef       	ldi	r25, 0xFF	; 255
    2664:	90 93 b3 0d 	sts	0x0DB3, r25	; 0x800db3 <xNextTaskUnblockTime+0x1>
    2668:	80 93 b2 0d 	sts	0x0DB2, r24	; 0x800db2 <xNextTaskUnblockTime>
		xSchedulerRunning = pdTRUE;
    266c:	81 e0       	ldi	r24, 0x01	; 1
    266e:	80 93 ad 0d 	sts	0x0DAD, r24	; 0x800dad <xSchedulerRunning>
		xTickCount = ( TickType_t ) 0U;
    2672:	10 92 ab 0d 	sts	0x0DAB, r1	; 0x800dab <xTickCount+0x1>
    2676:	10 92 aa 0d 	sts	0x0DAA, r1	; 0x800daa <xTickCount>
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    267a:	0e 94 71 06 	call	0xce2	; 0xce2 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    267e:	00 00       	nop
    2680:	0f 90       	pop	r0
    2682:	df 91       	pop	r29
    2684:	cf 91       	pop	r28
    2686:	0f 91       	pop	r16
    2688:	ff 90       	pop	r15
    268a:	ef 90       	pop	r14
    268c:	08 95       	ret

0000268e <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    268e:	cf 93       	push	r28
    2690:	df 93       	push	r29
    2692:	cd b7       	in	r28, 0x3d	; 61
    2694:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    2696:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    2698:	10 92 ad 0d 	sts	0x0DAD, r1	; 0x800dad <xSchedulerRunning>
	vPortEndScheduler();
    269c:	0e 94 a6 06 	call	0xd4c	; 0xd4c <vPortEndScheduler>
}
    26a0:	00 00       	nop
    26a2:	df 91       	pop	r29
    26a4:	cf 91       	pop	r28
    26a6:	08 95       	ret

000026a8 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    26a8:	cf 93       	push	r28
    26aa:	df 93       	push	r29
    26ac:	cd b7       	in	r28, 0x3d	; 61
    26ae:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    26b0:	80 91 b6 0d 	lds	r24, 0x0DB6	; 0x800db6 <uxSchedulerSuspended>
    26b4:	8f 5f       	subi	r24, 0xFF	; 255
    26b6:	80 93 b6 0d 	sts	0x0DB6, r24	; 0x800db6 <uxSchedulerSuspended>
}
    26ba:	00 00       	nop
    26bc:	df 91       	pop	r29
    26be:	cf 91       	pop	r28
    26c0:	08 95       	ret

000026c2 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    26c2:	cf 93       	push	r28
    26c4:	df 93       	push	r29
    26c6:	00 d0       	rcall	.+0      	; 0x26c8 <xTaskResumeAll+0x6>
    26c8:	00 d0       	rcall	.+0      	; 0x26ca <xTaskResumeAll+0x8>
    26ca:	cd b7       	in	r28, 0x3d	; 61
    26cc:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB = NULL;
    26ce:	1a 82       	std	Y+2, r1	; 0x02
    26d0:	19 82       	std	Y+1, r1	; 0x01
BaseType_t xAlreadyYielded = pdFALSE;
    26d2:	1b 82       	std	Y+3, r1	; 0x03
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    26d4:	0f b6       	in	r0, 0x3f	; 63
    26d6:	f8 94       	cli
    26d8:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    26da:	80 91 b6 0d 	lds	r24, 0x0DB6	; 0x800db6 <uxSchedulerSuspended>
    26de:	81 50       	subi	r24, 0x01	; 1
    26e0:	80 93 b6 0d 	sts	0x0DB6, r24	; 0x800db6 <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    26e4:	80 91 b6 0d 	lds	r24, 0x0DB6	; 0x800db6 <uxSchedulerSuspended>
    26e8:	88 23       	and	r24, r24
    26ea:	09 f0       	breq	.+2      	; 0x26ee <xTaskResumeAll+0x2c>
    26ec:	77 c0       	rjmp	.+238    	; 0x27dc <xTaskResumeAll+0x11a>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    26ee:	80 91 a9 0d 	lds	r24, 0x0DA9	; 0x800da9 <uxCurrentNumberOfTasks>
    26f2:	88 23       	and	r24, r24
    26f4:	09 f4       	brne	.+2      	; 0x26f8 <xTaskResumeAll+0x36>
    26f6:	72 c0       	rjmp	.+228    	; 0x27dc <xTaskResumeAll+0x11a>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    26f8:	49 c0       	rjmp	.+146    	; 0x278c <xTaskResumeAll+0xca>
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    26fa:	80 91 9b 0d 	lds	r24, 0x0D9B	; 0x800d9b <xPendingReadyList+0x5>
    26fe:	90 91 9c 0d 	lds	r25, 0x0D9C	; 0x800d9c <xPendingReadyList+0x6>
    2702:	fc 01       	movw	r30, r24
    2704:	86 81       	ldd	r24, Z+6	; 0x06
    2706:	97 81       	ldd	r25, Z+7	; 0x07
    2708:	9a 83       	std	Y+2, r25	; 0x02
    270a:	89 83       	std	Y+1, r24	; 0x01
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    270c:	89 81       	ldd	r24, Y+1	; 0x01
    270e:	9a 81       	ldd	r25, Y+2	; 0x02
    2710:	0c 96       	adiw	r24, 0x0c	; 12
    2712:	0e 94 71 04 	call	0x8e2	; 0x8e2 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    2716:	89 81       	ldd	r24, Y+1	; 0x01
    2718:	9a 81       	ldd	r25, Y+2	; 0x02
    271a:	02 96       	adiw	r24, 0x02	; 2
    271c:	0e 94 71 04 	call	0x8e2	; 0x8e2 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    2720:	89 81       	ldd	r24, Y+1	; 0x01
    2722:	9a 81       	ldd	r25, Y+2	; 0x02
    2724:	fc 01       	movw	r30, r24
    2726:	96 89       	ldd	r25, Z+22	; 0x16
    2728:	80 91 ac 0d 	lds	r24, 0x0DAC	; 0x800dac <uxTopReadyPriority>
    272c:	89 17       	cp	r24, r25
    272e:	30 f4       	brcc	.+12     	; 0x273c <xTaskResumeAll+0x7a>
    2730:	89 81       	ldd	r24, Y+1	; 0x01
    2732:	9a 81       	ldd	r25, Y+2	; 0x02
    2734:	fc 01       	movw	r30, r24
    2736:	86 89       	ldd	r24, Z+22	; 0x16
    2738:	80 93 ac 0d 	sts	0x0DAC, r24	; 0x800dac <uxTopReadyPriority>
    273c:	89 81       	ldd	r24, Y+1	; 0x01
    273e:	9a 81       	ldd	r25, Y+2	; 0x02
    2740:	ac 01       	movw	r20, r24
    2742:	4e 5f       	subi	r20, 0xFE	; 254
    2744:	5f 4f       	sbci	r21, 0xFF	; 255
    2746:	89 81       	ldd	r24, Y+1	; 0x01
    2748:	9a 81       	ldd	r25, Y+2	; 0x02
    274a:	fc 01       	movw	r30, r24
    274c:	86 89       	ldd	r24, Z+22	; 0x16
    274e:	28 2f       	mov	r18, r24
    2750:	30 e0       	ldi	r19, 0x00	; 0
    2752:	c9 01       	movw	r24, r18
    2754:	88 0f       	add	r24, r24
    2756:	99 1f       	adc	r25, r25
    2758:	88 0f       	add	r24, r24
    275a:	99 1f       	adc	r25, r25
    275c:	88 0f       	add	r24, r24
    275e:	99 1f       	adc	r25, r25
    2760:	82 0f       	add	r24, r18
    2762:	93 1f       	adc	r25, r19
    2764:	84 5a       	subi	r24, 0xA4	; 164
    2766:	92 4f       	sbci	r25, 0xF2	; 242
    2768:	ba 01       	movw	r22, r20
    276a:	0e 94 aa 03 	call	0x754	; 0x754 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    276e:	89 81       	ldd	r24, Y+1	; 0x01
    2770:	9a 81       	ldd	r25, Y+2	; 0x02
    2772:	fc 01       	movw	r30, r24
    2774:	26 89       	ldd	r18, Z+22	; 0x16
    2776:	80 91 5a 0d 	lds	r24, 0x0D5A	; 0x800d5a <pxCurrentTCB>
    277a:	90 91 5b 0d 	lds	r25, 0x0D5B	; 0x800d5b <pxCurrentTCB+0x1>
    277e:	fc 01       	movw	r30, r24
    2780:	86 89       	ldd	r24, Z+22	; 0x16
    2782:	28 17       	cp	r18, r24
    2784:	18 f0       	brcs	.+6      	; 0x278c <xTaskResumeAll+0xca>
					{
						xYieldPending = pdTRUE;
    2786:	81 e0       	ldi	r24, 0x01	; 1
    2788:	80 93 af 0d 	sts	0x0DAF, r24	; 0x800daf <xYieldPending>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    278c:	80 91 96 0d 	lds	r24, 0x0D96	; 0x800d96 <xPendingReadyList>
    2790:	88 23       	and	r24, r24
    2792:	09 f0       	breq	.+2      	; 0x2796 <xTaskResumeAll+0xd4>
    2794:	b2 cf       	rjmp	.-156    	; 0x26fa <xTaskResumeAll+0x38>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    2796:	89 81       	ldd	r24, Y+1	; 0x01
    2798:	9a 81       	ldd	r25, Y+2	; 0x02
    279a:	89 2b       	or	r24, r25
    279c:	11 f0       	breq	.+4      	; 0x27a2 <xTaskResumeAll+0xe0>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    279e:	0e 94 12 18 	call	0x3024	; 0x3024 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    27a2:	80 91 ae 0d 	lds	r24, 0x0DAE	; 0x800dae <uxPendedTicks>
    27a6:	8c 83       	std	Y+4, r24	; 0x04

					if( uxPendedCounts > ( UBaseType_t ) 0U )
    27a8:	8c 81       	ldd	r24, Y+4	; 0x04
    27aa:	88 23       	and	r24, r24
    27ac:	79 f0       	breq	.+30     	; 0x27cc <xTaskResumeAll+0x10a>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    27ae:	0e 94 4c 14 	call	0x2898	; 0x2898 <xTaskIncrementTick>
    27b2:	88 23       	and	r24, r24
    27b4:	19 f0       	breq	.+6      	; 0x27bc <xTaskResumeAll+0xfa>
							{
								xYieldPending = pdTRUE;
    27b6:	81 e0       	ldi	r24, 0x01	; 1
    27b8:	80 93 af 0d 	sts	0x0DAF, r24	; 0x800daf <xYieldPending>
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
    27bc:	8c 81       	ldd	r24, Y+4	; 0x04
    27be:	81 50       	subi	r24, 0x01	; 1
    27c0:	8c 83       	std	Y+4, r24	; 0x04
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    27c2:	8c 81       	ldd	r24, Y+4	; 0x04
    27c4:	88 23       	and	r24, r24
    27c6:	99 f7       	brne	.-26     	; 0x27ae <xTaskResumeAll+0xec>

						uxPendedTicks = 0;
    27c8:	10 92 ae 0d 	sts	0x0DAE, r1	; 0x800dae <uxPendedTicks>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    27cc:	80 91 af 0d 	lds	r24, 0x0DAF	; 0x800daf <xYieldPending>
    27d0:	88 23       	and	r24, r24
    27d2:	21 f0       	breq	.+8      	; 0x27dc <xTaskResumeAll+0x11a>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    27d4:	81 e0       	ldi	r24, 0x01	; 1
    27d6:	8b 83       	std	Y+3, r24	; 0x03
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    27d8:	0e 94 ae 06 	call	0xd5c	; 0xd5c <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    27dc:	0f 90       	pop	r0
    27de:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    27e0:	8b 81       	ldd	r24, Y+3	; 0x03
}
    27e2:	0f 90       	pop	r0
    27e4:	0f 90       	pop	r0
    27e6:	0f 90       	pop	r0
    27e8:	0f 90       	pop	r0
    27ea:	df 91       	pop	r29
    27ec:	cf 91       	pop	r28
    27ee:	08 95       	ret

000027f0 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    27f0:	cf 93       	push	r28
    27f2:	df 93       	push	r29
    27f4:	00 d0       	rcall	.+0      	; 0x27f6 <xTaskGetTickCount+0x6>
    27f6:	cd b7       	in	r28, 0x3d	; 61
    27f8:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    27fa:	0f b6       	in	r0, 0x3f	; 63
    27fc:	f8 94       	cli
    27fe:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    2800:	80 91 aa 0d 	lds	r24, 0x0DAA	; 0x800daa <xTickCount>
    2804:	90 91 ab 0d 	lds	r25, 0x0DAB	; 0x800dab <xTickCount+0x1>
    2808:	9a 83       	std	Y+2, r25	; 0x02
    280a:	89 83       	std	Y+1, r24	; 0x01
	}
	portTICK_TYPE_EXIT_CRITICAL();
    280c:	0f 90       	pop	r0
    280e:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    2810:	89 81       	ldd	r24, Y+1	; 0x01
    2812:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2814:	0f 90       	pop	r0
    2816:	0f 90       	pop	r0
    2818:	df 91       	pop	r29
    281a:	cf 91       	pop	r28
    281c:	08 95       	ret

0000281e <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    281e:	cf 93       	push	r28
    2820:	df 93       	push	r29
    2822:	00 d0       	rcall	.+0      	; 0x2824 <xTaskGetTickCountFromISR+0x6>
    2824:	1f 92       	push	r1
    2826:	cd b7       	in	r28, 0x3d	; 61
    2828:	de b7       	in	r29, 0x3e	; 62
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    282a:	19 82       	std	Y+1, r1	; 0x01
	{
		xReturn = xTickCount;
    282c:	80 91 aa 0d 	lds	r24, 0x0DAA	; 0x800daa <xTickCount>
    2830:	90 91 ab 0d 	lds	r25, 0x0DAB	; 0x800dab <xTickCount+0x1>
    2834:	9b 83       	std	Y+3, r25	; 0x03
    2836:	8a 83       	std	Y+2, r24	; 0x02
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2838:	8a 81       	ldd	r24, Y+2	; 0x02
    283a:	9b 81       	ldd	r25, Y+3	; 0x03
}
    283c:	0f 90       	pop	r0
    283e:	0f 90       	pop	r0
    2840:	0f 90       	pop	r0
    2842:	df 91       	pop	r29
    2844:	cf 91       	pop	r28
    2846:	08 95       	ret

00002848 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    2848:	cf 93       	push	r28
    284a:	df 93       	push	r29
    284c:	cd b7       	in	r28, 0x3d	; 61
    284e:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    2850:	80 91 a9 0d 	lds	r24, 0x0DA9	; 0x800da9 <uxCurrentNumberOfTasks>
}
    2854:	df 91       	pop	r29
    2856:	cf 91       	pop	r28
    2858:	08 95       	ret

0000285a <pcTaskGetName>:
/*-----------------------------------------------------------*/

char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    285a:	cf 93       	push	r28
    285c:	df 93       	push	r29
    285e:	00 d0       	rcall	.+0      	; 0x2860 <pcTaskGetName+0x6>
    2860:	00 d0       	rcall	.+0      	; 0x2862 <pcTaskGetName+0x8>
    2862:	cd b7       	in	r28, 0x3d	; 61
    2864:	de b7       	in	r29, 0x3e	; 62
    2866:	9c 83       	std	Y+4, r25	; 0x04
    2868:	8b 83       	std	Y+3, r24	; 0x03
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    286a:	8b 81       	ldd	r24, Y+3	; 0x03
    286c:	9c 81       	ldd	r25, Y+4	; 0x04
    286e:	89 2b       	or	r24, r25
    2870:	29 f4       	brne	.+10     	; 0x287c <pcTaskGetName+0x22>
    2872:	80 91 5a 0d 	lds	r24, 0x0D5A	; 0x800d5a <pxCurrentTCB>
    2876:	90 91 5b 0d 	lds	r25, 0x0D5B	; 0x800d5b <pxCurrentTCB+0x1>
    287a:	02 c0       	rjmp	.+4      	; 0x2880 <pcTaskGetName+0x26>
    287c:	8b 81       	ldd	r24, Y+3	; 0x03
    287e:	9c 81       	ldd	r25, Y+4	; 0x04
    2880:	9a 83       	std	Y+2, r25	; 0x02
    2882:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
    2884:	89 81       	ldd	r24, Y+1	; 0x01
    2886:	9a 81       	ldd	r25, Y+2	; 0x02
    2888:	49 96       	adiw	r24, 0x19	; 25
}
    288a:	0f 90       	pop	r0
    288c:	0f 90       	pop	r0
    288e:	0f 90       	pop	r0
    2890:	0f 90       	pop	r0
    2892:	df 91       	pop	r29
    2894:	cf 91       	pop	r28
    2896:	08 95       	ret

00002898 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    2898:	cf 93       	push	r28
    289a:	df 93       	push	r29
    289c:	cd b7       	in	r28, 0x3d	; 61
    289e:	de b7       	in	r29, 0x3e	; 62
    28a0:	29 97       	sbiw	r28, 0x09	; 9
    28a2:	0f b6       	in	r0, 0x3f	; 63
    28a4:	f8 94       	cli
    28a6:	de bf       	out	0x3e, r29	; 62
    28a8:	0f be       	out	0x3f, r0	; 63
    28aa:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    28ac:	19 82       	std	Y+1, r1	; 0x01

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    28ae:	80 91 b6 0d 	lds	r24, 0x0DB6	; 0x800db6 <uxSchedulerSuspended>
    28b2:	88 23       	and	r24, r24
    28b4:	09 f0       	breq	.+2      	; 0x28b8 <xTaskIncrementTick+0x20>
    28b6:	c8 c0       	rjmp	.+400    	; 0x2a48 <xTaskIncrementTick+0x1b0>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + 1;
    28b8:	80 91 aa 0d 	lds	r24, 0x0DAA	; 0x800daa <xTickCount>
    28bc:	90 91 ab 0d 	lds	r25, 0x0DAB	; 0x800dab <xTickCount+0x1>
    28c0:	01 96       	adiw	r24, 0x01	; 1
    28c2:	9b 83       	std	Y+3, r25	; 0x03
    28c4:	8a 83       	std	Y+2, r24	; 0x02

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    28c6:	8a 81       	ldd	r24, Y+2	; 0x02
    28c8:	9b 81       	ldd	r25, Y+3	; 0x03
    28ca:	90 93 ab 0d 	sts	0x0DAB, r25	; 0x800dab <xTickCount+0x1>
    28ce:	80 93 aa 0d 	sts	0x0DAA, r24	; 0x800daa <xTickCount>

		if( xConstTickCount == ( TickType_t ) 0U )
    28d2:	8a 81       	ldd	r24, Y+2	; 0x02
    28d4:	9b 81       	ldd	r25, Y+3	; 0x03
    28d6:	89 2b       	or	r24, r25
    28d8:	d9 f4       	brne	.+54     	; 0x2910 <xTaskIncrementTick+0x78>
		{
			taskSWITCH_DELAYED_LISTS();
    28da:	80 91 92 0d 	lds	r24, 0x0D92	; 0x800d92 <pxDelayedTaskList>
    28de:	90 91 93 0d 	lds	r25, 0x0D93	; 0x800d93 <pxDelayedTaskList+0x1>
    28e2:	9d 83       	std	Y+5, r25	; 0x05
    28e4:	8c 83       	std	Y+4, r24	; 0x04
    28e6:	80 91 94 0d 	lds	r24, 0x0D94	; 0x800d94 <pxOverflowDelayedTaskList>
    28ea:	90 91 95 0d 	lds	r25, 0x0D95	; 0x800d95 <pxOverflowDelayedTaskList+0x1>
    28ee:	90 93 93 0d 	sts	0x0D93, r25	; 0x800d93 <pxDelayedTaskList+0x1>
    28f2:	80 93 92 0d 	sts	0x0D92, r24	; 0x800d92 <pxDelayedTaskList>
    28f6:	8c 81       	ldd	r24, Y+4	; 0x04
    28f8:	9d 81       	ldd	r25, Y+5	; 0x05
    28fa:	90 93 95 0d 	sts	0x0D95, r25	; 0x800d95 <pxOverflowDelayedTaskList+0x1>
    28fe:	80 93 94 0d 	sts	0x0D94, r24	; 0x800d94 <pxOverflowDelayedTaskList>
    2902:	80 91 b0 0d 	lds	r24, 0x0DB0	; 0x800db0 <xNumOfOverflows>
    2906:	8f 5f       	subi	r24, 0xFF	; 255
    2908:	80 93 b0 0d 	sts	0x0DB0, r24	; 0x800db0 <xNumOfOverflows>
    290c:	0e 94 12 18 	call	0x3024	; 0x3024 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    2910:	80 91 b2 0d 	lds	r24, 0x0DB2	; 0x800db2 <xNextTaskUnblockTime>
    2914:	90 91 b3 0d 	lds	r25, 0x0DB3	; 0x800db3 <xNextTaskUnblockTime+0x1>
    2918:	2a 81       	ldd	r18, Y+2	; 0x02
    291a:	3b 81       	ldd	r19, Y+3	; 0x03
    291c:	28 17       	cp	r18, r24
    291e:	39 07       	cpc	r19, r25
    2920:	08 f4       	brcc	.+2      	; 0x2924 <xTaskIncrementTick+0x8c>
    2922:	78 c0       	rjmp	.+240    	; 0x2a14 <xTaskIncrementTick+0x17c>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    2924:	80 91 92 0d 	lds	r24, 0x0D92	; 0x800d92 <pxDelayedTaskList>
    2928:	90 91 93 0d 	lds	r25, 0x0D93	; 0x800d93 <pxDelayedTaskList+0x1>
    292c:	fc 01       	movw	r30, r24
    292e:	80 81       	ld	r24, Z
    2930:	88 23       	and	r24, r24
    2932:	39 f4       	brne	.+14     	; 0x2942 <xTaskIncrementTick+0xaa>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2934:	8f ef       	ldi	r24, 0xFF	; 255
    2936:	9f ef       	ldi	r25, 0xFF	; 255
    2938:	90 93 b3 0d 	sts	0x0DB3, r25	; 0x800db3 <xNextTaskUnblockTime+0x1>
    293c:	80 93 b2 0d 	sts	0x0DB2, r24	; 0x800db2 <xNextTaskUnblockTime>
					break;
    2940:	69 c0       	rjmp	.+210    	; 0x2a14 <xTaskIncrementTick+0x17c>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    2942:	80 91 92 0d 	lds	r24, 0x0D92	; 0x800d92 <pxDelayedTaskList>
    2946:	90 91 93 0d 	lds	r25, 0x0D93	; 0x800d93 <pxDelayedTaskList+0x1>
    294a:	fc 01       	movw	r30, r24
    294c:	85 81       	ldd	r24, Z+5	; 0x05
    294e:	96 81       	ldd	r25, Z+6	; 0x06
    2950:	fc 01       	movw	r30, r24
    2952:	86 81       	ldd	r24, Z+6	; 0x06
    2954:	97 81       	ldd	r25, Z+7	; 0x07
    2956:	9f 83       	std	Y+7, r25	; 0x07
    2958:	8e 83       	std	Y+6, r24	; 0x06
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    295a:	8e 81       	ldd	r24, Y+6	; 0x06
    295c:	9f 81       	ldd	r25, Y+7	; 0x07
    295e:	fc 01       	movw	r30, r24
    2960:	82 81       	ldd	r24, Z+2	; 0x02
    2962:	93 81       	ldd	r25, Z+3	; 0x03
    2964:	99 87       	std	Y+9, r25	; 0x09
    2966:	88 87       	std	Y+8, r24	; 0x08

					if( xConstTickCount < xItemValue )
    2968:	2a 81       	ldd	r18, Y+2	; 0x02
    296a:	3b 81       	ldd	r19, Y+3	; 0x03
    296c:	88 85       	ldd	r24, Y+8	; 0x08
    296e:	99 85       	ldd	r25, Y+9	; 0x09
    2970:	28 17       	cp	r18, r24
    2972:	39 07       	cpc	r19, r25
    2974:	38 f4       	brcc	.+14     	; 0x2984 <xTaskIncrementTick+0xec>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    2976:	88 85       	ldd	r24, Y+8	; 0x08
    2978:	99 85       	ldd	r25, Y+9	; 0x09
    297a:	90 93 b3 0d 	sts	0x0DB3, r25	; 0x800db3 <xNextTaskUnblockTime+0x1>
    297e:	80 93 b2 0d 	sts	0x0DB2, r24	; 0x800db2 <xNextTaskUnblockTime>
						break;
    2982:	48 c0       	rjmp	.+144    	; 0x2a14 <xTaskIncrementTick+0x17c>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    2984:	8e 81       	ldd	r24, Y+6	; 0x06
    2986:	9f 81       	ldd	r25, Y+7	; 0x07
    2988:	02 96       	adiw	r24, 0x02	; 2
    298a:	0e 94 71 04 	call	0x8e2	; 0x8e2 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    298e:	8e 81       	ldd	r24, Y+6	; 0x06
    2990:	9f 81       	ldd	r25, Y+7	; 0x07
    2992:	fc 01       	movw	r30, r24
    2994:	84 89       	ldd	r24, Z+20	; 0x14
    2996:	95 89       	ldd	r25, Z+21	; 0x15
    2998:	89 2b       	or	r24, r25
    299a:	29 f0       	breq	.+10     	; 0x29a6 <xTaskIncrementTick+0x10e>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    299c:	8e 81       	ldd	r24, Y+6	; 0x06
    299e:	9f 81       	ldd	r25, Y+7	; 0x07
    29a0:	0c 96       	adiw	r24, 0x0c	; 12
    29a2:	0e 94 71 04 	call	0x8e2	; 0x8e2 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    29a6:	8e 81       	ldd	r24, Y+6	; 0x06
    29a8:	9f 81       	ldd	r25, Y+7	; 0x07
    29aa:	fc 01       	movw	r30, r24
    29ac:	96 89       	ldd	r25, Z+22	; 0x16
    29ae:	80 91 ac 0d 	lds	r24, 0x0DAC	; 0x800dac <uxTopReadyPriority>
    29b2:	89 17       	cp	r24, r25
    29b4:	30 f4       	brcc	.+12     	; 0x29c2 <xTaskIncrementTick+0x12a>
    29b6:	8e 81       	ldd	r24, Y+6	; 0x06
    29b8:	9f 81       	ldd	r25, Y+7	; 0x07
    29ba:	fc 01       	movw	r30, r24
    29bc:	86 89       	ldd	r24, Z+22	; 0x16
    29be:	80 93 ac 0d 	sts	0x0DAC, r24	; 0x800dac <uxTopReadyPriority>
    29c2:	8e 81       	ldd	r24, Y+6	; 0x06
    29c4:	9f 81       	ldd	r25, Y+7	; 0x07
    29c6:	ac 01       	movw	r20, r24
    29c8:	4e 5f       	subi	r20, 0xFE	; 254
    29ca:	5f 4f       	sbci	r21, 0xFF	; 255
    29cc:	8e 81       	ldd	r24, Y+6	; 0x06
    29ce:	9f 81       	ldd	r25, Y+7	; 0x07
    29d0:	fc 01       	movw	r30, r24
    29d2:	86 89       	ldd	r24, Z+22	; 0x16
    29d4:	28 2f       	mov	r18, r24
    29d6:	30 e0       	ldi	r19, 0x00	; 0
    29d8:	c9 01       	movw	r24, r18
    29da:	88 0f       	add	r24, r24
    29dc:	99 1f       	adc	r25, r25
    29de:	88 0f       	add	r24, r24
    29e0:	99 1f       	adc	r25, r25
    29e2:	88 0f       	add	r24, r24
    29e4:	99 1f       	adc	r25, r25
    29e6:	82 0f       	add	r24, r18
    29e8:	93 1f       	adc	r25, r19
    29ea:	84 5a       	subi	r24, 0xA4	; 164
    29ec:	92 4f       	sbci	r25, 0xF2	; 242
    29ee:	ba 01       	movw	r22, r20
    29f0:	0e 94 aa 03 	call	0x754	; 0x754 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    29f4:	8e 81       	ldd	r24, Y+6	; 0x06
    29f6:	9f 81       	ldd	r25, Y+7	; 0x07
    29f8:	fc 01       	movw	r30, r24
    29fa:	26 89       	ldd	r18, Z+22	; 0x16
    29fc:	80 91 5a 0d 	lds	r24, 0x0D5A	; 0x800d5a <pxCurrentTCB>
    2a00:	90 91 5b 0d 	lds	r25, 0x0D5B	; 0x800d5b <pxCurrentTCB+0x1>
    2a04:	fc 01       	movw	r30, r24
    2a06:	86 89       	ldd	r24, Z+22	; 0x16
    2a08:	28 17       	cp	r18, r24
    2a0a:	08 f4       	brcc	.+2      	; 0x2a0e <xTaskIncrementTick+0x176>
    2a0c:	8b cf       	rjmp	.-234    	; 0x2924 <xTaskIncrementTick+0x8c>
						{
							xSwitchRequired = pdTRUE;
    2a0e:	81 e0       	ldi	r24, 0x01	; 1
    2a10:	89 83       	std	Y+1, r24	; 0x01
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_PREEMPTION */
				}
			}
    2a12:	88 cf       	rjmp	.-240    	; 0x2924 <xTaskIncrementTick+0x8c>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    2a14:	80 91 5a 0d 	lds	r24, 0x0D5A	; 0x800d5a <pxCurrentTCB>
    2a18:	90 91 5b 0d 	lds	r25, 0x0D5B	; 0x800d5b <pxCurrentTCB+0x1>
    2a1c:	fc 01       	movw	r30, r24
    2a1e:	86 89       	ldd	r24, Z+22	; 0x16
    2a20:	28 2f       	mov	r18, r24
    2a22:	30 e0       	ldi	r19, 0x00	; 0
    2a24:	c9 01       	movw	r24, r18
    2a26:	88 0f       	add	r24, r24
    2a28:	99 1f       	adc	r25, r25
    2a2a:	88 0f       	add	r24, r24
    2a2c:	99 1f       	adc	r25, r25
    2a2e:	88 0f       	add	r24, r24
    2a30:	99 1f       	adc	r25, r25
    2a32:	82 0f       	add	r24, r18
    2a34:	93 1f       	adc	r25, r19
    2a36:	84 5a       	subi	r24, 0xA4	; 164
    2a38:	92 4f       	sbci	r25, 0xF2	; 242
    2a3a:	fc 01       	movw	r30, r24
    2a3c:	80 81       	ld	r24, Z
    2a3e:	82 30       	cpi	r24, 0x02	; 2
    2a40:	40 f0       	brcs	.+16     	; 0x2a52 <xTaskIncrementTick+0x1ba>
			{
				xSwitchRequired = pdTRUE;
    2a42:	81 e0       	ldi	r24, 0x01	; 1
    2a44:	89 83       	std	Y+1, r24	; 0x01
    2a46:	05 c0       	rjmp	.+10     	; 0x2a52 <xTaskIncrementTick+0x1ba>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    2a48:	80 91 ae 0d 	lds	r24, 0x0DAE	; 0x800dae <uxPendedTicks>
    2a4c:	8f 5f       	subi	r24, 0xFF	; 255
    2a4e:	80 93 ae 0d 	sts	0x0DAE, r24	; 0x800dae <uxPendedTicks>
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    2a52:	80 91 af 0d 	lds	r24, 0x0DAF	; 0x800daf <xYieldPending>
    2a56:	88 23       	and	r24, r24
    2a58:	11 f0       	breq	.+4      	; 0x2a5e <xTaskIncrementTick+0x1c6>
		{
			xSwitchRequired = pdTRUE;
    2a5a:	81 e0       	ldi	r24, 0x01	; 1
    2a5c:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    2a5e:	89 81       	ldd	r24, Y+1	; 0x01
}
    2a60:	29 96       	adiw	r28, 0x09	; 9
    2a62:	0f b6       	in	r0, 0x3f	; 63
    2a64:	f8 94       	cli
    2a66:	de bf       	out	0x3e, r29	; 62
    2a68:	0f be       	out	0x3f, r0	; 63
    2a6a:	cd bf       	out	0x3d, r28	; 61
    2a6c:	df 91       	pop	r29
    2a6e:	cf 91       	pop	r28
    2a70:	08 95       	ret

00002a72 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    2a72:	cf 93       	push	r28
    2a74:	df 93       	push	r29
    2a76:	00 d0       	rcall	.+0      	; 0x2a78 <vTaskSwitchContext+0x6>
    2a78:	1f 92       	push	r1
    2a7a:	cd b7       	in	r28, 0x3d	; 61
    2a7c:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    2a7e:	80 91 b6 0d 	lds	r24, 0x0DB6	; 0x800db6 <uxSchedulerSuspended>
    2a82:	88 23       	and	r24, r24
    2a84:	21 f0       	breq	.+8      	; 0x2a8e <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    2a86:	81 e0       	ldi	r24, 0x01	; 1
    2a88:	80 93 af 0d 	sts	0x0DAF, r24	; 0x800daf <xYieldPending>
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    2a8c:	5f c0       	rjmp	.+190    	; 0x2b4c <vTaskSwitchContext+0xda>
		switch. */
		xYieldPending = pdTRUE;
	}
	else
	{
		xYieldPending = pdFALSE;
    2a8e:	10 92 af 0d 	sts	0x0DAF, r1	; 0x800daf <xYieldPending>
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    2a92:	80 91 ac 0d 	lds	r24, 0x0DAC	; 0x800dac <uxTopReadyPriority>
    2a96:	89 83       	std	Y+1, r24	; 0x01
    2a98:	03 c0       	rjmp	.+6      	; 0x2aa0 <vTaskSwitchContext+0x2e>
    2a9a:	89 81       	ldd	r24, Y+1	; 0x01
    2a9c:	81 50       	subi	r24, 0x01	; 1
    2a9e:	89 83       	std	Y+1, r24	; 0x01
    2aa0:	89 81       	ldd	r24, Y+1	; 0x01
    2aa2:	28 2f       	mov	r18, r24
    2aa4:	30 e0       	ldi	r19, 0x00	; 0
    2aa6:	c9 01       	movw	r24, r18
    2aa8:	88 0f       	add	r24, r24
    2aaa:	99 1f       	adc	r25, r25
    2aac:	88 0f       	add	r24, r24
    2aae:	99 1f       	adc	r25, r25
    2ab0:	88 0f       	add	r24, r24
    2ab2:	99 1f       	adc	r25, r25
    2ab4:	82 0f       	add	r24, r18
    2ab6:	93 1f       	adc	r25, r19
    2ab8:	84 5a       	subi	r24, 0xA4	; 164
    2aba:	92 4f       	sbci	r25, 0xF2	; 242
    2abc:	fc 01       	movw	r30, r24
    2abe:	80 81       	ld	r24, Z
    2ac0:	88 23       	and	r24, r24
    2ac2:	59 f3       	breq	.-42     	; 0x2a9a <vTaskSwitchContext+0x28>
    2ac4:	89 81       	ldd	r24, Y+1	; 0x01
    2ac6:	28 2f       	mov	r18, r24
    2ac8:	30 e0       	ldi	r19, 0x00	; 0
    2aca:	c9 01       	movw	r24, r18
    2acc:	88 0f       	add	r24, r24
    2ace:	99 1f       	adc	r25, r25
    2ad0:	88 0f       	add	r24, r24
    2ad2:	99 1f       	adc	r25, r25
    2ad4:	88 0f       	add	r24, r24
    2ad6:	99 1f       	adc	r25, r25
    2ad8:	82 0f       	add	r24, r18
    2ada:	93 1f       	adc	r25, r19
    2adc:	84 5a       	subi	r24, 0xA4	; 164
    2ade:	92 4f       	sbci	r25, 0xF2	; 242
    2ae0:	9b 83       	std	Y+3, r25	; 0x03
    2ae2:	8a 83       	std	Y+2, r24	; 0x02
    2ae4:	8a 81       	ldd	r24, Y+2	; 0x02
    2ae6:	9b 81       	ldd	r25, Y+3	; 0x03
    2ae8:	fc 01       	movw	r30, r24
    2aea:	81 81       	ldd	r24, Z+1	; 0x01
    2aec:	92 81       	ldd	r25, Z+2	; 0x02
    2aee:	fc 01       	movw	r30, r24
    2af0:	22 81       	ldd	r18, Z+2	; 0x02
    2af2:	33 81       	ldd	r19, Z+3	; 0x03
    2af4:	8a 81       	ldd	r24, Y+2	; 0x02
    2af6:	9b 81       	ldd	r25, Y+3	; 0x03
    2af8:	fc 01       	movw	r30, r24
    2afa:	32 83       	std	Z+2, r19	; 0x02
    2afc:	21 83       	std	Z+1, r18	; 0x01
    2afe:	8a 81       	ldd	r24, Y+2	; 0x02
    2b00:	9b 81       	ldd	r25, Y+3	; 0x03
    2b02:	fc 01       	movw	r30, r24
    2b04:	21 81       	ldd	r18, Z+1	; 0x01
    2b06:	32 81       	ldd	r19, Z+2	; 0x02
    2b08:	8a 81       	ldd	r24, Y+2	; 0x02
    2b0a:	9b 81       	ldd	r25, Y+3	; 0x03
    2b0c:	03 96       	adiw	r24, 0x03	; 3
    2b0e:	28 17       	cp	r18, r24
    2b10:	39 07       	cpc	r19, r25
    2b12:	69 f4       	brne	.+26     	; 0x2b2e <vTaskSwitchContext+0xbc>
    2b14:	8a 81       	ldd	r24, Y+2	; 0x02
    2b16:	9b 81       	ldd	r25, Y+3	; 0x03
    2b18:	fc 01       	movw	r30, r24
    2b1a:	81 81       	ldd	r24, Z+1	; 0x01
    2b1c:	92 81       	ldd	r25, Z+2	; 0x02
    2b1e:	fc 01       	movw	r30, r24
    2b20:	22 81       	ldd	r18, Z+2	; 0x02
    2b22:	33 81       	ldd	r19, Z+3	; 0x03
    2b24:	8a 81       	ldd	r24, Y+2	; 0x02
    2b26:	9b 81       	ldd	r25, Y+3	; 0x03
    2b28:	fc 01       	movw	r30, r24
    2b2a:	32 83       	std	Z+2, r19	; 0x02
    2b2c:	21 83       	std	Z+1, r18	; 0x01
    2b2e:	8a 81       	ldd	r24, Y+2	; 0x02
    2b30:	9b 81       	ldd	r25, Y+3	; 0x03
    2b32:	fc 01       	movw	r30, r24
    2b34:	81 81       	ldd	r24, Z+1	; 0x01
    2b36:	92 81       	ldd	r25, Z+2	; 0x02
    2b38:	fc 01       	movw	r30, r24
    2b3a:	86 81       	ldd	r24, Z+6	; 0x06
    2b3c:	97 81       	ldd	r25, Z+7	; 0x07
    2b3e:	90 93 5b 0d 	sts	0x0D5B, r25	; 0x800d5b <pxCurrentTCB+0x1>
    2b42:	80 93 5a 0d 	sts	0x0D5A, r24	; 0x800d5a <pxCurrentTCB>
    2b46:	89 81       	ldd	r24, Y+1	; 0x01
    2b48:	80 93 ac 0d 	sts	0x0DAC, r24	; 0x800dac <uxTopReadyPriority>
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    2b4c:	00 00       	nop
    2b4e:	0f 90       	pop	r0
    2b50:	0f 90       	pop	r0
    2b52:	0f 90       	pop	r0
    2b54:	df 91       	pop	r29
    2b56:	cf 91       	pop	r28
    2b58:	08 95       	ret

00002b5a <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    2b5a:	cf 93       	push	r28
    2b5c:	df 93       	push	r29
    2b5e:	00 d0       	rcall	.+0      	; 0x2b60 <vTaskPlaceOnEventList+0x6>
    2b60:	00 d0       	rcall	.+0      	; 0x2b62 <vTaskPlaceOnEventList+0x8>
    2b62:	cd b7       	in	r28, 0x3d	; 61
    2b64:	de b7       	in	r29, 0x3e	; 62
    2b66:	9a 83       	std	Y+2, r25	; 0x02
    2b68:	89 83       	std	Y+1, r24	; 0x01
    2b6a:	7c 83       	std	Y+4, r23	; 0x04
    2b6c:	6b 83       	std	Y+3, r22	; 0x03

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    2b6e:	80 91 5a 0d 	lds	r24, 0x0D5A	; 0x800d5a <pxCurrentTCB>
    2b72:	90 91 5b 0d 	lds	r25, 0x0D5B	; 0x800d5b <pxCurrentTCB+0x1>
    2b76:	9c 01       	movw	r18, r24
    2b78:	24 5f       	subi	r18, 0xF4	; 244
    2b7a:	3f 4f       	sbci	r19, 0xFF	; 255
    2b7c:	89 81       	ldd	r24, Y+1	; 0x01
    2b7e:	9a 81       	ldd	r25, Y+2	; 0x02
    2b80:	b9 01       	movw	r22, r18
    2b82:	0e 94 f9 03 	call	0x7f2	; 0x7f2 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    2b86:	8b 81       	ldd	r24, Y+3	; 0x03
    2b88:	9c 81       	ldd	r25, Y+4	; 0x04
    2b8a:	61 e0       	ldi	r22, 0x01	; 1
    2b8c:	0e 94 2b 1c 	call	0x3856	; 0x3856 <prvAddCurrentTaskToDelayedList>
}
    2b90:	00 00       	nop
    2b92:	0f 90       	pop	r0
    2b94:	0f 90       	pop	r0
    2b96:	0f 90       	pop	r0
    2b98:	0f 90       	pop	r0
    2b9a:	df 91       	pop	r29
    2b9c:	cf 91       	pop	r28
    2b9e:	08 95       	ret

00002ba0 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    2ba0:	cf 93       	push	r28
    2ba2:	df 93       	push	r29
    2ba4:	00 d0       	rcall	.+0      	; 0x2ba6 <vTaskPlaceOnUnorderedEventList+0x6>
    2ba6:	00 d0       	rcall	.+0      	; 0x2ba8 <vTaskPlaceOnUnorderedEventList+0x8>
    2ba8:	00 d0       	rcall	.+0      	; 0x2baa <vTaskPlaceOnUnorderedEventList+0xa>
    2baa:	cd b7       	in	r28, 0x3d	; 61
    2bac:	de b7       	in	r29, 0x3e	; 62
    2bae:	9a 83       	std	Y+2, r25	; 0x02
    2bb0:	89 83       	std	Y+1, r24	; 0x01
    2bb2:	7c 83       	std	Y+4, r23	; 0x04
    2bb4:	6b 83       	std	Y+3, r22	; 0x03
    2bb6:	5e 83       	std	Y+6, r21	; 0x06
    2bb8:	4d 83       	std	Y+5, r20	; 0x05
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    2bba:	80 91 5a 0d 	lds	r24, 0x0D5A	; 0x800d5a <pxCurrentTCB>
    2bbe:	90 91 5b 0d 	lds	r25, 0x0D5B	; 0x800d5b <pxCurrentTCB+0x1>
    2bc2:	2b 81       	ldd	r18, Y+3	; 0x03
    2bc4:	3c 81       	ldd	r19, Y+4	; 0x04
    2bc6:	30 68       	ori	r19, 0x80	; 128
    2bc8:	fc 01       	movw	r30, r24
    2bca:	35 87       	std	Z+13, r19	; 0x0d
    2bcc:	24 87       	std	Z+12, r18	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    2bce:	80 91 5a 0d 	lds	r24, 0x0D5A	; 0x800d5a <pxCurrentTCB>
    2bd2:	90 91 5b 0d 	lds	r25, 0x0D5B	; 0x800d5b <pxCurrentTCB+0x1>
    2bd6:	9c 01       	movw	r18, r24
    2bd8:	24 5f       	subi	r18, 0xF4	; 244
    2bda:	3f 4f       	sbci	r19, 0xFF	; 255
    2bdc:	89 81       	ldd	r24, Y+1	; 0x01
    2bde:	9a 81       	ldd	r25, Y+2	; 0x02
    2be0:	b9 01       	movw	r22, r18
    2be2:	0e 94 aa 03 	call	0x754	; 0x754 <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    2be6:	8d 81       	ldd	r24, Y+5	; 0x05
    2be8:	9e 81       	ldd	r25, Y+6	; 0x06
    2bea:	61 e0       	ldi	r22, 0x01	; 1
    2bec:	0e 94 2b 1c 	call	0x3856	; 0x3856 <prvAddCurrentTaskToDelayedList>
}
    2bf0:	00 00       	nop
    2bf2:	26 96       	adiw	r28, 0x06	; 6
    2bf4:	0f b6       	in	r0, 0x3f	; 63
    2bf6:	f8 94       	cli
    2bf8:	de bf       	out	0x3e, r29	; 62
    2bfa:	0f be       	out	0x3f, r0	; 63
    2bfc:	cd bf       	out	0x3d, r28	; 61
    2bfe:	df 91       	pop	r29
    2c00:	cf 91       	pop	r28
    2c02:	08 95       	ret

00002c04 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    2c04:	cf 93       	push	r28
    2c06:	df 93       	push	r29
    2c08:	00 d0       	rcall	.+0      	; 0x2c0a <xTaskRemoveFromEventList+0x6>
    2c0a:	00 d0       	rcall	.+0      	; 0x2c0c <xTaskRemoveFromEventList+0x8>
    2c0c:	1f 92       	push	r1
    2c0e:	cd b7       	in	r28, 0x3d	; 61
    2c10:	de b7       	in	r29, 0x3e	; 62
    2c12:	9d 83       	std	Y+5, r25	; 0x05
    2c14:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2c16:	8c 81       	ldd	r24, Y+4	; 0x04
    2c18:	9d 81       	ldd	r25, Y+5	; 0x05
    2c1a:	fc 01       	movw	r30, r24
    2c1c:	85 81       	ldd	r24, Z+5	; 0x05
    2c1e:	96 81       	ldd	r25, Z+6	; 0x06
    2c20:	fc 01       	movw	r30, r24
    2c22:	86 81       	ldd	r24, Z+6	; 0x06
    2c24:	97 81       	ldd	r25, Z+7	; 0x07
    2c26:	9b 83       	std	Y+3, r25	; 0x03
    2c28:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    2c2a:	8a 81       	ldd	r24, Y+2	; 0x02
    2c2c:	9b 81       	ldd	r25, Y+3	; 0x03
    2c2e:	0c 96       	adiw	r24, 0x0c	; 12
    2c30:	0e 94 71 04 	call	0x8e2	; 0x8e2 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2c34:	80 91 b6 0d 	lds	r24, 0x0DB6	; 0x800db6 <uxSchedulerSuspended>
    2c38:	88 23       	and	r24, r24
    2c3a:	69 f5       	brne	.+90     	; 0x2c96 <xTaskRemoveFromEventList+0x92>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    2c3c:	8a 81       	ldd	r24, Y+2	; 0x02
    2c3e:	9b 81       	ldd	r25, Y+3	; 0x03
    2c40:	02 96       	adiw	r24, 0x02	; 2
    2c42:	0e 94 71 04 	call	0x8e2	; 0x8e2 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    2c46:	8a 81       	ldd	r24, Y+2	; 0x02
    2c48:	9b 81       	ldd	r25, Y+3	; 0x03
    2c4a:	fc 01       	movw	r30, r24
    2c4c:	96 89       	ldd	r25, Z+22	; 0x16
    2c4e:	80 91 ac 0d 	lds	r24, 0x0DAC	; 0x800dac <uxTopReadyPriority>
    2c52:	89 17       	cp	r24, r25
    2c54:	30 f4       	brcc	.+12     	; 0x2c62 <xTaskRemoveFromEventList+0x5e>
    2c56:	8a 81       	ldd	r24, Y+2	; 0x02
    2c58:	9b 81       	ldd	r25, Y+3	; 0x03
    2c5a:	fc 01       	movw	r30, r24
    2c5c:	86 89       	ldd	r24, Z+22	; 0x16
    2c5e:	80 93 ac 0d 	sts	0x0DAC, r24	; 0x800dac <uxTopReadyPriority>
    2c62:	8a 81       	ldd	r24, Y+2	; 0x02
    2c64:	9b 81       	ldd	r25, Y+3	; 0x03
    2c66:	ac 01       	movw	r20, r24
    2c68:	4e 5f       	subi	r20, 0xFE	; 254
    2c6a:	5f 4f       	sbci	r21, 0xFF	; 255
    2c6c:	8a 81       	ldd	r24, Y+2	; 0x02
    2c6e:	9b 81       	ldd	r25, Y+3	; 0x03
    2c70:	fc 01       	movw	r30, r24
    2c72:	86 89       	ldd	r24, Z+22	; 0x16
    2c74:	28 2f       	mov	r18, r24
    2c76:	30 e0       	ldi	r19, 0x00	; 0
    2c78:	c9 01       	movw	r24, r18
    2c7a:	88 0f       	add	r24, r24
    2c7c:	99 1f       	adc	r25, r25
    2c7e:	88 0f       	add	r24, r24
    2c80:	99 1f       	adc	r25, r25
    2c82:	88 0f       	add	r24, r24
    2c84:	99 1f       	adc	r25, r25
    2c86:	82 0f       	add	r24, r18
    2c88:	93 1f       	adc	r25, r19
    2c8a:	84 5a       	subi	r24, 0xA4	; 164
    2c8c:	92 4f       	sbci	r25, 0xF2	; 242
    2c8e:	ba 01       	movw	r22, r20
    2c90:	0e 94 aa 03 	call	0x754	; 0x754 <vListInsertEnd>
    2c94:	08 c0       	rjmp	.+16     	; 0x2ca6 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2c96:	8a 81       	ldd	r24, Y+2	; 0x02
    2c98:	9b 81       	ldd	r25, Y+3	; 0x03
    2c9a:	0c 96       	adiw	r24, 0x0c	; 12
    2c9c:	bc 01       	movw	r22, r24
    2c9e:	86 e9       	ldi	r24, 0x96	; 150
    2ca0:	9d e0       	ldi	r25, 0x0D	; 13
    2ca2:	0e 94 aa 03 	call	0x754	; 0x754 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    2ca6:	8a 81       	ldd	r24, Y+2	; 0x02
    2ca8:	9b 81       	ldd	r25, Y+3	; 0x03
    2caa:	fc 01       	movw	r30, r24
    2cac:	26 89       	ldd	r18, Z+22	; 0x16
    2cae:	80 91 5a 0d 	lds	r24, 0x0D5A	; 0x800d5a <pxCurrentTCB>
    2cb2:	90 91 5b 0d 	lds	r25, 0x0D5B	; 0x800d5b <pxCurrentTCB+0x1>
    2cb6:	fc 01       	movw	r30, r24
    2cb8:	86 89       	ldd	r24, Z+22	; 0x16
    2cba:	82 17       	cp	r24, r18
    2cbc:	30 f4       	brcc	.+12     	; 0x2cca <xTaskRemoveFromEventList+0xc6>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    2cbe:	81 e0       	ldi	r24, 0x01	; 1
    2cc0:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    2cc2:	81 e0       	ldi	r24, 0x01	; 1
    2cc4:	80 93 af 0d 	sts	0x0DAF, r24	; 0x800daf <xYieldPending>
    2cc8:	01 c0       	rjmp	.+2      	; 0x2ccc <xTaskRemoveFromEventList+0xc8>
	}
	else
	{
		xReturn = pdFALSE;
    2cca:	19 82       	std	Y+1, r1	; 0x01
		ensure it is updated at the earliest possible time. */
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
    2ccc:	89 81       	ldd	r24, Y+1	; 0x01
}
    2cce:	0f 90       	pop	r0
    2cd0:	0f 90       	pop	r0
    2cd2:	0f 90       	pop	r0
    2cd4:	0f 90       	pop	r0
    2cd6:	0f 90       	pop	r0
    2cd8:	df 91       	pop	r29
    2cda:	cf 91       	pop	r28
    2cdc:	08 95       	ret

00002cde <xTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    2cde:	cf 93       	push	r28
    2ce0:	df 93       	push	r29
    2ce2:	cd b7       	in	r28, 0x3d	; 61
    2ce4:	de b7       	in	r29, 0x3e	; 62
    2ce6:	27 97       	sbiw	r28, 0x07	; 7
    2ce8:	0f b6       	in	r0, 0x3f	; 63
    2cea:	f8 94       	cli
    2cec:	de bf       	out	0x3e, r29	; 62
    2cee:	0f be       	out	0x3f, r0	; 63
    2cf0:	cd bf       	out	0x3d, r28	; 61
    2cf2:	9d 83       	std	Y+5, r25	; 0x05
    2cf4:	8c 83       	std	Y+4, r24	; 0x04
    2cf6:	7f 83       	std	Y+7, r23	; 0x07
    2cf8:	6e 83       	std	Y+6, r22	; 0x06
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    2cfa:	8e 81       	ldd	r24, Y+6	; 0x06
    2cfc:	9f 81       	ldd	r25, Y+7	; 0x07
    2cfe:	9c 01       	movw	r18, r24
    2d00:	30 68       	ori	r19, 0x80	; 128
    2d02:	8c 81       	ldd	r24, Y+4	; 0x04
    2d04:	9d 81       	ldd	r25, Y+5	; 0x05
    2d06:	fc 01       	movw	r30, r24
    2d08:	31 83       	std	Z+1, r19	; 0x01
    2d0a:	20 83       	st	Z, r18

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
    2d0c:	8c 81       	ldd	r24, Y+4	; 0x04
    2d0e:	9d 81       	ldd	r25, Y+5	; 0x05
    2d10:	fc 01       	movw	r30, r24
    2d12:	86 81       	ldd	r24, Z+6	; 0x06
    2d14:	97 81       	ldd	r25, Z+7	; 0x07
    2d16:	9b 83       	std	Y+3, r25	; 0x03
    2d18:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    2d1a:	8c 81       	ldd	r24, Y+4	; 0x04
    2d1c:	9d 81       	ldd	r25, Y+5	; 0x05
    2d1e:	0e 94 71 04 	call	0x8e2	; 0x8e2 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    2d22:	8a 81       	ldd	r24, Y+2	; 0x02
    2d24:	9b 81       	ldd	r25, Y+3	; 0x03
    2d26:	02 96       	adiw	r24, 0x02	; 2
    2d28:	0e 94 71 04 	call	0x8e2	; 0x8e2 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    2d2c:	8a 81       	ldd	r24, Y+2	; 0x02
    2d2e:	9b 81       	ldd	r25, Y+3	; 0x03
    2d30:	fc 01       	movw	r30, r24
    2d32:	96 89       	ldd	r25, Z+22	; 0x16
    2d34:	80 91 ac 0d 	lds	r24, 0x0DAC	; 0x800dac <uxTopReadyPriority>
    2d38:	89 17       	cp	r24, r25
    2d3a:	30 f4       	brcc	.+12     	; 0x2d48 <xTaskRemoveFromUnorderedEventList+0x6a>
    2d3c:	8a 81       	ldd	r24, Y+2	; 0x02
    2d3e:	9b 81       	ldd	r25, Y+3	; 0x03
    2d40:	fc 01       	movw	r30, r24
    2d42:	86 89       	ldd	r24, Z+22	; 0x16
    2d44:	80 93 ac 0d 	sts	0x0DAC, r24	; 0x800dac <uxTopReadyPriority>
    2d48:	8a 81       	ldd	r24, Y+2	; 0x02
    2d4a:	9b 81       	ldd	r25, Y+3	; 0x03
    2d4c:	ac 01       	movw	r20, r24
    2d4e:	4e 5f       	subi	r20, 0xFE	; 254
    2d50:	5f 4f       	sbci	r21, 0xFF	; 255
    2d52:	8a 81       	ldd	r24, Y+2	; 0x02
    2d54:	9b 81       	ldd	r25, Y+3	; 0x03
    2d56:	fc 01       	movw	r30, r24
    2d58:	86 89       	ldd	r24, Z+22	; 0x16
    2d5a:	28 2f       	mov	r18, r24
    2d5c:	30 e0       	ldi	r19, 0x00	; 0
    2d5e:	c9 01       	movw	r24, r18
    2d60:	88 0f       	add	r24, r24
    2d62:	99 1f       	adc	r25, r25
    2d64:	88 0f       	add	r24, r24
    2d66:	99 1f       	adc	r25, r25
    2d68:	88 0f       	add	r24, r24
    2d6a:	99 1f       	adc	r25, r25
    2d6c:	82 0f       	add	r24, r18
    2d6e:	93 1f       	adc	r25, r19
    2d70:	84 5a       	subi	r24, 0xA4	; 164
    2d72:	92 4f       	sbci	r25, 0xF2	; 242
    2d74:	ba 01       	movw	r22, r20
    2d76:	0e 94 aa 03 	call	0x754	; 0x754 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    2d7a:	8a 81       	ldd	r24, Y+2	; 0x02
    2d7c:	9b 81       	ldd	r25, Y+3	; 0x03
    2d7e:	fc 01       	movw	r30, r24
    2d80:	26 89       	ldd	r18, Z+22	; 0x16
    2d82:	80 91 5a 0d 	lds	r24, 0x0D5A	; 0x800d5a <pxCurrentTCB>
    2d86:	90 91 5b 0d 	lds	r25, 0x0D5B	; 0x800d5b <pxCurrentTCB+0x1>
    2d8a:	fc 01       	movw	r30, r24
    2d8c:	86 89       	ldd	r24, Z+22	; 0x16
    2d8e:	82 17       	cp	r24, r18
    2d90:	30 f4       	brcc	.+12     	; 0x2d9e <xTaskRemoveFromUnorderedEventList+0xc0>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    2d92:	81 e0       	ldi	r24, 0x01	; 1
    2d94:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    2d96:	81 e0       	ldi	r24, 0x01	; 1
    2d98:	80 93 af 0d 	sts	0x0DAF, r24	; 0x800daf <xYieldPending>
    2d9c:	01 c0       	rjmp	.+2      	; 0x2da0 <xTaskRemoveFromUnorderedEventList+0xc2>
	}
	else
	{
		xReturn = pdFALSE;
    2d9e:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2da0:	89 81       	ldd	r24, Y+1	; 0x01
}
    2da2:	27 96       	adiw	r28, 0x07	; 7
    2da4:	0f b6       	in	r0, 0x3f	; 63
    2da6:	f8 94       	cli
    2da8:	de bf       	out	0x3e, r29	; 62
    2daa:	0f be       	out	0x3f, r0	; 63
    2dac:	cd bf       	out	0x3d, r28	; 61
    2dae:	df 91       	pop	r29
    2db0:	cf 91       	pop	r28
    2db2:	08 95       	ret

00002db4 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    2db4:	cf 93       	push	r28
    2db6:	df 93       	push	r29
    2db8:	00 d0       	rcall	.+0      	; 0x2dba <vTaskSetTimeOutState+0x6>
    2dba:	cd b7       	in	r28, 0x3d	; 61
    2dbc:	de b7       	in	r29, 0x3e	; 62
    2dbe:	9a 83       	std	Y+2, r25	; 0x02
    2dc0:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2dc2:	20 91 b0 0d 	lds	r18, 0x0DB0	; 0x800db0 <xNumOfOverflows>
    2dc6:	89 81       	ldd	r24, Y+1	; 0x01
    2dc8:	9a 81       	ldd	r25, Y+2	; 0x02
    2dca:	fc 01       	movw	r30, r24
    2dcc:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    2dce:	20 91 aa 0d 	lds	r18, 0x0DAA	; 0x800daa <xTickCount>
    2dd2:	30 91 ab 0d 	lds	r19, 0x0DAB	; 0x800dab <xTickCount+0x1>
    2dd6:	89 81       	ldd	r24, Y+1	; 0x01
    2dd8:	9a 81       	ldd	r25, Y+2	; 0x02
    2dda:	fc 01       	movw	r30, r24
    2ddc:	32 83       	std	Z+2, r19	; 0x02
    2dde:	21 83       	std	Z+1, r18	; 0x01
}
    2de0:	00 00       	nop
    2de2:	0f 90       	pop	r0
    2de4:	0f 90       	pop	r0
    2de6:	df 91       	pop	r29
    2de8:	cf 91       	pop	r28
    2dea:	08 95       	ret

00002dec <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    2dec:	cf 93       	push	r28
    2dee:	df 93       	push	r29
    2df0:	cd b7       	in	r28, 0x3d	; 61
    2df2:	de b7       	in	r29, 0x3e	; 62
    2df4:	27 97       	sbiw	r28, 0x07	; 7
    2df6:	0f b6       	in	r0, 0x3f	; 63
    2df8:	f8 94       	cli
    2dfa:	de bf       	out	0x3e, r29	; 62
    2dfc:	0f be       	out	0x3f, r0	; 63
    2dfe:	cd bf       	out	0x3d, r28	; 61
    2e00:	9d 83       	std	Y+5, r25	; 0x05
    2e02:	8c 83       	std	Y+4, r24	; 0x04
    2e04:	7f 83       	std	Y+7, r23	; 0x07
    2e06:	6e 83       	std	Y+6, r22	; 0x06
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    2e08:	0f b6       	in	r0, 0x3f	; 63
    2e0a:	f8 94       	cli
    2e0c:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    2e0e:	80 91 aa 0d 	lds	r24, 0x0DAA	; 0x800daa <xTickCount>
    2e12:	90 91 ab 0d 	lds	r25, 0x0DAB	; 0x800dab <xTickCount+0x1>
    2e16:	9b 83       	std	Y+3, r25	; 0x03
    2e18:	8a 83       	std	Y+2, r24	; 0x02
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    2e1a:	8c 81       	ldd	r24, Y+4	; 0x04
    2e1c:	9d 81       	ldd	r25, Y+5	; 0x05
    2e1e:	fc 01       	movw	r30, r24
    2e20:	90 81       	ld	r25, Z
    2e22:	80 91 b0 0d 	lds	r24, 0x0DB0	; 0x800db0 <xNumOfOverflows>
    2e26:	98 17       	cp	r25, r24
    2e28:	69 f0       	breq	.+26     	; 0x2e44 <xTaskCheckForTimeOut+0x58>
    2e2a:	8c 81       	ldd	r24, Y+4	; 0x04
    2e2c:	9d 81       	ldd	r25, Y+5	; 0x05
    2e2e:	fc 01       	movw	r30, r24
    2e30:	21 81       	ldd	r18, Z+1	; 0x01
    2e32:	32 81       	ldd	r19, Z+2	; 0x02
    2e34:	8a 81       	ldd	r24, Y+2	; 0x02
    2e36:	9b 81       	ldd	r25, Y+3	; 0x03
    2e38:	82 17       	cp	r24, r18
    2e3a:	93 07       	cpc	r25, r19
    2e3c:	18 f0       	brcs	.+6      	; 0x2e44 <xTaskCheckForTimeOut+0x58>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    2e3e:	81 e0       	ldi	r24, 0x01	; 1
    2e40:	89 83       	std	Y+1, r24	; 0x01
    2e42:	30 c0       	rjmp	.+96     	; 0x2ea4 <xTaskCheckForTimeOut+0xb8>
		}
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    2e44:	8c 81       	ldd	r24, Y+4	; 0x04
    2e46:	9d 81       	ldd	r25, Y+5	; 0x05
    2e48:	fc 01       	movw	r30, r24
    2e4a:	81 81       	ldd	r24, Z+1	; 0x01
    2e4c:	92 81       	ldd	r25, Z+2	; 0x02
    2e4e:	2a 81       	ldd	r18, Y+2	; 0x02
    2e50:	3b 81       	ldd	r19, Y+3	; 0x03
    2e52:	28 1b       	sub	r18, r24
    2e54:	39 0b       	sbc	r19, r25
    2e56:	8e 81       	ldd	r24, Y+6	; 0x06
    2e58:	9f 81       	ldd	r25, Y+7	; 0x07
    2e5a:	fc 01       	movw	r30, r24
    2e5c:	80 81       	ld	r24, Z
    2e5e:	91 81       	ldd	r25, Z+1	; 0x01
    2e60:	28 17       	cp	r18, r24
    2e62:	39 07       	cpc	r19, r25
    2e64:	e8 f4       	brcc	.+58     	; 0x2ea0 <xTaskCheckForTimeOut+0xb4>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
    2e66:	8e 81       	ldd	r24, Y+6	; 0x06
    2e68:	9f 81       	ldd	r25, Y+7	; 0x07
    2e6a:	fc 01       	movw	r30, r24
    2e6c:	20 81       	ld	r18, Z
    2e6e:	31 81       	ldd	r19, Z+1	; 0x01
    2e70:	8c 81       	ldd	r24, Y+4	; 0x04
    2e72:	9d 81       	ldd	r25, Y+5	; 0x05
    2e74:	fc 01       	movw	r30, r24
    2e76:	41 81       	ldd	r20, Z+1	; 0x01
    2e78:	52 81       	ldd	r21, Z+2	; 0x02
    2e7a:	8a 81       	ldd	r24, Y+2	; 0x02
    2e7c:	9b 81       	ldd	r25, Y+3	; 0x03
    2e7e:	ba 01       	movw	r22, r20
    2e80:	68 1b       	sub	r22, r24
    2e82:	79 0b       	sbc	r23, r25
    2e84:	cb 01       	movw	r24, r22
    2e86:	28 0f       	add	r18, r24
    2e88:	39 1f       	adc	r19, r25
    2e8a:	8e 81       	ldd	r24, Y+6	; 0x06
    2e8c:	9f 81       	ldd	r25, Y+7	; 0x07
    2e8e:	fc 01       	movw	r30, r24
    2e90:	31 83       	std	Z+1, r19	; 0x01
    2e92:	20 83       	st	Z, r18
			vTaskSetTimeOutState( pxTimeOut );
    2e94:	8c 81       	ldd	r24, Y+4	; 0x04
    2e96:	9d 81       	ldd	r25, Y+5	; 0x05
    2e98:	0e 94 da 16 	call	0x2db4	; 0x2db4 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    2e9c:	19 82       	std	Y+1, r1	; 0x01
    2e9e:	02 c0       	rjmp	.+4      	; 0x2ea4 <xTaskCheckForTimeOut+0xb8>
		}
		else
		{
			xReturn = pdTRUE;
    2ea0:	81 e0       	ldi	r24, 0x01	; 1
    2ea2:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    2ea4:	0f 90       	pop	r0
    2ea6:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2ea8:	89 81       	ldd	r24, Y+1	; 0x01
}
    2eaa:	27 96       	adiw	r28, 0x07	; 7
    2eac:	0f b6       	in	r0, 0x3f	; 63
    2eae:	f8 94       	cli
    2eb0:	de bf       	out	0x3e, r29	; 62
    2eb2:	0f be       	out	0x3f, r0	; 63
    2eb4:	cd bf       	out	0x3d, r28	; 61
    2eb6:	df 91       	pop	r29
    2eb8:	cf 91       	pop	r28
    2eba:	08 95       	ret

00002ebc <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    2ebc:	cf 93       	push	r28
    2ebe:	df 93       	push	r29
    2ec0:	cd b7       	in	r28, 0x3d	; 61
    2ec2:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    2ec4:	81 e0       	ldi	r24, 0x01	; 1
    2ec6:	80 93 af 0d 	sts	0x0DAF, r24	; 0x800daf <xYieldPending>
}
    2eca:	00 00       	nop
    2ecc:	df 91       	pop	r29
    2ece:	cf 91       	pop	r28
    2ed0:	08 95       	ret

00002ed2 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    2ed2:	cf 93       	push	r28
    2ed4:	df 93       	push	r29
    2ed6:	00 d0       	rcall	.+0      	; 0x2ed8 <prvIdleTask+0x6>
    2ed8:	cd b7       	in	r28, 0x3d	; 61
    2eda:	de b7       	in	r29, 0x3e	; 62
    2edc:	9a 83       	std	Y+2, r25	; 0x02
    2ede:	89 83       	std	Y+1, r24	; 0x01

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
    2ee0:	0e 94 b9 17 	call	0x2f72	; 0x2f72 <prvCheckTasksWaitingTermination>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    2ee4:	80 91 5c 0d 	lds	r24, 0x0D5C	; 0x800d5c <pxReadyTasksLists>
    2ee8:	82 30       	cpi	r24, 0x02	; 2
    2eea:	10 f0       	brcs	.+4      	; 0x2ef0 <prvIdleTask+0x1e>
			{
				taskYIELD();
    2eec:	0e 94 ae 06 	call	0xd5c	; 0xd5c <vPortYield>
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
    2ef0:	0e 94 6a 1d 	call	0x3ad4	; 0x3ad4 <vApplicationIdleHook>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
    2ef4:	f5 cf       	rjmp	.-22     	; 0x2ee0 <prvIdleTask+0xe>

00002ef6 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    2ef6:	cf 93       	push	r28
    2ef8:	df 93       	push	r29
    2efa:	1f 92       	push	r1
    2efc:	cd b7       	in	r28, 0x3d	; 61
    2efe:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    2f00:	19 82       	std	Y+1, r1	; 0x01
    2f02:	13 c0       	rjmp	.+38     	; 0x2f2a <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    2f04:	89 81       	ldd	r24, Y+1	; 0x01
    2f06:	28 2f       	mov	r18, r24
    2f08:	30 e0       	ldi	r19, 0x00	; 0
    2f0a:	c9 01       	movw	r24, r18
    2f0c:	88 0f       	add	r24, r24
    2f0e:	99 1f       	adc	r25, r25
    2f10:	88 0f       	add	r24, r24
    2f12:	99 1f       	adc	r25, r25
    2f14:	88 0f       	add	r24, r24
    2f16:	99 1f       	adc	r25, r25
    2f18:	82 0f       	add	r24, r18
    2f1a:	93 1f       	adc	r25, r19
    2f1c:	84 5a       	subi	r24, 0xA4	; 164
    2f1e:	92 4f       	sbci	r25, 0xF2	; 242
    2f20:	0e 94 62 03 	call	0x6c4	; 0x6c4 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    2f24:	89 81       	ldd	r24, Y+1	; 0x01
    2f26:	8f 5f       	subi	r24, 0xFF	; 255
    2f28:	89 83       	std	Y+1, r24	; 0x01
    2f2a:	89 81       	ldd	r24, Y+1	; 0x01
    2f2c:	84 30       	cpi	r24, 0x04	; 4
    2f2e:	50 f3       	brcs	.-44     	; 0x2f04 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    2f30:	80 e8       	ldi	r24, 0x80	; 128
    2f32:	9d e0       	ldi	r25, 0x0D	; 13
    2f34:	0e 94 62 03 	call	0x6c4	; 0x6c4 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    2f38:	89 e8       	ldi	r24, 0x89	; 137
    2f3a:	9d e0       	ldi	r25, 0x0D	; 13
    2f3c:	0e 94 62 03 	call	0x6c4	; 0x6c4 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    2f40:	86 e9       	ldi	r24, 0x96	; 150
    2f42:	9d e0       	ldi	r25, 0x0D	; 13
    2f44:	0e 94 62 03 	call	0x6c4	; 0x6c4 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    2f48:	8f e9       	ldi	r24, 0x9F	; 159
    2f4a:	9d e0       	ldi	r25, 0x0D	; 13
    2f4c:	0e 94 62 03 	call	0x6c4	; 0x6c4 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    2f50:	80 e8       	ldi	r24, 0x80	; 128
    2f52:	9d e0       	ldi	r25, 0x0D	; 13
    2f54:	90 93 93 0d 	sts	0x0D93, r25	; 0x800d93 <pxDelayedTaskList+0x1>
    2f58:	80 93 92 0d 	sts	0x0D92, r24	; 0x800d92 <pxDelayedTaskList>
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    2f5c:	89 e8       	ldi	r24, 0x89	; 137
    2f5e:	9d e0       	ldi	r25, 0x0D	; 13
    2f60:	90 93 95 0d 	sts	0x0D95, r25	; 0x800d95 <pxOverflowDelayedTaskList+0x1>
    2f64:	80 93 94 0d 	sts	0x0D94, r24	; 0x800d94 <pxOverflowDelayedTaskList>
}
    2f68:	00 00       	nop
    2f6a:	0f 90       	pop	r0
    2f6c:	df 91       	pop	r29
    2f6e:	cf 91       	pop	r28
    2f70:	08 95       	ret

00002f72 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    2f72:	cf 93       	push	r28
    2f74:	df 93       	push	r29
    2f76:	00 d0       	rcall	.+0      	; 0x2f78 <prvCheckTasksWaitingTermination+0x6>
    2f78:	1f 92       	push	r1
    2f7a:	cd b7       	in	r28, 0x3d	; 61
    2f7c:	de b7       	in	r29, 0x3e	; 62
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    2f7e:	2f c0       	rjmp	.+94     	; 0x2fde <prvCheckTasksWaitingTermination+0x6c>
		{
			vTaskSuspendAll();
    2f80:	0e 94 54 13 	call	0x26a8	; 0x26a8 <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    2f84:	90 91 9f 0d 	lds	r25, 0x0D9F	; 0x800d9f <xTasksWaitingTermination>
    2f88:	81 e0       	ldi	r24, 0x01	; 1
    2f8a:	99 23       	and	r25, r25
    2f8c:	09 f0       	breq	.+2      	; 0x2f90 <prvCheckTasksWaitingTermination+0x1e>
    2f8e:	80 e0       	ldi	r24, 0x00	; 0
    2f90:	89 83       	std	Y+1, r24	; 0x01
			}
			( void ) xTaskResumeAll();
    2f92:	0e 94 61 13 	call	0x26c2	; 0x26c2 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    2f96:	89 81       	ldd	r24, Y+1	; 0x01
    2f98:	88 23       	and	r24, r24
    2f9a:	09 f5       	brne	.+66     	; 0x2fde <prvCheckTasksWaitingTermination+0x6c>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
    2f9c:	0f b6       	in	r0, 0x3f	; 63
    2f9e:	f8 94       	cli
    2fa0:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    2fa2:	80 91 a4 0d 	lds	r24, 0x0DA4	; 0x800da4 <xTasksWaitingTermination+0x5>
    2fa6:	90 91 a5 0d 	lds	r25, 0x0DA5	; 0x800da5 <xTasksWaitingTermination+0x6>
    2faa:	fc 01       	movw	r30, r24
    2fac:	86 81       	ldd	r24, Z+6	; 0x06
    2fae:	97 81       	ldd	r25, Z+7	; 0x07
    2fb0:	9b 83       	std	Y+3, r25	; 0x03
    2fb2:	8a 83       	std	Y+2, r24	; 0x02
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    2fb4:	8a 81       	ldd	r24, Y+2	; 0x02
    2fb6:	9b 81       	ldd	r25, Y+3	; 0x03
    2fb8:	02 96       	adiw	r24, 0x02	; 2
    2fba:	0e 94 71 04 	call	0x8e2	; 0x8e2 <uxListRemove>
					--uxCurrentNumberOfTasks;
    2fbe:	80 91 a9 0d 	lds	r24, 0x0DA9	; 0x800da9 <uxCurrentNumberOfTasks>
    2fc2:	81 50       	subi	r24, 0x01	; 1
    2fc4:	80 93 a9 0d 	sts	0x0DA9, r24	; 0x800da9 <uxCurrentNumberOfTasks>
					--uxDeletedTasksWaitingCleanUp;
    2fc8:	80 91 a8 0d 	lds	r24, 0x0DA8	; 0x800da8 <uxDeletedTasksWaitingCleanUp>
    2fcc:	81 50       	subi	r24, 0x01	; 1
    2fce:	80 93 a8 0d 	sts	0x0DA8, r24	; 0x800da8 <uxDeletedTasksWaitingCleanUp>
				}
				taskEXIT_CRITICAL();
    2fd2:	0f 90       	pop	r0
    2fd4:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    2fd6:	8a 81       	ldd	r24, Y+2	; 0x02
    2fd8:	9b 81       	ldd	r25, Y+3	; 0x03
    2fda:	0e 94 fa 17 	call	0x2ff4	; 0x2ff4 <prvDeleteTCB>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    2fde:	80 91 a8 0d 	lds	r24, 0x0DA8	; 0x800da8 <uxDeletedTasksWaitingCleanUp>
    2fe2:	88 23       	and	r24, r24
    2fe4:	69 f6       	brne	.-102    	; 0x2f80 <prvCheckTasksWaitingTermination+0xe>
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
    2fe6:	00 00       	nop
    2fe8:	0f 90       	pop	r0
    2fea:	0f 90       	pop	r0
    2fec:	0f 90       	pop	r0
    2fee:	df 91       	pop	r29
    2ff0:	cf 91       	pop	r28
    2ff2:	08 95       	ret

00002ff4 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    2ff4:	cf 93       	push	r28
    2ff6:	df 93       	push	r29
    2ff8:	00 d0       	rcall	.+0      	; 0x2ffa <prvDeleteTCB+0x6>
    2ffa:	cd b7       	in	r28, 0x3d	; 61
    2ffc:	de b7       	in	r29, 0x3e	; 62
    2ffe:	9a 83       	std	Y+2, r25	; 0x02
    3000:	89 83       	std	Y+1, r24	; 0x01

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
    3002:	89 81       	ldd	r24, Y+1	; 0x01
    3004:	9a 81       	ldd	r25, Y+2	; 0x02
    3006:	fc 01       	movw	r30, r24
    3008:	87 89       	ldd	r24, Z+23	; 0x17
    300a:	90 8d       	ldd	r25, Z+24	; 0x18
    300c:	0e 94 21 08 	call	0x1042	; 0x1042 <vPortFree>
			vPortFree( pxTCB );
    3010:	89 81       	ldd	r24, Y+1	; 0x01
    3012:	9a 81       	ldd	r25, Y+2	; 0x02
    3014:	0e 94 21 08 	call	0x1042	; 0x1042 <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	)
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
    3018:	00 00       	nop
    301a:	0f 90       	pop	r0
    301c:	0f 90       	pop	r0
    301e:	df 91       	pop	r29
    3020:	cf 91       	pop	r28
    3022:	08 95       	ret

00003024 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    3024:	cf 93       	push	r28
    3026:	df 93       	push	r29
    3028:	00 d0       	rcall	.+0      	; 0x302a <prvResetNextTaskUnblockTime+0x6>
    302a:	cd b7       	in	r28, 0x3d	; 61
    302c:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    302e:	80 91 92 0d 	lds	r24, 0x0D92	; 0x800d92 <pxDelayedTaskList>
    3032:	90 91 93 0d 	lds	r25, 0x0D93	; 0x800d93 <pxDelayedTaskList+0x1>
    3036:	fc 01       	movw	r30, r24
    3038:	80 81       	ld	r24, Z
    303a:	88 23       	and	r24, r24
    303c:	39 f4       	brne	.+14     	; 0x304c <prvResetNextTaskUnblockTime+0x28>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    303e:	8f ef       	ldi	r24, 0xFF	; 255
    3040:	9f ef       	ldi	r25, 0xFF	; 255
    3042:	90 93 b3 0d 	sts	0x0DB3, r25	; 0x800db3 <xNextTaskUnblockTime+0x1>
    3046:	80 93 b2 0d 	sts	0x0DB2, r24	; 0x800db2 <xNextTaskUnblockTime>
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
	}
}
    304a:	15 c0       	rjmp	.+42     	; 0x3076 <prvResetNextTaskUnblockTime+0x52>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    304c:	80 91 92 0d 	lds	r24, 0x0D92	; 0x800d92 <pxDelayedTaskList>
    3050:	90 91 93 0d 	lds	r25, 0x0D93	; 0x800d93 <pxDelayedTaskList+0x1>
    3054:	fc 01       	movw	r30, r24
    3056:	85 81       	ldd	r24, Z+5	; 0x05
    3058:	96 81       	ldd	r25, Z+6	; 0x06
    305a:	fc 01       	movw	r30, r24
    305c:	86 81       	ldd	r24, Z+6	; 0x06
    305e:	97 81       	ldd	r25, Z+7	; 0x07
    3060:	9a 83       	std	Y+2, r25	; 0x02
    3062:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    3064:	89 81       	ldd	r24, Y+1	; 0x01
    3066:	9a 81       	ldd	r25, Y+2	; 0x02
    3068:	fc 01       	movw	r30, r24
    306a:	82 81       	ldd	r24, Z+2	; 0x02
    306c:	93 81       	ldd	r25, Z+3	; 0x03
    306e:	90 93 b3 0d 	sts	0x0DB3, r25	; 0x800db3 <xNextTaskUnblockTime+0x1>
    3072:	80 93 b2 0d 	sts	0x0DB2, r24	; 0x800db2 <xNextTaskUnblockTime>
	}
}
    3076:	00 00       	nop
    3078:	0f 90       	pop	r0
    307a:	0f 90       	pop	r0
    307c:	df 91       	pop	r29
    307e:	cf 91       	pop	r28
    3080:	08 95       	ret

00003082 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    3082:	cf 93       	push	r28
    3084:	df 93       	push	r29
    3086:	00 d0       	rcall	.+0      	; 0x3088 <uxTaskResetEventItemValue+0x6>
    3088:	cd b7       	in	r28, 0x3d	; 61
    308a:	de b7       	in	r29, 0x3e	; 62
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    308c:	80 91 5a 0d 	lds	r24, 0x0D5A	; 0x800d5a <pxCurrentTCB>
    3090:	90 91 5b 0d 	lds	r25, 0x0D5B	; 0x800d5b <pxCurrentTCB+0x1>
    3094:	fc 01       	movw	r30, r24
    3096:	84 85       	ldd	r24, Z+12	; 0x0c
    3098:	95 85       	ldd	r25, Z+13	; 0x0d
    309a:	9a 83       	std	Y+2, r25	; 0x02
    309c:	89 83       	std	Y+1, r24	; 0x01

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    309e:	80 91 5a 0d 	lds	r24, 0x0D5A	; 0x800d5a <pxCurrentTCB>
    30a2:	90 91 5b 0d 	lds	r25, 0x0D5B	; 0x800d5b <pxCurrentTCB+0x1>
    30a6:	20 91 5a 0d 	lds	r18, 0x0D5A	; 0x800d5a <pxCurrentTCB>
    30aa:	30 91 5b 0d 	lds	r19, 0x0D5B	; 0x800d5b <pxCurrentTCB+0x1>
    30ae:	f9 01       	movw	r30, r18
    30b0:	26 89       	ldd	r18, Z+22	; 0x16
    30b2:	22 2f       	mov	r18, r18
    30b4:	30 e0       	ldi	r19, 0x00	; 0
    30b6:	44 e0       	ldi	r20, 0x04	; 4
    30b8:	50 e0       	ldi	r21, 0x00	; 0
    30ba:	ba 01       	movw	r22, r20
    30bc:	62 1b       	sub	r22, r18
    30be:	73 0b       	sbc	r23, r19
    30c0:	9b 01       	movw	r18, r22
    30c2:	fc 01       	movw	r30, r24
    30c4:	35 87       	std	Z+13, r19	; 0x0d
    30c6:	24 87       	std	Z+12, r18	; 0x0c

	return uxReturn;
    30c8:	89 81       	ldd	r24, Y+1	; 0x01
    30ca:	9a 81       	ldd	r25, Y+2	; 0x02
}
    30cc:	0f 90       	pop	r0
    30ce:	0f 90       	pop	r0
    30d0:	df 91       	pop	r29
    30d2:	cf 91       	pop	r28
    30d4:	08 95       	ret

000030d6 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    30d6:	cf 93       	push	r28
    30d8:	df 93       	push	r29
    30da:	cd b7       	in	r28, 0x3d	; 61
    30dc:	de b7       	in	r29, 0x3e	; 62
    30de:	27 97       	sbiw	r28, 0x07	; 7
    30e0:	0f b6       	in	r0, 0x3f	; 63
    30e2:	f8 94       	cli
    30e4:	de bf       	out	0x3e, r29	; 62
    30e6:	0f be       	out	0x3f, r0	; 63
    30e8:	cd bf       	out	0x3d, r28	; 61
    30ea:	8d 83       	std	Y+5, r24	; 0x05
    30ec:	7f 83       	std	Y+7, r23	; 0x07
    30ee:	6e 83       	std	Y+6, r22	; 0x06
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    30f0:	0f b6       	in	r0, 0x3f	; 63
    30f2:	f8 94       	cli
    30f4:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    30f6:	80 91 5a 0d 	lds	r24, 0x0D5A	; 0x800d5a <pxCurrentTCB>
    30fa:	90 91 5b 0d 	lds	r25, 0x0D5B	; 0x800d5b <pxCurrentTCB+0x1>
    30fe:	fc 01       	movw	r30, r24
    3100:	81 a1       	ldd	r24, Z+33	; 0x21
    3102:	92 a1       	ldd	r25, Z+34	; 0x22
    3104:	a3 a1       	ldd	r26, Z+35	; 0x23
    3106:	b4 a1       	ldd	r27, Z+36	; 0x24
    3108:	89 2b       	or	r24, r25
    310a:	8a 2b       	or	r24, r26
    310c:	8b 2b       	or	r24, r27
    310e:	91 f4       	brne	.+36     	; 0x3134 <ulTaskNotifyTake+0x5e>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    3110:	80 91 5a 0d 	lds	r24, 0x0D5A	; 0x800d5a <pxCurrentTCB>
    3114:	90 91 5b 0d 	lds	r25, 0x0D5B	; 0x800d5b <pxCurrentTCB+0x1>
    3118:	21 e0       	ldi	r18, 0x01	; 1
    311a:	fc 01       	movw	r30, r24
    311c:	25 a3       	std	Z+37, r18	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    311e:	8e 81       	ldd	r24, Y+6	; 0x06
    3120:	9f 81       	ldd	r25, Y+7	; 0x07
    3122:	89 2b       	or	r24, r25
    3124:	39 f0       	breq	.+14     	; 0x3134 <ulTaskNotifyTake+0x5e>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    3126:	8e 81       	ldd	r24, Y+6	; 0x06
    3128:	9f 81       	ldd	r25, Y+7	; 0x07
    312a:	61 e0       	ldi	r22, 0x01	; 1
    312c:	0e 94 2b 1c 	call	0x3856	; 0x3856 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    3130:	0e 94 ae 06 	call	0xd5c	; 0xd5c <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    3134:	0f 90       	pop	r0
    3136:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    3138:	0f b6       	in	r0, 0x3f	; 63
    313a:	f8 94       	cli
    313c:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    313e:	80 91 5a 0d 	lds	r24, 0x0D5A	; 0x800d5a <pxCurrentTCB>
    3142:	90 91 5b 0d 	lds	r25, 0x0D5B	; 0x800d5b <pxCurrentTCB+0x1>
    3146:	fc 01       	movw	r30, r24
    3148:	81 a1       	ldd	r24, Z+33	; 0x21
    314a:	92 a1       	ldd	r25, Z+34	; 0x22
    314c:	a3 a1       	ldd	r26, Z+35	; 0x23
    314e:	b4 a1       	ldd	r27, Z+36	; 0x24
    3150:	89 83       	std	Y+1, r24	; 0x01
    3152:	9a 83       	std	Y+2, r25	; 0x02
    3154:	ab 83       	std	Y+3, r26	; 0x03
    3156:	bc 83       	std	Y+4, r27	; 0x04

			if( ulReturn != 0UL )
    3158:	89 81       	ldd	r24, Y+1	; 0x01
    315a:	9a 81       	ldd	r25, Y+2	; 0x02
    315c:	ab 81       	ldd	r26, Y+3	; 0x03
    315e:	bc 81       	ldd	r27, Y+4	; 0x04
    3160:	89 2b       	or	r24, r25
    3162:	8a 2b       	or	r24, r26
    3164:	8b 2b       	or	r24, r27
    3166:	e9 f0       	breq	.+58     	; 0x31a2 <ulTaskNotifyTake+0xcc>
			{
				if( xClearCountOnExit != pdFALSE )
    3168:	8d 81       	ldd	r24, Y+5	; 0x05
    316a:	88 23       	and	r24, r24
    316c:	51 f0       	breq	.+20     	; 0x3182 <ulTaskNotifyTake+0xac>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    316e:	80 91 5a 0d 	lds	r24, 0x0D5A	; 0x800d5a <pxCurrentTCB>
    3172:	90 91 5b 0d 	lds	r25, 0x0D5B	; 0x800d5b <pxCurrentTCB+0x1>
    3176:	fc 01       	movw	r30, r24
    3178:	11 a2       	std	Z+33, r1	; 0x21
    317a:	12 a2       	std	Z+34, r1	; 0x22
    317c:	13 a2       	std	Z+35, r1	; 0x23
    317e:	14 a2       	std	Z+36, r1	; 0x24
    3180:	10 c0       	rjmp	.+32     	; 0x31a2 <ulTaskNotifyTake+0xcc>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - 1;
    3182:	20 91 5a 0d 	lds	r18, 0x0D5A	; 0x800d5a <pxCurrentTCB>
    3186:	30 91 5b 0d 	lds	r19, 0x0D5B	; 0x800d5b <pxCurrentTCB+0x1>
    318a:	89 81       	ldd	r24, Y+1	; 0x01
    318c:	9a 81       	ldd	r25, Y+2	; 0x02
    318e:	ab 81       	ldd	r26, Y+3	; 0x03
    3190:	bc 81       	ldd	r27, Y+4	; 0x04
    3192:	01 97       	sbiw	r24, 0x01	; 1
    3194:	a1 09       	sbc	r26, r1
    3196:	b1 09       	sbc	r27, r1
    3198:	f9 01       	movw	r30, r18
    319a:	81 a3       	std	Z+33, r24	; 0x21
    319c:	92 a3       	std	Z+34, r25	; 0x22
    319e:	a3 a3       	std	Z+35, r26	; 0x23
    31a0:	b4 a3       	std	Z+36, r27	; 0x24
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    31a2:	80 91 5a 0d 	lds	r24, 0x0D5A	; 0x800d5a <pxCurrentTCB>
    31a6:	90 91 5b 0d 	lds	r25, 0x0D5B	; 0x800d5b <pxCurrentTCB+0x1>
    31aa:	fc 01       	movw	r30, r24
    31ac:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    31ae:	0f 90       	pop	r0
    31b0:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
    31b2:	89 81       	ldd	r24, Y+1	; 0x01
    31b4:	9a 81       	ldd	r25, Y+2	; 0x02
    31b6:	ab 81       	ldd	r26, Y+3	; 0x03
    31b8:	bc 81       	ldd	r27, Y+4	; 0x04
	}
    31ba:	bc 01       	movw	r22, r24
    31bc:	cd 01       	movw	r24, r26
    31be:	27 96       	adiw	r28, 0x07	; 7
    31c0:	0f b6       	in	r0, 0x3f	; 63
    31c2:	f8 94       	cli
    31c4:	de bf       	out	0x3e, r29	; 62
    31c6:	0f be       	out	0x3f, r0	; 63
    31c8:	cd bf       	out	0x3d, r28	; 61
    31ca:	df 91       	pop	r29
    31cc:	cf 91       	pop	r28
    31ce:	08 95       	ret

000031d0 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    31d0:	ef 92       	push	r14
    31d2:	ff 92       	push	r15
    31d4:	0f 93       	push	r16
    31d6:	1f 93       	push	r17
    31d8:	cf 93       	push	r28
    31da:	df 93       	push	r29
    31dc:	cd b7       	in	r28, 0x3d	; 61
    31de:	de b7       	in	r29, 0x3e	; 62
    31e0:	2d 97       	sbiw	r28, 0x0d	; 13
    31e2:	0f b6       	in	r0, 0x3f	; 63
    31e4:	f8 94       	cli
    31e6:	de bf       	out	0x3e, r29	; 62
    31e8:	0f be       	out	0x3f, r0	; 63
    31ea:	cd bf       	out	0x3d, r28	; 61
    31ec:	6a 83       	std	Y+2, r22	; 0x02
    31ee:	7b 83       	std	Y+3, r23	; 0x03
    31f0:	8c 83       	std	Y+4, r24	; 0x04
    31f2:	9d 83       	std	Y+5, r25	; 0x05
    31f4:	2e 83       	std	Y+6, r18	; 0x06
    31f6:	3f 83       	std	Y+7, r19	; 0x07
    31f8:	48 87       	std	Y+8, r20	; 0x08
    31fa:	59 87       	std	Y+9, r21	; 0x09
    31fc:	1b 87       	std	Y+11, r17	; 0x0b
    31fe:	0a 87       	std	Y+10, r16	; 0x0a
    3200:	fd 86       	std	Y+13, r15	; 0x0d
    3202:	ec 86       	std	Y+12, r14	; 0x0c
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    3204:	0f b6       	in	r0, 0x3f	; 63
    3206:	f8 94       	cli
    3208:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    320a:	80 91 5a 0d 	lds	r24, 0x0D5A	; 0x800d5a <pxCurrentTCB>
    320e:	90 91 5b 0d 	lds	r25, 0x0D5B	; 0x800d5b <pxCurrentTCB+0x1>
    3212:	fc 01       	movw	r30, r24
    3214:	85 a1       	ldd	r24, Z+37	; 0x25
    3216:	82 30       	cpi	r24, 0x02	; 2
    3218:	61 f1       	breq	.+88     	; 0x3272 <xTaskNotifyWait+0xa2>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    321a:	60 91 5a 0d 	lds	r22, 0x0D5A	; 0x800d5a <pxCurrentTCB>
    321e:	70 91 5b 0d 	lds	r23, 0x0D5B	; 0x800d5b <pxCurrentTCB+0x1>
    3222:	fb 01       	movw	r30, r22
    3224:	21 a1       	ldd	r18, Z+33	; 0x21
    3226:	32 a1       	ldd	r19, Z+34	; 0x22
    3228:	43 a1       	ldd	r20, Z+35	; 0x23
    322a:	54 a1       	ldd	r21, Z+36	; 0x24
    322c:	8a 81       	ldd	r24, Y+2	; 0x02
    322e:	9b 81       	ldd	r25, Y+3	; 0x03
    3230:	ac 81       	ldd	r26, Y+4	; 0x04
    3232:	bd 81       	ldd	r27, Y+5	; 0x05
    3234:	80 95       	com	r24
    3236:	90 95       	com	r25
    3238:	a0 95       	com	r26
    323a:	b0 95       	com	r27
    323c:	82 23       	and	r24, r18
    323e:	93 23       	and	r25, r19
    3240:	a4 23       	and	r26, r20
    3242:	b5 23       	and	r27, r21
    3244:	fb 01       	movw	r30, r22
    3246:	81 a3       	std	Z+33, r24	; 0x21
    3248:	92 a3       	std	Z+34, r25	; 0x22
    324a:	a3 a3       	std	Z+35, r26	; 0x23
    324c:	b4 a3       	std	Z+36, r27	; 0x24

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    324e:	80 91 5a 0d 	lds	r24, 0x0D5A	; 0x800d5a <pxCurrentTCB>
    3252:	90 91 5b 0d 	lds	r25, 0x0D5B	; 0x800d5b <pxCurrentTCB+0x1>
    3256:	21 e0       	ldi	r18, 0x01	; 1
    3258:	fc 01       	movw	r30, r24
    325a:	25 a3       	std	Z+37, r18	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    325c:	8c 85       	ldd	r24, Y+12	; 0x0c
    325e:	9d 85       	ldd	r25, Y+13	; 0x0d
    3260:	89 2b       	or	r24, r25
    3262:	39 f0       	breq	.+14     	; 0x3272 <xTaskNotifyWait+0xa2>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    3264:	8c 85       	ldd	r24, Y+12	; 0x0c
    3266:	9d 85       	ldd	r25, Y+13	; 0x0d
    3268:	61 e0       	ldi	r22, 0x01	; 1
    326a:	0e 94 2b 1c 	call	0x3856	; 0x3856 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    326e:	0e 94 ae 06 	call	0xd5c	; 0xd5c <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    3272:	0f 90       	pop	r0
    3274:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    3276:	0f b6       	in	r0, 0x3f	; 63
    3278:	f8 94       	cli
    327a:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    327c:	8a 85       	ldd	r24, Y+10	; 0x0a
    327e:	9b 85       	ldd	r25, Y+11	; 0x0b
    3280:	89 2b       	or	r24, r25
    3282:	81 f0       	breq	.+32     	; 0x32a4 <xTaskNotifyWait+0xd4>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    3284:	80 91 5a 0d 	lds	r24, 0x0D5A	; 0x800d5a <pxCurrentTCB>
    3288:	90 91 5b 0d 	lds	r25, 0x0D5B	; 0x800d5b <pxCurrentTCB+0x1>
    328c:	fc 01       	movw	r30, r24
    328e:	81 a1       	ldd	r24, Z+33	; 0x21
    3290:	92 a1       	ldd	r25, Z+34	; 0x22
    3292:	a3 a1       	ldd	r26, Z+35	; 0x23
    3294:	b4 a1       	ldd	r27, Z+36	; 0x24
    3296:	2a 85       	ldd	r18, Y+10	; 0x0a
    3298:	3b 85       	ldd	r19, Y+11	; 0x0b
    329a:	f9 01       	movw	r30, r18
    329c:	80 83       	st	Z, r24
    329e:	91 83       	std	Z+1, r25	; 0x01
    32a0:	a2 83       	std	Z+2, r26	; 0x02
    32a2:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState == taskWAITING_NOTIFICATION )
    32a4:	80 91 5a 0d 	lds	r24, 0x0D5A	; 0x800d5a <pxCurrentTCB>
    32a8:	90 91 5b 0d 	lds	r25, 0x0D5B	; 0x800d5b <pxCurrentTCB+0x1>
    32ac:	fc 01       	movw	r30, r24
    32ae:	85 a1       	ldd	r24, Z+37	; 0x25
    32b0:	81 30       	cpi	r24, 0x01	; 1
    32b2:	11 f4       	brne	.+4      	; 0x32b8 <xTaskNotifyWait+0xe8>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    32b4:	19 82       	std	Y+1, r1	; 0x01
    32b6:	1c c0       	rjmp	.+56     	; 0x32f0 <xTaskNotifyWait+0x120>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    32b8:	60 91 5a 0d 	lds	r22, 0x0D5A	; 0x800d5a <pxCurrentTCB>
    32bc:	70 91 5b 0d 	lds	r23, 0x0D5B	; 0x800d5b <pxCurrentTCB+0x1>
    32c0:	fb 01       	movw	r30, r22
    32c2:	21 a1       	ldd	r18, Z+33	; 0x21
    32c4:	32 a1       	ldd	r19, Z+34	; 0x22
    32c6:	43 a1       	ldd	r20, Z+35	; 0x23
    32c8:	54 a1       	ldd	r21, Z+36	; 0x24
    32ca:	8e 81       	ldd	r24, Y+6	; 0x06
    32cc:	9f 81       	ldd	r25, Y+7	; 0x07
    32ce:	a8 85       	ldd	r26, Y+8	; 0x08
    32d0:	b9 85       	ldd	r27, Y+9	; 0x09
    32d2:	80 95       	com	r24
    32d4:	90 95       	com	r25
    32d6:	a0 95       	com	r26
    32d8:	b0 95       	com	r27
    32da:	82 23       	and	r24, r18
    32dc:	93 23       	and	r25, r19
    32de:	a4 23       	and	r26, r20
    32e0:	b5 23       	and	r27, r21
    32e2:	fb 01       	movw	r30, r22
    32e4:	81 a3       	std	Z+33, r24	; 0x21
    32e6:	92 a3       	std	Z+34, r25	; 0x22
    32e8:	a3 a3       	std	Z+35, r26	; 0x23
    32ea:	b4 a3       	std	Z+36, r27	; 0x24
				xReturn = pdTRUE;
    32ec:	81 e0       	ldi	r24, 0x01	; 1
    32ee:	89 83       	std	Y+1, r24	; 0x01
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    32f0:	80 91 5a 0d 	lds	r24, 0x0D5A	; 0x800d5a <pxCurrentTCB>
    32f4:	90 91 5b 0d 	lds	r25, 0x0D5B	; 0x800d5b <pxCurrentTCB+0x1>
    32f8:	fc 01       	movw	r30, r24
    32fa:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    32fc:	0f 90       	pop	r0
    32fe:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    3300:	89 81       	ldd	r24, Y+1	; 0x01
	}
    3302:	2d 96       	adiw	r28, 0x0d	; 13
    3304:	0f b6       	in	r0, 0x3f	; 63
    3306:	f8 94       	cli
    3308:	de bf       	out	0x3e, r29	; 62
    330a:	0f be       	out	0x3f, r0	; 63
    330c:	cd bf       	out	0x3d, r28	; 61
    330e:	df 91       	pop	r29
    3310:	cf 91       	pop	r28
    3312:	1f 91       	pop	r17
    3314:	0f 91       	pop	r16
    3316:	ff 90       	pop	r15
    3318:	ef 90       	pop	r14
    331a:	08 95       	ret

0000331c <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    331c:	0f 93       	push	r16
    331e:	1f 93       	push	r17
    3320:	cf 93       	push	r28
    3322:	df 93       	push	r29
    3324:	cd b7       	in	r28, 0x3d	; 61
    3326:	de b7       	in	r29, 0x3e	; 62
    3328:	2d 97       	sbiw	r28, 0x0d	; 13
    332a:	0f b6       	in	r0, 0x3f	; 63
    332c:	f8 94       	cli
    332e:	de bf       	out	0x3e, r29	; 62
    3330:	0f be       	out	0x3f, r0	; 63
    3332:	cd bf       	out	0x3d, r28	; 61
    3334:	9e 83       	std	Y+6, r25	; 0x06
    3336:	8d 83       	std	Y+5, r24	; 0x05
    3338:	4f 83       	std	Y+7, r20	; 0x07
    333a:	58 87       	std	Y+8, r21	; 0x08
    333c:	69 87       	std	Y+9, r22	; 0x09
    333e:	7a 87       	std	Y+10, r23	; 0x0a
    3340:	2b 87       	std	Y+11, r18	; 0x0b
    3342:	1d 87       	std	Y+13, r17	; 0x0d
    3344:	0c 87       	std	Y+12, r16	; 0x0c
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    3346:	81 e0       	ldi	r24, 0x01	; 1
    3348:	89 83       	std	Y+1, r24	; 0x01
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = ( TCB_t * ) xTaskToNotify;
    334a:	8d 81       	ldd	r24, Y+5	; 0x05
    334c:	9e 81       	ldd	r25, Y+6	; 0x06
    334e:	9b 83       	std	Y+3, r25	; 0x03
    3350:	8a 83       	std	Y+2, r24	; 0x02

		taskENTER_CRITICAL();
    3352:	0f b6       	in	r0, 0x3f	; 63
    3354:	f8 94       	cli
    3356:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    3358:	8c 85       	ldd	r24, Y+12	; 0x0c
    335a:	9d 85       	ldd	r25, Y+13	; 0x0d
    335c:	89 2b       	or	r24, r25
    335e:	71 f0       	breq	.+28     	; 0x337c <xTaskGenericNotify+0x60>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    3360:	8a 81       	ldd	r24, Y+2	; 0x02
    3362:	9b 81       	ldd	r25, Y+3	; 0x03
    3364:	fc 01       	movw	r30, r24
    3366:	81 a1       	ldd	r24, Z+33	; 0x21
    3368:	92 a1       	ldd	r25, Z+34	; 0x22
    336a:	a3 a1       	ldd	r26, Z+35	; 0x23
    336c:	b4 a1       	ldd	r27, Z+36	; 0x24
    336e:	2c 85       	ldd	r18, Y+12	; 0x0c
    3370:	3d 85       	ldd	r19, Y+13	; 0x0d
    3372:	f9 01       	movw	r30, r18
    3374:	80 83       	st	Z, r24
    3376:	91 83       	std	Z+1, r25	; 0x01
    3378:	a2 83       	std	Z+2, r26	; 0x02
    337a:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    337c:	8a 81       	ldd	r24, Y+2	; 0x02
    337e:	9b 81       	ldd	r25, Y+3	; 0x03
    3380:	fc 01       	movw	r30, r24
    3382:	85 a1       	ldd	r24, Z+37	; 0x25
    3384:	8c 83       	std	Y+4, r24	; 0x04

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    3386:	8a 81       	ldd	r24, Y+2	; 0x02
    3388:	9b 81       	ldd	r25, Y+3	; 0x03
    338a:	22 e0       	ldi	r18, 0x02	; 2
    338c:	fc 01       	movw	r30, r24
    338e:	25 a3       	std	Z+37, r18	; 0x25

			switch( eAction )
    3390:	8b 85       	ldd	r24, Y+11	; 0x0b
    3392:	88 2f       	mov	r24, r24
    3394:	90 e0       	ldi	r25, 0x00	; 0
    3396:	82 30       	cpi	r24, 0x02	; 2
    3398:	91 05       	cpc	r25, r1
    339a:	31 f1       	breq	.+76     	; 0x33e8 <xTaskGenericNotify+0xcc>
    339c:	83 30       	cpi	r24, 0x03	; 3
    339e:	91 05       	cpc	r25, r1
    33a0:	34 f4       	brge	.+12     	; 0x33ae <xTaskGenericNotify+0x92>
    33a2:	00 97       	sbiw	r24, 0x00	; 0
    33a4:	09 f4       	brne	.+2      	; 0x33a8 <xTaskGenericNotify+0x8c>
    33a6:	4f c0       	rjmp	.+158    	; 0x3446 <xTaskGenericNotify+0x12a>
    33a8:	01 97       	sbiw	r24, 0x01	; 1
    33aa:	39 f0       	breq	.+14     	; 0x33ba <xTaskGenericNotify+0x9e>
    33ac:	4d c0       	rjmp	.+154    	; 0x3448 <xTaskGenericNotify+0x12c>
    33ae:	83 30       	cpi	r24, 0x03	; 3
    33b0:	91 05       	cpc	r25, r1
    33b2:	61 f1       	breq	.+88     	; 0x340c <xTaskGenericNotify+0xf0>
    33b4:	04 97       	sbiw	r24, 0x04	; 4
    33b6:	b1 f1       	breq	.+108    	; 0x3424 <xTaskGenericNotify+0x108>
    33b8:	47 c0       	rjmp	.+142    	; 0x3448 <xTaskGenericNotify+0x12c>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    33ba:	8a 81       	ldd	r24, Y+2	; 0x02
    33bc:	9b 81       	ldd	r25, Y+3	; 0x03
    33be:	fc 01       	movw	r30, r24
    33c0:	21 a1       	ldd	r18, Z+33	; 0x21
    33c2:	32 a1       	ldd	r19, Z+34	; 0x22
    33c4:	43 a1       	ldd	r20, Z+35	; 0x23
    33c6:	54 a1       	ldd	r21, Z+36	; 0x24
    33c8:	8f 81       	ldd	r24, Y+7	; 0x07
    33ca:	98 85       	ldd	r25, Y+8	; 0x08
    33cc:	a9 85       	ldd	r26, Y+9	; 0x09
    33ce:	ba 85       	ldd	r27, Y+10	; 0x0a
    33d0:	82 2b       	or	r24, r18
    33d2:	93 2b       	or	r25, r19
    33d4:	a4 2b       	or	r26, r20
    33d6:	b5 2b       	or	r27, r21
    33d8:	2a 81       	ldd	r18, Y+2	; 0x02
    33da:	3b 81       	ldd	r19, Y+3	; 0x03
    33dc:	f9 01       	movw	r30, r18
    33de:	81 a3       	std	Z+33, r24	; 0x21
    33e0:	92 a3       	std	Z+34, r25	; 0x22
    33e2:	a3 a3       	std	Z+35, r26	; 0x23
    33e4:	b4 a3       	std	Z+36, r27	; 0x24
					break;
    33e6:	30 c0       	rjmp	.+96     	; 0x3448 <xTaskGenericNotify+0x12c>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    33e8:	8a 81       	ldd	r24, Y+2	; 0x02
    33ea:	9b 81       	ldd	r25, Y+3	; 0x03
    33ec:	fc 01       	movw	r30, r24
    33ee:	81 a1       	ldd	r24, Z+33	; 0x21
    33f0:	92 a1       	ldd	r25, Z+34	; 0x22
    33f2:	a3 a1       	ldd	r26, Z+35	; 0x23
    33f4:	b4 a1       	ldd	r27, Z+36	; 0x24
    33f6:	01 96       	adiw	r24, 0x01	; 1
    33f8:	a1 1d       	adc	r26, r1
    33fa:	b1 1d       	adc	r27, r1
    33fc:	2a 81       	ldd	r18, Y+2	; 0x02
    33fe:	3b 81       	ldd	r19, Y+3	; 0x03
    3400:	f9 01       	movw	r30, r18
    3402:	81 a3       	std	Z+33, r24	; 0x21
    3404:	92 a3       	std	Z+34, r25	; 0x22
    3406:	a3 a3       	std	Z+35, r26	; 0x23
    3408:	b4 a3       	std	Z+36, r27	; 0x24
					break;
    340a:	1e c0       	rjmp	.+60     	; 0x3448 <xTaskGenericNotify+0x12c>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    340c:	2a 81       	ldd	r18, Y+2	; 0x02
    340e:	3b 81       	ldd	r19, Y+3	; 0x03
    3410:	8f 81       	ldd	r24, Y+7	; 0x07
    3412:	98 85       	ldd	r25, Y+8	; 0x08
    3414:	a9 85       	ldd	r26, Y+9	; 0x09
    3416:	ba 85       	ldd	r27, Y+10	; 0x0a
    3418:	f9 01       	movw	r30, r18
    341a:	81 a3       	std	Z+33, r24	; 0x21
    341c:	92 a3       	std	Z+34, r25	; 0x22
    341e:	a3 a3       	std	Z+35, r26	; 0x23
    3420:	b4 a3       	std	Z+36, r27	; 0x24
					break;
    3422:	12 c0       	rjmp	.+36     	; 0x3448 <xTaskGenericNotify+0x12c>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    3424:	8c 81       	ldd	r24, Y+4	; 0x04
    3426:	82 30       	cpi	r24, 0x02	; 2
    3428:	61 f0       	breq	.+24     	; 0x3442 <xTaskGenericNotify+0x126>
					{
						pxTCB->ulNotifiedValue = ulValue;
    342a:	2a 81       	ldd	r18, Y+2	; 0x02
    342c:	3b 81       	ldd	r19, Y+3	; 0x03
    342e:	8f 81       	ldd	r24, Y+7	; 0x07
    3430:	98 85       	ldd	r25, Y+8	; 0x08
    3432:	a9 85       	ldd	r26, Y+9	; 0x09
    3434:	ba 85       	ldd	r27, Y+10	; 0x0a
    3436:	f9 01       	movw	r30, r18
    3438:	81 a3       	std	Z+33, r24	; 0x21
    343a:	92 a3       	std	Z+34, r25	; 0x22
    343c:	a3 a3       	std	Z+35, r26	; 0x23
    343e:	b4 a3       	std	Z+36, r27	; 0x24
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
					}
					break;
    3440:	03 c0       	rjmp	.+6      	; 0x3448 <xTaskGenericNotify+0x12c>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    3442:	19 82       	std	Y+1, r1	; 0x01
					}
					break;
    3444:	01 c0       	rjmp	.+2      	; 0x3448 <xTaskGenericNotify+0x12c>

				case eNoAction:
					/* The task is being notified without its notify value being
					updated. */
					break;
    3446:	00 00       	nop

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    3448:	8c 81       	ldd	r24, Y+4	; 0x04
    344a:	81 30       	cpi	r24, 0x01	; 1
    344c:	d1 f5       	brne	.+116    	; 0x34c2 <xTaskGenericNotify+0x1a6>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    344e:	8a 81       	ldd	r24, Y+2	; 0x02
    3450:	9b 81       	ldd	r25, Y+3	; 0x03
    3452:	02 96       	adiw	r24, 0x02	; 2
    3454:	0e 94 71 04 	call	0x8e2	; 0x8e2 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    3458:	8a 81       	ldd	r24, Y+2	; 0x02
    345a:	9b 81       	ldd	r25, Y+3	; 0x03
    345c:	fc 01       	movw	r30, r24
    345e:	96 89       	ldd	r25, Z+22	; 0x16
    3460:	80 91 ac 0d 	lds	r24, 0x0DAC	; 0x800dac <uxTopReadyPriority>
    3464:	89 17       	cp	r24, r25
    3466:	30 f4       	brcc	.+12     	; 0x3474 <xTaskGenericNotify+0x158>
    3468:	8a 81       	ldd	r24, Y+2	; 0x02
    346a:	9b 81       	ldd	r25, Y+3	; 0x03
    346c:	fc 01       	movw	r30, r24
    346e:	86 89       	ldd	r24, Z+22	; 0x16
    3470:	80 93 ac 0d 	sts	0x0DAC, r24	; 0x800dac <uxTopReadyPriority>
    3474:	8a 81       	ldd	r24, Y+2	; 0x02
    3476:	9b 81       	ldd	r25, Y+3	; 0x03
    3478:	ac 01       	movw	r20, r24
    347a:	4e 5f       	subi	r20, 0xFE	; 254
    347c:	5f 4f       	sbci	r21, 0xFF	; 255
    347e:	8a 81       	ldd	r24, Y+2	; 0x02
    3480:	9b 81       	ldd	r25, Y+3	; 0x03
    3482:	fc 01       	movw	r30, r24
    3484:	86 89       	ldd	r24, Z+22	; 0x16
    3486:	28 2f       	mov	r18, r24
    3488:	30 e0       	ldi	r19, 0x00	; 0
    348a:	c9 01       	movw	r24, r18
    348c:	88 0f       	add	r24, r24
    348e:	99 1f       	adc	r25, r25
    3490:	88 0f       	add	r24, r24
    3492:	99 1f       	adc	r25, r25
    3494:	88 0f       	add	r24, r24
    3496:	99 1f       	adc	r25, r25
    3498:	82 0f       	add	r24, r18
    349a:	93 1f       	adc	r25, r19
    349c:	84 5a       	subi	r24, 0xA4	; 164
    349e:	92 4f       	sbci	r25, 0xF2	; 242
    34a0:	ba 01       	movw	r22, r20
    34a2:	0e 94 aa 03 	call	0x754	; 0x754 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    34a6:	8a 81       	ldd	r24, Y+2	; 0x02
    34a8:	9b 81       	ldd	r25, Y+3	; 0x03
    34aa:	fc 01       	movw	r30, r24
    34ac:	26 89       	ldd	r18, Z+22	; 0x16
    34ae:	80 91 5a 0d 	lds	r24, 0x0D5A	; 0x800d5a <pxCurrentTCB>
    34b2:	90 91 5b 0d 	lds	r25, 0x0D5B	; 0x800d5b <pxCurrentTCB+0x1>
    34b6:	fc 01       	movw	r30, r24
    34b8:	86 89       	ldd	r24, Z+22	; 0x16
    34ba:	82 17       	cp	r24, r18
    34bc:	10 f4       	brcc	.+4      	; 0x34c2 <xTaskGenericNotify+0x1a6>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    34be:	0e 94 ae 06 	call	0xd5c	; 0xd5c <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    34c2:	0f 90       	pop	r0
    34c4:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    34c6:	89 81       	ldd	r24, Y+1	; 0x01
	}
    34c8:	2d 96       	adiw	r28, 0x0d	; 13
    34ca:	0f b6       	in	r0, 0x3f	; 63
    34cc:	f8 94       	cli
    34ce:	de bf       	out	0x3e, r29	; 62
    34d0:	0f be       	out	0x3f, r0	; 63
    34d2:	cd bf       	out	0x3d, r28	; 61
    34d4:	df 91       	pop	r29
    34d6:	cf 91       	pop	r28
    34d8:	1f 91       	pop	r17
    34da:	0f 91       	pop	r16
    34dc:	08 95       	ret

000034de <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    34de:	ef 92       	push	r14
    34e0:	ff 92       	push	r15
    34e2:	0f 93       	push	r16
    34e4:	1f 93       	push	r17
    34e6:	cf 93       	push	r28
    34e8:	df 93       	push	r29
    34ea:	cd b7       	in	r28, 0x3d	; 61
    34ec:	de b7       	in	r29, 0x3e	; 62
    34ee:	60 97       	sbiw	r28, 0x10	; 16
    34f0:	0f b6       	in	r0, 0x3f	; 63
    34f2:	f8 94       	cli
    34f4:	de bf       	out	0x3e, r29	; 62
    34f6:	0f be       	out	0x3f, r0	; 63
    34f8:	cd bf       	out	0x3d, r28	; 61
    34fa:	9f 83       	std	Y+7, r25	; 0x07
    34fc:	8e 83       	std	Y+6, r24	; 0x06
    34fe:	48 87       	std	Y+8, r20	; 0x08
    3500:	59 87       	std	Y+9, r21	; 0x09
    3502:	6a 87       	std	Y+10, r22	; 0x0a
    3504:	7b 87       	std	Y+11, r23	; 0x0b
    3506:	2c 87       	std	Y+12, r18	; 0x0c
    3508:	1e 87       	std	Y+14, r17	; 0x0e
    350a:	0d 87       	std	Y+13, r16	; 0x0d
    350c:	f8 8a       	std	Y+16, r15	; 0x10
    350e:	ef 86       	std	Y+15, r14	; 0x0f
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    3510:	81 e0       	ldi	r24, 0x01	; 1
    3512:	89 83       	std	Y+1, r24	; 0x01
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = ( TCB_t * ) xTaskToNotify;
    3514:	8e 81       	ldd	r24, Y+6	; 0x06
    3516:	9f 81       	ldd	r25, Y+7	; 0x07
    3518:	9b 83       	std	Y+3, r25	; 0x03
    351a:	8a 83       	std	Y+2, r24	; 0x02

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    351c:	1c 82       	std	Y+4, r1	; 0x04
		{
			if( pulPreviousNotificationValue != NULL )
    351e:	8d 85       	ldd	r24, Y+13	; 0x0d
    3520:	9e 85       	ldd	r25, Y+14	; 0x0e
    3522:	89 2b       	or	r24, r25
    3524:	71 f0       	breq	.+28     	; 0x3542 <xTaskGenericNotifyFromISR+0x64>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    3526:	8a 81       	ldd	r24, Y+2	; 0x02
    3528:	9b 81       	ldd	r25, Y+3	; 0x03
    352a:	fc 01       	movw	r30, r24
    352c:	81 a1       	ldd	r24, Z+33	; 0x21
    352e:	92 a1       	ldd	r25, Z+34	; 0x22
    3530:	a3 a1       	ldd	r26, Z+35	; 0x23
    3532:	b4 a1       	ldd	r27, Z+36	; 0x24
    3534:	2d 85       	ldd	r18, Y+13	; 0x0d
    3536:	3e 85       	ldd	r19, Y+14	; 0x0e
    3538:	f9 01       	movw	r30, r18
    353a:	80 83       	st	Z, r24
    353c:	91 83       	std	Z+1, r25	; 0x01
    353e:	a2 83       	std	Z+2, r26	; 0x02
    3540:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    3542:	8a 81       	ldd	r24, Y+2	; 0x02
    3544:	9b 81       	ldd	r25, Y+3	; 0x03
    3546:	fc 01       	movw	r30, r24
    3548:	85 a1       	ldd	r24, Z+37	; 0x25
    354a:	8d 83       	std	Y+5, r24	; 0x05
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    354c:	8a 81       	ldd	r24, Y+2	; 0x02
    354e:	9b 81       	ldd	r25, Y+3	; 0x03
    3550:	22 e0       	ldi	r18, 0x02	; 2
    3552:	fc 01       	movw	r30, r24
    3554:	25 a3       	std	Z+37, r18	; 0x25

			switch( eAction )
    3556:	8c 85       	ldd	r24, Y+12	; 0x0c
    3558:	88 2f       	mov	r24, r24
    355a:	90 e0       	ldi	r25, 0x00	; 0
    355c:	82 30       	cpi	r24, 0x02	; 2
    355e:	91 05       	cpc	r25, r1
    3560:	31 f1       	breq	.+76     	; 0x35ae <xTaskGenericNotifyFromISR+0xd0>
    3562:	83 30       	cpi	r24, 0x03	; 3
    3564:	91 05       	cpc	r25, r1
    3566:	34 f4       	brge	.+12     	; 0x3574 <xTaskGenericNotifyFromISR+0x96>
    3568:	00 97       	sbiw	r24, 0x00	; 0
    356a:	09 f4       	brne	.+2      	; 0x356e <xTaskGenericNotifyFromISR+0x90>
    356c:	4f c0       	rjmp	.+158    	; 0x360c <xTaskGenericNotifyFromISR+0x12e>
    356e:	01 97       	sbiw	r24, 0x01	; 1
    3570:	39 f0       	breq	.+14     	; 0x3580 <xTaskGenericNotifyFromISR+0xa2>
    3572:	4d c0       	rjmp	.+154    	; 0x360e <xTaskGenericNotifyFromISR+0x130>
    3574:	83 30       	cpi	r24, 0x03	; 3
    3576:	91 05       	cpc	r25, r1
    3578:	61 f1       	breq	.+88     	; 0x35d2 <xTaskGenericNotifyFromISR+0xf4>
    357a:	04 97       	sbiw	r24, 0x04	; 4
    357c:	b1 f1       	breq	.+108    	; 0x35ea <xTaskGenericNotifyFromISR+0x10c>
    357e:	47 c0       	rjmp	.+142    	; 0x360e <xTaskGenericNotifyFromISR+0x130>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    3580:	8a 81       	ldd	r24, Y+2	; 0x02
    3582:	9b 81       	ldd	r25, Y+3	; 0x03
    3584:	fc 01       	movw	r30, r24
    3586:	21 a1       	ldd	r18, Z+33	; 0x21
    3588:	32 a1       	ldd	r19, Z+34	; 0x22
    358a:	43 a1       	ldd	r20, Z+35	; 0x23
    358c:	54 a1       	ldd	r21, Z+36	; 0x24
    358e:	88 85       	ldd	r24, Y+8	; 0x08
    3590:	99 85       	ldd	r25, Y+9	; 0x09
    3592:	aa 85       	ldd	r26, Y+10	; 0x0a
    3594:	bb 85       	ldd	r27, Y+11	; 0x0b
    3596:	82 2b       	or	r24, r18
    3598:	93 2b       	or	r25, r19
    359a:	a4 2b       	or	r26, r20
    359c:	b5 2b       	or	r27, r21
    359e:	2a 81       	ldd	r18, Y+2	; 0x02
    35a0:	3b 81       	ldd	r19, Y+3	; 0x03
    35a2:	f9 01       	movw	r30, r18
    35a4:	81 a3       	std	Z+33, r24	; 0x21
    35a6:	92 a3       	std	Z+34, r25	; 0x22
    35a8:	a3 a3       	std	Z+35, r26	; 0x23
    35aa:	b4 a3       	std	Z+36, r27	; 0x24
					break;
    35ac:	30 c0       	rjmp	.+96     	; 0x360e <xTaskGenericNotifyFromISR+0x130>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    35ae:	8a 81       	ldd	r24, Y+2	; 0x02
    35b0:	9b 81       	ldd	r25, Y+3	; 0x03
    35b2:	fc 01       	movw	r30, r24
    35b4:	81 a1       	ldd	r24, Z+33	; 0x21
    35b6:	92 a1       	ldd	r25, Z+34	; 0x22
    35b8:	a3 a1       	ldd	r26, Z+35	; 0x23
    35ba:	b4 a1       	ldd	r27, Z+36	; 0x24
    35bc:	01 96       	adiw	r24, 0x01	; 1
    35be:	a1 1d       	adc	r26, r1
    35c0:	b1 1d       	adc	r27, r1
    35c2:	2a 81       	ldd	r18, Y+2	; 0x02
    35c4:	3b 81       	ldd	r19, Y+3	; 0x03
    35c6:	f9 01       	movw	r30, r18
    35c8:	81 a3       	std	Z+33, r24	; 0x21
    35ca:	92 a3       	std	Z+34, r25	; 0x22
    35cc:	a3 a3       	std	Z+35, r26	; 0x23
    35ce:	b4 a3       	std	Z+36, r27	; 0x24
					break;
    35d0:	1e c0       	rjmp	.+60     	; 0x360e <xTaskGenericNotifyFromISR+0x130>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    35d2:	2a 81       	ldd	r18, Y+2	; 0x02
    35d4:	3b 81       	ldd	r19, Y+3	; 0x03
    35d6:	88 85       	ldd	r24, Y+8	; 0x08
    35d8:	99 85       	ldd	r25, Y+9	; 0x09
    35da:	aa 85       	ldd	r26, Y+10	; 0x0a
    35dc:	bb 85       	ldd	r27, Y+11	; 0x0b
    35de:	f9 01       	movw	r30, r18
    35e0:	81 a3       	std	Z+33, r24	; 0x21
    35e2:	92 a3       	std	Z+34, r25	; 0x22
    35e4:	a3 a3       	std	Z+35, r26	; 0x23
    35e6:	b4 a3       	std	Z+36, r27	; 0x24
					break;
    35e8:	12 c0       	rjmp	.+36     	; 0x360e <xTaskGenericNotifyFromISR+0x130>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    35ea:	8d 81       	ldd	r24, Y+5	; 0x05
    35ec:	82 30       	cpi	r24, 0x02	; 2
    35ee:	61 f0       	breq	.+24     	; 0x3608 <xTaskGenericNotifyFromISR+0x12a>
					{
						pxTCB->ulNotifiedValue = ulValue;
    35f0:	2a 81       	ldd	r18, Y+2	; 0x02
    35f2:	3b 81       	ldd	r19, Y+3	; 0x03
    35f4:	88 85       	ldd	r24, Y+8	; 0x08
    35f6:	99 85       	ldd	r25, Y+9	; 0x09
    35f8:	aa 85       	ldd	r26, Y+10	; 0x0a
    35fa:	bb 85       	ldd	r27, Y+11	; 0x0b
    35fc:	f9 01       	movw	r30, r18
    35fe:	81 a3       	std	Z+33, r24	; 0x21
    3600:	92 a3       	std	Z+34, r25	; 0x22
    3602:	a3 a3       	std	Z+35, r26	; 0x23
    3604:	b4 a3       	std	Z+36, r27	; 0x24
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
					}
					break;
    3606:	03 c0       	rjmp	.+6      	; 0x360e <xTaskGenericNotifyFromISR+0x130>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    3608:	19 82       	std	Y+1, r1	; 0x01
					}
					break;
    360a:	01 c0       	rjmp	.+2      	; 0x360e <xTaskGenericNotifyFromISR+0x130>

				case eNoAction :
					/* The task is being notified without its notify value being
					updated. */
					break;
    360c:	00 00       	nop

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    360e:	8d 81       	ldd	r24, Y+5	; 0x05
    3610:	81 30       	cpi	r24, 0x01	; 1
    3612:	09 f0       	breq	.+2      	; 0x3616 <xTaskGenericNotifyFromISR+0x138>
    3614:	52 c0       	rjmp	.+164    	; 0x36ba <xTaskGenericNotifyFromISR+0x1dc>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3616:	80 91 b6 0d 	lds	r24, 0x0DB6	; 0x800db6 <uxSchedulerSuspended>
    361a:	88 23       	and	r24, r24
    361c:	69 f5       	brne	.+90     	; 0x3678 <xTaskGenericNotifyFromISR+0x19a>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    361e:	8a 81       	ldd	r24, Y+2	; 0x02
    3620:	9b 81       	ldd	r25, Y+3	; 0x03
    3622:	02 96       	adiw	r24, 0x02	; 2
    3624:	0e 94 71 04 	call	0x8e2	; 0x8e2 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    3628:	8a 81       	ldd	r24, Y+2	; 0x02
    362a:	9b 81       	ldd	r25, Y+3	; 0x03
    362c:	fc 01       	movw	r30, r24
    362e:	96 89       	ldd	r25, Z+22	; 0x16
    3630:	80 91 ac 0d 	lds	r24, 0x0DAC	; 0x800dac <uxTopReadyPriority>
    3634:	89 17       	cp	r24, r25
    3636:	30 f4       	brcc	.+12     	; 0x3644 <xTaskGenericNotifyFromISR+0x166>
    3638:	8a 81       	ldd	r24, Y+2	; 0x02
    363a:	9b 81       	ldd	r25, Y+3	; 0x03
    363c:	fc 01       	movw	r30, r24
    363e:	86 89       	ldd	r24, Z+22	; 0x16
    3640:	80 93 ac 0d 	sts	0x0DAC, r24	; 0x800dac <uxTopReadyPriority>
    3644:	8a 81       	ldd	r24, Y+2	; 0x02
    3646:	9b 81       	ldd	r25, Y+3	; 0x03
    3648:	ac 01       	movw	r20, r24
    364a:	4e 5f       	subi	r20, 0xFE	; 254
    364c:	5f 4f       	sbci	r21, 0xFF	; 255
    364e:	8a 81       	ldd	r24, Y+2	; 0x02
    3650:	9b 81       	ldd	r25, Y+3	; 0x03
    3652:	fc 01       	movw	r30, r24
    3654:	86 89       	ldd	r24, Z+22	; 0x16
    3656:	28 2f       	mov	r18, r24
    3658:	30 e0       	ldi	r19, 0x00	; 0
    365a:	c9 01       	movw	r24, r18
    365c:	88 0f       	add	r24, r24
    365e:	99 1f       	adc	r25, r25
    3660:	88 0f       	add	r24, r24
    3662:	99 1f       	adc	r25, r25
    3664:	88 0f       	add	r24, r24
    3666:	99 1f       	adc	r25, r25
    3668:	82 0f       	add	r24, r18
    366a:	93 1f       	adc	r25, r19
    366c:	84 5a       	subi	r24, 0xA4	; 164
    366e:	92 4f       	sbci	r25, 0xF2	; 242
    3670:	ba 01       	movw	r22, r20
    3672:	0e 94 aa 03 	call	0x754	; 0x754 <vListInsertEnd>
    3676:	08 c0       	rjmp	.+16     	; 0x3688 <xTaskGenericNotifyFromISR+0x1aa>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    3678:	8a 81       	ldd	r24, Y+2	; 0x02
    367a:	9b 81       	ldd	r25, Y+3	; 0x03
    367c:	0c 96       	adiw	r24, 0x0c	; 12
    367e:	bc 01       	movw	r22, r24
    3680:	86 e9       	ldi	r24, 0x96	; 150
    3682:	9d e0       	ldi	r25, 0x0D	; 13
    3684:	0e 94 aa 03 	call	0x754	; 0x754 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    3688:	8a 81       	ldd	r24, Y+2	; 0x02
    368a:	9b 81       	ldd	r25, Y+3	; 0x03
    368c:	fc 01       	movw	r30, r24
    368e:	26 89       	ldd	r18, Z+22	; 0x16
    3690:	80 91 5a 0d 	lds	r24, 0x0D5A	; 0x800d5a <pxCurrentTCB>
    3694:	90 91 5b 0d 	lds	r25, 0x0D5B	; 0x800d5b <pxCurrentTCB+0x1>
    3698:	fc 01       	movw	r30, r24
    369a:	86 89       	ldd	r24, Z+22	; 0x16
    369c:	82 17       	cp	r24, r18
    369e:	68 f4       	brcc	.+26     	; 0x36ba <xTaskGenericNotifyFromISR+0x1dc>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    36a0:	8f 85       	ldd	r24, Y+15	; 0x0f
    36a2:	98 89       	ldd	r25, Y+16	; 0x10
    36a4:	89 2b       	or	r24, r25
    36a6:	31 f0       	breq	.+12     	; 0x36b4 <xTaskGenericNotifyFromISR+0x1d6>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    36a8:	8f 85       	ldd	r24, Y+15	; 0x0f
    36aa:	98 89       	ldd	r25, Y+16	; 0x10
    36ac:	21 e0       	ldi	r18, 0x01	; 1
    36ae:	fc 01       	movw	r30, r24
    36b0:	20 83       	st	Z, r18
    36b2:	03 c0       	rjmp	.+6      	; 0x36ba <xTaskGenericNotifyFromISR+0x1dc>
					else
					{
						/* Mark that a yield is pending in case the user is not
						using the "xHigherPriorityTaskWoken" parameter to an ISR
						safe FreeRTOS function. */
						xYieldPending = pdTRUE;
    36b4:	81 e0       	ldi	r24, 0x01	; 1
    36b6:	80 93 af 0d 	sts	0x0DAF, r24	; 0x800daf <xYieldPending>
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
    36ba:	89 81       	ldd	r24, Y+1	; 0x01
	}
    36bc:	60 96       	adiw	r28, 0x10	; 16
    36be:	0f b6       	in	r0, 0x3f	; 63
    36c0:	f8 94       	cli
    36c2:	de bf       	out	0x3e, r29	; 62
    36c4:	0f be       	out	0x3f, r0	; 63
    36c6:	cd bf       	out	0x3d, r28	; 61
    36c8:	df 91       	pop	r29
    36ca:	cf 91       	pop	r28
    36cc:	1f 91       	pop	r17
    36ce:	0f 91       	pop	r16
    36d0:	ff 90       	pop	r15
    36d2:	ef 90       	pop	r14
    36d4:	08 95       	ret

000036d6 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    36d6:	cf 93       	push	r28
    36d8:	df 93       	push	r29
    36da:	cd b7       	in	r28, 0x3d	; 61
    36dc:	de b7       	in	r29, 0x3e	; 62
    36de:	28 97       	sbiw	r28, 0x08	; 8
    36e0:	0f b6       	in	r0, 0x3f	; 63
    36e2:	f8 94       	cli
    36e4:	de bf       	out	0x3e, r29	; 62
    36e6:	0f be       	out	0x3f, r0	; 63
    36e8:	cd bf       	out	0x3d, r28	; 61
    36ea:	9e 83       	std	Y+6, r25	; 0x06
    36ec:	8d 83       	std	Y+5, r24	; 0x05
    36ee:	78 87       	std	Y+8, r23	; 0x08
    36f0:	6f 83       	std	Y+7, r22	; 0x07
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = ( TCB_t * ) xTaskToNotify;
    36f2:	8d 81       	ldd	r24, Y+5	; 0x05
    36f4:	9e 81       	ldd	r25, Y+6	; 0x06
    36f6:	9a 83       	std	Y+2, r25	; 0x02
    36f8:	89 83       	std	Y+1, r24	; 0x01

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    36fa:	1b 82       	std	Y+3, r1	; 0x03
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    36fc:	89 81       	ldd	r24, Y+1	; 0x01
    36fe:	9a 81       	ldd	r25, Y+2	; 0x02
    3700:	fc 01       	movw	r30, r24
    3702:	85 a1       	ldd	r24, Z+37	; 0x25
    3704:	8c 83       	std	Y+4, r24	; 0x04
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    3706:	89 81       	ldd	r24, Y+1	; 0x01
    3708:	9a 81       	ldd	r25, Y+2	; 0x02
    370a:	22 e0       	ldi	r18, 0x02	; 2
    370c:	fc 01       	movw	r30, r24
    370e:	25 a3       	std	Z+37, r18	; 0x25

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    3710:	89 81       	ldd	r24, Y+1	; 0x01
    3712:	9a 81       	ldd	r25, Y+2	; 0x02
    3714:	fc 01       	movw	r30, r24
    3716:	81 a1       	ldd	r24, Z+33	; 0x21
    3718:	92 a1       	ldd	r25, Z+34	; 0x22
    371a:	a3 a1       	ldd	r26, Z+35	; 0x23
    371c:	b4 a1       	ldd	r27, Z+36	; 0x24
    371e:	01 96       	adiw	r24, 0x01	; 1
    3720:	a1 1d       	adc	r26, r1
    3722:	b1 1d       	adc	r27, r1
    3724:	29 81       	ldd	r18, Y+1	; 0x01
    3726:	3a 81       	ldd	r19, Y+2	; 0x02
    3728:	f9 01       	movw	r30, r18
    372a:	81 a3       	std	Z+33, r24	; 0x21
    372c:	92 a3       	std	Z+34, r25	; 0x22
    372e:	a3 a3       	std	Z+35, r26	; 0x23
    3730:	b4 a3       	std	Z+36, r27	; 0x24

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    3732:	8c 81       	ldd	r24, Y+4	; 0x04
    3734:	81 30       	cpi	r24, 0x01	; 1
    3736:	09 f0       	breq	.+2      	; 0x373a <vTaskNotifyGiveFromISR+0x64>
    3738:	52 c0       	rjmp	.+164    	; 0x37de <vTaskNotifyGiveFromISR+0x108>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    373a:	80 91 b6 0d 	lds	r24, 0x0DB6	; 0x800db6 <uxSchedulerSuspended>
    373e:	88 23       	and	r24, r24
    3740:	69 f5       	brne	.+90     	; 0x379c <vTaskNotifyGiveFromISR+0xc6>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    3742:	89 81       	ldd	r24, Y+1	; 0x01
    3744:	9a 81       	ldd	r25, Y+2	; 0x02
    3746:	02 96       	adiw	r24, 0x02	; 2
    3748:	0e 94 71 04 	call	0x8e2	; 0x8e2 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    374c:	89 81       	ldd	r24, Y+1	; 0x01
    374e:	9a 81       	ldd	r25, Y+2	; 0x02
    3750:	fc 01       	movw	r30, r24
    3752:	96 89       	ldd	r25, Z+22	; 0x16
    3754:	80 91 ac 0d 	lds	r24, 0x0DAC	; 0x800dac <uxTopReadyPriority>
    3758:	89 17       	cp	r24, r25
    375a:	30 f4       	brcc	.+12     	; 0x3768 <vTaskNotifyGiveFromISR+0x92>
    375c:	89 81       	ldd	r24, Y+1	; 0x01
    375e:	9a 81       	ldd	r25, Y+2	; 0x02
    3760:	fc 01       	movw	r30, r24
    3762:	86 89       	ldd	r24, Z+22	; 0x16
    3764:	80 93 ac 0d 	sts	0x0DAC, r24	; 0x800dac <uxTopReadyPriority>
    3768:	89 81       	ldd	r24, Y+1	; 0x01
    376a:	9a 81       	ldd	r25, Y+2	; 0x02
    376c:	ac 01       	movw	r20, r24
    376e:	4e 5f       	subi	r20, 0xFE	; 254
    3770:	5f 4f       	sbci	r21, 0xFF	; 255
    3772:	89 81       	ldd	r24, Y+1	; 0x01
    3774:	9a 81       	ldd	r25, Y+2	; 0x02
    3776:	fc 01       	movw	r30, r24
    3778:	86 89       	ldd	r24, Z+22	; 0x16
    377a:	28 2f       	mov	r18, r24
    377c:	30 e0       	ldi	r19, 0x00	; 0
    377e:	c9 01       	movw	r24, r18
    3780:	88 0f       	add	r24, r24
    3782:	99 1f       	adc	r25, r25
    3784:	88 0f       	add	r24, r24
    3786:	99 1f       	adc	r25, r25
    3788:	88 0f       	add	r24, r24
    378a:	99 1f       	adc	r25, r25
    378c:	82 0f       	add	r24, r18
    378e:	93 1f       	adc	r25, r19
    3790:	84 5a       	subi	r24, 0xA4	; 164
    3792:	92 4f       	sbci	r25, 0xF2	; 242
    3794:	ba 01       	movw	r22, r20
    3796:	0e 94 aa 03 	call	0x754	; 0x754 <vListInsertEnd>
    379a:	08 c0       	rjmp	.+16     	; 0x37ac <vTaskNotifyGiveFromISR+0xd6>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    379c:	89 81       	ldd	r24, Y+1	; 0x01
    379e:	9a 81       	ldd	r25, Y+2	; 0x02
    37a0:	0c 96       	adiw	r24, 0x0c	; 12
    37a2:	bc 01       	movw	r22, r24
    37a4:	86 e9       	ldi	r24, 0x96	; 150
    37a6:	9d e0       	ldi	r25, 0x0D	; 13
    37a8:	0e 94 aa 03 	call	0x754	; 0x754 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    37ac:	89 81       	ldd	r24, Y+1	; 0x01
    37ae:	9a 81       	ldd	r25, Y+2	; 0x02
    37b0:	fc 01       	movw	r30, r24
    37b2:	26 89       	ldd	r18, Z+22	; 0x16
    37b4:	80 91 5a 0d 	lds	r24, 0x0D5A	; 0x800d5a <pxCurrentTCB>
    37b8:	90 91 5b 0d 	lds	r25, 0x0D5B	; 0x800d5b <pxCurrentTCB+0x1>
    37bc:	fc 01       	movw	r30, r24
    37be:	86 89       	ldd	r24, Z+22	; 0x16
    37c0:	82 17       	cp	r24, r18
    37c2:	68 f4       	brcc	.+26     	; 0x37de <vTaskNotifyGiveFromISR+0x108>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    37c4:	8f 81       	ldd	r24, Y+7	; 0x07
    37c6:	98 85       	ldd	r25, Y+8	; 0x08
    37c8:	89 2b       	or	r24, r25
    37ca:	31 f0       	breq	.+12     	; 0x37d8 <vTaskNotifyGiveFromISR+0x102>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    37cc:	8f 81       	ldd	r24, Y+7	; 0x07
    37ce:	98 85       	ldd	r25, Y+8	; 0x08
    37d0:	21 e0       	ldi	r18, 0x01	; 1
    37d2:	fc 01       	movw	r30, r24
    37d4:	20 83       	st	Z, r18
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    37d6:	03 c0       	rjmp	.+6      	; 0x37de <vTaskNotifyGiveFromISR+0x108>
					else
					{
						/* Mark that a yield is pending in case the user is not
						using the "xHigherPriorityTaskWoken" parameter in an ISR
						safe FreeRTOS function. */
						xYieldPending = pdTRUE;
    37d8:	81 e0       	ldi	r24, 0x01	; 1
    37da:	80 93 af 0d 	sts	0x0DAF, r24	; 0x800daf <xYieldPending>
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    37de:	00 00       	nop
    37e0:	28 96       	adiw	r28, 0x08	; 8
    37e2:	0f b6       	in	r0, 0x3f	; 63
    37e4:	f8 94       	cli
    37e6:	de bf       	out	0x3e, r29	; 62
    37e8:	0f be       	out	0x3f, r0	; 63
    37ea:	cd bf       	out	0x3d, r28	; 61
    37ec:	df 91       	pop	r29
    37ee:	cf 91       	pop	r28
    37f0:	08 95       	ret

000037f2 <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
    37f2:	cf 93       	push	r28
    37f4:	df 93       	push	r29
    37f6:	00 d0       	rcall	.+0      	; 0x37f8 <xTaskNotifyStateClear+0x6>
    37f8:	00 d0       	rcall	.+0      	; 0x37fa <xTaskNotifyStateClear+0x8>
    37fa:	1f 92       	push	r1
    37fc:	cd b7       	in	r28, 0x3d	; 61
    37fe:	de b7       	in	r29, 0x3e	; 62
    3800:	9d 83       	std	Y+5, r25	; 0x05
    3802:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    3804:	8c 81       	ldd	r24, Y+4	; 0x04
    3806:	9d 81       	ldd	r25, Y+5	; 0x05
    3808:	89 2b       	or	r24, r25
    380a:	29 f4       	brne	.+10     	; 0x3816 <xTaskNotifyStateClear+0x24>
    380c:	80 91 5a 0d 	lds	r24, 0x0D5A	; 0x800d5a <pxCurrentTCB>
    3810:	90 91 5b 0d 	lds	r25, 0x0D5B	; 0x800d5b <pxCurrentTCB+0x1>
    3814:	02 c0       	rjmp	.+4      	; 0x381a <xTaskNotifyStateClear+0x28>
    3816:	8c 81       	ldd	r24, Y+4	; 0x04
    3818:	9d 81       	ldd	r25, Y+5	; 0x05
    381a:	9b 83       	std	Y+3, r25	; 0x03
    381c:	8a 83       	std	Y+2, r24	; 0x02

		taskENTER_CRITICAL();
    381e:	0f b6       	in	r0, 0x3f	; 63
    3820:	f8 94       	cli
    3822:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    3824:	8a 81       	ldd	r24, Y+2	; 0x02
    3826:	9b 81       	ldd	r25, Y+3	; 0x03
    3828:	fc 01       	movw	r30, r24
    382a:	85 a1       	ldd	r24, Z+37	; 0x25
    382c:	82 30       	cpi	r24, 0x02	; 2
    382e:	39 f4       	brne	.+14     	; 0x383e <xTaskNotifyStateClear+0x4c>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    3830:	8a 81       	ldd	r24, Y+2	; 0x02
    3832:	9b 81       	ldd	r25, Y+3	; 0x03
    3834:	fc 01       	movw	r30, r24
    3836:	15 a2       	std	Z+37, r1	; 0x25
				xReturn = pdPASS;
    3838:	81 e0       	ldi	r24, 0x01	; 1
    383a:	89 83       	std	Y+1, r24	; 0x01
    383c:	01 c0       	rjmp	.+2      	; 0x3840 <xTaskNotifyStateClear+0x4e>
			}
			else
			{
				xReturn = pdFAIL;
    383e:	19 82       	std	Y+1, r1	; 0x01
			}
		}
		taskEXIT_CRITICAL();
    3840:	0f 90       	pop	r0
    3842:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    3844:	89 81       	ldd	r24, Y+1	; 0x01
	}
    3846:	0f 90       	pop	r0
    3848:	0f 90       	pop	r0
    384a:	0f 90       	pop	r0
    384c:	0f 90       	pop	r0
    384e:	0f 90       	pop	r0
    3850:	df 91       	pop	r29
    3852:	cf 91       	pop	r28
    3854:	08 95       	ret

00003856 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    3856:	cf 93       	push	r28
    3858:	df 93       	push	r29
    385a:	cd b7       	in	r28, 0x3d	; 61
    385c:	de b7       	in	r29, 0x3e	; 62
    385e:	27 97       	sbiw	r28, 0x07	; 7
    3860:	0f b6       	in	r0, 0x3f	; 63
    3862:	f8 94       	cli
    3864:	de bf       	out	0x3e, r29	; 62
    3866:	0f be       	out	0x3f, r0	; 63
    3868:	cd bf       	out	0x3d, r28	; 61
    386a:	9e 83       	std	Y+6, r25	; 0x06
    386c:	8d 83       	std	Y+5, r24	; 0x05
    386e:	6f 83       	std	Y+7, r22	; 0x07
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    3870:	80 91 aa 0d 	lds	r24, 0x0DAA	; 0x800daa <xTickCount>
    3874:	90 91 ab 0d 	lds	r25, 0x0DAB	; 0x800dab <xTickCount+0x1>
    3878:	9a 83       	std	Y+2, r25	; 0x02
    387a:	89 83       	std	Y+1, r24	; 0x01
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    387c:	80 91 5a 0d 	lds	r24, 0x0D5A	; 0x800d5a <pxCurrentTCB>
    3880:	90 91 5b 0d 	lds	r25, 0x0D5B	; 0x800d5b <pxCurrentTCB+0x1>
    3884:	02 96       	adiw	r24, 0x02	; 2
    3886:	0e 94 71 04 	call	0x8e2	; 0x8e2 <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
		/* Calculate the time at which the task should be woken if the event
		does not occur.  This may overflow but this doesn't matter, the kernel
		will manage it correctly. */
		xTimeToWake = xConstTickCount + xTicksToWait;
    388a:	29 81       	ldd	r18, Y+1	; 0x01
    388c:	3a 81       	ldd	r19, Y+2	; 0x02
    388e:	8d 81       	ldd	r24, Y+5	; 0x05
    3890:	9e 81       	ldd	r25, Y+6	; 0x06
    3892:	82 0f       	add	r24, r18
    3894:	93 1f       	adc	r25, r19
    3896:	9c 83       	std	Y+4, r25	; 0x04
    3898:	8b 83       	std	Y+3, r24	; 0x03

		/* The list item will be inserted in wake time order. */
		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    389a:	80 91 5a 0d 	lds	r24, 0x0D5A	; 0x800d5a <pxCurrentTCB>
    389e:	90 91 5b 0d 	lds	r25, 0x0D5B	; 0x800d5b <pxCurrentTCB+0x1>
    38a2:	2b 81       	ldd	r18, Y+3	; 0x03
    38a4:	3c 81       	ldd	r19, Y+4	; 0x04
    38a6:	fc 01       	movw	r30, r24
    38a8:	33 83       	std	Z+3, r19	; 0x03
    38aa:	22 83       	std	Z+2, r18	; 0x02

		if( xTimeToWake < xConstTickCount )
    38ac:	2b 81       	ldd	r18, Y+3	; 0x03
    38ae:	3c 81       	ldd	r19, Y+4	; 0x04
    38b0:	89 81       	ldd	r24, Y+1	; 0x01
    38b2:	9a 81       	ldd	r25, Y+2	; 0x02
    38b4:	28 17       	cp	r18, r24
    38b6:	39 07       	cpc	r19, r25
    38b8:	78 f4       	brcc	.+30     	; 0x38d8 <prvAddCurrentTaskToDelayedList+0x82>
		{
			/* Wake time has overflowed.  Place this item in the overflow list. */
			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    38ba:	80 91 5a 0d 	lds	r24, 0x0D5A	; 0x800d5a <pxCurrentTCB>
    38be:	90 91 5b 0d 	lds	r25, 0x0D5B	; 0x800d5b <pxCurrentTCB+0x1>
    38c2:	9c 01       	movw	r18, r24
    38c4:	2e 5f       	subi	r18, 0xFE	; 254
    38c6:	3f 4f       	sbci	r19, 0xFF	; 255
    38c8:	80 91 94 0d 	lds	r24, 0x0D94	; 0x800d94 <pxOverflowDelayedTaskList>
    38cc:	90 91 95 0d 	lds	r25, 0x0D95	; 0x800d95 <pxOverflowDelayedTaskList+0x1>
    38d0:	b9 01       	movw	r22, r18
    38d2:	0e 94 f9 03 	call	0x7f2	; 0x7f2 <vListInsert>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    38d6:	1d c0       	rjmp	.+58     	; 0x3912 <prvAddCurrentTaskToDelayedList+0xbc>
			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
		}
		else
		{
			/* The wake time has not overflowed, so the current block list is used. */
			vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    38d8:	80 91 5a 0d 	lds	r24, 0x0D5A	; 0x800d5a <pxCurrentTCB>
    38dc:	90 91 5b 0d 	lds	r25, 0x0D5B	; 0x800d5b <pxCurrentTCB+0x1>
    38e0:	9c 01       	movw	r18, r24
    38e2:	2e 5f       	subi	r18, 0xFE	; 254
    38e4:	3f 4f       	sbci	r19, 0xFF	; 255
    38e6:	80 91 92 0d 	lds	r24, 0x0D92	; 0x800d92 <pxDelayedTaskList>
    38ea:	90 91 93 0d 	lds	r25, 0x0D93	; 0x800d93 <pxDelayedTaskList+0x1>
    38ee:	b9 01       	movw	r22, r18
    38f0:	0e 94 f9 03 	call	0x7f2	; 0x7f2 <vListInsert>

			/* If the task entering the blocked state was placed at the head of the
			list of blocked tasks then xNextTaskUnblockTime needs to be updated
			too. */
			if( xTimeToWake < xNextTaskUnblockTime )
    38f4:	80 91 b2 0d 	lds	r24, 0x0DB2	; 0x800db2 <xNextTaskUnblockTime>
    38f8:	90 91 b3 0d 	lds	r25, 0x0DB3	; 0x800db3 <xNextTaskUnblockTime+0x1>
    38fc:	2b 81       	ldd	r18, Y+3	; 0x03
    38fe:	3c 81       	ldd	r19, Y+4	; 0x04
    3900:	28 17       	cp	r18, r24
    3902:	39 07       	cpc	r19, r25
    3904:	30 f4       	brcc	.+12     	; 0x3912 <prvAddCurrentTaskToDelayedList+0xbc>
			{
				xNextTaskUnblockTime = xTimeToWake;
    3906:	8b 81       	ldd	r24, Y+3	; 0x03
    3908:	9c 81       	ldd	r25, Y+4	; 0x04
    390a:	90 93 b3 0d 	sts	0x0DB3, r25	; 0x800db3 <xNextTaskUnblockTime+0x1>
    390e:	80 93 b2 0d 	sts	0x0DB2, r24	; 0x800db2 <xNextTaskUnblockTime>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    3912:	00 00       	nop
    3914:	27 96       	adiw	r28, 0x07	; 7
    3916:	0f b6       	in	r0, 0x3f	; 63
    3918:	f8 94       	cli
    391a:	de bf       	out	0x3e, r29	; 62
    391c:	0f be       	out	0x3f, r0	; 63
    391e:	cd bf       	out	0x3d, r28	; 61
    3920:	df 91       	pop	r29
    3922:	cf 91       	pop	r28
    3924:	08 95       	ret

00003926 <main>:

unsigned char message[] = "Hello! ";
QueueHandle_t bufferSendUART0;
QueueHandle_t bufferReceiveUART0;

int main( void ) {
    3926:	ef 92       	push	r14
    3928:	ff 92       	push	r15
    392a:	0f 93       	push	r16
    392c:	cf 93       	push	r28
    392e:	df 93       	push	r29
    3930:	cd b7       	in	r28, 0x3d	; 61
    3932:	de b7       	in	r29, 0x3e	; 62

	bufferSendUART0 = xQueueCreate(16, sizeof(unsigned char));
    3934:	40 e0       	ldi	r20, 0x00	; 0
    3936:	61 e0       	ldi	r22, 0x01	; 1
    3938:	80 e1       	ldi	r24, 0x10	; 16
    393a:	0e 94 df 08 	call	0x11be	; 0x11be <xQueueGenericCreate>
    393e:	90 93 ba 0d 	sts	0x0DBA, r25	; 0x800dba <bufferSendUART0+0x1>
    3942:	80 93 b9 0d 	sts	0x0DB9, r24	; 0x800db9 <bufferSendUART0>
	bufferReceiveUART0 = xQueueCreate(16, sizeof(unsigned char));
    3946:	40 e0       	ldi	r20, 0x00	; 0
    3948:	61 e0       	ldi	r22, 0x01	; 1
    394a:	80 e1       	ldi	r24, 0x10	; 16
    394c:	0e 94 df 08 	call	0x11be	; 0x11be <xQueueGenericCreate>
    3950:	90 93 b8 0d 	sts	0x0DB8, r25	; 0x800db8 <bufferReceiveUART0+0x1>
    3954:	80 93 b7 0d 	sts	0x0DB7, r24	; 0x800db7 <bufferReceiveUART0>

	DDRB |= (1 << PB0);
    3958:	87 e3       	ldi	r24, 0x37	; 55
    395a:	90 e0       	ldi	r25, 0x00	; 0
    395c:	27 e3       	ldi	r18, 0x37	; 55
    395e:	30 e0       	ldi	r19, 0x00	; 0
    3960:	f9 01       	movw	r30, r18
    3962:	20 81       	ld	r18, Z
    3964:	21 60       	ori	r18, 0x01	; 1
    3966:	fc 01       	movw	r30, r24
    3968:	20 83       	st	Z, r18
	DDRB |= (1 << PB1);
    396a:	87 e3       	ldi	r24, 0x37	; 55
    396c:	90 e0       	ldi	r25, 0x00	; 0
    396e:	27 e3       	ldi	r18, 0x37	; 55
    3970:	30 e0       	ldi	r19, 0x00	; 0
    3972:	f9 01       	movw	r30, r18
    3974:	20 81       	ld	r18, Z
    3976:	22 60       	ori	r18, 0x02	; 2
    3978:	fc 01       	movw	r30, r24
    397a:	20 83       	st	Z, r18

	USART_Init();
    397c:	0e 94 9d 1d 	call	0x3b3a	; 0x3b3a <USART_Init>

	/* Create the tasks defined within this file. */
	xTaskCreate( vRedLED, "RedLED", configMINIMAL_STACK_SIZE, NULL, mainLED_TASK_PRIORITY, NULL );
    3980:	e1 2c       	mov	r14, r1
    3982:	f1 2c       	mov	r15, r1
    3984:	01 e0       	ldi	r16, 0x01	; 1
    3986:	20 e0       	ldi	r18, 0x00	; 0
    3988:	30 e0       	ldi	r19, 0x00	; 0
    398a:	45 e5       	ldi	r20, 0x55	; 85
    398c:	50 e0       	ldi	r21, 0x00	; 0
    398e:	6d e0       	ldi	r22, 0x0D	; 13
    3990:	71 e0       	ldi	r23, 0x01	; 1
    3992:	84 ee       	ldi	r24, 0xE4	; 228
    3994:	9c e1       	ldi	r25, 0x1C	; 28
    3996:	0e 94 4f 10 	call	0x209e	; 0x209e <xTaskCreate>
	//xTaskCreate( vGreenLED, "GreenLED", configMINIMAL_STACK_SIZE, NULL, mainLED_TASK_PRIORITY, NULL );
	xTaskCreate( vUART0TransmitService, "UART0Tx", configMINIMAL_STACK_SIZE, NULL, mainUART_PRIORITY, NULL );
    399a:	e1 2c       	mov	r14, r1
    399c:	f1 2c       	mov	r15, r1
    399e:	02 e0       	ldi	r16, 0x02	; 2
    39a0:	20 e0       	ldi	r18, 0x00	; 0
    39a2:	30 e0       	ldi	r19, 0x00	; 0
    39a4:	45 e5       	ldi	r20, 0x55	; 85
    39a6:	50 e0       	ldi	r21, 0x00	; 0
    39a8:	64 e1       	ldi	r22, 0x14	; 20
    39aa:	71 e0       	ldi	r23, 0x01	; 1
    39ac:	89 e1       	ldi	r24, 0x19	; 25
    39ae:	9d e1       	ldi	r25, 0x1D	; 29
    39b0:	0e 94 4f 10 	call	0x209e	; 0x209e <xTaskCreate>

	vTaskStartScheduler();
    39b4:	0e 94 12 13 	call	0x2624	; 0x2624 <vTaskStartScheduler>

	return 0;
    39b8:	80 e0       	ldi	r24, 0x00	; 0
    39ba:	90 e0       	ldi	r25, 0x00	; 0
}
    39bc:	df 91       	pop	r29
    39be:	cf 91       	pop	r28
    39c0:	0f 91       	pop	r16
    39c2:	ff 90       	pop	r15
    39c4:	ef 90       	pop	r14
    39c6:	08 95       	ret

000039c8 <vRedLED>:
/*-----------------------------------------------------------*/

static void vRedLED( void *pvParameters ) {
    39c8:	cf 93       	push	r28
    39ca:	df 93       	push	r29
    39cc:	00 d0       	rcall	.+0      	; 0x39ce <vRedLED+0x6>
    39ce:	cd b7       	in	r28, 0x3d	; 61
    39d0:	de b7       	in	r29, 0x3e	; 62
    39d2:	9a 83       	std	Y+2, r25	; 0x02
    39d4:	89 83       	std	Y+1, r24	; 0x01

	/* The parameters are not used. */
	( void ) pvParameters;

	for( ;; ) {
		PORTB ^= (1 << PB0);
    39d6:	88 e3       	ldi	r24, 0x38	; 56
    39d8:	90 e0       	ldi	r25, 0x00	; 0
    39da:	28 e3       	ldi	r18, 0x38	; 56
    39dc:	30 e0       	ldi	r19, 0x00	; 0
    39de:	f9 01       	movw	r30, r18
    39e0:	30 81       	ld	r19, Z
    39e2:	21 e0       	ldi	r18, 0x01	; 1
    39e4:	23 27       	eor	r18, r19
    39e6:	fc 01       	movw	r30, r24
    39e8:	20 83       	st	Z, r18
		sendMessage(message, bufferSendUART0);
    39ea:	80 91 b9 0d 	lds	r24, 0x0DB9	; 0x800db9 <bufferSendUART0>
    39ee:	90 91 ba 0d 	lds	r25, 0x0DBA	; 0x800dba <bufferSendUART0+0x1>
    39f2:	bc 01       	movw	r22, r24
    39f4:	80 e0       	ldi	r24, 0x00	; 0
    39f6:	91 e0       	ldi	r25, 0x01	; 1
    39f8:	0e 94 37 1d 	call	0x3a6e	; 0x3a6e <sendMessage>
		PORTB ^= (1 << PB0);
    39fc:	88 e3       	ldi	r24, 0x38	; 56
    39fe:	90 e0       	ldi	r25, 0x00	; 0
    3a00:	28 e3       	ldi	r18, 0x38	; 56
    3a02:	30 e0       	ldi	r19, 0x00	; 0
    3a04:	f9 01       	movw	r30, r18
    3a06:	30 81       	ld	r19, Z
    3a08:	21 e0       	ldi	r18, 0x01	; 1
    3a0a:	23 27       	eor	r18, r19
    3a0c:	fc 01       	movw	r30, r24
    3a0e:	20 83       	st	Z, r18
		vTaskDelay( 200 );
    3a10:	88 ec       	ldi	r24, 0xC8	; 200
    3a12:	90 e0       	ldi	r25, 0x00	; 0
    3a14:	0e 94 ef 12 	call	0x25de	; 0x25de <vTaskDelay>
	}
    3a18:	de cf       	rjmp	.-68     	; 0x39d6 <vRedLED+0xe>

00003a1a <vGreenLED>:
}

static void vGreenLED( void *pvParameters ) {
    3a1a:	cf 93       	push	r28
    3a1c:	df 93       	push	r29
    3a1e:	00 d0       	rcall	.+0      	; 0x3a20 <vGreenLED+0x6>
    3a20:	cd b7       	in	r28, 0x3d	; 61
    3a22:	de b7       	in	r29, 0x3e	; 62
    3a24:	9a 83       	std	Y+2, r25	; 0x02
    3a26:	89 83       	std	Y+1, r24	; 0x01
	/* The parameters are not used. */
	( void ) pvParameters;

	for( ;; ) {
		//PORTB ^= (1 << PB1);
		vTaskDelay( 50 );
    3a28:	82 e3       	ldi	r24, 0x32	; 50
    3a2a:	90 e0       	ldi	r25, 0x00	; 0
    3a2c:	0e 94 ef 12 	call	0x25de	; 0x25de <vTaskDelay>
		//USART0_SendString(message);
	}
    3a30:	fb cf       	rjmp	.-10     	; 0x3a28 <vGreenLED+0xe>

00003a32 <vUART0TransmitService>:
}

static void vUART0TransmitService( void *pvParameters ) {
    3a32:	cf 93       	push	r28
    3a34:	df 93       	push	r29
    3a36:	00 d0       	rcall	.+0      	; 0x3a38 <vUART0TransmitService+0x6>
    3a38:	cd b7       	in	r28, 0x3d	; 61
    3a3a:	de b7       	in	r29, 0x3e	; 62
    3a3c:	9a 83       	std	Y+2, r25	; 0x02
    3a3e:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;
	
	for( ;; ) {
		/* Waits for bufferSendUART0 to fill, then pops first byte of data and
		   copies it to UART0 data register UDR0 effectively transmitting it. */ 
		xQueueReceive( bufferSendUART0, &UDR0, portMAX_DELAY );
    3a40:	80 91 b9 0d 	lds	r24, 0x0DB9	; 0x800db9 <bufferSendUART0>
    3a44:	90 91 ba 0d 	lds	r25, 0x0DBA	; 0x800dba <bufferSendUART0+0x1>
    3a48:	20 e0       	ldi	r18, 0x00	; 0
    3a4a:	4f ef       	ldi	r20, 0xFF	; 255
    3a4c:	5f ef       	ldi	r21, 0xFF	; 255
    3a4e:	6c e2       	ldi	r22, 0x2C	; 44
    3a50:	70 e0       	ldi	r23, 0x00	; 0
    3a52:	0e 94 d5 0a 	call	0x15aa	; 0x15aa <xQueueGenericReceive>
		while(!( UCSR0A & (1<<UDRE0)));		// Wait for transmit to finish
    3a56:	00 00       	nop
    3a58:	8b e2       	ldi	r24, 0x2B	; 43
    3a5a:	90 e0       	ldi	r25, 0x00	; 0
    3a5c:	fc 01       	movw	r30, r24
    3a5e:	80 81       	ld	r24, Z
    3a60:	88 2f       	mov	r24, r24
    3a62:	90 e0       	ldi	r25, 0x00	; 0
    3a64:	80 72       	andi	r24, 0x20	; 32
    3a66:	99 27       	eor	r25, r25
    3a68:	89 2b       	or	r24, r25
    3a6a:	b1 f3       	breq	.-20     	; 0x3a58 <vUART0TransmitService+0x26>
	}
    3a6c:	e9 cf       	rjmp	.-46     	; 0x3a40 <vUART0TransmitService+0xe>

00003a6e <sendMessage>:
}

void sendMessage( unsigned char *message, QueueHandle_t queue) {
    3a6e:	cf 93       	push	r28
    3a70:	df 93       	push	r29
    3a72:	00 d0       	rcall	.+0      	; 0x3a74 <sendMessage+0x6>
    3a74:	00 d0       	rcall	.+0      	; 0x3a76 <sendMessage+0x8>
    3a76:	1f 92       	push	r1
    3a78:	cd b7       	in	r28, 0x3d	; 61
    3a7a:	de b7       	in	r29, 0x3e	; 62
    3a7c:	9b 83       	std	Y+3, r25	; 0x03
    3a7e:	8a 83       	std	Y+2, r24	; 0x02
    3a80:	7d 83       	std	Y+5, r23	; 0x05
    3a82:	6c 83       	std	Y+4, r22	; 0x04
	/* Receives a message and pushes it on UART send queue character by character.
	   Limited to 255 characters for efficiency (counter i is single byte). */
	for(uint8_t i = 0; message[i] != '\0'; ++i) {
    3a84:	19 82       	std	Y+1, r1	; 0x01
    3a86:	12 c0       	rjmp	.+36     	; 0x3aac <sendMessage+0x3e>
		xQueueSendToBack( queue, message+i, pdMS_TO_TICKS(50));
    3a88:	89 81       	ldd	r24, Y+1	; 0x01
    3a8a:	88 2f       	mov	r24, r24
    3a8c:	90 e0       	ldi	r25, 0x00	; 0
    3a8e:	2a 81       	ldd	r18, Y+2	; 0x02
    3a90:	3b 81       	ldd	r19, Y+3	; 0x03
    3a92:	b9 01       	movw	r22, r18
    3a94:	68 0f       	add	r22, r24
    3a96:	79 1f       	adc	r23, r25
    3a98:	8c 81       	ldd	r24, Y+4	; 0x04
    3a9a:	9d 81       	ldd	r25, Y+5	; 0x05
    3a9c:	20 e0       	ldi	r18, 0x00	; 0
    3a9e:	45 e0       	ldi	r20, 0x05	; 5
    3aa0:	50 e0       	ldi	r21, 0x00	; 0
    3aa2:	0e 94 6b 09 	call	0x12d6	; 0x12d6 <xQueueGenericSend>
}

void sendMessage( unsigned char *message, QueueHandle_t queue) {
	/* Receives a message and pushes it on UART send queue character by character.
	   Limited to 255 characters for efficiency (counter i is single byte). */
	for(uint8_t i = 0; message[i] != '\0'; ++i) {
    3aa6:	89 81       	ldd	r24, Y+1	; 0x01
    3aa8:	8f 5f       	subi	r24, 0xFF	; 255
    3aaa:	89 83       	std	Y+1, r24	; 0x01
    3aac:	89 81       	ldd	r24, Y+1	; 0x01
    3aae:	88 2f       	mov	r24, r24
    3ab0:	90 e0       	ldi	r25, 0x00	; 0
    3ab2:	2a 81       	ldd	r18, Y+2	; 0x02
    3ab4:	3b 81       	ldd	r19, Y+3	; 0x03
    3ab6:	82 0f       	add	r24, r18
    3ab8:	93 1f       	adc	r25, r19
    3aba:	fc 01       	movw	r30, r24
    3abc:	80 81       	ld	r24, Z
    3abe:	88 23       	and	r24, r24
    3ac0:	19 f7       	brne	.-58     	; 0x3a88 <sendMessage+0x1a>
		xQueueSendToBack( queue, message+i, pdMS_TO_TICKS(50));
	}
}
    3ac2:	00 00       	nop
    3ac4:	0f 90       	pop	r0
    3ac6:	0f 90       	pop	r0
    3ac8:	0f 90       	pop	r0
    3aca:	0f 90       	pop	r0
    3acc:	0f 90       	pop	r0
    3ace:	df 91       	pop	r29
    3ad0:	cf 91       	pop	r28
    3ad2:	08 95       	ret

00003ad4 <vApplicationIdleHook>:

void vApplicationIdleHook( void ) {
    3ad4:	cf 93       	push	r28
    3ad6:	df 93       	push	r29
    3ad8:	cd b7       	in	r28, 0x3d	; 61
    3ada:	de b7       	in	r29, 0x3e	; 62
	PORTB ^= (1 << PB1);
    3adc:	88 e3       	ldi	r24, 0x38	; 56
    3ade:	90 e0       	ldi	r25, 0x00	; 0
    3ae0:	28 e3       	ldi	r18, 0x38	; 56
    3ae2:	30 e0       	ldi	r19, 0x00	; 0
    3ae4:	f9 01       	movw	r30, r18
    3ae6:	30 81       	ld	r19, Z
    3ae8:	22 e0       	ldi	r18, 0x02	; 2
    3aea:	23 27       	eor	r18, r19
    3aec:	fc 01       	movw	r30, r24
    3aee:	20 83       	st	Z, r18
}
    3af0:	00 00       	nop
    3af2:	df 91       	pop	r29
    3af4:	cf 91       	pop	r28
    3af6:	08 95       	ret

00003af8 <__vector_18>:
volatile unsigned char value;
/* This variable is volatile so both main and RX interrupt can use it.
It could also be a uint8_t type */

//Interrupt Service Routine for Receive Complete
ISR(USART0_RX_vect){
    3af8:	1f 92       	push	r1
    3afa:	0f 92       	push	r0
    3afc:	00 90 5f 00 	lds	r0, 0x005F	; 0x80005f <__TEXT_REGION_LENGTH__+0x7e005f>
    3b00:	0f 92       	push	r0
    3b02:	11 24       	eor	r1, r1
    3b04:	8f 93       	push	r24
    3b06:	9f 93       	push	r25
    3b08:	ef 93       	push	r30
    3b0a:	ff 93       	push	r31
    3b0c:	cf 93       	push	r28
    3b0e:	df 93       	push	r29
    3b10:	cd b7       	in	r28, 0x3d	; 61
    3b12:	de b7       	in	r29, 0x3e	; 62
	value = UDR0;             //read UART register into value
    3b14:	8c e2       	ldi	r24, 0x2C	; 44
    3b16:	90 e0       	ldi	r25, 0x00	; 0
    3b18:	fc 01       	movw	r30, r24
    3b1a:	80 81       	ld	r24, Z
    3b1c:	80 93 bb 0d 	sts	0x0DBB, r24	; 0x800dbb <value>
}
    3b20:	00 00       	nop
    3b22:	df 91       	pop	r29
    3b24:	cf 91       	pop	r28
    3b26:	ff 91       	pop	r31
    3b28:	ef 91       	pop	r30
    3b2a:	9f 91       	pop	r25
    3b2c:	8f 91       	pop	r24
    3b2e:	0f 90       	pop	r0
    3b30:	00 92 5f 00 	sts	0x005F, r0	; 0x80005f <__TEXT_REGION_LENGTH__+0x7e005f>
    3b34:	0f 90       	pop	r0
    3b36:	1f 90       	pop	r1
    3b38:	18 95       	reti

00003b3a <USART_Init>:

void USART_Init(void) {
    3b3a:	cf 93       	push	r28
    3b3c:	df 93       	push	r29
    3b3e:	cd b7       	in	r28, 0x3d	; 61
    3b40:	de b7       	in	r29, 0x3e	; 62
	/* Set baud rate */
	UBRR0H = (uint8_t)(MYUBRR>>8);
    3b42:	80 e9       	ldi	r24, 0x90	; 144
    3b44:	90 e0       	ldi	r25, 0x00	; 0
    3b46:	fc 01       	movw	r30, r24
    3b48:	10 82       	st	Z, r1
	UBRR0L = (uint8_t)MYUBRR;
    3b4a:	89 e2       	ldi	r24, 0x29	; 41
    3b4c:	90 e0       	ldi	r25, 0x00	; 0
    3b4e:	27 e4       	ldi	r18, 0x47	; 71
    3b50:	fc 01       	movw	r30, r24
    3b52:	20 83       	st	Z, r18

	/* Enable receiver and transmitter */
	UCSR0B = (1<<RXEN0)|(1<<TXEN0);
    3b54:	8a e2       	ldi	r24, 0x2A	; 42
    3b56:	90 e0       	ldi	r25, 0x00	; 0
    3b58:	28 e1       	ldi	r18, 0x18	; 24
    3b5a:	fc 01       	movw	r30, r24
    3b5c:	20 83       	st	Z, r18
	/* Set frame format: 8data, 2stop bit */
	//UCSR0C = (1<<USBS0)|(3<<UCSZ00);
}
    3b5e:	00 00       	nop
    3b60:	df 91       	pop	r29
    3b62:	cf 91       	pop	r28
    3b64:	08 95       	ret

00003b66 <USART_SendByte>:


void USART_SendByte(uint8_t data) {
    3b66:	cf 93       	push	r28
    3b68:	df 93       	push	r29
    3b6a:	1f 92       	push	r1
    3b6c:	cd b7       	in	r28, 0x3d	; 61
    3b6e:	de b7       	in	r29, 0x3e	; 62
    3b70:	89 83       	std	Y+1, r24	; 0x01

	/* Wait for empty transmit buffer */
	//while ( !( UCSR0A & (1<<UDRE0)) );
	while(!UDRE0);
    3b72:	00 00       	nop

	/* Put data into buffer, sends the data */
	UDR0 = data;
    3b74:	8c e2       	ldi	r24, 0x2C	; 44
    3b76:	90 e0       	ldi	r25, 0x00	; 0
    3b78:	29 81       	ldd	r18, Y+1	; 0x01
    3b7a:	fc 01       	movw	r30, r24
    3b7c:	20 83       	st	Z, r18
}
    3b7e:	00 00       	nop
    3b80:	0f 90       	pop	r0
    3b82:	df 91       	pop	r29
    3b84:	cf 91       	pop	r28
    3b86:	08 95       	ret

00003b88 <USART0_SendChar>:

void USART0_SendChar(unsigned char c) {
    3b88:	cf 93       	push	r28
    3b8a:	df 93       	push	r29
    3b8c:	1f 92       	push	r1
    3b8e:	cd b7       	in	r28, 0x3d	; 61
    3b90:	de b7       	in	r29, 0x3e	; 62
    3b92:	89 83       	std	Y+1, r24	; 0x01

	/* Wait for empty transmit buffer */
	while(!UDRE0);
    3b94:	00 00       	nop

	/* Put data into buffer, sends the data */
	UDR0 = c;
    3b96:	8c e2       	ldi	r24, 0x2C	; 44
    3b98:	90 e0       	ldi	r25, 0x00	; 0
    3b9a:	29 81       	ldd	r18, Y+1	; 0x01
    3b9c:	fc 01       	movw	r30, r24
    3b9e:	20 83       	st	Z, r18
}
    3ba0:	00 00       	nop
    3ba2:	0f 90       	pop	r0
    3ba4:	df 91       	pop	r29
    3ba6:	cf 91       	pop	r28
    3ba8:	08 95       	ret

00003baa <USART0_SendString>:

// Max 256 characters
void USART0_SendString(unsigned char *str) {
    3baa:	cf 93       	push	r28
    3bac:	df 93       	push	r29
    3bae:	00 d0       	rcall	.+0      	; 0x3bb0 <USART0_SendString+0x6>
    3bb0:	1f 92       	push	r1
    3bb2:	cd b7       	in	r28, 0x3d	; 61
    3bb4:	de b7       	in	r29, 0x3e	; 62
    3bb6:	9b 83       	std	Y+3, r25	; 0x03
    3bb8:	8a 83       	std	Y+2, r24	; 0x02

	for(uint8_t i = 0; str[i] != '\0'; ++i) {
    3bba:	19 82       	std	Y+1, r1	; 0x01
    3bbc:	1b c0       	rjmp	.+54     	; 0x3bf4 <USART0_SendString+0x4a>
		while(!( UCSR0A & (1<<UDRE0)));		// Wait for empty transmit buffer
    3bbe:	00 00       	nop
    3bc0:	8b e2       	ldi	r24, 0x2B	; 43
    3bc2:	90 e0       	ldi	r25, 0x00	; 0
    3bc4:	fc 01       	movw	r30, r24
    3bc6:	80 81       	ld	r24, Z
    3bc8:	88 2f       	mov	r24, r24
    3bca:	90 e0       	ldi	r25, 0x00	; 0
    3bcc:	80 72       	andi	r24, 0x20	; 32
    3bce:	99 27       	eor	r25, r25
    3bd0:	89 2b       	or	r24, r25
    3bd2:	b1 f3       	breq	.-20     	; 0x3bc0 <USART0_SendString+0x16>
		UDR0 = str[i];						// Put character into buffer and send
    3bd4:	8c e2       	ldi	r24, 0x2C	; 44
    3bd6:	90 e0       	ldi	r25, 0x00	; 0
    3bd8:	29 81       	ldd	r18, Y+1	; 0x01
    3bda:	22 2f       	mov	r18, r18
    3bdc:	30 e0       	ldi	r19, 0x00	; 0
    3bde:	4a 81       	ldd	r20, Y+2	; 0x02
    3be0:	5b 81       	ldd	r21, Y+3	; 0x03
    3be2:	24 0f       	add	r18, r20
    3be4:	35 1f       	adc	r19, r21
    3be6:	f9 01       	movw	r30, r18
    3be8:	20 81       	ld	r18, Z
    3bea:	fc 01       	movw	r30, r24
    3bec:	20 83       	st	Z, r18
}

// Max 256 characters
void USART0_SendString(unsigned char *str) {

	for(uint8_t i = 0; str[i] != '\0'; ++i) {
    3bee:	89 81       	ldd	r24, Y+1	; 0x01
    3bf0:	8f 5f       	subi	r24, 0xFF	; 255
    3bf2:	89 83       	std	Y+1, r24	; 0x01
    3bf4:	89 81       	ldd	r24, Y+1	; 0x01
    3bf6:	88 2f       	mov	r24, r24
    3bf8:	90 e0       	ldi	r25, 0x00	; 0
    3bfa:	2a 81       	ldd	r18, Y+2	; 0x02
    3bfc:	3b 81       	ldd	r19, Y+3	; 0x03
    3bfe:	82 0f       	add	r24, r18
    3c00:	93 1f       	adc	r25, r19
    3c02:	fc 01       	movw	r30, r24
    3c04:	80 81       	ld	r24, Z
    3c06:	88 23       	and	r24, r24
    3c08:	d1 f6       	brne	.-76     	; 0x3bbe <USART0_SendString+0x14>
		while(!( UCSR0A & (1<<UDRE0)));		// Wait for empty transmit buffer
		UDR0 = str[i];						// Put character into buffer and send
	}
}
    3c0a:	00 00       	nop
    3c0c:	0f 90       	pop	r0
    3c0e:	0f 90       	pop	r0
    3c10:	0f 90       	pop	r0
    3c12:	df 91       	pop	r29
    3c14:	cf 91       	pop	r28
    3c16:	08 95       	ret

00003c18 <USART_ReceiveByte>:

// Wait until a byte has been received and return received data
uint8_t USART_ReceiveByte() {
    3c18:	cf 93       	push	r28
    3c1a:	df 93       	push	r29
    3c1c:	cd b7       	in	r28, 0x3d	; 61
    3c1e:	de b7       	in	r29, 0x3e	; 62
	while((UCSR0A &(1<<RXC)) == 0);
    3c20:	00 00       	nop
    3c22:	8b e2       	ldi	r24, 0x2B	; 43
    3c24:	90 e0       	ldi	r25, 0x00	; 0
    3c26:	fc 01       	movw	r30, r24
    3c28:	80 81       	ld	r24, Z
    3c2a:	88 23       	and	r24, r24
    3c2c:	d4 f7       	brge	.-12     	; 0x3c22 <USART_ReceiveByte+0xa>
	return UDR0;
    3c2e:	8c e2       	ldi	r24, 0x2C	; 44
    3c30:	90 e0       	ldi	r25, 0x00	; 0
    3c32:	fc 01       	movw	r30, r24
    3c34:	80 81       	ld	r24, Z
    3c36:	df 91       	pop	r29
    3c38:	cf 91       	pop	r28
    3c3a:	08 95       	ret

00003c3c <memcpy>:
    3c3c:	fb 01       	movw	r30, r22
    3c3e:	dc 01       	movw	r26, r24
    3c40:	02 c0       	rjmp	.+4      	; 0x3c46 <memcpy+0xa>
    3c42:	01 90       	ld	r0, Z+
    3c44:	0d 92       	st	X+, r0
    3c46:	41 50       	subi	r20, 0x01	; 1
    3c48:	50 40       	sbci	r21, 0x00	; 0
    3c4a:	d8 f7       	brcc	.-10     	; 0x3c42 <memcpy+0x6>
    3c4c:	08 95       	ret

00003c4e <_exit>:
    3c4e:	f8 94       	cli

00003c50 <__stop_program>:
    3c50:	ff cf       	rjmp	.-2      	; 0x3c50 <__stop_program>
