
RoombaCommander_ATmega64.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000034  00800100  00002460  000024f4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002460  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000cc7  00800134  00800134  00002528  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002528  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00002558  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000120  00000000  00000000  00002594  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00004bc7  00000000  00000000  000026b4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000015ad  00000000  00000000  0000727b  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000024d4  00000000  00000000  00008828  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000ab8  00000000  00000000  0000acfc  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000016c5  00000000  00000000  0000b7b4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000041b6  00000000  00000000  0000ce79  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000108  00000000  00000000  0001102f  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 46 00 	jmp	0x8c	; 0x8c <__ctors_end>
       4:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
       8:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
       c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      10:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      14:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      18:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      1c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      20:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      24:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      28:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      2c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      30:	0c 94 61 04 	jmp	0x8c2	; 0x8c2 <__vector_12>
      34:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      38:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      3c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      40:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      44:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      48:	0c 94 60 11 	jmp	0x22c0	; 0x22c0 <__vector_18>
      4c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      50:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      54:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      58:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      5c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      60:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      64:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      68:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      6c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      70:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      74:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      78:	0c 94 8d 11 	jmp	0x231a	; 0x231a <__vector_30>
      7c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      80:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      84:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      88:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>

0000008c <__ctors_end>:
      8c:	11 24       	eor	r1, r1
      8e:	1f be       	out	0x3f, r1	; 63
      90:	cf ef       	ldi	r28, 0xFF	; 255
      92:	d0 e1       	ldi	r29, 0x10	; 16
      94:	de bf       	out	0x3e, r29	; 62
      96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
      98:	11 e0       	ldi	r17, 0x01	; 1
      9a:	a0 e0       	ldi	r26, 0x00	; 0
      9c:	b1 e0       	ldi	r27, 0x01	; 1
      9e:	e0 e6       	ldi	r30, 0x60	; 96
      a0:	f4 e2       	ldi	r31, 0x24	; 36
      a2:	02 c0       	rjmp	.+4      	; 0xa8 <__do_copy_data+0x10>
      a4:	05 90       	lpm	r0, Z+
      a6:	0d 92       	st	X+, r0
      a8:	a4 33       	cpi	r26, 0x34	; 52
      aa:	b1 07       	cpc	r27, r17
      ac:	d9 f7       	brne	.-10     	; 0xa4 <__do_copy_data+0xc>

000000ae <__do_clear_bss>:
      ae:	2d e0       	ldi	r18, 0x0D	; 13
      b0:	a4 e3       	ldi	r26, 0x34	; 52
      b2:	b1 e0       	ldi	r27, 0x01	; 1
      b4:	01 c0       	rjmp	.+2      	; 0xb8 <.do_clear_bss_start>

000000b6 <.do_clear_bss_loop>:
      b6:	1d 92       	st	X+, r1

000000b8 <.do_clear_bss_start>:
      b8:	ab 3f       	cpi	r26, 0xFB	; 251
      ba:	b2 07       	cpc	r27, r18
      bc:	e1 f7       	brne	.-8      	; 0xb6 <.do_clear_bss_loop>
      be:	0e 94 dd 10 	call	0x21ba	; 0x21ba <main>
      c2:	0c 94 2e 12 	jmp	0x245c	; 0x245c <_exit>

000000c6 <__bad_interrupt>:
      c6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ca <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, UBaseType_t uxPriority, UBaseType_t uxIndex )
{
      ca:	cf 92       	push	r12
      cc:	df 92       	push	r13
      ce:	ef 92       	push	r14
      d0:	ff 92       	push	r15
      d2:	1f 93       	push	r17
      d4:	cf 93       	push	r28
      d6:	df 93       	push	r29
      d8:	6c 01       	movw	r12, r24
      da:	16 2f       	mov	r17, r22
      dc:	f4 2e       	mov	r15, r20
BaseType_t xReturn;
CRCB_t *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
      de:	8a e1       	ldi	r24, 0x1A	; 26
      e0:	90 e0       	ldi	r25, 0x00	; 0
      e2:	0e 94 64 04 	call	0x8c8	; 0x8c8 <pvPortMalloc>
      e6:	ec 01       	movw	r28, r24
	if( pxCoRoutine )
      e8:	89 2b       	or	r24, r25
      ea:	09 f4       	brne	.+2      	; 0xee <xCoRoutineCreate+0x24>
      ec:	5d c0       	rjmp	.+186    	; 0x1a8 <xCoRoutineCreate+0xde>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
      ee:	80 91 34 01 	lds	r24, 0x0134	; 0x800134 <__data_end>
      f2:	90 91 35 01 	lds	r25, 0x0135	; 0x800135 <__data_end+0x1>
      f6:	89 2b       	or	r24, r25
      f8:	21 f5       	brne	.+72     	; 0x142 <xCoRoutineCreate+0x78>
		{
			pxCurrentCoRoutine = pxCoRoutine;
      fa:	d0 93 35 01 	sts	0x0135, r29	; 0x800135 <__data_end+0x1>
      fe:	c0 93 34 01 	sts	0x0134, r28	; 0x800134 <__data_end>
{
UBaseType_t uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
     102:	8c e5       	ldi	r24, 0x5C	; 92
     104:	91 e0       	ldi	r25, 0x01	; 1
     106:	0e 94 7f 02 	call	0x4fe	; 0x4fe <vListInitialise>
     10a:	85 e6       	ldi	r24, 0x65	; 101
     10c:	91 e0       	ldi	r25, 0x01	; 1
     10e:	0e 94 7f 02 	call	0x4fe	; 0x4fe <vListInitialise>
	}

	vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
     112:	83 e5       	ldi	r24, 0x53	; 83
     114:	91 e0       	ldi	r25, 0x01	; 1
     116:	0e 94 7f 02 	call	0x4fe	; 0x4fe <vListInitialise>
	vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
     11a:	8a e4       	ldi	r24, 0x4A	; 74
     11c:	91 e0       	ldi	r25, 0x01	; 1
     11e:	0e 94 7f 02 	call	0x4fe	; 0x4fe <vListInitialise>
	vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
     122:	8d e3       	ldi	r24, 0x3D	; 61
     124:	91 e0       	ldi	r25, 0x01	; 1
     126:	0e 94 7f 02 	call	0x4fe	; 0x4fe <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
     12a:	83 e5       	ldi	r24, 0x53	; 83
     12c:	91 e0       	ldi	r25, 0x01	; 1
     12e:	90 93 49 01 	sts	0x0149, r25	; 0x800149 <pxDelayedCoRoutineList+0x1>
     132:	80 93 48 01 	sts	0x0148, r24	; 0x800148 <pxDelayedCoRoutineList>
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
     136:	8a e4       	ldi	r24, 0x4A	; 74
     138:	91 e0       	ldi	r25, 0x01	; 1
     13a:	90 93 47 01 	sts	0x0147, r25	; 0x800147 <pxOverflowDelayedCoRoutineList+0x1>
     13e:	80 93 46 01 	sts	0x0146, r24	; 0x800146 <pxOverflowDelayedCoRoutineList>
     142:	11 11       	cpse	r17, r1
     144:	11 e0       	ldi	r17, 0x01	; 1
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
     146:	19 8e       	std	Y+25, r1	; 0x19
     148:	18 8e       	std	Y+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
     14a:	1e 8b       	std	Y+22, r17	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
     14c:	ff 8a       	std	Y+23, r15	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     14e:	fe 01       	movw	r30, r28
     150:	c1 92       	st	Z+, r12
     152:	d1 92       	st	Z+, r13
     154:	7f 01       	movw	r14, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     156:	cf 01       	movw	r24, r30
     158:	0e 94 8d 02 	call	0x51a	; 0x51a <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     15c:	ce 01       	movw	r24, r28
     15e:	0c 96       	adiw	r24, 0x0c	; 12
     160:	0e 94 8d 02 	call	0x51a	; 0x51a <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the ListItem_t.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     164:	d9 87       	std	Y+9, r29	; 0x09
     166:	c8 87       	std	Y+8, r28	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     168:	db 8b       	std	Y+19, r29	; 0x13
     16a:	ca 8b       	std	Y+18, r28	; 0x12

		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
     16c:	82 e0       	ldi	r24, 0x02	; 2
     16e:	90 e0       	ldi	r25, 0x00	; 0
     170:	81 1b       	sub	r24, r17
     172:	91 09       	sbc	r25, r1
     174:	9d 87       	std	Y+13, r25	; 0x0d
     176:	8c 87       	std	Y+12, r24	; 0x0c

		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
     178:	8e 89       	ldd	r24, Y+22	; 0x16
     17a:	90 91 3c 01 	lds	r25, 0x013C	; 0x80013c <uxTopCoRoutineReadyPriority>
     17e:	98 17       	cp	r25, r24
     180:	10 f4       	brcc	.+4      	; 0x186 <xCoRoutineCreate+0xbc>
     182:	80 93 3c 01 	sts	0x013C, r24	; 0x80013c <uxTopCoRoutineReadyPriority>
     186:	90 e0       	ldi	r25, 0x00	; 0
     188:	9c 01       	movw	r18, r24
     18a:	22 0f       	add	r18, r18
     18c:	33 1f       	adc	r19, r19
     18e:	22 0f       	add	r18, r18
     190:	33 1f       	adc	r19, r19
     192:	22 0f       	add	r18, r18
     194:	33 1f       	adc	r19, r19
     196:	82 0f       	add	r24, r18
     198:	93 1f       	adc	r25, r19
     19a:	b7 01       	movw	r22, r14
     19c:	84 5a       	subi	r24, 0xA4	; 164
     19e:	9e 4f       	sbci	r25, 0xFE	; 254
     1a0:	0e 94 91 02 	call	0x522	; 0x522 <vListInsertEnd>

		xReturn = pdPASS;
     1a4:	81 e0       	ldi	r24, 0x01	; 1
     1a6:	01 c0       	rjmp	.+2      	; 0x1aa <xCoRoutineCreate+0xe0>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     1a8:	8f ef       	ldi	r24, 0xFF	; 255
	}

	return xReturn;
}
     1aa:	df 91       	pop	r29
     1ac:	cf 91       	pop	r28
     1ae:	1f 91       	pop	r17
     1b0:	ff 90       	pop	r15
     1b2:	ef 90       	pop	r14
     1b4:	df 90       	pop	r13
     1b6:	cf 90       	pop	r12
     1b8:	08 95       	ret

000001ba <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay, List_t *pxEventList )
{
     1ba:	0f 93       	push	r16
     1bc:	1f 93       	push	r17
     1be:	cf 93       	push	r28
     1c0:	df 93       	push	r29
     1c2:	8b 01       	movw	r16, r22
TickType_t xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     1c4:	c0 91 3a 01 	lds	r28, 0x013A	; 0x80013a <xCoRoutineTickCount>
     1c8:	d0 91 3b 01 	lds	r29, 0x013B	; 0x80013b <xCoRoutineTickCount+0x1>
     1cc:	c8 0f       	add	r28, r24
     1ce:	d9 1f       	adc	r29, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     1d0:	80 91 34 01 	lds	r24, 0x0134	; 0x800134 <__data_end>
     1d4:	90 91 35 01 	lds	r25, 0x0135	; 0x800135 <__data_end+0x1>
     1d8:	02 96       	adiw	r24, 0x02	; 2
     1da:	0e 94 e3 02 	call	0x5c6	; 0x5c6 <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     1de:	e0 91 34 01 	lds	r30, 0x0134	; 0x800134 <__data_end>
     1e2:	f0 91 35 01 	lds	r31, 0x0135	; 0x800135 <__data_end+0x1>
     1e6:	d3 83       	std	Z+3, r29	; 0x03
     1e8:	c2 83       	std	Z+2, r28	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
     1ea:	80 91 3a 01 	lds	r24, 0x013A	; 0x80013a <xCoRoutineTickCount>
     1ee:	90 91 3b 01 	lds	r25, 0x013B	; 0x80013b <xCoRoutineTickCount+0x1>
     1f2:	c8 17       	cp	r28, r24
     1f4:	d9 07       	cpc	r29, r25
     1f6:	50 f4       	brcc	.+20     	; 0x20c <vCoRoutineAddToDelayedList+0x52>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     1f8:	bf 01       	movw	r22, r30
     1fa:	6e 5f       	subi	r22, 0xFE	; 254
     1fc:	7f 4f       	sbci	r23, 0xFF	; 255
     1fe:	80 91 46 01 	lds	r24, 0x0146	; 0x800146 <pxOverflowDelayedCoRoutineList>
     202:	90 91 47 01 	lds	r25, 0x0147	; 0x800147 <pxOverflowDelayedCoRoutineList+0x1>
     206:	0e 94 b2 02 	call	0x564	; 0x564 <vListInsert>
     20a:	09 c0       	rjmp	.+18     	; 0x21e <vCoRoutineAddToDelayedList+0x64>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     20c:	bf 01       	movw	r22, r30
     20e:	6e 5f       	subi	r22, 0xFE	; 254
     210:	7f 4f       	sbci	r23, 0xFF	; 255
     212:	80 91 48 01 	lds	r24, 0x0148	; 0x800148 <pxDelayedCoRoutineList>
     216:	90 91 49 01 	lds	r25, 0x0149	; 0x800149 <pxDelayedCoRoutineList+0x1>
     21a:	0e 94 b2 02 	call	0x564	; 0x564 <vListInsert>
	}

	if( pxEventList )
     21e:	01 15       	cp	r16, r1
     220:	11 05       	cpc	r17, r1
     222:	49 f0       	breq	.+18     	; 0x236 <vCoRoutineAddToDelayedList+0x7c>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     224:	60 91 34 01 	lds	r22, 0x0134	; 0x800134 <__data_end>
     228:	70 91 35 01 	lds	r23, 0x0135	; 0x800135 <__data_end+0x1>
     22c:	64 5f       	subi	r22, 0xF4	; 244
     22e:	7f 4f       	sbci	r23, 0xFF	; 255
     230:	c8 01       	movw	r24, r16
     232:	0e 94 b2 02 	call	0x564	; 0x564 <vListInsert>
	}
}
     236:	df 91       	pop	r29
     238:	cf 91       	pop	r28
     23a:	1f 91       	pop	r17
     23c:	0f 91       	pop	r16
     23e:	08 95       	ret

00000240 <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
     240:	ef 92       	push	r14
     242:	ff 92       	push	r15
     244:	0f 93       	push	r16
     246:	1f 93       	push	r17
     248:	cf 93       	push	r28
     24a:	df 93       	push	r29
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     24c:	80 91 3d 01 	lds	r24, 0x013D	; 0x80013d <xPendingReadyCoRoutineList>
     250:	88 23       	and	r24, r24
     252:	99 f1       	breq	.+102    	; 0x2ba <vCoRoutineSchedule+0x7a>
		CRCB_t *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
		{
			pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
     254:	0f 2e       	mov	r0, r31
     256:	fd e3       	ldi	r31, 0x3D	; 61
     258:	ef 2e       	mov	r14, r31
     25a:	f1 e0       	ldi	r31, 0x01	; 1
     25c:	ff 2e       	mov	r15, r31
     25e:	f0 2d       	mov	r31, r0
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		CRCB_t *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
     260:	f8 94       	cli
		{
			pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
     262:	d7 01       	movw	r26, r14
     264:	15 96       	adiw	r26, 0x05	; 5
     266:	ed 91       	ld	r30, X+
     268:	fc 91       	ld	r31, X
     26a:	16 97       	sbiw	r26, 0x06	; 6
     26c:	c6 81       	ldd	r28, Z+6	; 0x06
     26e:	d7 81       	ldd	r29, Z+7	; 0x07
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     270:	ce 01       	movw	r24, r28
     272:	0c 96       	adiw	r24, 0x0c	; 12
     274:	0e 94 e3 02 	call	0x5c6	; 0x5c6 <uxListRemove>
		}
		portENABLE_INTERRUPTS();
     278:	78 94       	sei

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
     27a:	8e 01       	movw	r16, r28
     27c:	0e 5f       	subi	r16, 0xFE	; 254
     27e:	1f 4f       	sbci	r17, 0xFF	; 255
     280:	c8 01       	movw	r24, r16
     282:	0e 94 e3 02 	call	0x5c6	; 0x5c6 <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
     286:	8e 89       	ldd	r24, Y+22	; 0x16
     288:	90 91 3c 01 	lds	r25, 0x013C	; 0x80013c <uxTopCoRoutineReadyPriority>
     28c:	98 17       	cp	r25, r24
     28e:	10 f4       	brcc	.+4      	; 0x294 <vCoRoutineSchedule+0x54>
     290:	80 93 3c 01 	sts	0x013C, r24	; 0x80013c <uxTopCoRoutineReadyPriority>
     294:	90 e0       	ldi	r25, 0x00	; 0
     296:	9c 01       	movw	r18, r24
     298:	22 0f       	add	r18, r18
     29a:	33 1f       	adc	r19, r19
     29c:	22 0f       	add	r18, r18
     29e:	33 1f       	adc	r19, r19
     2a0:	22 0f       	add	r18, r18
     2a2:	33 1f       	adc	r19, r19
     2a4:	82 0f       	add	r24, r18
     2a6:	93 1f       	adc	r25, r19
     2a8:	b8 01       	movw	r22, r16
     2aa:	84 5a       	subi	r24, 0xA4	; 164
     2ac:	9e 4f       	sbci	r25, 0xFE	; 254
     2ae:	0e 94 91 02 	call	0x522	; 0x522 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     2b2:	f7 01       	movw	r30, r14
     2b4:	80 81       	ld	r24, Z
     2b6:	81 11       	cpse	r24, r1
     2b8:	d3 cf       	rjmp	.-90     	; 0x260 <vCoRoutineSchedule+0x20>

static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
     2ba:	0e 94 cb 0a 	call	0x1596	; 0x1596 <xTaskGetTickCount>
     2be:	20 91 38 01 	lds	r18, 0x0138	; 0x800138 <xLastTickCount>
     2c2:	30 91 39 01 	lds	r19, 0x0139	; 0x800139 <xLastTickCount+0x1>
     2c6:	82 1b       	sub	r24, r18
     2c8:	93 0b       	sbc	r25, r19
     2ca:	90 93 37 01 	sts	0x0137, r25	; 0x800137 <xPassedTicks+0x1>
     2ce:	80 93 36 01 	sts	0x0136, r24	; 0x800136 <xPassedTicks>
     2d2:	6f c0       	rjmp	.+222    	; 0x3b2 <vCoRoutineSchedule+0x172>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
     2d4:	80 91 3a 01 	lds	r24, 0x013A	; 0x80013a <xCoRoutineTickCount>
     2d8:	90 91 3b 01 	lds	r25, 0x013B	; 0x80013b <xCoRoutineTickCount+0x1>
     2dc:	01 96       	adiw	r24, 0x01	; 1
     2de:	90 93 3b 01 	sts	0x013B, r25	; 0x80013b <xCoRoutineTickCount+0x1>
     2e2:	80 93 3a 01 	sts	0x013A, r24	; 0x80013a <xCoRoutineTickCount>
		xPassedTicks--;
     2e6:	21 50       	subi	r18, 0x01	; 1
     2e8:	31 09       	sbc	r19, r1
     2ea:	30 93 37 01 	sts	0x0137, r19	; 0x800137 <xPassedTicks+0x1>
     2ee:	20 93 36 01 	sts	0x0136, r18	; 0x800136 <xPassedTicks>

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
     2f2:	00 97       	sbiw	r24, 0x00	; 0
     2f4:	81 f4       	brne	.+32     	; 0x316 <vCoRoutineSchedule+0xd6>
		{
			List_t * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
     2f6:	20 91 48 01 	lds	r18, 0x0148	; 0x800148 <pxDelayedCoRoutineList>
     2fa:	30 91 49 01 	lds	r19, 0x0149	; 0x800149 <pxDelayedCoRoutineList+0x1>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
     2fe:	40 91 46 01 	lds	r20, 0x0146	; 0x800146 <pxOverflowDelayedCoRoutineList>
     302:	50 91 47 01 	lds	r21, 0x0147	; 0x800147 <pxOverflowDelayedCoRoutineList+0x1>
     306:	50 93 49 01 	sts	0x0149, r21	; 0x800149 <pxDelayedCoRoutineList+0x1>
     30a:	40 93 48 01 	sts	0x0148, r20	; 0x800148 <pxDelayedCoRoutineList>
			pxOverflowDelayedCoRoutineList = pxTemp;
     30e:	30 93 47 01 	sts	0x0147, r19	; 0x800147 <pxOverflowDelayedCoRoutineList+0x1>
     312:	20 93 46 01 	sts	0x0146, r18	; 0x800146 <pxOverflowDelayedCoRoutineList>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     316:	e0 91 48 01 	lds	r30, 0x0148	; 0x800148 <pxDelayedCoRoutineList>
     31a:	f0 91 49 01 	lds	r31, 0x0149	; 0x800149 <pxDelayedCoRoutineList+0x1>
     31e:	20 81       	ld	r18, Z
     320:	22 23       	and	r18, r18
     322:	09 f4       	brne	.+2      	; 0x326 <vCoRoutineSchedule+0xe6>
     324:	46 c0       	rjmp	.+140    	; 0x3b2 <vCoRoutineSchedule+0x172>
		{
			pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     326:	05 80       	ldd	r0, Z+5	; 0x05
     328:	f6 81       	ldd	r31, Z+6	; 0x06
     32a:	e0 2d       	mov	r30, r0
     32c:	c6 81       	ldd	r28, Z+6	; 0x06
     32e:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
     330:	2a 81       	ldd	r18, Y+2	; 0x02
     332:	3b 81       	ldd	r19, Y+3	; 0x03
     334:	82 17       	cp	r24, r18
     336:	93 07       	cpc	r25, r19
     338:	78 f4       	brcc	.+30     	; 0x358 <vCoRoutineSchedule+0x118>
     33a:	3b c0       	rjmp	.+118    	; 0x3b2 <vCoRoutineSchedule+0x172>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     33c:	05 80       	ldd	r0, Z+5	; 0x05
     33e:	f6 81       	ldd	r31, Z+6	; 0x06
     340:	e0 2d       	mov	r30, r0
     342:	c6 81       	ldd	r28, Z+6	; 0x06
     344:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
     346:	2a 81       	ldd	r18, Y+2	; 0x02
     348:	3b 81       	ldd	r19, Y+3	; 0x03
     34a:	80 91 3a 01 	lds	r24, 0x013A	; 0x80013a <xCoRoutineTickCount>
     34e:	90 91 3b 01 	lds	r25, 0x013B	; 0x80013b <xCoRoutineTickCount+0x1>
     352:	82 17       	cp	r24, r18
     354:	93 07       	cpc	r25, r19
     356:	68 f1       	brcs	.+90     	; 0x3b2 <vCoRoutineSchedule+0x172>
			{
				/* Timeout not yet expired. */
				break;
			}

			portDISABLE_INTERRUPTS();
     358:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
     35a:	8e 01       	movw	r16, r28
     35c:	0e 5f       	subi	r16, 0xFE	; 254
     35e:	1f 4f       	sbci	r17, 0xFF	; 255
     360:	c8 01       	movw	r24, r16
     362:	0e 94 e3 02 	call	0x5c6	; 0x5c6 <uxListRemove>

				/* Is the co-routine waiting on an event also? */
				if( pxCRCB->xEventListItem.pvContainer )
     366:	8c 89       	ldd	r24, Y+20	; 0x14
     368:	9d 89       	ldd	r25, Y+21	; 0x15
     36a:	89 2b       	or	r24, r25
     36c:	21 f0       	breq	.+8      	; 0x376 <vCoRoutineSchedule+0x136>
				{
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
     36e:	ce 01       	movw	r24, r28
     370:	0c 96       	adiw	r24, 0x0c	; 12
     372:	0e 94 e3 02 	call	0x5c6	; 0x5c6 <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
     376:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );
     378:	8e 89       	ldd	r24, Y+22	; 0x16
     37a:	90 91 3c 01 	lds	r25, 0x013C	; 0x80013c <uxTopCoRoutineReadyPriority>
     37e:	98 17       	cp	r25, r24
     380:	10 f4       	brcc	.+4      	; 0x386 <vCoRoutineSchedule+0x146>
     382:	80 93 3c 01 	sts	0x013C, r24	; 0x80013c <uxTopCoRoutineReadyPriority>
     386:	90 e0       	ldi	r25, 0x00	; 0
     388:	9c 01       	movw	r18, r24
     38a:	22 0f       	add	r18, r18
     38c:	33 1f       	adc	r19, r19
     38e:	22 0f       	add	r18, r18
     390:	33 1f       	adc	r19, r19
     392:	22 0f       	add	r18, r18
     394:	33 1f       	adc	r19, r19
     396:	82 0f       	add	r24, r18
     398:	93 1f       	adc	r25, r19
     39a:	b8 01       	movw	r22, r16
     39c:	84 5a       	subi	r24, 0xA4	; 164
     39e:	9e 4f       	sbci	r25, 0xFE	; 254
     3a0:	0e 94 91 02 	call	0x522	; 0x522 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     3a4:	e0 91 48 01 	lds	r30, 0x0148	; 0x800148 <pxDelayedCoRoutineList>
     3a8:	f0 91 49 01 	lds	r31, 0x0149	; 0x800149 <pxDelayedCoRoutineList+0x1>
     3ac:	80 81       	ld	r24, Z
     3ae:	81 11       	cpse	r24, r1
     3b0:	c5 cf       	rjmp	.-118    	; 0x33c <vCoRoutineSchedule+0xfc>
static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
     3b2:	20 91 36 01 	lds	r18, 0x0136	; 0x800136 <xPassedTicks>
     3b6:	30 91 37 01 	lds	r19, 0x0137	; 0x800137 <xPassedTicks+0x1>
     3ba:	21 15       	cp	r18, r1
     3bc:	31 05       	cpc	r19, r1
     3be:	09 f0       	breq	.+2      	; 0x3c2 <vCoRoutineSchedule+0x182>
     3c0:	89 cf       	rjmp	.-238    	; 0x2d4 <vCoRoutineSchedule+0x94>

			prvAddCoRoutineToReadyQueue( pxCRCB );
		}
	}

	xLastTickCount = xCoRoutineTickCount;
     3c2:	80 91 3a 01 	lds	r24, 0x013A	; 0x80013a <xCoRoutineTickCount>
     3c6:	90 91 3b 01 	lds	r25, 0x013B	; 0x80013b <xCoRoutineTickCount+0x1>
     3ca:	90 93 39 01 	sts	0x0139, r25	; 0x800139 <xLastTickCount+0x1>
     3ce:	80 93 38 01 	sts	0x0138, r24	; 0x800138 <xLastTickCount>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     3d2:	80 91 3c 01 	lds	r24, 0x013C	; 0x80013c <uxTopCoRoutineReadyPriority>
     3d6:	28 2f       	mov	r18, r24
     3d8:	30 e0       	ldi	r19, 0x00	; 0
     3da:	f9 01       	movw	r30, r18
     3dc:	ee 0f       	add	r30, r30
     3de:	ff 1f       	adc	r31, r31
     3e0:	ee 0f       	add	r30, r30
     3e2:	ff 1f       	adc	r31, r31
     3e4:	ee 0f       	add	r30, r30
     3e6:	ff 1f       	adc	r31, r31
     3e8:	e2 0f       	add	r30, r18
     3ea:	f3 1f       	adc	r31, r19
     3ec:	e4 5a       	subi	r30, 0xA4	; 164
     3ee:	fe 4f       	sbci	r31, 0xFE	; 254
     3f0:	90 81       	ld	r25, Z
     3f2:	91 11       	cpse	r25, r1
     3f4:	1b c0       	rjmp	.+54     	; 0x42c <__LOCK_REGION_LENGTH__+0x2c>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
     3f6:	81 11       	cpse	r24, r1
     3f8:	06 c0       	rjmp	.+12     	; 0x406 <__LOCK_REGION_LENGTH__+0x6>
     3fa:	55 c0       	rjmp	.+170    	; 0x4a6 <__LOCK_REGION_LENGTH__+0xa6>
     3fc:	81 11       	cpse	r24, r1
     3fe:	03 c0       	rjmp	.+6      	; 0x406 <__LOCK_REGION_LENGTH__+0x6>
     400:	10 92 3c 01 	sts	0x013C, r1	; 0x80013c <uxTopCoRoutineReadyPriority>
     404:	50 c0       	rjmp	.+160    	; 0x4a6 <__LOCK_REGION_LENGTH__+0xa6>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
     406:	81 50       	subi	r24, 0x01	; 1

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     408:	28 2f       	mov	r18, r24
     40a:	30 e0       	ldi	r19, 0x00	; 0
     40c:	f9 01       	movw	r30, r18
     40e:	ee 0f       	add	r30, r30
     410:	ff 1f       	adc	r31, r31
     412:	ee 0f       	add	r30, r30
     414:	ff 1f       	adc	r31, r31
     416:	ee 0f       	add	r30, r30
     418:	ff 1f       	adc	r31, r31
     41a:	e2 0f       	add	r30, r18
     41c:	f3 1f       	adc	r31, r19
     41e:	e4 5a       	subi	r30, 0xA4	; 164
     420:	fe 4f       	sbci	r31, 0xFE	; 254
     422:	90 81       	ld	r25, Z
     424:	99 23       	and	r25, r25
     426:	51 f3       	breq	.-44     	; 0x3fc <vCoRoutineSchedule+0x1bc>
     428:	80 93 3c 01 	sts	0x013C, r24	; 0x80013c <uxTopCoRoutineReadyPriority>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
     42c:	c9 01       	movw	r24, r18
     42e:	88 0f       	add	r24, r24
     430:	99 1f       	adc	r25, r25
     432:	88 0f       	add	r24, r24
     434:	99 1f       	adc	r25, r25
     436:	88 0f       	add	r24, r24
     438:	99 1f       	adc	r25, r25
     43a:	82 0f       	add	r24, r18
     43c:	93 1f       	adc	r25, r19
     43e:	dc 01       	movw	r26, r24
     440:	a4 5a       	subi	r26, 0xA4	; 164
     442:	be 4f       	sbci	r27, 0xFE	; 254
     444:	11 96       	adiw	r26, 0x01	; 1
     446:	ed 91       	ld	r30, X+
     448:	fc 91       	ld	r31, X
     44a:	12 97       	sbiw	r26, 0x02	; 2
     44c:	02 80       	ldd	r0, Z+2	; 0x02
     44e:	f3 81       	ldd	r31, Z+3	; 0x03
     450:	e0 2d       	mov	r30, r0
     452:	12 96       	adiw	r26, 0x02	; 2
     454:	fc 93       	st	X, r31
     456:	ee 93       	st	-X, r30
     458:	11 97       	sbiw	r26, 0x01	; 1
     45a:	81 5a       	subi	r24, 0xA1	; 161
     45c:	9e 4f       	sbci	r25, 0xFE	; 254
     45e:	e8 17       	cp	r30, r24
     460:	f9 07       	cpc	r31, r25
     462:	29 f4       	brne	.+10     	; 0x46e <__LOCK_REGION_LENGTH__+0x6e>
     464:	82 81       	ldd	r24, Z+2	; 0x02
     466:	93 81       	ldd	r25, Z+3	; 0x03
     468:	fd 01       	movw	r30, r26
     46a:	92 83       	std	Z+2, r25	; 0x02
     46c:	81 83       	std	Z+1, r24	; 0x01
     46e:	f9 01       	movw	r30, r18
     470:	ee 0f       	add	r30, r30
     472:	ff 1f       	adc	r31, r31
     474:	ee 0f       	add	r30, r30
     476:	ff 1f       	adc	r31, r31
     478:	ee 0f       	add	r30, r30
     47a:	ff 1f       	adc	r31, r31
     47c:	2e 0f       	add	r18, r30
     47e:	3f 1f       	adc	r19, r31
     480:	f9 01       	movw	r30, r18
     482:	e4 5a       	subi	r30, 0xA4	; 164
     484:	fe 4f       	sbci	r31, 0xFE	; 254
     486:	01 80       	ldd	r0, Z+1	; 0x01
     488:	f2 81       	ldd	r31, Z+2	; 0x02
     48a:	e0 2d       	mov	r30, r0
     48c:	86 81       	ldd	r24, Z+6	; 0x06
     48e:	97 81       	ldd	r25, Z+7	; 0x07
     490:	90 93 35 01 	sts	0x0135, r25	; 0x800135 <__data_end+0x1>
     494:	80 93 34 01 	sts	0x0134, r24	; 0x800134 <__data_end>

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
     498:	dc 01       	movw	r26, r24
     49a:	ed 91       	ld	r30, X+
     49c:	fc 91       	ld	r31, X
     49e:	11 97       	sbiw	r26, 0x01	; 1
     4a0:	57 96       	adiw	r26, 0x17	; 23
     4a2:	6c 91       	ld	r22, X
     4a4:	09 95       	icall

	return;
}
     4a6:	df 91       	pop	r29
     4a8:	cf 91       	pop	r28
     4aa:	1f 91       	pop	r17
     4ac:	0f 91       	pop	r16
     4ae:	ff 90       	pop	r15
     4b0:	ef 90       	pop	r14
     4b2:	08 95       	ret

000004b4 <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

BaseType_t xCoRoutineRemoveFromEventList( const List_t *pxEventList )
{
     4b4:	0f 93       	push	r16
     4b6:	1f 93       	push	r17
     4b8:	cf 93       	push	r28
     4ba:	df 93       	push	r29
BaseType_t xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     4bc:	dc 01       	movw	r26, r24
     4be:	15 96       	adiw	r26, 0x05	; 5
     4c0:	ed 91       	ld	r30, X+
     4c2:	fc 91       	ld	r31, X
     4c4:	16 97       	sbiw	r26, 0x06	; 6
     4c6:	c6 81       	ldd	r28, Z+6	; 0x06
     4c8:	d7 81       	ldd	r29, Z+7	; 0x07
	( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     4ca:	8e 01       	movw	r16, r28
     4cc:	04 5f       	subi	r16, 0xF4	; 244
     4ce:	1f 4f       	sbci	r17, 0xFF	; 255
     4d0:	c8 01       	movw	r24, r16
     4d2:	0e 94 e3 02 	call	0x5c6	; 0x5c6 <uxListRemove>
	vListInsertEnd( ( List_t * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
     4d6:	b8 01       	movw	r22, r16
     4d8:	8d e3       	ldi	r24, 0x3D	; 61
     4da:	91 e0       	ldi	r25, 0x01	; 1
     4dc:	0e 94 91 02 	call	0x522	; 0x522 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
     4e0:	e0 91 34 01 	lds	r30, 0x0134	; 0x800134 <__data_end>
     4e4:	f0 91 35 01 	lds	r31, 0x0135	; 0x800135 <__data_end+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
     4e8:	81 e0       	ldi	r24, 0x01	; 1
     4ea:	2e 89       	ldd	r18, Y+22	; 0x16
     4ec:	96 89       	ldd	r25, Z+22	; 0x16
     4ee:	29 17       	cp	r18, r25
     4f0:	08 f4       	brcc	.+2      	; 0x4f4 <xCoRoutineRemoveFromEventList+0x40>
     4f2:	80 e0       	ldi	r24, 0x00	; 0
}
     4f4:	df 91       	pop	r29
     4f6:	cf 91       	pop	r28
     4f8:	1f 91       	pop	r17
     4fa:	0f 91       	pop	r16
     4fc:	08 95       	ret

000004fe <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     4fe:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     500:	03 96       	adiw	r24, 0x03	; 3
     502:	92 83       	std	Z+2, r25	; 0x02
     504:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     506:	2f ef       	ldi	r18, 0xFF	; 255
     508:	3f ef       	ldi	r19, 0xFF	; 255
     50a:	34 83       	std	Z+4, r19	; 0x04
     50c:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     50e:	96 83       	std	Z+6, r25	; 0x06
     510:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     512:	90 87       	std	Z+8, r25	; 0x08
     514:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     516:	10 82       	st	Z, r1
     518:	08 95       	ret

0000051a <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     51a:	fc 01       	movw	r30, r24
     51c:	11 86       	std	Z+9, r1	; 0x09
     51e:	10 86       	std	Z+8, r1	; 0x08
     520:	08 95       	ret

00000522 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     522:	cf 93       	push	r28
     524:	df 93       	push	r29
     526:	9c 01       	movw	r18, r24
     528:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     52a:	dc 01       	movw	r26, r24
     52c:	11 96       	adiw	r26, 0x01	; 1
     52e:	cd 91       	ld	r28, X+
     530:	dc 91       	ld	r29, X
     532:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     534:	d3 83       	std	Z+3, r29	; 0x03
     536:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     538:	8c 81       	ldd	r24, Y+4	; 0x04
     53a:	9d 81       	ldd	r25, Y+5	; 0x05
     53c:	95 83       	std	Z+5, r25	; 0x05
     53e:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     540:	8c 81       	ldd	r24, Y+4	; 0x04
     542:	9d 81       	ldd	r25, Y+5	; 0x05
     544:	dc 01       	movw	r26, r24
     546:	13 96       	adiw	r26, 0x03	; 3
     548:	7c 93       	st	X, r23
     54a:	6e 93       	st	-X, r22
     54c:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     54e:	7d 83       	std	Y+5, r23	; 0x05
     550:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     552:	31 87       	std	Z+9, r19	; 0x09
     554:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     556:	f9 01       	movw	r30, r18
     558:	80 81       	ld	r24, Z
     55a:	8f 5f       	subi	r24, 0xFF	; 255
     55c:	80 83       	st	Z, r24
}
     55e:	df 91       	pop	r29
     560:	cf 91       	pop	r28
     562:	08 95       	ret

00000564 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     564:	cf 93       	push	r28
     566:	df 93       	push	r29
     568:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     56a:	48 81       	ld	r20, Y
     56c:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     56e:	4f 3f       	cpi	r20, 0xFF	; 255
     570:	2f ef       	ldi	r18, 0xFF	; 255
     572:	52 07       	cpc	r21, r18
     574:	21 f4       	brne	.+8      	; 0x57e <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     576:	fc 01       	movw	r30, r24
     578:	a7 81       	ldd	r26, Z+7	; 0x07
     57a:	b0 85       	ldd	r27, Z+8	; 0x08
     57c:	0d c0       	rjmp	.+26     	; 0x598 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     57e:	dc 01       	movw	r26, r24
     580:	13 96       	adiw	r26, 0x03	; 3
     582:	01 c0       	rjmp	.+2      	; 0x586 <vListInsert+0x22>
     584:	df 01       	movw	r26, r30
     586:	12 96       	adiw	r26, 0x02	; 2
     588:	ed 91       	ld	r30, X+
     58a:	fc 91       	ld	r31, X
     58c:	13 97       	sbiw	r26, 0x03	; 3
     58e:	20 81       	ld	r18, Z
     590:	31 81       	ldd	r19, Z+1	; 0x01
     592:	42 17       	cp	r20, r18
     594:	53 07       	cpc	r21, r19
     596:	b0 f7       	brcc	.-20     	; 0x584 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     598:	12 96       	adiw	r26, 0x02	; 2
     59a:	ed 91       	ld	r30, X+
     59c:	fc 91       	ld	r31, X
     59e:	13 97       	sbiw	r26, 0x03	; 3
     5a0:	fb 83       	std	Y+3, r31	; 0x03
     5a2:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     5a4:	d5 83       	std	Z+5, r29	; 0x05
     5a6:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     5a8:	bd 83       	std	Y+5, r27	; 0x05
     5aa:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     5ac:	13 96       	adiw	r26, 0x03	; 3
     5ae:	dc 93       	st	X, r29
     5b0:	ce 93       	st	-X, r28
     5b2:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     5b4:	99 87       	std	Y+9, r25	; 0x09
     5b6:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     5b8:	fc 01       	movw	r30, r24
     5ba:	20 81       	ld	r18, Z
     5bc:	2f 5f       	subi	r18, 0xFF	; 255
     5be:	20 83       	st	Z, r18
}
     5c0:	df 91       	pop	r29
     5c2:	cf 91       	pop	r28
     5c4:	08 95       	ret

000005c6 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     5c6:	cf 93       	push	r28
     5c8:	df 93       	push	r29
     5ca:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     5cc:	a0 85       	ldd	r26, Z+8	; 0x08
     5ce:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     5d0:	c2 81       	ldd	r28, Z+2	; 0x02
     5d2:	d3 81       	ldd	r29, Z+3	; 0x03
     5d4:	84 81       	ldd	r24, Z+4	; 0x04
     5d6:	95 81       	ldd	r25, Z+5	; 0x05
     5d8:	9d 83       	std	Y+5, r25	; 0x05
     5da:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     5dc:	c4 81       	ldd	r28, Z+4	; 0x04
     5de:	d5 81       	ldd	r29, Z+5	; 0x05
     5e0:	82 81       	ldd	r24, Z+2	; 0x02
     5e2:	93 81       	ldd	r25, Z+3	; 0x03
     5e4:	9b 83       	std	Y+3, r25	; 0x03
     5e6:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     5e8:	11 96       	adiw	r26, 0x01	; 1
     5ea:	8d 91       	ld	r24, X+
     5ec:	9c 91       	ld	r25, X
     5ee:	12 97       	sbiw	r26, 0x02	; 2
     5f0:	e8 17       	cp	r30, r24
     5f2:	f9 07       	cpc	r31, r25
     5f4:	31 f4       	brne	.+12     	; 0x602 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     5f6:	84 81       	ldd	r24, Z+4	; 0x04
     5f8:	95 81       	ldd	r25, Z+5	; 0x05
     5fa:	12 96       	adiw	r26, 0x02	; 2
     5fc:	9c 93       	st	X, r25
     5fe:	8e 93       	st	-X, r24
     600:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     602:	11 86       	std	Z+9, r1	; 0x09
     604:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     606:	8c 91       	ld	r24, X
     608:	81 50       	subi	r24, 0x01	; 1
     60a:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     60c:	df 91       	pop	r29
     60e:	cf 91       	pop	r28
     610:	08 95       	ret

00000612 <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     612:	31 e1       	ldi	r19, 0x11	; 17
     614:	fc 01       	movw	r30, r24
     616:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
     618:	31 97       	sbiw	r30, 0x01	; 1
     61a:	22 e2       	ldi	r18, 0x22	; 34
     61c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
     61e:	31 97       	sbiw	r30, 0x01	; 1
     620:	a3 e3       	ldi	r26, 0x33	; 51
     622:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     624:	31 97       	sbiw	r30, 0x01	; 1
     626:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     628:	31 97       	sbiw	r30, 0x01	; 1
     62a:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
     62c:	31 97       	sbiw	r30, 0x01	; 1
     62e:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     630:	31 97       	sbiw	r30, 0x01	; 1
     632:	60 e8       	ldi	r22, 0x80	; 128
     634:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
     636:	31 97       	sbiw	r30, 0x01	; 1
     638:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
     63a:	31 97       	sbiw	r30, 0x01	; 1
     63c:	62 e0       	ldi	r22, 0x02	; 2
     63e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
     640:	31 97       	sbiw	r30, 0x01	; 1
     642:	63 e0       	ldi	r22, 0x03	; 3
     644:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
     646:	31 97       	sbiw	r30, 0x01	; 1
     648:	64 e0       	ldi	r22, 0x04	; 4
     64a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
     64c:	31 97       	sbiw	r30, 0x01	; 1
     64e:	65 e0       	ldi	r22, 0x05	; 5
     650:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
     652:	31 97       	sbiw	r30, 0x01	; 1
     654:	66 e0       	ldi	r22, 0x06	; 6
     656:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
     658:	31 97       	sbiw	r30, 0x01	; 1
     65a:	67 e0       	ldi	r22, 0x07	; 7
     65c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
     65e:	31 97       	sbiw	r30, 0x01	; 1
     660:	68 e0       	ldi	r22, 0x08	; 8
     662:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
     664:	31 97       	sbiw	r30, 0x01	; 1
     666:	69 e0       	ldi	r22, 0x09	; 9
     668:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
     66a:	31 97       	sbiw	r30, 0x01	; 1
     66c:	60 e1       	ldi	r22, 0x10	; 16
     66e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
     670:	31 97       	sbiw	r30, 0x01	; 1
     672:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
     674:	31 97       	sbiw	r30, 0x01	; 1
     676:	32 e1       	ldi	r19, 0x12	; 18
     678:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
     67a:	31 97       	sbiw	r30, 0x01	; 1
     67c:	33 e1       	ldi	r19, 0x13	; 19
     67e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
     680:	31 97       	sbiw	r30, 0x01	; 1
     682:	34 e1       	ldi	r19, 0x14	; 20
     684:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
     686:	31 97       	sbiw	r30, 0x01	; 1
     688:	35 e1       	ldi	r19, 0x15	; 21
     68a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
     68c:	31 97       	sbiw	r30, 0x01	; 1
     68e:	36 e1       	ldi	r19, 0x16	; 22
     690:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
     692:	31 97       	sbiw	r30, 0x01	; 1
     694:	37 e1       	ldi	r19, 0x17	; 23
     696:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
     698:	31 97       	sbiw	r30, 0x01	; 1
     69a:	38 e1       	ldi	r19, 0x18	; 24
     69c:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
     69e:	31 97       	sbiw	r30, 0x01	; 1
     6a0:	39 e1       	ldi	r19, 0x19	; 25
     6a2:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
     6a4:	31 97       	sbiw	r30, 0x01	; 1
     6a6:	30 e2       	ldi	r19, 0x20	; 32
     6a8:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
     6aa:	31 97       	sbiw	r30, 0x01	; 1
     6ac:	31 e2       	ldi	r19, 0x21	; 33
     6ae:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
     6b0:	31 97       	sbiw	r30, 0x01	; 1
     6b2:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
     6b4:	31 97       	sbiw	r30, 0x01	; 1
     6b6:	23 e2       	ldi	r18, 0x23	; 35
     6b8:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     6ba:	31 97       	sbiw	r30, 0x01	; 1
     6bc:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     6be:	31 97       	sbiw	r30, 0x01	; 1
     6c0:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
     6c2:	31 97       	sbiw	r30, 0x01	; 1
     6c4:	26 e2       	ldi	r18, 0x26	; 38
     6c6:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
     6c8:	31 97       	sbiw	r30, 0x01	; 1
     6ca:	27 e2       	ldi	r18, 0x27	; 39
     6cc:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
     6ce:	31 97       	sbiw	r30, 0x01	; 1
     6d0:	28 e2       	ldi	r18, 0x28	; 40
     6d2:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
     6d4:	31 97       	sbiw	r30, 0x01	; 1
     6d6:	29 e2       	ldi	r18, 0x29	; 41
     6d8:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
     6da:	31 97       	sbiw	r30, 0x01	; 1
     6dc:	20 e3       	ldi	r18, 0x30	; 48
     6de:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
     6e0:	31 97       	sbiw	r30, 0x01	; 1
     6e2:	21 e3       	ldi	r18, 0x31	; 49
     6e4:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
     6e6:	86 97       	sbiw	r24, 0x26	; 38
     6e8:	08 95       	ret

000006ea <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	OCR1AH = ucHighByte;
     6ea:	86 e0       	ldi	r24, 0x06	; 6
     6ec:	8b bd       	out	0x2b, r24	; 43
	OCR1AL = ucLowByte;
     6ee:	8f eb       	ldi	r24, 0xBF	; 191
     6f0:	8a bd       	out	0x2a, r24	; 42

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
     6f2:	8b e0       	ldi	r24, 0x0B	; 11
     6f4:	8e bd       	out	0x2e, r24	; 46

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
     6f6:	87 b7       	in	r24, 0x37	; 55
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     6f8:	80 61       	ori	r24, 0x10	; 16
	TIMSK = ucLowByte;
     6fa:	87 bf       	out	0x37, r24	; 55
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     6fc:	a0 91 72 0d 	lds	r26, 0x0D72	; 0x800d72 <pxCurrentTCB>
     700:	b0 91 73 0d 	lds	r27, 0x0D73	; 0x800d73 <pxCurrentTCB+0x1>
     704:	cd 91       	ld	r28, X+
     706:	cd bf       	out	0x3d, r28	; 61
     708:	dd 91       	ld	r29, X+
     70a:	de bf       	out	0x3e, r29	; 62
     70c:	ff 91       	pop	r31
     70e:	ef 91       	pop	r30
     710:	df 91       	pop	r29
     712:	cf 91       	pop	r28
     714:	bf 91       	pop	r27
     716:	af 91       	pop	r26
     718:	9f 91       	pop	r25
     71a:	8f 91       	pop	r24
     71c:	7f 91       	pop	r23
     71e:	6f 91       	pop	r22
     720:	5f 91       	pop	r21
     722:	4f 91       	pop	r20
     724:	3f 91       	pop	r19
     726:	2f 91       	pop	r18
     728:	1f 91       	pop	r17
     72a:	0f 91       	pop	r16
     72c:	ff 90       	pop	r15
     72e:	ef 90       	pop	r14
     730:	df 90       	pop	r13
     732:	cf 90       	pop	r12
     734:	bf 90       	pop	r11
     736:	af 90       	pop	r10
     738:	9f 90       	pop	r9
     73a:	8f 90       	pop	r8
     73c:	7f 90       	pop	r7
     73e:	6f 90       	pop	r6
     740:	5f 90       	pop	r5
     742:	4f 90       	pop	r4
     744:	3f 90       	pop	r3
     746:	2f 90       	pop	r2
     748:	1f 90       	pop	r1
     74a:	0f 90       	pop	r0
     74c:	0f be       	out	0x3f, r0	; 63
     74e:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     750:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
     752:	81 e0       	ldi	r24, 0x01	; 1
     754:	08 95       	ret

00000756 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     756:	08 95       	ret

00000758 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     758:	0f 92       	push	r0
     75a:	0f b6       	in	r0, 0x3f	; 63
     75c:	f8 94       	cli
     75e:	0f 92       	push	r0
     760:	1f 92       	push	r1
     762:	11 24       	eor	r1, r1
     764:	2f 92       	push	r2
     766:	3f 92       	push	r3
     768:	4f 92       	push	r4
     76a:	5f 92       	push	r5
     76c:	6f 92       	push	r6
     76e:	7f 92       	push	r7
     770:	8f 92       	push	r8
     772:	9f 92       	push	r9
     774:	af 92       	push	r10
     776:	bf 92       	push	r11
     778:	cf 92       	push	r12
     77a:	df 92       	push	r13
     77c:	ef 92       	push	r14
     77e:	ff 92       	push	r15
     780:	0f 93       	push	r16
     782:	1f 93       	push	r17
     784:	2f 93       	push	r18
     786:	3f 93       	push	r19
     788:	4f 93       	push	r20
     78a:	5f 93       	push	r21
     78c:	6f 93       	push	r22
     78e:	7f 93       	push	r23
     790:	8f 93       	push	r24
     792:	9f 93       	push	r25
     794:	af 93       	push	r26
     796:	bf 93       	push	r27
     798:	cf 93       	push	r28
     79a:	df 93       	push	r29
     79c:	ef 93       	push	r30
     79e:	ff 93       	push	r31
     7a0:	a0 91 72 0d 	lds	r26, 0x0D72	; 0x800d72 <pxCurrentTCB>
     7a4:	b0 91 73 0d 	lds	r27, 0x0D73	; 0x800d73 <pxCurrentTCB+0x1>
     7a8:	0d b6       	in	r0, 0x3d	; 61
     7aa:	0d 92       	st	X+, r0
     7ac:	0e b6       	in	r0, 0x3e	; 62
     7ae:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     7b0:	0e 94 b0 0c 	call	0x1960	; 0x1960 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     7b4:	a0 91 72 0d 	lds	r26, 0x0D72	; 0x800d72 <pxCurrentTCB>
     7b8:	b0 91 73 0d 	lds	r27, 0x0D73	; 0x800d73 <pxCurrentTCB+0x1>
     7bc:	cd 91       	ld	r28, X+
     7be:	cd bf       	out	0x3d, r28	; 61
     7c0:	dd 91       	ld	r29, X+
     7c2:	de bf       	out	0x3e, r29	; 62
     7c4:	ff 91       	pop	r31
     7c6:	ef 91       	pop	r30
     7c8:	df 91       	pop	r29
     7ca:	cf 91       	pop	r28
     7cc:	bf 91       	pop	r27
     7ce:	af 91       	pop	r26
     7d0:	9f 91       	pop	r25
     7d2:	8f 91       	pop	r24
     7d4:	7f 91       	pop	r23
     7d6:	6f 91       	pop	r22
     7d8:	5f 91       	pop	r21
     7da:	4f 91       	pop	r20
     7dc:	3f 91       	pop	r19
     7de:	2f 91       	pop	r18
     7e0:	1f 91       	pop	r17
     7e2:	0f 91       	pop	r16
     7e4:	ff 90       	pop	r15
     7e6:	ef 90       	pop	r14
     7e8:	df 90       	pop	r13
     7ea:	cf 90       	pop	r12
     7ec:	bf 90       	pop	r11
     7ee:	af 90       	pop	r10
     7f0:	9f 90       	pop	r9
     7f2:	8f 90       	pop	r8
     7f4:	7f 90       	pop	r7
     7f6:	6f 90       	pop	r6
     7f8:	5f 90       	pop	r5
     7fa:	4f 90       	pop	r4
     7fc:	3f 90       	pop	r3
     7fe:	2f 90       	pop	r2
     800:	1f 90       	pop	r1
     802:	0f 90       	pop	r0
     804:	0f be       	out	0x3f, r0	; 63
     806:	0f 90       	pop	r0

	asm volatile ( "ret" );
     808:	08 95       	ret

0000080a <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     80a:	0f 92       	push	r0
     80c:	0f b6       	in	r0, 0x3f	; 63
     80e:	f8 94       	cli
     810:	0f 92       	push	r0
     812:	1f 92       	push	r1
     814:	11 24       	eor	r1, r1
     816:	2f 92       	push	r2
     818:	3f 92       	push	r3
     81a:	4f 92       	push	r4
     81c:	5f 92       	push	r5
     81e:	6f 92       	push	r6
     820:	7f 92       	push	r7
     822:	8f 92       	push	r8
     824:	9f 92       	push	r9
     826:	af 92       	push	r10
     828:	bf 92       	push	r11
     82a:	cf 92       	push	r12
     82c:	df 92       	push	r13
     82e:	ef 92       	push	r14
     830:	ff 92       	push	r15
     832:	0f 93       	push	r16
     834:	1f 93       	push	r17
     836:	2f 93       	push	r18
     838:	3f 93       	push	r19
     83a:	4f 93       	push	r20
     83c:	5f 93       	push	r21
     83e:	6f 93       	push	r22
     840:	7f 93       	push	r23
     842:	8f 93       	push	r24
     844:	9f 93       	push	r25
     846:	af 93       	push	r26
     848:	bf 93       	push	r27
     84a:	cf 93       	push	r28
     84c:	df 93       	push	r29
     84e:	ef 93       	push	r30
     850:	ff 93       	push	r31
     852:	a0 91 72 0d 	lds	r26, 0x0D72	; 0x800d72 <pxCurrentTCB>
     856:	b0 91 73 0d 	lds	r27, 0x0D73	; 0x800d73 <pxCurrentTCB+0x1>
     85a:	0d b6       	in	r0, 0x3d	; 61
     85c:	0d 92       	st	X+, r0
     85e:	0e b6       	in	r0, 0x3e	; 62
     860:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     862:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <xTaskIncrementTick>
     866:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     868:	0e 94 b0 0c 	call	0x1960	; 0x1960 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     86c:	a0 91 72 0d 	lds	r26, 0x0D72	; 0x800d72 <pxCurrentTCB>
     870:	b0 91 73 0d 	lds	r27, 0x0D73	; 0x800d73 <pxCurrentTCB+0x1>
     874:	cd 91       	ld	r28, X+
     876:	cd bf       	out	0x3d, r28	; 61
     878:	dd 91       	ld	r29, X+
     87a:	de bf       	out	0x3e, r29	; 62
     87c:	ff 91       	pop	r31
     87e:	ef 91       	pop	r30
     880:	df 91       	pop	r29
     882:	cf 91       	pop	r28
     884:	bf 91       	pop	r27
     886:	af 91       	pop	r26
     888:	9f 91       	pop	r25
     88a:	8f 91       	pop	r24
     88c:	7f 91       	pop	r23
     88e:	6f 91       	pop	r22
     890:	5f 91       	pop	r21
     892:	4f 91       	pop	r20
     894:	3f 91       	pop	r19
     896:	2f 91       	pop	r18
     898:	1f 91       	pop	r17
     89a:	0f 91       	pop	r16
     89c:	ff 90       	pop	r15
     89e:	ef 90       	pop	r14
     8a0:	df 90       	pop	r13
     8a2:	cf 90       	pop	r12
     8a4:	bf 90       	pop	r11
     8a6:	af 90       	pop	r10
     8a8:	9f 90       	pop	r9
     8aa:	8f 90       	pop	r8
     8ac:	7f 90       	pop	r7
     8ae:	6f 90       	pop	r6
     8b0:	5f 90       	pop	r5
     8b2:	4f 90       	pop	r4
     8b4:	3f 90       	pop	r3
     8b6:	2f 90       	pop	r2
     8b8:	1f 90       	pop	r1
     8ba:	0f 90       	pop	r0
     8bc:	0f be       	out	0x3f, r0	; 63
     8be:	0f 90       	pop	r0

	asm volatile ( "ret" );
     8c0:	08 95       	ret

000008c2 <__vector_12>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     8c2:	0e 94 05 04 	call	0x80a	; 0x80a <vPortYieldFromTick>
		asm volatile ( "reti" );
     8c6:	18 95       	reti

000008c8 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     8c8:	cf 93       	push	r28
     8ca:	df 93       	push	r29
     8cc:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
     8ce:	0e 94 c5 0a 	call	0x158a	; 0x158a <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     8d2:	80 91 6e 01 	lds	r24, 0x016E	; 0x80016e <pucAlignedHeap.2068>
     8d6:	90 91 6f 01 	lds	r25, 0x016F	; 0x80016f <pucAlignedHeap.2068+0x1>
     8da:	89 2b       	or	r24, r25
     8dc:	31 f4       	brne	.+12     	; 0x8ea <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     8de:	83 e7       	ldi	r24, 0x73	; 115
     8e0:	91 e0       	ldi	r25, 0x01	; 1
     8e2:	90 93 6f 01 	sts	0x016F, r25	; 0x80016f <pucAlignedHeap.2068+0x1>
     8e6:	80 93 6e 01 	sts	0x016E, r24	; 0x80016e <pucAlignedHeap.2068>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     8ea:	20 91 70 01 	lds	r18, 0x0170	; 0x800170 <xNextFreeByte>
     8ee:	30 91 71 01 	lds	r19, 0x0171	; 0x800171 <xNextFreeByte+0x1>
     8f2:	c9 01       	movw	r24, r18
     8f4:	8c 0f       	add	r24, r28
     8f6:	9d 1f       	adc	r25, r29
     8f8:	8f 3f       	cpi	r24, 0xFF	; 255
     8fa:	4b e0       	ldi	r20, 0x0B	; 11
     8fc:	94 07       	cpc	r25, r20
     8fe:	70 f4       	brcc	.+28     	; 0x91c <pvPortMalloc+0x54>
     900:	28 17       	cp	r18, r24
     902:	39 07       	cpc	r19, r25
     904:	70 f4       	brcc	.+28     	; 0x922 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     906:	c0 91 6e 01 	lds	r28, 0x016E	; 0x80016e <pucAlignedHeap.2068>
     90a:	d0 91 6f 01 	lds	r29, 0x016F	; 0x80016f <pucAlignedHeap.2068+0x1>
     90e:	c2 0f       	add	r28, r18
     910:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
     912:	90 93 71 01 	sts	0x0171, r25	; 0x800171 <xNextFreeByte+0x1>
     916:	80 93 70 01 	sts	0x0170, r24	; 0x800170 <xNextFreeByte>
     91a:	05 c0       	rjmp	.+10     	; 0x926 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     91c:	c0 e0       	ldi	r28, 0x00	; 0
     91e:	d0 e0       	ldi	r29, 0x00	; 0
     920:	02 c0       	rjmp	.+4      	; 0x926 <pvPortMalloc+0x5e>
     922:	c0 e0       	ldi	r28, 0x00	; 0
     924:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     926:	0e 94 a0 0b 	call	0x1740	; 0x1740 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     92a:	ce 01       	movw	r24, r28
     92c:	df 91       	pop	r29
     92e:	cf 91       	pop	r28
     930:	08 95       	ret

00000932 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     932:	08 95       	ret

00000934 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
     934:	10 92 71 01 	sts	0x0171, r1	; 0x800171 <xNextFreeByte+0x1>
     938:	10 92 70 01 	sts	0x0170, r1	; 0x800170 <xNextFreeByte>
     93c:	08 95       	ret

0000093e <xPortGetFreeHeapSize>:
}
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
     93e:	20 91 70 01 	lds	r18, 0x0170	; 0x800170 <xNextFreeByte>
     942:	30 91 71 01 	lds	r19, 0x0171	; 0x800171 <xNextFreeByte+0x1>
}
     946:	8f ef       	ldi	r24, 0xFF	; 255
     948:	9b e0       	ldi	r25, 0x0B	; 11
     94a:	82 1b       	sub	r24, r18
     94c:	93 0b       	sbc	r25, r19
     94e:	08 95       	ret

00000950 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
     950:	0f 93       	push	r16
     952:	1f 93       	push	r17
     954:	cf 93       	push	r28
     956:	df 93       	push	r29
     958:	ec 01       	movw	r28, r24
     95a:	04 2f       	mov	r16, r20
BaseType_t xReturn = pdFALSE;
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
     95c:	1a 8d       	ldd	r17, Y+26	; 0x1a

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
     95e:	4c 8d       	ldd	r20, Y+28	; 0x1c
     960:	44 23       	and	r20, r20
     962:	b9 f1       	breq	.+110    	; 0x9d2 <prvCopyDataToQueue+0x82>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
     964:	01 11       	cpse	r16, r1
     966:	16 c0       	rjmp	.+44     	; 0x994 <prvCopyDataToQueue+0x44>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
     968:	50 e0       	ldi	r21, 0x00	; 0
     96a:	8c 81       	ldd	r24, Y+4	; 0x04
     96c:	9d 81       	ldd	r25, Y+5	; 0x05
     96e:	0e 94 25 12 	call	0x244a	; 0x244a <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     972:	2c 8d       	ldd	r18, Y+28	; 0x1c
     974:	8c 81       	ldd	r24, Y+4	; 0x04
     976:	9d 81       	ldd	r25, Y+5	; 0x05
     978:	82 0f       	add	r24, r18
     97a:	91 1d       	adc	r25, r1
     97c:	9d 83       	std	Y+5, r25	; 0x05
     97e:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     980:	2a 81       	ldd	r18, Y+2	; 0x02
     982:	3b 81       	ldd	r19, Y+3	; 0x03
     984:	82 17       	cp	r24, r18
     986:	93 07       	cpc	r25, r19
     988:	20 f1       	brcs	.+72     	; 0x9d2 <prvCopyDataToQueue+0x82>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
     98a:	88 81       	ld	r24, Y
     98c:	99 81       	ldd	r25, Y+1	; 0x01
     98e:	9d 83       	std	Y+5, r25	; 0x05
     990:	8c 83       	std	Y+4, r24	; 0x04
     992:	1f c0       	rjmp	.+62     	; 0x9d2 <prvCopyDataToQueue+0x82>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     994:	50 e0       	ldi	r21, 0x00	; 0
     996:	8e 81       	ldd	r24, Y+6	; 0x06
     998:	9f 81       	ldd	r25, Y+7	; 0x07
     99a:	0e 94 25 12 	call	0x244a	; 0x244a <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
     99e:	8c 8d       	ldd	r24, Y+28	; 0x1c
     9a0:	90 e0       	ldi	r25, 0x00	; 0
     9a2:	91 95       	neg	r25
     9a4:	81 95       	neg	r24
     9a6:	91 09       	sbc	r25, r1
     9a8:	2e 81       	ldd	r18, Y+6	; 0x06
     9aa:	3f 81       	ldd	r19, Y+7	; 0x07
     9ac:	28 0f       	add	r18, r24
     9ae:	39 1f       	adc	r19, r25
     9b0:	3f 83       	std	Y+7, r19	; 0x07
     9b2:	2e 83       	std	Y+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     9b4:	48 81       	ld	r20, Y
     9b6:	59 81       	ldd	r21, Y+1	; 0x01
     9b8:	24 17       	cp	r18, r20
     9ba:	35 07       	cpc	r19, r21
     9bc:	30 f4       	brcc	.+12     	; 0x9ca <prvCopyDataToQueue+0x7a>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
     9be:	2a 81       	ldd	r18, Y+2	; 0x02
     9c0:	3b 81       	ldd	r19, Y+3	; 0x03
     9c2:	82 0f       	add	r24, r18
     9c4:	93 1f       	adc	r25, r19
     9c6:	9f 83       	std	Y+7, r25	; 0x07
     9c8:	8e 83       	std	Y+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
     9ca:	02 30       	cpi	r16, 0x02	; 2
     9cc:	11 f4       	brne	.+4      	; 0x9d2 <prvCopyDataToQueue+0x82>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
     9ce:	11 11       	cpse	r17, r1
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
     9d0:	11 50       	subi	r17, 0x01	; 1
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
     9d2:	1f 5f       	subi	r17, 0xFF	; 255
     9d4:	1a 8f       	std	Y+26, r17	; 0x1a

	return xReturn;
}
     9d6:	80 e0       	ldi	r24, 0x00	; 0
     9d8:	df 91       	pop	r29
     9da:	cf 91       	pop	r28
     9dc:	1f 91       	pop	r17
     9de:	0f 91       	pop	r16
     9e0:	08 95       	ret

000009e2 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
     9e2:	fc 01       	movw	r30, r24
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
     9e4:	44 8d       	ldd	r20, Z+28	; 0x1c
     9e6:	44 23       	and	r20, r20
     9e8:	a9 f0       	breq	.+42     	; 0xa14 <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
     9ea:	50 e0       	ldi	r21, 0x00	; 0
     9ec:	26 81       	ldd	r18, Z+6	; 0x06
     9ee:	37 81       	ldd	r19, Z+7	; 0x07
     9f0:	24 0f       	add	r18, r20
     9f2:	35 1f       	adc	r19, r21
     9f4:	37 83       	std	Z+7, r19	; 0x07
     9f6:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
     9f8:	82 81       	ldd	r24, Z+2	; 0x02
     9fa:	93 81       	ldd	r25, Z+3	; 0x03
     9fc:	28 17       	cp	r18, r24
     9fe:	39 07       	cpc	r19, r25
     a00:	20 f0       	brcs	.+8      	; 0xa0a <prvCopyDataFromQueue+0x28>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
     a02:	80 81       	ld	r24, Z
     a04:	91 81       	ldd	r25, Z+1	; 0x01
     a06:	97 83       	std	Z+7, r25	; 0x07
     a08:	86 83       	std	Z+6, r24	; 0x06
     a0a:	cb 01       	movw	r24, r22
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
     a0c:	66 81       	ldd	r22, Z+6	; 0x06
     a0e:	77 81       	ldd	r23, Z+7	; 0x07
     a10:	0e 94 25 12 	call	0x244a	; 0x244a <memcpy>
     a14:	08 95       	ret

00000a16 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
     a16:	ef 92       	push	r14
     a18:	ff 92       	push	r15
     a1a:	0f 93       	push	r16
     a1c:	1f 93       	push	r17
     a1e:	cf 93       	push	r28
     a20:	8c 01       	movw	r16, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
     a22:	0f b6       	in	r0, 0x3f	; 63
     a24:	f8 94       	cli
     a26:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
     a28:	fc 01       	movw	r30, r24
     a2a:	c6 8d       	ldd	r28, Z+30	; 0x1e

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
     a2c:	1c 16       	cp	r1, r28
     a2e:	ac f4       	brge	.+42     	; 0xa5a <prvUnlockQueue+0x44>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     a30:	81 89       	ldd	r24, Z+17	; 0x11
     a32:	81 11       	cpse	r24, r1
     a34:	06 c0       	rjmp	.+12     	; 0xa42 <prvUnlockQueue+0x2c>
     a36:	11 c0       	rjmp	.+34     	; 0xa5a <prvUnlockQueue+0x44>
     a38:	f8 01       	movw	r30, r16
     a3a:	81 89       	ldd	r24, Z+17	; 0x11
     a3c:	81 11       	cpse	r24, r1
     a3e:	05 c0       	rjmp	.+10     	; 0xa4a <prvUnlockQueue+0x34>
     a40:	0c c0       	rjmp	.+24     	; 0xa5a <prvUnlockQueue+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     a42:	78 01       	movw	r14, r16
     a44:	f1 e1       	ldi	r31, 0x11	; 17
     a46:	ef 0e       	add	r14, r31
     a48:	f1 1c       	adc	r15, r1
     a4a:	c7 01       	movw	r24, r14
     a4c:	0e 94 41 0d 	call	0x1a82	; 0x1a82 <xTaskRemoveFromEventList>
     a50:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
     a52:	0e 94 00 0e 	call	0x1c00	; 0x1c00 <vTaskMissedYield>
     a56:	c1 50       	subi	r28, 0x01	; 1
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
     a58:	79 f7       	brne	.-34     	; 0xa38 <prvUnlockQueue+0x22>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
     a5a:	8f ef       	ldi	r24, 0xFF	; 255
     a5c:	f8 01       	movw	r30, r16
     a5e:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
     a60:	0f 90       	pop	r0
     a62:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
     a64:	0f b6       	in	r0, 0x3f	; 63
     a66:	f8 94       	cli
     a68:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
     a6a:	c5 8d       	ldd	r28, Z+29	; 0x1d

		while( cRxLock > queueLOCKED_UNMODIFIED )
     a6c:	1c 16       	cp	r1, r28
     a6e:	ac f4       	brge	.+42     	; 0xa9a <prvUnlockQueue+0x84>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     a70:	80 85       	ldd	r24, Z+8	; 0x08
     a72:	81 11       	cpse	r24, r1
     a74:	06 c0       	rjmp	.+12     	; 0xa82 <prvUnlockQueue+0x6c>
     a76:	11 c0       	rjmp	.+34     	; 0xa9a <prvUnlockQueue+0x84>
     a78:	f8 01       	movw	r30, r16
     a7a:	80 85       	ldd	r24, Z+8	; 0x08
     a7c:	81 11       	cpse	r24, r1
     a7e:	05 c0       	rjmp	.+10     	; 0xa8a <prvUnlockQueue+0x74>
     a80:	0c c0       	rjmp	.+24     	; 0xa9a <prvUnlockQueue+0x84>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     a82:	78 01       	movw	r14, r16
     a84:	f8 e0       	ldi	r31, 0x08	; 8
     a86:	ef 0e       	add	r14, r31
     a88:	f1 1c       	adc	r15, r1
     a8a:	c7 01       	movw	r24, r14
     a8c:	0e 94 41 0d 	call	0x1a82	; 0x1a82 <xTaskRemoveFromEventList>
     a90:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
     a92:	0e 94 00 0e 	call	0x1c00	; 0x1c00 <vTaskMissedYield>
     a96:	c1 50       	subi	r28, 0x01	; 1
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
     a98:	79 f7       	brne	.-34     	; 0xa78 <prvUnlockQueue+0x62>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
     a9a:	8f ef       	ldi	r24, 0xFF	; 255
     a9c:	f8 01       	movw	r30, r16
     a9e:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
     aa0:	0f 90       	pop	r0
     aa2:	0f be       	out	0x3f, r0	; 63
}
     aa4:	cf 91       	pop	r28
     aa6:	1f 91       	pop	r17
     aa8:	0f 91       	pop	r16
     aaa:	ff 90       	pop	r15
     aac:	ef 90       	pop	r14
     aae:	08 95       	ret

00000ab0 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
     ab0:	cf 93       	push	r28
     ab2:	df 93       	push	r29
     ab4:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
     ab6:	0f b6       	in	r0, 0x3f	; 63
     ab8:	f8 94       	cli
     aba:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
     abc:	48 81       	ld	r20, Y
     abe:	59 81       	ldd	r21, Y+1	; 0x01
     ac0:	2c 8d       	ldd	r18, Y+28	; 0x1c
     ac2:	30 e0       	ldi	r19, 0x00	; 0
     ac4:	7b 8d       	ldd	r23, Y+27	; 0x1b
     ac6:	72 9f       	mul	r23, r18
     ac8:	c0 01       	movw	r24, r0
     aca:	73 9f       	mul	r23, r19
     acc:	90 0d       	add	r25, r0
     ace:	11 24       	eor	r1, r1
     ad0:	fa 01       	movw	r30, r20
     ad2:	e8 0f       	add	r30, r24
     ad4:	f9 1f       	adc	r31, r25
     ad6:	fb 83       	std	Y+3, r31	; 0x03
     ad8:	ea 83       	std	Y+2, r30	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
     ada:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
     adc:	5d 83       	std	Y+5, r21	; 0x05
     ade:	4c 83       	std	Y+4, r20	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
     ae0:	82 1b       	sub	r24, r18
     ae2:	93 0b       	sbc	r25, r19
     ae4:	84 0f       	add	r24, r20
     ae6:	95 1f       	adc	r25, r21
     ae8:	9f 83       	std	Y+7, r25	; 0x07
     aea:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
     aec:	8f ef       	ldi	r24, 0xFF	; 255
     aee:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
     af0:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
     af2:	61 11       	cpse	r22, r1
     af4:	0c c0       	rjmp	.+24     	; 0xb0e <xQueueGenericReset+0x5e>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     af6:	88 85       	ldd	r24, Y+8	; 0x08
     af8:	88 23       	and	r24, r24
     afa:	89 f0       	breq	.+34     	; 0xb1e <xQueueGenericReset+0x6e>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     afc:	ce 01       	movw	r24, r28
     afe:	08 96       	adiw	r24, 0x08	; 8
     b00:	0e 94 41 0d 	call	0x1a82	; 0x1a82 <xTaskRemoveFromEventList>
     b04:	88 23       	and	r24, r24
     b06:	59 f0       	breq	.+22     	; 0xb1e <xQueueGenericReset+0x6e>
				{
					queueYIELD_IF_USING_PREEMPTION();
     b08:	0e 94 ac 03 	call	0x758	; 0x758 <vPortYield>
     b0c:	08 c0       	rjmp	.+16     	; 0xb1e <xQueueGenericReset+0x6e>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
     b0e:	ce 01       	movw	r24, r28
     b10:	08 96       	adiw	r24, 0x08	; 8
     b12:	0e 94 7f 02 	call	0x4fe	; 0x4fe <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
     b16:	ce 01       	movw	r24, r28
     b18:	41 96       	adiw	r24, 0x11	; 17
     b1a:	0e 94 7f 02 	call	0x4fe	; 0x4fe <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
     b1e:	0f 90       	pop	r0
     b20:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
     b22:	81 e0       	ldi	r24, 0x01	; 1
     b24:	df 91       	pop	r29
     b26:	cf 91       	pop	r28
     b28:	08 95       	ret

00000b2a <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
     b2a:	0f 93       	push	r16
     b2c:	1f 93       	push	r17
     b2e:	cf 93       	push	r28
     b30:	df 93       	push	r29
     b32:	08 2f       	mov	r16, r24
     b34:	16 2f       	mov	r17, r22
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
     b36:	66 23       	and	r22, r22
     b38:	c1 f0       	breq	.+48     	; 0xb6a <xQueueGenericCreate+0x40>
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
		}

		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
     b3a:	86 9f       	mul	r24, r22
     b3c:	c0 01       	movw	r24, r0
     b3e:	11 24       	eor	r1, r1
     b40:	4f 96       	adiw	r24, 0x1f	; 31
     b42:	0e 94 64 04 	call	0x8c8	; 0x8c8 <pvPortMalloc>
     b46:	ec 01       	movw	r28, r24

		if( pxNewQueue != NULL )
     b48:	00 97       	sbiw	r24, 0x00	; 0
     b4a:	41 f4       	brne	.+16     	; 0xb5c <xQueueGenericCreate+0x32>
     b4c:	15 c0       	rjmp	.+42     	; 0xb78 <xQueueGenericCreate+0x4e>
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
     b4e:	0b 8f       	std	Y+27, r16	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
     b50:	1c 8f       	std	Y+28, r17	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
     b52:	61 e0       	ldi	r22, 0x01	; 1
     b54:	ce 01       	movw	r24, r28
     b56:	0e 94 58 05 	call	0xab0	; 0xab0 <xQueueGenericReset>
     b5a:	0e c0       	rjmp	.+28     	; 0xb78 <xQueueGenericCreate+0x4e>
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
     b5c:	4f 96       	adiw	r24, 0x1f	; 31
     b5e:	99 83       	std	Y+1, r25	; 0x01
     b60:	88 83       	st	Y, r24
     b62:	f5 cf       	rjmp	.-22     	; 0xb4e <xQueueGenericCreate+0x24>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
     b64:	d9 83       	std	Y+1, r29	; 0x01
     b66:	c8 83       	st	Y, r28
     b68:	f2 cf       	rjmp	.-28     	; 0xb4e <xQueueGenericCreate+0x24>
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
		}

		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
     b6a:	8f e1       	ldi	r24, 0x1F	; 31
     b6c:	90 e0       	ldi	r25, 0x00	; 0
     b6e:	0e 94 64 04 	call	0x8c8	; 0x8c8 <pvPortMalloc>
     b72:	ec 01       	movw	r28, r24

		if( pxNewQueue != NULL )
     b74:	89 2b       	or	r24, r25
     b76:	b1 f7       	brne	.-20     	; 0xb64 <xQueueGenericCreate+0x3a>

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
		}

		return pxNewQueue;
	}
     b78:	ce 01       	movw	r24, r28
     b7a:	df 91       	pop	r29
     b7c:	cf 91       	pop	r28
     b7e:	1f 91       	pop	r17
     b80:	0f 91       	pop	r16
     b82:	08 95       	ret

00000b84 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
     b84:	9f 92       	push	r9
     b86:	af 92       	push	r10
     b88:	bf 92       	push	r11
     b8a:	cf 92       	push	r12
     b8c:	df 92       	push	r13
     b8e:	ef 92       	push	r14
     b90:	ff 92       	push	r15
     b92:	0f 93       	push	r16
     b94:	1f 93       	push	r17
     b96:	cf 93       	push	r28
     b98:	df 93       	push	r29
     b9a:	00 d0       	rcall	.+0      	; 0xb9c <xQueueGenericSend+0x18>
     b9c:	00 d0       	rcall	.+0      	; 0xb9e <xQueueGenericSend+0x1a>
     b9e:	1f 92       	push	r1
     ba0:	cd b7       	in	r28, 0x3d	; 61
     ba2:	de b7       	in	r29, 0x3e	; 62
     ba4:	8c 01       	movw	r16, r24
     ba6:	6b 01       	movw	r12, r22
     ba8:	5d 83       	std	Y+5, r21	; 0x05
     baa:	4c 83       	std	Y+4, r20	; 0x04
     bac:	a2 2e       	mov	r10, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
     bae:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
     bb0:	99 24       	eor	r9, r9
     bb2:	93 94       	inc	r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     bb4:	7c 01       	movw	r14, r24
     bb6:	88 e0       	ldi	r24, 0x08	; 8
     bb8:	e8 0e       	add	r14, r24
     bba:	f1 1c       	adc	r15, r1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
     bbc:	0f b6       	in	r0, 0x3f	; 63
     bbe:	f8 94       	cli
     bc0:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
     bc2:	f8 01       	movw	r30, r16
     bc4:	92 8d       	ldd	r25, Z+26	; 0x1a
     bc6:	83 8d       	ldd	r24, Z+27	; 0x1b
     bc8:	98 17       	cp	r25, r24
     bca:	18 f0       	brcs	.+6      	; 0xbd2 <xQueueGenericSend+0x4e>
     bcc:	f2 e0       	ldi	r31, 0x02	; 2
     bce:	af 12       	cpse	r10, r31
     bd0:	19 c0       	rjmp	.+50     	; 0xc04 <xQueueGenericSend+0x80>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     bd2:	4a 2d       	mov	r20, r10
     bd4:	b6 01       	movw	r22, r12
     bd6:	c8 01       	movw	r24, r16
     bd8:	0e 94 a8 04 	call	0x950	; 0x950 <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     bdc:	f8 01       	movw	r30, r16
     bde:	91 89       	ldd	r25, Z+17	; 0x11
     be0:	99 23       	and	r25, r25
     be2:	49 f0       	breq	.+18     	; 0xbf6 <xQueueGenericSend+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     be4:	c8 01       	movw	r24, r16
     be6:	41 96       	adiw	r24, 0x11	; 17
     be8:	0e 94 41 0d 	call	0x1a82	; 0x1a82 <xTaskRemoveFromEventList>
     bec:	88 23       	and	r24, r24
     bee:	31 f0       	breq	.+12     	; 0xbfc <xQueueGenericSend+0x78>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
     bf0:	0e 94 ac 03 	call	0x758	; 0x758 <vPortYield>
     bf4:	03 c0       	rjmp	.+6      	; 0xbfc <xQueueGenericSend+0x78>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
     bf6:	81 11       	cpse	r24, r1
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
     bf8:	0e 94 ac 03 	call	0x758	; 0x758 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
     bfc:	0f 90       	pop	r0
     bfe:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     c00:	81 e0       	ldi	r24, 0x01	; 1
     c02:	50 c0       	rjmp	.+160    	; 0xca4 <xQueueGenericSend+0x120>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
     c04:	8c 81       	ldd	r24, Y+4	; 0x04
     c06:	9d 81       	ldd	r25, Y+5	; 0x05
     c08:	89 2b       	or	r24, r25
     c0a:	21 f4       	brne	.+8      	; 0xc14 <xQueueGenericSend+0x90>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     c0c:	0f 90       	pop	r0
     c0e:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
     c10:	80 e0       	ldi	r24, 0x00	; 0
     c12:	48 c0       	rjmp	.+144    	; 0xca4 <xQueueGenericSend+0x120>
				}
				else if( xEntryTimeSet == pdFALSE )
     c14:	b1 10       	cpse	r11, r1
     c16:	05 c0       	rjmp	.+10     	; 0xc22 <xQueueGenericSend+0x9e>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     c18:	ce 01       	movw	r24, r28
     c1a:	01 96       	adiw	r24, 0x01	; 1
     c1c:	0e 94 c3 0d 	call	0x1b86	; 0x1b86 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     c20:	b9 2c       	mov	r11, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
     c22:	0f 90       	pop	r0
     c24:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     c26:	0e 94 c5 0a 	call	0x158a	; 0x158a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     c2a:	0f b6       	in	r0, 0x3f	; 63
     c2c:	f8 94       	cli
     c2e:	0f 92       	push	r0
     c30:	f8 01       	movw	r30, r16
     c32:	85 8d       	ldd	r24, Z+29	; 0x1d
     c34:	8f 3f       	cpi	r24, 0xFF	; 255
     c36:	09 f4       	brne	.+2      	; 0xc3a <xQueueGenericSend+0xb6>
     c38:	15 8e       	std	Z+29, r1	; 0x1d
     c3a:	f8 01       	movw	r30, r16
     c3c:	86 8d       	ldd	r24, Z+30	; 0x1e
     c3e:	8f 3f       	cpi	r24, 0xFF	; 255
     c40:	09 f4       	brne	.+2      	; 0xc44 <xQueueGenericSend+0xc0>
     c42:	16 8e       	std	Z+30, r1	; 0x1e
     c44:	0f 90       	pop	r0
     c46:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     c48:	be 01       	movw	r22, r28
     c4a:	6c 5f       	subi	r22, 0xFC	; 252
     c4c:	7f 4f       	sbci	r23, 0xFF	; 255
     c4e:	ce 01       	movw	r24, r28
     c50:	01 96       	adiw	r24, 0x01	; 1
     c52:	0e 94 ce 0d 	call	0x1b9c	; 0x1b9c <xTaskCheckForTimeOut>
     c56:	81 11       	cpse	r24, r1
     c58:	1f c0       	rjmp	.+62     	; 0xc98 <xQueueGenericSend+0x114>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
     c5a:	0f b6       	in	r0, 0x3f	; 63
     c5c:	f8 94       	cli
     c5e:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
     c60:	f8 01       	movw	r30, r16
     c62:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
     c64:	0f 90       	pop	r0
     c66:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
     c68:	83 8d       	ldd	r24, Z+27	; 0x1b
     c6a:	98 13       	cpse	r25, r24
     c6c:	0f c0       	rjmp	.+30     	; 0xc8c <xQueueGenericSend+0x108>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     c6e:	6c 81       	ldd	r22, Y+4	; 0x04
     c70:	7d 81       	ldd	r23, Y+5	; 0x05
     c72:	c7 01       	movw	r24, r14
     c74:	0e 94 16 0d 	call	0x1a2c	; 0x1a2c <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
     c78:	c8 01       	movw	r24, r16
     c7a:	0e 94 0b 05 	call	0xa16	; 0xa16 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
     c7e:	0e 94 a0 0b 	call	0x1740	; 0x1740 <xTaskResumeAll>
     c82:	81 11       	cpse	r24, r1
     c84:	9b cf       	rjmp	.-202    	; 0xbbc <xQueueGenericSend+0x38>
				{
					portYIELD_WITHIN_API();
     c86:	0e 94 ac 03 	call	0x758	; 0x758 <vPortYield>
     c8a:	98 cf       	rjmp	.-208    	; 0xbbc <xQueueGenericSend+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     c8c:	c8 01       	movw	r24, r16
     c8e:	0e 94 0b 05 	call	0xa16	; 0xa16 <prvUnlockQueue>
				( void ) xTaskResumeAll();
     c92:	0e 94 a0 0b 	call	0x1740	; 0x1740 <xTaskResumeAll>
     c96:	92 cf       	rjmp	.-220    	; 0xbbc <xQueueGenericSend+0x38>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
     c98:	c8 01       	movw	r24, r16
     c9a:	0e 94 0b 05 	call	0xa16	; 0xa16 <prvUnlockQueue>
			( void ) xTaskResumeAll();
     c9e:	0e 94 a0 0b 	call	0x1740	; 0x1740 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
     ca2:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     ca4:	0f 90       	pop	r0
     ca6:	0f 90       	pop	r0
     ca8:	0f 90       	pop	r0
     caa:	0f 90       	pop	r0
     cac:	0f 90       	pop	r0
     cae:	df 91       	pop	r29
     cb0:	cf 91       	pop	r28
     cb2:	1f 91       	pop	r17
     cb4:	0f 91       	pop	r16
     cb6:	ff 90       	pop	r15
     cb8:	ef 90       	pop	r14
     cba:	df 90       	pop	r13
     cbc:	cf 90       	pop	r12
     cbe:	bf 90       	pop	r11
     cc0:	af 90       	pop	r10
     cc2:	9f 90       	pop	r9
     cc4:	08 95       	ret

00000cc6 <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
     cc6:	ef 92       	push	r14
     cc8:	ff 92       	push	r15
     cca:	0f 93       	push	r16
     ccc:	1f 93       	push	r17
     cce:	cf 93       	push	r28
     cd0:	df 93       	push	r29
     cd2:	8a 01       	movw	r16, r20
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
     cd4:	fc 01       	movw	r30, r24
     cd6:	52 8d       	ldd	r21, Z+26	; 0x1a
     cd8:	33 8d       	ldd	r19, Z+27	; 0x1b
     cda:	53 17       	cp	r21, r19
     cdc:	10 f0       	brcs	.+4      	; 0xce2 <xQueueGenericSendFromISR+0x1c>
     cde:	22 30       	cpi	r18, 0x02	; 2
     ce0:	f1 f4       	brne	.+60     	; 0xd1e <xQueueGenericSendFromISR+0x58>
     ce2:	42 2f       	mov	r20, r18
     ce4:	78 01       	movw	r14, r16
     ce6:	ec 01       	movw	r28, r24
		{
			const int8_t cTxLock = pxQueue->cTxLock;
     ce8:	1e 8d       	ldd	r17, Y+30	; 0x1e
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     cea:	0e 94 a8 04 	call	0x950	; 0x950 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
     cee:	1f 3f       	cpi	r17, 0xFF	; 255
     cf0:	81 f4       	brne	.+32     	; 0xd12 <xQueueGenericSendFromISR+0x4c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     cf2:	89 89       	ldd	r24, Y+17	; 0x11
     cf4:	88 23       	and	r24, r24
     cf6:	a9 f0       	breq	.+42     	; 0xd22 <xQueueGenericSendFromISR+0x5c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     cf8:	ce 01       	movw	r24, r28
     cfa:	41 96       	adiw	r24, 0x11	; 17
     cfc:	0e 94 41 0d 	call	0x1a82	; 0x1a82 <xTaskRemoveFromEventList>
     d00:	88 23       	and	r24, r24
     d02:	89 f0       	breq	.+34     	; 0xd26 <xQueueGenericSendFromISR+0x60>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
     d04:	e1 14       	cp	r14, r1
     d06:	f1 04       	cpc	r15, r1
     d08:	81 f0       	breq	.+32     	; 0xd2a <xQueueGenericSendFromISR+0x64>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
     d0a:	81 e0       	ldi	r24, 0x01	; 1
     d0c:	f7 01       	movw	r30, r14
     d0e:	80 83       	st	Z, r24
     d10:	0d c0       	rjmp	.+26     	; 0xd2c <xQueueGenericSendFromISR+0x66>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
     d12:	ff 24       	eor	r15, r15
     d14:	f3 94       	inc	r15
     d16:	f1 0e       	add	r15, r17
     d18:	fe 8e       	std	Y+30, r15	; 0x1e
			}

			xReturn = pdPASS;
     d1a:	81 e0       	ldi	r24, 0x01	; 1
     d1c:	07 c0       	rjmp	.+14     	; 0xd2c <xQueueGenericSendFromISR+0x66>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
     d1e:	80 e0       	ldi	r24, 0x00	; 0
     d20:	05 c0       	rjmp	.+10     	; 0xd2c <xQueueGenericSendFromISR+0x66>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
			}

			xReturn = pdPASS;
     d22:	81 e0       	ldi	r24, 0x01	; 1
     d24:	03 c0       	rjmp	.+6      	; 0xd2c <xQueueGenericSendFromISR+0x66>
     d26:	81 e0       	ldi	r24, 0x01	; 1
     d28:	01 c0       	rjmp	.+2      	; 0xd2c <xQueueGenericSendFromISR+0x66>
     d2a:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     d2c:	df 91       	pop	r29
     d2e:	cf 91       	pop	r28
     d30:	1f 91       	pop	r17
     d32:	0f 91       	pop	r16
     d34:	ff 90       	pop	r15
     d36:	ef 90       	pop	r14
     d38:	08 95       	ret

00000d3a <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
     d3a:	cf 93       	push	r28
     d3c:	df 93       	push	r29
     d3e:	fc 01       	movw	r30, r24
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
     d40:	82 8d       	ldd	r24, Z+26	; 0x1a

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
     d42:	93 8d       	ldd	r25, Z+27	; 0x1b
     d44:	89 17       	cp	r24, r25
     d46:	c0 f4       	brcc	.+48     	; 0xd78 <xQueueGiveFromISR+0x3e>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
     d48:	96 8d       	ldd	r25, Z+30	; 0x1e
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
     d4a:	8f 5f       	subi	r24, 0xFF	; 255
     d4c:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
     d4e:	9f 3f       	cpi	r25, 0xFF	; 255
     d50:	79 f4       	brne	.+30     	; 0xd70 <xQueueGiveFromISR+0x36>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     d52:	81 89       	ldd	r24, Z+17	; 0x11
     d54:	88 23       	and	r24, r24
     d56:	91 f0       	breq	.+36     	; 0xd7c <xQueueGiveFromISR+0x42>
     d58:	eb 01       	movw	r28, r22
     d5a:	cf 01       	movw	r24, r30
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     d5c:	41 96       	adiw	r24, 0x11	; 17
     d5e:	0e 94 41 0d 	call	0x1a82	; 0x1a82 <xTaskRemoveFromEventList>
     d62:	88 23       	and	r24, r24
     d64:	69 f0       	breq	.+26     	; 0xd80 <xQueueGiveFromISR+0x46>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
     d66:	20 97       	sbiw	r28, 0x00	; 0
     d68:	69 f0       	breq	.+26     	; 0xd84 <xQueueGiveFromISR+0x4a>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
     d6a:	81 e0       	ldi	r24, 0x01	; 1
     d6c:	88 83       	st	Y, r24
     d6e:	0b c0       	rjmp	.+22     	; 0xd86 <xQueueGiveFromISR+0x4c>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
     d70:	9f 5f       	subi	r25, 0xFF	; 255
     d72:	96 8f       	std	Z+30, r25	; 0x1e
			}

			xReturn = pdPASS;
     d74:	81 e0       	ldi	r24, 0x01	; 1
     d76:	07 c0       	rjmp	.+14     	; 0xd86 <xQueueGiveFromISR+0x4c>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
     d78:	80 e0       	ldi	r24, 0x00	; 0
     d7a:	05 c0       	rjmp	.+10     	; 0xd86 <xQueueGiveFromISR+0x4c>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
			}

			xReturn = pdPASS;
     d7c:	81 e0       	ldi	r24, 0x01	; 1
     d7e:	03 c0       	rjmp	.+6      	; 0xd86 <xQueueGiveFromISR+0x4c>
     d80:	81 e0       	ldi	r24, 0x01	; 1
     d82:	01 c0       	rjmp	.+2      	; 0xd86 <xQueueGiveFromISR+0x4c>
     d84:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     d86:	df 91       	pop	r29
     d88:	cf 91       	pop	r28
     d8a:	08 95       	ret

00000d8c <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
     d8c:	8f 92       	push	r8
     d8e:	9f 92       	push	r9
     d90:	af 92       	push	r10
     d92:	bf 92       	push	r11
     d94:	cf 92       	push	r12
     d96:	df 92       	push	r13
     d98:	ef 92       	push	r14
     d9a:	ff 92       	push	r15
     d9c:	0f 93       	push	r16
     d9e:	1f 93       	push	r17
     da0:	cf 93       	push	r28
     da2:	df 93       	push	r29
     da4:	00 d0       	rcall	.+0      	; 0xda6 <xQueueGenericReceive+0x1a>
     da6:	00 d0       	rcall	.+0      	; 0xda8 <xQueueGenericReceive+0x1c>
     da8:	1f 92       	push	r1
     daa:	cd b7       	in	r28, 0x3d	; 61
     dac:	de b7       	in	r29, 0x3e	; 62
     dae:	8c 01       	movw	r16, r24
     db0:	5b 01       	movw	r10, r22
     db2:	5d 83       	std	Y+5, r21	; 0x05
     db4:	4c 83       	std	Y+4, r20	; 0x04
     db6:	82 2e       	mov	r8, r18
BaseType_t xEntryTimeSet = pdFALSE;
     db8:	e1 2c       	mov	r14, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
     dba:	99 24       	eor	r9, r9
     dbc:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     dbe:	6c 01       	movw	r12, r24
     dc0:	81 e1       	ldi	r24, 0x11	; 17
     dc2:	c8 0e       	add	r12, r24
     dc4:	d1 1c       	adc	r13, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
     dc6:	0f b6       	in	r0, 0x3f	; 63
     dc8:	f8 94       	cli
     dca:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
     dcc:	f8 01       	movw	r30, r16
     dce:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
     dd0:	ff 20       	and	r15, r15
     dd2:	41 f1       	breq	.+80     	; 0xe24 <xQueueGenericReceive+0x98>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
     dd4:	c6 80       	ldd	r12, Z+6	; 0x06
     dd6:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
     dd8:	b5 01       	movw	r22, r10
     dda:	c8 01       	movw	r24, r16
     ddc:	0e 94 f1 04 	call	0x9e2	; 0x9e2 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
     de0:	81 10       	cpse	r8, r1
     de2:	0f c0       	rjmp	.+30     	; 0xe02 <xQueueGenericReceive+0x76>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
     de4:	fa 94       	dec	r15
     de6:	f8 01       	movw	r30, r16
     de8:	f2 8e       	std	Z+26, r15	; 0x1a
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     dea:	80 85       	ldd	r24, Z+8	; 0x08
     dec:	88 23       	and	r24, r24
     dee:	b1 f0       	breq	.+44     	; 0xe1c <xQueueGenericReceive+0x90>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     df0:	c8 01       	movw	r24, r16
     df2:	08 96       	adiw	r24, 0x08	; 8
     df4:	0e 94 41 0d 	call	0x1a82	; 0x1a82 <xTaskRemoveFromEventList>
     df8:	88 23       	and	r24, r24
     dfa:	81 f0       	breq	.+32     	; 0xe1c <xQueueGenericReceive+0x90>
						{
							queueYIELD_IF_USING_PREEMPTION();
     dfc:	0e 94 ac 03 	call	0x758	; 0x758 <vPortYield>
     e00:	0d c0       	rjmp	.+26     	; 0xe1c <xQueueGenericReceive+0x90>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
     e02:	f8 01       	movw	r30, r16
     e04:	d7 82       	std	Z+7, r13	; 0x07
     e06:	c6 82       	std	Z+6, r12	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     e08:	81 89       	ldd	r24, Z+17	; 0x11
     e0a:	88 23       	and	r24, r24
     e0c:	39 f0       	breq	.+14     	; 0xe1c <xQueueGenericReceive+0x90>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     e0e:	c8 01       	movw	r24, r16
     e10:	41 96       	adiw	r24, 0x11	; 17
     e12:	0e 94 41 0d 	call	0x1a82	; 0x1a82 <xTaskRemoveFromEventList>
     e16:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
     e18:	0e 94 ac 03 	call	0x758	; 0x758 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
     e1c:	0f 90       	pop	r0
     e1e:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     e20:	81 e0       	ldi	r24, 0x01	; 1
     e22:	57 c0       	rjmp	.+174    	; 0xed2 <xQueueGenericReceive+0x146>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
     e24:	8c 81       	ldd	r24, Y+4	; 0x04
     e26:	9d 81       	ldd	r25, Y+5	; 0x05
     e28:	89 2b       	or	r24, r25
     e2a:	21 f4       	brne	.+8      	; 0xe34 <xQueueGenericReceive+0xa8>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     e2c:	0f 90       	pop	r0
     e2e:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
     e30:	80 e0       	ldi	r24, 0x00	; 0
     e32:	4f c0       	rjmp	.+158    	; 0xed2 <xQueueGenericReceive+0x146>
				}
				else if( xEntryTimeSet == pdFALSE )
     e34:	e1 10       	cpse	r14, r1
     e36:	05 c0       	rjmp	.+10     	; 0xe42 <xQueueGenericReceive+0xb6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     e38:	ce 01       	movw	r24, r28
     e3a:	01 96       	adiw	r24, 0x01	; 1
     e3c:	0e 94 c3 0d 	call	0x1b86	; 0x1b86 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     e40:	e9 2c       	mov	r14, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
     e42:	0f 90       	pop	r0
     e44:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     e46:	0e 94 c5 0a 	call	0x158a	; 0x158a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     e4a:	0f b6       	in	r0, 0x3f	; 63
     e4c:	f8 94       	cli
     e4e:	0f 92       	push	r0
     e50:	f8 01       	movw	r30, r16
     e52:	85 8d       	ldd	r24, Z+29	; 0x1d
     e54:	8f 3f       	cpi	r24, 0xFF	; 255
     e56:	09 f4       	brne	.+2      	; 0xe5a <xQueueGenericReceive+0xce>
     e58:	15 8e       	std	Z+29, r1	; 0x1d
     e5a:	f8 01       	movw	r30, r16
     e5c:	86 8d       	ldd	r24, Z+30	; 0x1e
     e5e:	8f 3f       	cpi	r24, 0xFF	; 255
     e60:	09 f4       	brne	.+2      	; 0xe64 <xQueueGenericReceive+0xd8>
     e62:	16 8e       	std	Z+30, r1	; 0x1e
     e64:	0f 90       	pop	r0
     e66:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     e68:	be 01       	movw	r22, r28
     e6a:	6c 5f       	subi	r22, 0xFC	; 252
     e6c:	7f 4f       	sbci	r23, 0xFF	; 255
     e6e:	ce 01       	movw	r24, r28
     e70:	01 96       	adiw	r24, 0x01	; 1
     e72:	0e 94 ce 0d 	call	0x1b9c	; 0x1b9c <xTaskCheckForTimeOut>
     e76:	81 11       	cpse	r24, r1
     e78:	1e c0       	rjmp	.+60     	; 0xeb6 <xQueueGenericReceive+0x12a>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
     e7a:	0f b6       	in	r0, 0x3f	; 63
     e7c:	f8 94       	cli
     e7e:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
     e80:	f8 01       	movw	r30, r16
     e82:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
     e84:	0f 90       	pop	r0
     e86:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     e88:	81 11       	cpse	r24, r1
     e8a:	0f c0       	rjmp	.+30     	; 0xeaa <xQueueGenericReceive+0x11e>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     e8c:	6c 81       	ldd	r22, Y+4	; 0x04
     e8e:	7d 81       	ldd	r23, Y+5	; 0x05
     e90:	c6 01       	movw	r24, r12
     e92:	0e 94 16 0d 	call	0x1a2c	; 0x1a2c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
     e96:	c8 01       	movw	r24, r16
     e98:	0e 94 0b 05 	call	0xa16	; 0xa16 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
     e9c:	0e 94 a0 0b 	call	0x1740	; 0x1740 <xTaskResumeAll>
     ea0:	81 11       	cpse	r24, r1
     ea2:	91 cf       	rjmp	.-222    	; 0xdc6 <xQueueGenericReceive+0x3a>
				{
					portYIELD_WITHIN_API();
     ea4:	0e 94 ac 03 	call	0x758	; 0x758 <vPortYield>
     ea8:	8e cf       	rjmp	.-228    	; 0xdc6 <xQueueGenericReceive+0x3a>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     eaa:	c8 01       	movw	r24, r16
     eac:	0e 94 0b 05 	call	0xa16	; 0xa16 <prvUnlockQueue>
				( void ) xTaskResumeAll();
     eb0:	0e 94 a0 0b 	call	0x1740	; 0x1740 <xTaskResumeAll>
     eb4:	88 cf       	rjmp	.-240    	; 0xdc6 <xQueueGenericReceive+0x3a>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
     eb6:	c8 01       	movw	r24, r16
     eb8:	0e 94 0b 05 	call	0xa16	; 0xa16 <prvUnlockQueue>
			( void ) xTaskResumeAll();
     ebc:	0e 94 a0 0b 	call	0x1740	; 0x1740 <xTaskResumeAll>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
     ec0:	0f b6       	in	r0, 0x3f	; 63
     ec2:	f8 94       	cli
     ec4:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
     ec6:	f8 01       	movw	r30, r16
     ec8:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
     eca:	0f 90       	pop	r0
     ecc:	0f be       	out	0x3f, r0	; 63
		else
		{
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     ece:	81 11       	cpse	r24, r1
     ed0:	7a cf       	rjmp	.-268    	; 0xdc6 <xQueueGenericReceive+0x3a>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
     ed2:	0f 90       	pop	r0
     ed4:	0f 90       	pop	r0
     ed6:	0f 90       	pop	r0
     ed8:	0f 90       	pop	r0
     eda:	0f 90       	pop	r0
     edc:	df 91       	pop	r29
     ede:	cf 91       	pop	r28
     ee0:	1f 91       	pop	r17
     ee2:	0f 91       	pop	r16
     ee4:	ff 90       	pop	r15
     ee6:	ef 90       	pop	r14
     ee8:	df 90       	pop	r13
     eea:	cf 90       	pop	r12
     eec:	bf 90       	pop	r11
     eee:	af 90       	pop	r10
     ef0:	9f 90       	pop	r9
     ef2:	8f 90       	pop	r8
     ef4:	08 95       	ret

00000ef6 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
     ef6:	ef 92       	push	r14
     ef8:	ff 92       	push	r15
     efa:	0f 93       	push	r16
     efc:	1f 93       	push	r17
     efe:	cf 93       	push	r28
     f00:	df 93       	push	r29
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
     f02:	fc 01       	movw	r30, r24
     f04:	c2 8d       	ldd	r28, Z+26	; 0x1a

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
     f06:	cc 23       	and	r28, r28
     f08:	f9 f0       	breq	.+62     	; 0xf48 <xQueueReceiveFromISR+0x52>
     f0a:	7a 01       	movw	r14, r20
     f0c:	8c 01       	movw	r16, r24
		{
			const int8_t cRxLock = pxQueue->cRxLock;
     f0e:	d5 8d       	ldd	r29, Z+29	; 0x1d

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
     f10:	0e 94 f1 04 	call	0x9e2	; 0x9e2 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
     f14:	c1 50       	subi	r28, 0x01	; 1
     f16:	f8 01       	movw	r30, r16
     f18:	c2 8f       	std	Z+26, r28	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
     f1a:	df 3f       	cpi	r29, 0xFF	; 255
     f1c:	81 f4       	brne	.+32     	; 0xf3e <xQueueReceiveFromISR+0x48>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     f1e:	80 85       	ldd	r24, Z+8	; 0x08
     f20:	88 23       	and	r24, r24
     f22:	a1 f0       	breq	.+40     	; 0xf4c <xQueueReceiveFromISR+0x56>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     f24:	c8 01       	movw	r24, r16
     f26:	08 96       	adiw	r24, 0x08	; 8
     f28:	0e 94 41 0d 	call	0x1a82	; 0x1a82 <xTaskRemoveFromEventList>
     f2c:	88 23       	and	r24, r24
     f2e:	81 f0       	breq	.+32     	; 0xf50 <xQueueReceiveFromISR+0x5a>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
     f30:	e1 14       	cp	r14, r1
     f32:	f1 04       	cpc	r15, r1
     f34:	79 f0       	breq	.+30     	; 0xf54 <xQueueReceiveFromISR+0x5e>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
     f36:	81 e0       	ldi	r24, 0x01	; 1
     f38:	f7 01       	movw	r30, r14
     f3a:	80 83       	st	Z, r24
     f3c:	0c c0       	rjmp	.+24     	; 0xf56 <xQueueReceiveFromISR+0x60>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
     f3e:	df 5f       	subi	r29, 0xFF	; 255
     f40:	f8 01       	movw	r30, r16
     f42:	d5 8f       	std	Z+29, r29	; 0x1d
			}

			xReturn = pdPASS;
     f44:	81 e0       	ldi	r24, 0x01	; 1
     f46:	07 c0       	rjmp	.+14     	; 0xf56 <xQueueReceiveFromISR+0x60>
		}
		else
		{
			xReturn = pdFAIL;
     f48:	80 e0       	ldi	r24, 0x00	; 0
     f4a:	05 c0       	rjmp	.+10     	; 0xf56 <xQueueReceiveFromISR+0x60>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
			}

			xReturn = pdPASS;
     f4c:	81 e0       	ldi	r24, 0x01	; 1
     f4e:	03 c0       	rjmp	.+6      	; 0xf56 <xQueueReceiveFromISR+0x60>
     f50:	81 e0       	ldi	r24, 0x01	; 1
     f52:	01 c0       	rjmp	.+2      	; 0xf56 <xQueueReceiveFromISR+0x60>
     f54:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     f56:	df 91       	pop	r29
     f58:	cf 91       	pop	r28
     f5a:	1f 91       	pop	r17
     f5c:	0f 91       	pop	r16
     f5e:	ff 90       	pop	r15
     f60:	ef 90       	pop	r14
     f62:	08 95       	ret

00000f64 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
     f64:	0f 93       	push	r16
     f66:	1f 93       	push	r17
     f68:	cf 93       	push	r28
     f6a:	df 93       	push	r29
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
     f6c:	fc 01       	movw	r30, r24
     f6e:	22 8d       	ldd	r18, Z+26	; 0x1a
     f70:	22 23       	and	r18, r18
     f72:	49 f0       	breq	.+18     	; 0xf86 <xQueuePeekFromISR+0x22>
     f74:	ec 01       	movw	r28, r24
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
     f76:	06 81       	ldd	r16, Z+6	; 0x06
     f78:	17 81       	ldd	r17, Z+7	; 0x07
			prvCopyDataFromQueue( pxQueue, pvBuffer );
     f7a:	0e 94 f1 04 	call	0x9e2	; 0x9e2 <prvCopyDataFromQueue>
			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
     f7e:	1f 83       	std	Y+7, r17	; 0x07
     f80:	0e 83       	std	Y+6, r16	; 0x06

			xReturn = pdPASS;
     f82:	81 e0       	ldi	r24, 0x01	; 1
     f84:	01 c0       	rjmp	.+2      	; 0xf88 <xQueuePeekFromISR+0x24>
		}
		else
		{
			xReturn = pdFAIL;
     f86:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     f88:	df 91       	pop	r29
     f8a:	cf 91       	pop	r28
     f8c:	1f 91       	pop	r17
     f8e:	0f 91       	pop	r16
     f90:	08 95       	ret

00000f92 <uxQueueMessagesWaiting>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
     f92:	0f b6       	in	r0, 0x3f	; 63
     f94:	f8 94       	cli
     f96:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
     f98:	fc 01       	movw	r30, r24
     f9a:	82 8d       	ldd	r24, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
     f9c:	0f 90       	pop	r0
     f9e:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
     fa0:	08 95       	ret

00000fa2 <uxQueueSpacesAvailable>:
Queue_t *pxQueue;

	pxQueue = ( Queue_t * ) xQueue;
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
     fa2:	0f b6       	in	r0, 0x3f	; 63
     fa4:	f8 94       	cli
     fa6:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
     fa8:	fc 01       	movw	r30, r24
     faa:	22 8d       	ldd	r18, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
     fac:	0f 90       	pop	r0
     fae:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
     fb0:	83 8d       	ldd	r24, Z+27	; 0x1b
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
     fb2:	82 1b       	sub	r24, r18
     fb4:	08 95       	ret

00000fb6 <uxQueueMessagesWaitingFromISR>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
     fb6:	fc 01       	movw	r30, r24
     fb8:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
     fba:	08 95       	ret

00000fbc <vQueueDelete>:

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
     fbc:	0e 94 99 04 	call	0x932	; 0x932 <vPortFree>
     fc0:	08 95       	ret

00000fc2 <xQueueIsQueueEmptyFromISR>:
BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
     fc2:	fc 01       	movw	r30, r24
     fc4:	92 8d       	ldd	r25, Z+26	; 0x1a
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
     fc6:	81 e0       	ldi	r24, 0x01	; 1
     fc8:	91 11       	cpse	r25, r1
     fca:	80 e0       	ldi	r24, 0x00	; 0
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
     fcc:	08 95       	ret

00000fce <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
     fce:	fc 01       	movw	r30, r24
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
     fd0:	92 8d       	ldd	r25, Z+26	; 0x1a
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
     fd2:	81 e0       	ldi	r24, 0x01	; 1
     fd4:	23 8d       	ldd	r18, Z+27	; 0x1b
     fd6:	29 13       	cpse	r18, r25
     fd8:	80 e0       	ldi	r24, 0x00	; 0
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
     fda:	08 95       	ret

00000fdc <xQueueCRSend>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait )
	{
     fdc:	cf 93       	push	r28
     fde:	df 93       	push	r29
     fe0:	ec 01       	movw	r28, r24
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;

		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
     fe2:	f8 94       	cli

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
     fe4:	0f b6       	in	r0, 0x3f	; 63
     fe6:	f8 94       	cli
     fe8:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
     fea:	2a 8d       	ldd	r18, Y+26	; 0x1a
     fec:	9b 8d       	ldd	r25, Y+27	; 0x1b
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
     fee:	0f 90       	pop	r0
     ff0:	0f be       	out	0x3f, r0	; 63
		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
     ff2:	29 13       	cpse	r18, r25
     ff4:	0f c0       	rjmp	.+30     	; 0x1014 <xQueueCRSend+0x38>
			{
				/* The queue is full - do we want to block or just leave without
				posting? */
				if( xTicksToWait > ( TickType_t ) 0 )
     ff6:	41 15       	cp	r20, r1
     ff8:	51 05       	cpc	r21, r1
     ffa:	49 f0       	breq	.+18     	; 0x100e <xQueueCRSend+0x32>
				{
					/* As this is called from a coroutine we cannot block directly, but
					return indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
     ffc:	be 01       	movw	r22, r28
     ffe:	68 5f       	subi	r22, 0xF8	; 248
    1000:	7f 4f       	sbci	r23, 0xFF	; 255
    1002:	ca 01       	movw	r24, r20
    1004:	0e 94 dd 00 	call	0x1ba	; 0x1ba <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    1008:	78 94       	sei
					return errQUEUE_BLOCKED;
    100a:	8c ef       	ldi	r24, 0xFC	; 252
    100c:	1d c0       	rjmp	.+58     	; 0x1048 <xQueueCRSend+0x6c>
				}
				else
				{
					portENABLE_INTERRUPTS();
    100e:	78 94       	sei
					return errQUEUE_FULL;
    1010:	80 e0       	ldi	r24, 0x00	; 0
    1012:	1a c0       	rjmp	.+52     	; 0x1048 <xQueueCRSend+0x6c>
				}
			}
		}
		portENABLE_INTERRUPTS();
    1014:	78 94       	sei

		portDISABLE_INTERRUPTS();
    1016:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1018:	8a 8d       	ldd	r24, Y+26	; 0x1a
    101a:	89 17       	cp	r24, r25
    101c:	78 f4       	brcc	.+30     	; 0x103c <xQueueCRSend+0x60>
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    101e:	40 e0       	ldi	r20, 0x00	; 0
    1020:	ce 01       	movw	r24, r28
    1022:	0e 94 a8 04 	call	0x950	; 0x950 <prvCopyDataToQueue>
				xReturn = pdPASS;

				/* Were any co-routines waiting for data to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1026:	89 89       	ldd	r24, Y+17	; 0x11
    1028:	88 23       	and	r24, r24
    102a:	51 f0       	breq	.+20     	; 0x1040 <xQueueCRSend+0x64>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    102c:	ce 01       	movw	r24, r28
    102e:	41 96       	adiw	r24, 0x11	; 17
    1030:	0e 94 5a 02 	call	0x4b4	; 0x4b4 <xCoRoutineRemoveFromEventList>
    1034:	88 23       	and	r24, r24
    1036:	31 f0       	breq	.+12     	; 0x1044 <xQueueCRSend+0x68>
					{
						/* The co-routine waiting has a higher priority so record
						that a yield might be appropriate. */
						xReturn = errQUEUE_YIELD;
    1038:	8b ef       	ldi	r24, 0xFB	; 251
    103a:	05 c0       	rjmp	.+10     	; 0x1046 <xQueueCRSend+0x6a>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = errQUEUE_FULL;
    103c:	80 e0       	ldi	r24, 0x00	; 0
    103e:	03 c0       	rjmp	.+6      	; 0x1046 <xQueueCRSend+0x6a>
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
				xReturn = pdPASS;
    1040:	81 e0       	ldi	r24, 0x01	; 1
    1042:	01 c0       	rjmp	.+2      	; 0x1046 <xQueueCRSend+0x6a>
    1044:	81 e0       	ldi	r24, 0x01	; 1
			else
			{
				xReturn = errQUEUE_FULL;
			}
		}
		portENABLE_INTERRUPTS();
    1046:	78 94       	sei

		return xReturn;
	}
    1048:	df 91       	pop	r29
    104a:	cf 91       	pop	r28
    104c:	08 95       	ret

0000104e <xQueueCRReceive>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
	{
    104e:	cf 93       	push	r28
    1050:	df 93       	push	r29
    1052:	ec 01       	movw	r28, r24
    1054:	9b 01       	movw	r18, r22
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;

		/* If the queue is already empty we may have to block.  A critical section
		is required to prevent an interrupt adding something to the queue
		between the check to see if the queue is empty and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    1056:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1058:	9a 8d       	ldd	r25, Y+26	; 0x1a
    105a:	91 11       	cpse	r25, r1
    105c:	0f c0       	rjmp	.+30     	; 0x107c <xQueueCRReceive+0x2e>
			{
				/* There are no messages in the queue, do we want to block or just
				leave with nothing? */
				if( xTicksToWait > ( TickType_t ) 0 )
    105e:	41 15       	cp	r20, r1
    1060:	51 05       	cpc	r21, r1
    1062:	49 f0       	breq	.+18     	; 0x1076 <xQueueCRReceive+0x28>
				{
					/* As this is a co-routine we cannot block directly, but return
					indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    1064:	be 01       	movw	r22, r28
    1066:	6f 5e       	subi	r22, 0xEF	; 239
    1068:	7f 4f       	sbci	r23, 0xFF	; 255
    106a:	ca 01       	movw	r24, r20
    106c:	0e 94 dd 00 	call	0x1ba	; 0x1ba <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    1070:	78 94       	sei
					return errQUEUE_BLOCKED;
    1072:	8c ef       	ldi	r24, 0xFC	; 252
    1074:	32 c0       	rjmp	.+100    	; 0x10da <xQueueCRReceive+0x8c>
				}
				else
				{
					portENABLE_INTERRUPTS();
    1076:	78 94       	sei
					return errQUEUE_FULL;
    1078:	80 e0       	ldi	r24, 0x00	; 0
    107a:	2f c0       	rjmp	.+94     	; 0x10da <xQueueCRReceive+0x8c>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portENABLE_INTERRUPTS();
    107c:	78 94       	sei

		portDISABLE_INTERRUPTS();
    107e:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1080:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1082:	88 23       	and	r24, r24
    1084:	21 f1       	breq	.+72     	; 0x10ce <xQueueCRReceive+0x80>
			{
				/* Data is available from the queue. */
				pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    1086:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1088:	50 e0       	ldi	r21, 0x00	; 0
    108a:	8e 81       	ldd	r24, Y+6	; 0x06
    108c:	9f 81       	ldd	r25, Y+7	; 0x07
    108e:	84 0f       	add	r24, r20
    1090:	95 1f       	adc	r25, r21
    1092:	9f 83       	std	Y+7, r25	; 0x07
    1094:	8e 83       	std	Y+6, r24	; 0x06
				if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
    1096:	6a 81       	ldd	r22, Y+2	; 0x02
    1098:	7b 81       	ldd	r23, Y+3	; 0x03
    109a:	86 17       	cp	r24, r22
    109c:	97 07       	cpc	r25, r23
    109e:	20 f0       	brcs	.+8      	; 0x10a8 <xQueueCRReceive+0x5a>
				{
					pxQueue->u.pcReadFrom = pxQueue->pcHead;
    10a0:	88 81       	ld	r24, Y
    10a2:	99 81       	ldd	r25, Y+1	; 0x01
    10a4:	9f 83       	std	Y+7, r25	; 0x07
    10a6:	8e 83       	std	Y+6, r24	; 0x06
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
    10a8:	8a 8d       	ldd	r24, Y+26	; 0x1a
    10aa:	81 50       	subi	r24, 0x01	; 1
    10ac:	8a 8f       	std	Y+26, r24	; 0x1a
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    10ae:	6e 81       	ldd	r22, Y+6	; 0x06
    10b0:	7f 81       	ldd	r23, Y+7	; 0x07
    10b2:	c9 01       	movw	r24, r18
    10b4:	0e 94 25 12 	call	0x244a	; 0x244a <memcpy>

				xReturn = pdPASS;

				/* Were any co-routines waiting for space to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    10b8:	88 85       	ldd	r24, Y+8	; 0x08
    10ba:	88 23       	and	r24, r24
    10bc:	51 f0       	breq	.+20     	; 0x10d2 <xQueueCRReceive+0x84>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    10be:	ce 01       	movw	r24, r28
    10c0:	08 96       	adiw	r24, 0x08	; 8
    10c2:	0e 94 5a 02 	call	0x4b4	; 0x4b4 <xCoRoutineRemoveFromEventList>
    10c6:	88 23       	and	r24, r24
    10c8:	31 f0       	breq	.+12     	; 0x10d6 <xQueueCRReceive+0x88>
					{
						xReturn = errQUEUE_YIELD;
    10ca:	8b ef       	ldi	r24, 0xFB	; 251
    10cc:	05 c0       	rjmp	.+10     	; 0x10d8 <xQueueCRReceive+0x8a>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = pdFAIL;
    10ce:	80 e0       	ldi	r24, 0x00	; 0
    10d0:	03 c0       	rjmp	.+6      	; 0x10d8 <xQueueCRReceive+0x8a>
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

				xReturn = pdPASS;
    10d2:	81 e0       	ldi	r24, 0x01	; 1
    10d4:	01 c0       	rjmp	.+2      	; 0x10d8 <xQueueCRReceive+0x8a>
    10d6:	81 e0       	ldi	r24, 0x01	; 1
			else
			{
				xReturn = pdFAIL;
			}
		}
		portENABLE_INTERRUPTS();
    10d8:	78 94       	sei

		return xReturn;
	}
    10da:	df 91       	pop	r29
    10dc:	cf 91       	pop	r28
    10de:	08 95       	ret

000010e0 <xQueueCRSendFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken )
	{
    10e0:	0f 93       	push	r16
    10e2:	1f 93       	push	r17
    10e4:	cf 93       	push	r28
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;

		/* Cannot block within an ISR so if there is no space on the queue then
		exit without doing anything. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    10e6:	fc 01       	movw	r30, r24
    10e8:	32 8d       	ldd	r19, Z+26	; 0x1a
    10ea:	23 8d       	ldd	r18, Z+27	; 0x1b
    10ec:	32 17       	cp	r19, r18
    10ee:	b8 f4       	brcc	.+46     	; 0x111e <__stack+0x1f>
    10f0:	c4 2f       	mov	r28, r20
    10f2:	8c 01       	movw	r16, r24
		{
			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    10f4:	40 e0       	ldi	r20, 0x00	; 0
    10f6:	0e 94 a8 04 	call	0x950	; 0x950 <prvCopyDataToQueue>

			/* We only want to wake one co-routine per ISR, so check that a
			co-routine has not already been woken. */
			if( xCoRoutinePreviouslyWoken == pdFALSE )
    10fa:	c1 11       	cpse	r28, r1
    10fc:	0d c0       	rjmp	.+26     	; 0x1118 <__stack+0x19>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    10fe:	f8 01       	movw	r30, r16
    1100:	81 89       	ldd	r24, Z+17	; 0x11
    1102:	88 23       	and	r24, r24
    1104:	59 f0       	breq	.+22     	; 0x111c <__stack+0x1d>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1106:	c8 01       	movw	r24, r16
    1108:	41 96       	adiw	r24, 0x11	; 17
    110a:	0e 94 5a 02 	call	0x4b4	; 0x4b4 <xCoRoutineRemoveFromEventList>
					{
						return pdTRUE;
    110e:	41 e0       	ldi	r20, 0x01	; 1
    1110:	81 11       	cpse	r24, r1
    1112:	05 c0       	rjmp	.+10     	; 0x111e <__stack+0x1f>
    1114:	40 e0       	ldi	r20, 0x00	; 0
    1116:	03 c0       	rjmp	.+6      	; 0x111e <__stack+0x1f>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xCoRoutinePreviouslyWoken;
    1118:	4c 2f       	mov	r20, r28
    111a:	01 c0       	rjmp	.+2      	; 0x111e <__stack+0x1f>
    111c:	40 e0       	ldi	r20, 0x00	; 0
	}
    111e:	84 2f       	mov	r24, r20
    1120:	cf 91       	pop	r28
    1122:	1f 91       	pop	r17
    1124:	0f 91       	pop	r16
    1126:	08 95       	ret

00001128 <xQueueCRReceiveFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWoken )
	{
    1128:	0f 93       	push	r16
    112a:	1f 93       	push	r17
    112c:	cf 93       	push	r28
    112e:	df 93       	push	r29
    1130:	fc 01       	movw	r30, r24
	BaseType_t xReturn;
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;

		/* We cannot block from an ISR, so check there is data available. If
		not then just leave without doing anything. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1132:	82 8d       	ldd	r24, Z+26	; 0x1a
    1134:	88 23       	and	r24, r24
    1136:	69 f1       	breq	.+90     	; 0x1192 <xQueueCRReceiveFromISR+0x6a>
		{
			/* Copy the data from the queue. */
			pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    1138:	24 8d       	ldd	r18, Z+28	; 0x1c
    113a:	30 e0       	ldi	r19, 0x00	; 0
    113c:	a6 81       	ldd	r26, Z+6	; 0x06
    113e:	b7 81       	ldd	r27, Z+7	; 0x07
    1140:	a2 0f       	add	r26, r18
    1142:	b3 1f       	adc	r27, r19
    1144:	b7 83       	std	Z+7, r27	; 0x07
    1146:	a6 83       	std	Z+6, r26	; 0x06
			if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
    1148:	82 81       	ldd	r24, Z+2	; 0x02
    114a:	93 81       	ldd	r25, Z+3	; 0x03
    114c:	a8 17       	cp	r26, r24
    114e:	b9 07       	cpc	r27, r25
    1150:	20 f0       	brcs	.+8      	; 0x115a <xQueueCRReceiveFromISR+0x32>
			{
				pxQueue->u.pcReadFrom = pxQueue->pcHead;
    1152:	80 81       	ld	r24, Z
    1154:	91 81       	ldd	r25, Z+1	; 0x01
    1156:	97 83       	std	Z+7, r25	; 0x07
    1158:	86 83       	std	Z+6, r24	; 0x06
    115a:	8a 01       	movw	r16, r20
    115c:	cb 01       	movw	r24, r22
    115e:	ef 01       	movw	r28, r30
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
			--( pxQueue->uxMessagesWaiting );
    1160:	42 8d       	ldd	r20, Z+26	; 0x1a
    1162:	41 50       	subi	r20, 0x01	; 1
    1164:	42 8f       	std	Z+26, r20	; 0x1a
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1166:	66 81       	ldd	r22, Z+6	; 0x06
    1168:	77 81       	ldd	r23, Z+7	; 0x07
    116a:	a9 01       	movw	r20, r18
    116c:	0e 94 25 12 	call	0x244a	; 0x244a <memcpy>

			if( ( *pxCoRoutineWoken ) == pdFALSE )
    1170:	f8 01       	movw	r30, r16
    1172:	80 81       	ld	r24, Z
    1174:	81 11       	cpse	r24, r1
    1176:	0f c0       	rjmp	.+30     	; 0x1196 <xQueueCRReceiveFromISR+0x6e>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1178:	88 85       	ldd	r24, Y+8	; 0x08
    117a:	88 23       	and	r24, r24
    117c:	71 f0       	breq	.+28     	; 0x119a <xQueueCRReceiveFromISR+0x72>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    117e:	ce 01       	movw	r24, r28
    1180:	08 96       	adiw	r24, 0x08	; 8
    1182:	0e 94 5a 02 	call	0x4b4	; 0x4b4 <xCoRoutineRemoveFromEventList>
    1186:	88 23       	and	r24, r24
    1188:	51 f0       	breq	.+20     	; 0x119e <xQueueCRReceiveFromISR+0x76>
					{
						*pxCoRoutineWoken = pdTRUE;
    118a:	81 e0       	ldi	r24, 0x01	; 1
    118c:	f8 01       	movw	r30, r16
    118e:	80 83       	st	Z, r24
    1190:	07 c0       	rjmp	.+14     	; 0x11a0 <xQueueCRReceiveFromISR+0x78>

			xReturn = pdPASS;
		}
		else
		{
			xReturn = pdFAIL;
    1192:	80 e0       	ldi	r24, 0x00	; 0
    1194:	05 c0       	rjmp	.+10     	; 0x11a0 <xQueueCRReceiveFromISR+0x78>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			xReturn = pdPASS;
    1196:	81 e0       	ldi	r24, 0x01	; 1
    1198:	03 c0       	rjmp	.+6      	; 0x11a0 <xQueueCRReceiveFromISR+0x78>
    119a:	81 e0       	ldi	r24, 0x01	; 1
    119c:	01 c0       	rjmp	.+2      	; 0x11a0 <xQueueCRReceiveFromISR+0x78>
    119e:	81 e0       	ldi	r24, 0x01	; 1
		{
			xReturn = pdFAIL;
		}

		return xReturn;
	}
    11a0:	df 91       	pop	r29
    11a2:	cf 91       	pop	r28
    11a4:	1f 91       	pop	r17
    11a6:	0f 91       	pop	r16
    11a8:	08 95       	ret

000011aa <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    11aa:	e0 91 97 0d 	lds	r30, 0x0D97	; 0x800d97 <pxDelayedTaskList>
    11ae:	f0 91 98 0d 	lds	r31, 0x0D98	; 0x800d98 <pxDelayedTaskList+0x1>
    11b2:	80 81       	ld	r24, Z
    11b4:	81 11       	cpse	r24, r1
    11b6:	07 c0       	rjmp	.+14     	; 0x11c6 <prvResetNextTaskUnblockTime+0x1c>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    11b8:	8f ef       	ldi	r24, 0xFF	; 255
    11ba:	9f ef       	ldi	r25, 0xFF	; 255
    11bc:	90 93 78 0d 	sts	0x0D78, r25	; 0x800d78 <xNextTaskUnblockTime+0x1>
    11c0:	80 93 77 0d 	sts	0x0D77, r24	; 0x800d77 <xNextTaskUnblockTime>
    11c4:	08 95       	ret
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    11c6:	e0 91 97 0d 	lds	r30, 0x0D97	; 0x800d97 <pxDelayedTaskList>
    11ca:	f0 91 98 0d 	lds	r31, 0x0D98	; 0x800d98 <pxDelayedTaskList+0x1>
    11ce:	05 80       	ldd	r0, Z+5	; 0x05
    11d0:	f6 81       	ldd	r31, Z+6	; 0x06
    11d2:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    11d4:	06 80       	ldd	r0, Z+6	; 0x06
    11d6:	f7 81       	ldd	r31, Z+7	; 0x07
    11d8:	e0 2d       	mov	r30, r0
    11da:	82 81       	ldd	r24, Z+2	; 0x02
    11dc:	93 81       	ldd	r25, Z+3	; 0x03
    11de:	90 93 78 0d 	sts	0x0D78, r25	; 0x800d78 <xNextTaskUnblockTime+0x1>
    11e2:	80 93 77 0d 	sts	0x0D77, r24	; 0x800d77 <xNextTaskUnblockTime>
    11e6:	08 95       	ret

000011e8 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    11e8:	0f 93       	push	r16
    11ea:	1f 93       	push	r17
    11ec:	cf 93       	push	r28
    11ee:	df 93       	push	r29
    11f0:	ec 01       	movw	r28, r24
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    11f2:	00 91 7f 0d 	lds	r16, 0x0D7F	; 0x800d7f <xTickCount>
    11f6:	10 91 80 0d 	lds	r17, 0x0D80	; 0x800d80 <xTickCount+0x1>
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    11fa:	80 91 72 0d 	lds	r24, 0x0D72	; 0x800d72 <pxCurrentTCB>
    11fe:	90 91 73 0d 	lds	r25, 0x0D73	; 0x800d73 <pxCurrentTCB+0x1>
    1202:	02 96       	adiw	r24, 0x02	; 2
    1204:	0e 94 e3 02 	call	0x5c6	; 0x5c6 <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
		/* Calculate the time at which the task should be woken if the event
		does not occur.  This may overflow but this doesn't matter, the kernel
		will manage it correctly. */
		xTimeToWake = xConstTickCount + xTicksToWait;
    1208:	c0 0f       	add	r28, r16
    120a:	d1 1f       	adc	r29, r17

		/* The list item will be inserted in wake time order. */
		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    120c:	e0 91 72 0d 	lds	r30, 0x0D72	; 0x800d72 <pxCurrentTCB>
    1210:	f0 91 73 0d 	lds	r31, 0x0D73	; 0x800d73 <pxCurrentTCB+0x1>
    1214:	d3 83       	std	Z+3, r29	; 0x03
    1216:	c2 83       	std	Z+2, r28	; 0x02

		if( xTimeToWake < xConstTickCount )
    1218:	c0 17       	cp	r28, r16
    121a:	d1 07       	cpc	r29, r17
    121c:	68 f4       	brcc	.+26     	; 0x1238 <prvAddCurrentTaskToDelayedList+0x50>
		{
			/* Wake time has overflowed.  Place this item in the overflow list. */
			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    121e:	60 91 72 0d 	lds	r22, 0x0D72	; 0x800d72 <pxCurrentTCB>
    1222:	70 91 73 0d 	lds	r23, 0x0D73	; 0x800d73 <pxCurrentTCB+0x1>
    1226:	80 91 95 0d 	lds	r24, 0x0D95	; 0x800d95 <pxOverflowDelayedTaskList>
    122a:	90 91 96 0d 	lds	r25, 0x0D96	; 0x800d96 <pxOverflowDelayedTaskList+0x1>
    122e:	6e 5f       	subi	r22, 0xFE	; 254
    1230:	7f 4f       	sbci	r23, 0xFF	; 255
    1232:	0e 94 b2 02 	call	0x564	; 0x564 <vListInsert>
    1236:	17 c0       	rjmp	.+46     	; 0x1266 <prvAddCurrentTaskToDelayedList+0x7e>
		}
		else
		{
			/* The wake time has not overflowed, so the current block list is used. */
			vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    1238:	60 91 72 0d 	lds	r22, 0x0D72	; 0x800d72 <pxCurrentTCB>
    123c:	70 91 73 0d 	lds	r23, 0x0D73	; 0x800d73 <pxCurrentTCB+0x1>
    1240:	80 91 97 0d 	lds	r24, 0x0D97	; 0x800d97 <pxDelayedTaskList>
    1244:	90 91 98 0d 	lds	r25, 0x0D98	; 0x800d98 <pxDelayedTaskList+0x1>
    1248:	6e 5f       	subi	r22, 0xFE	; 254
    124a:	7f 4f       	sbci	r23, 0xFF	; 255
    124c:	0e 94 b2 02 	call	0x564	; 0x564 <vListInsert>

			/* If the task entering the blocked state was placed at the head of the
			list of blocked tasks then xNextTaskUnblockTime needs to be updated
			too. */
			if( xTimeToWake < xNextTaskUnblockTime )
    1250:	80 91 77 0d 	lds	r24, 0x0D77	; 0x800d77 <xNextTaskUnblockTime>
    1254:	90 91 78 0d 	lds	r25, 0x0D78	; 0x800d78 <xNextTaskUnblockTime+0x1>
    1258:	c8 17       	cp	r28, r24
    125a:	d9 07       	cpc	r29, r25
    125c:	20 f4       	brcc	.+8      	; 0x1266 <prvAddCurrentTaskToDelayedList+0x7e>
			{
				xNextTaskUnblockTime = xTimeToWake;
    125e:	d0 93 78 0d 	sts	0x0D78, r29	; 0x800d78 <xNextTaskUnblockTime+0x1>
    1262:	c0 93 77 0d 	sts	0x0D77, r28	; 0x800d77 <xNextTaskUnblockTime>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    1266:	df 91       	pop	r29
    1268:	cf 91       	pop	r28
    126a:	1f 91       	pop	r17
    126c:	0f 91       	pop	r16
    126e:	08 95       	ret

00001270 <xTaskCreate>:
							const char * const pcName,
							const uint16_t usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
    1270:	4f 92       	push	r4
    1272:	5f 92       	push	r5
    1274:	6f 92       	push	r6
    1276:	7f 92       	push	r7
    1278:	8f 92       	push	r8
    127a:	9f 92       	push	r9
    127c:	af 92       	push	r10
    127e:	bf 92       	push	r11
    1280:	cf 92       	push	r12
    1282:	df 92       	push	r13
    1284:	ef 92       	push	r14
    1286:	ff 92       	push	r15
    1288:	0f 93       	push	r16
    128a:	cf 93       	push	r28
    128c:	df 93       	push	r29
    128e:	4c 01       	movw	r8, r24
    1290:	6b 01       	movw	r12, r22
    1292:	5a 01       	movw	r10, r20
    1294:	29 01       	movw	r4, r18
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1296:	ca 01       	movw	r24, r20
    1298:	0e 94 64 04 	call	0x8c8	; 0x8c8 <pvPortMalloc>
    129c:	3c 01       	movw	r6, r24

			if( pxStack != NULL )
    129e:	89 2b       	or	r24, r25
    12a0:	09 f4       	brne	.+2      	; 0x12a4 <xTaskCreate+0x34>
    12a2:	dd c0       	rjmp	.+442    	; 0x145e <xTaskCreate+0x1ee>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
    12a4:	86 e2       	ldi	r24, 0x26	; 38
    12a6:	90 e0       	ldi	r25, 0x00	; 0
    12a8:	0e 94 64 04 	call	0x8c8	; 0x8c8 <pvPortMalloc>
    12ac:	ec 01       	movw	r28, r24

				if( pxNewTCB != NULL )
    12ae:	89 2b       	or	r24, r25
    12b0:	71 f0       	breq	.+28     	; 0x12ce <xTaskCreate+0x5e>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    12b2:	78 8e       	std	Y+24, r7	; 0x18
    12b4:	6f 8a       	std	Y+23, r6	; 0x17
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
    12b6:	81 e0       	ldi	r24, 0x01	; 1
    12b8:	a8 1a       	sub	r10, r24
    12ba:	b1 08       	sbc	r11, r1
    12bc:	a6 0c       	add	r10, r6
    12be:	b7 1c       	adc	r11, r7
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    12c0:	d6 01       	movw	r26, r12
    12c2:	8c 91       	ld	r24, X
    12c4:	89 8f       	std	Y+25, r24	; 0x19

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    12c6:	8c 91       	ld	r24, X
    12c8:	81 11       	cpse	r24, r1
    12ca:	05 c0       	rjmp	.+10     	; 0x12d6 <xTaskCreate+0x66>
    12cc:	18 c0       	rjmp	.+48     	; 0x12fe <xTaskCreate+0x8e>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    12ce:	c3 01       	movw	r24, r6
    12d0:	0e 94 99 04 	call	0x932	; 0x932 <vPortFree>
    12d4:	c4 c0       	rjmp	.+392    	; 0x145e <xTaskCreate+0x1ee>
    12d6:	ae 01       	movw	r20, r28
    12d8:	46 5e       	subi	r20, 0xE6	; 230
    12da:	5f 4f       	sbci	r21, 0xFF	; 255
    12dc:	f6 01       	movw	r30, r12
    12de:	31 96       	adiw	r30, 0x01	; 1
    12e0:	b8 e0       	ldi	r27, 0x08	; 8
    12e2:	cb 0e       	add	r12, r27
    12e4:	d1 1c       	adc	r13, r1
    12e6:	cf 01       	movw	r24, r30
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    12e8:	21 91       	ld	r18, Z+
    12ea:	da 01       	movw	r26, r20
    12ec:	2d 93       	st	X+, r18
    12ee:	ad 01       	movw	r20, r26

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    12f0:	dc 01       	movw	r26, r24
    12f2:	8c 91       	ld	r24, X
    12f4:	88 23       	and	r24, r24
    12f6:	19 f0       	breq	.+6      	; 0x12fe <xTaskCreate+0x8e>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    12f8:	ec 15       	cp	r30, r12
    12fa:	fd 05       	cpc	r31, r13
    12fc:	a1 f7       	brne	.-24     	; 0x12e6 <xTaskCreate+0x76>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    12fe:	18 a2       	std	Y+32, r1	; 0x20
    1300:	04 30       	cpi	r16, 0x04	; 4
    1302:	08 f0       	brcs	.+2      	; 0x1306 <xTaskCreate+0x96>
    1304:	03 e0       	ldi	r16, 0x03	; 3
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    1306:	0e 8b       	std	Y+22, r16	; 0x16
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    1308:	6e 01       	movw	r12, r28
    130a:	b2 e0       	ldi	r27, 0x02	; 2
    130c:	cb 0e       	add	r12, r27
    130e:	d1 1c       	adc	r13, r1
    1310:	c6 01       	movw	r24, r12
    1312:	0e 94 8d 02 	call	0x51a	; 0x51a <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    1316:	ce 01       	movw	r24, r28
    1318:	0c 96       	adiw	r24, 0x0c	; 12
    131a:	0e 94 8d 02 	call	0x51a	; 0x51a <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    131e:	d9 87       	std	Y+9, r29	; 0x09
    1320:	c8 87       	std	Y+8, r28	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1322:	84 e0       	ldi	r24, 0x04	; 4
    1324:	90 e0       	ldi	r25, 0x00	; 0
    1326:	80 1b       	sub	r24, r16
    1328:	91 09       	sbc	r25, r1
    132a:	9d 87       	std	Y+13, r25	; 0x0d
    132c:	8c 87       	std	Y+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    132e:	db 8b       	std	Y+19, r29	; 0x13
    1330:	ca 8b       	std	Y+18, r28	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    1332:	19 a2       	std	Y+33, r1	; 0x21
    1334:	1a a2       	std	Y+34, r1	; 0x22
    1336:	1b a2       	std	Y+35, r1	; 0x23
    1338:	1c a2       	std	Y+36, r1	; 0x24
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    133a:	1d a2       	std	Y+37, r1	; 0x25
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    133c:	a2 01       	movw	r20, r4
    133e:	b4 01       	movw	r22, r8
    1340:	c5 01       	movw	r24, r10
    1342:	0e 94 09 03 	call	0x612	; 0x612 <pxPortInitialiseStack>
    1346:	99 83       	std	Y+1, r25	; 0x01
    1348:	88 83       	st	Y, r24
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( ( void * ) pxCreatedTask != NULL )
    134a:	e1 14       	cp	r14, r1
    134c:	f1 04       	cpc	r15, r1
    134e:	19 f0       	breq	.+6      	; 0x1356 <xTaskCreate+0xe6>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    1350:	f7 01       	movw	r30, r14
    1352:	d1 83       	std	Z+1, r29	; 0x01
    1354:	c0 83       	st	Z, r28

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    1356:	0f b6       	in	r0, 0x3f	; 63
    1358:	f8 94       	cli
    135a:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    135c:	80 91 81 0d 	lds	r24, 0x0D81	; 0x800d81 <uxCurrentNumberOfTasks>
    1360:	8f 5f       	subi	r24, 0xFF	; 255
    1362:	80 93 81 0d 	sts	0x0D81, r24	; 0x800d81 <uxCurrentNumberOfTasks>
		if( pxCurrentTCB == NULL )
    1366:	80 91 72 0d 	lds	r24, 0x0D72	; 0x800d72 <pxCurrentTCB>
    136a:	90 91 73 0d 	lds	r25, 0x0D73	; 0x800d73 <pxCurrentTCB+0x1>
    136e:	89 2b       	or	r24, r25
    1370:	a9 f5       	brne	.+106    	; 0x13dc <xTaskCreate+0x16c>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    1372:	d0 93 73 0d 	sts	0x0D73, r29	; 0x800d73 <pxCurrentTCB+0x1>
    1376:	c0 93 72 0d 	sts	0x0D72, r28	; 0x800d72 <pxCurrentTCB>

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    137a:	80 91 81 0d 	lds	r24, 0x0D81	; 0x800d81 <uxCurrentNumberOfTasks>
    137e:	81 30       	cpi	r24, 0x01	; 1
    1380:	e9 f5       	brne	.+122    	; 0x13fc <xTaskCreate+0x18c>
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    1382:	8b ea       	ldi	r24, 0xAB	; 171
    1384:	9d e0       	ldi	r25, 0x0D	; 13
    1386:	0e 94 7f 02 	call	0x4fe	; 0x4fe <vListInitialise>
    138a:	84 eb       	ldi	r24, 0xB4	; 180
    138c:	9d e0       	ldi	r25, 0x0D	; 13
    138e:	0e 94 7f 02 	call	0x4fe	; 0x4fe <vListInitialise>
    1392:	8d eb       	ldi	r24, 0xBD	; 189
    1394:	9d e0       	ldi	r25, 0x0D	; 13
    1396:	0e 94 7f 02 	call	0x4fe	; 0x4fe <vListInitialise>
    139a:	86 ec       	ldi	r24, 0xC6	; 198
    139c:	9d e0       	ldi	r25, 0x0D	; 13
    139e:	0e 94 7f 02 	call	0x4fe	; 0x4fe <vListInitialise>
	}

	vListInitialise( &xDelayedTaskList1 );
    13a2:	82 ea       	ldi	r24, 0xA2	; 162
    13a4:	9d e0       	ldi	r25, 0x0D	; 13
    13a6:	0e 94 7f 02 	call	0x4fe	; 0x4fe <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    13aa:	89 e9       	ldi	r24, 0x99	; 153
    13ac:	9d e0       	ldi	r25, 0x0D	; 13
    13ae:	0e 94 7f 02 	call	0x4fe	; 0x4fe <vListInitialise>
	vListInitialise( &xPendingReadyList );
    13b2:	8c e8       	ldi	r24, 0x8C	; 140
    13b4:	9d e0       	ldi	r25, 0x0D	; 13
    13b6:	0e 94 7f 02 	call	0x4fe	; 0x4fe <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    13ba:	83 e8       	ldi	r24, 0x83	; 131
    13bc:	9d e0       	ldi	r25, 0x0D	; 13
    13be:	0e 94 7f 02 	call	0x4fe	; 0x4fe <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    13c2:	82 ea       	ldi	r24, 0xA2	; 162
    13c4:	9d e0       	ldi	r25, 0x0D	; 13
    13c6:	90 93 98 0d 	sts	0x0D98, r25	; 0x800d98 <pxDelayedTaskList+0x1>
    13ca:	80 93 97 0d 	sts	0x0D97, r24	; 0x800d97 <pxDelayedTaskList>
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    13ce:	89 e9       	ldi	r24, 0x99	; 153
    13d0:	9d e0       	ldi	r25, 0x0D	; 13
    13d2:	90 93 96 0d 	sts	0x0D96, r25	; 0x800d96 <pxOverflowDelayedTaskList+0x1>
    13d6:	80 93 95 0d 	sts	0x0D95, r24	; 0x800d95 <pxOverflowDelayedTaskList>
    13da:	10 c0       	rjmp	.+32     	; 0x13fc <xTaskCreate+0x18c>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    13dc:	80 91 7d 0d 	lds	r24, 0x0D7D	; 0x800d7d <xSchedulerRunning>
    13e0:	81 11       	cpse	r24, r1
    13e2:	0c c0       	rjmp	.+24     	; 0x13fc <xTaskCreate+0x18c>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    13e4:	e0 91 72 0d 	lds	r30, 0x0D72	; 0x800d72 <pxCurrentTCB>
    13e8:	f0 91 73 0d 	lds	r31, 0x0D73	; 0x800d73 <pxCurrentTCB+0x1>
    13ec:	96 89       	ldd	r25, Z+22	; 0x16
    13ee:	8e 89       	ldd	r24, Y+22	; 0x16
    13f0:	89 17       	cp	r24, r25
    13f2:	20 f0       	brcs	.+8      	; 0x13fc <xTaskCreate+0x18c>
				{
					pxCurrentTCB = pxNewTCB;
    13f4:	d0 93 73 0d 	sts	0x0D73, r29	; 0x800d73 <pxCurrentTCB+0x1>
    13f8:	c0 93 72 0d 	sts	0x0D72, r28	; 0x800d72 <pxCurrentTCB>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    13fc:	80 91 79 0d 	lds	r24, 0x0D79	; 0x800d79 <uxTaskNumber>
    1400:	8f 5f       	subi	r24, 0xFF	; 255
    1402:	80 93 79 0d 	sts	0x0D79, r24	; 0x800d79 <uxTaskNumber>
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    1406:	8e 89       	ldd	r24, Y+22	; 0x16
    1408:	90 91 7e 0d 	lds	r25, 0x0D7E	; 0x800d7e <uxTopReadyPriority>
    140c:	98 17       	cp	r25, r24
    140e:	10 f4       	brcc	.+4      	; 0x1414 <xTaskCreate+0x1a4>
    1410:	80 93 7e 0d 	sts	0x0D7E, r24	; 0x800d7e <uxTopReadyPriority>
    1414:	90 e0       	ldi	r25, 0x00	; 0
    1416:	9c 01       	movw	r18, r24
    1418:	22 0f       	add	r18, r18
    141a:	33 1f       	adc	r19, r19
    141c:	22 0f       	add	r18, r18
    141e:	33 1f       	adc	r19, r19
    1420:	22 0f       	add	r18, r18
    1422:	33 1f       	adc	r19, r19
    1424:	82 0f       	add	r24, r18
    1426:	93 1f       	adc	r25, r19
    1428:	b6 01       	movw	r22, r12
    142a:	85 55       	subi	r24, 0x55	; 85
    142c:	92 4f       	sbci	r25, 0xF2	; 242
    142e:	0e 94 91 02 	call	0x522	; 0x522 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    1432:	0f 90       	pop	r0
    1434:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    1436:	80 91 7d 0d 	lds	r24, 0x0D7D	; 0x800d7d <xSchedulerRunning>
    143a:	88 23       	and	r24, r24
    143c:	61 f0       	breq	.+24     	; 0x1456 <xTaskCreate+0x1e6>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    143e:	e0 91 72 0d 	lds	r30, 0x0D72	; 0x800d72 <pxCurrentTCB>
    1442:	f0 91 73 0d 	lds	r31, 0x0D73	; 0x800d73 <pxCurrentTCB+0x1>
    1446:	96 89       	ldd	r25, Z+22	; 0x16
    1448:	8e 89       	ldd	r24, Y+22	; 0x16
    144a:	98 17       	cp	r25, r24
    144c:	30 f4       	brcc	.+12     	; 0x145a <xTaskCreate+0x1ea>
		{
			taskYIELD_IF_USING_PREEMPTION();
    144e:	0e 94 ac 03 	call	0x758	; 0x758 <vPortYield>
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
			prvAddNewTaskToReadyList( pxNewTCB );
			xReturn = pdPASS;
    1452:	81 e0       	ldi	r24, 0x01	; 1
    1454:	05 c0       	rjmp	.+10     	; 0x1460 <xTaskCreate+0x1f0>
    1456:	81 e0       	ldi	r24, 0x01	; 1
    1458:	03 c0       	rjmp	.+6      	; 0x1460 <xTaskCreate+0x1f0>
    145a:	81 e0       	ldi	r24, 0x01	; 1
    145c:	01 c0       	rjmp	.+2      	; 0x1460 <xTaskCreate+0x1f0>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    145e:	8f ef       	ldi	r24, 0xFF	; 255
		}

		return xReturn;
	}
    1460:	df 91       	pop	r29
    1462:	cf 91       	pop	r28
    1464:	0f 91       	pop	r16
    1466:	ff 90       	pop	r15
    1468:	ef 90       	pop	r14
    146a:	df 90       	pop	r13
    146c:	cf 90       	pop	r12
    146e:	bf 90       	pop	r11
    1470:	af 90       	pop	r10
    1472:	9f 90       	pop	r9
    1474:	8f 90       	pop	r8
    1476:	7f 90       	pop	r7
    1478:	6f 90       	pop	r6
    147a:	5f 90       	pop	r5
    147c:	4f 90       	pop	r4
    147e:	08 95       	ret

00001480 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    1480:	0f 93       	push	r16
    1482:	1f 93       	push	r17
    1484:	cf 93       	push	r28
    1486:	df 93       	push	r29
    1488:	ec 01       	movw	r28, r24
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    148a:	0f b6       	in	r0, 0x3f	; 63
    148c:	f8 94       	cli
    148e:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    1490:	89 2b       	or	r24, r25
    1492:	21 f4       	brne	.+8      	; 0x149c <vTaskDelete+0x1c>
    1494:	c0 91 72 0d 	lds	r28, 0x0D72	; 0x800d72 <pxCurrentTCB>
    1498:	d0 91 73 0d 	lds	r29, 0x0D73	; 0x800d73 <pxCurrentTCB+0x1>

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    149c:	8e 01       	movw	r16, r28
    149e:	0e 5f       	subi	r16, 0xFE	; 254
    14a0:	1f 4f       	sbci	r17, 0xFF	; 255
    14a2:	c8 01       	movw	r24, r16
    14a4:	0e 94 e3 02 	call	0x5c6	; 0x5c6 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    14a8:	8c 89       	ldd	r24, Y+20	; 0x14
    14aa:	9d 89       	ldd	r25, Y+21	; 0x15
    14ac:	89 2b       	or	r24, r25
    14ae:	21 f0       	breq	.+8      	; 0x14b8 <vTaskDelete+0x38>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    14b0:	ce 01       	movw	r24, r28
    14b2:	0c 96       	adiw	r24, 0x0c	; 12
    14b4:	0e 94 e3 02 	call	0x5c6	; 0x5c6 <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
    14b8:	80 91 79 0d 	lds	r24, 0x0D79	; 0x800d79 <uxTaskNumber>
    14bc:	8f 5f       	subi	r24, 0xFF	; 255
    14be:	80 93 79 0d 	sts	0x0D79, r24	; 0x800d79 <uxTaskNumber>

			if( pxTCB == pxCurrentTCB )
    14c2:	80 91 72 0d 	lds	r24, 0x0D72	; 0x800d72 <pxCurrentTCB>
    14c6:	90 91 73 0d 	lds	r25, 0x0D73	; 0x800d73 <pxCurrentTCB+0x1>
    14ca:	c8 17       	cp	r28, r24
    14cc:	d9 07       	cpc	r29, r25
    14ce:	59 f4       	brne	.+22     	; 0x14e6 <vTaskDelete+0x66>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    14d0:	b8 01       	movw	r22, r16
    14d2:	83 e8       	ldi	r24, 0x83	; 131
    14d4:	9d e0       	ldi	r25, 0x0D	; 13
    14d6:	0e 94 91 02 	call	0x522	; 0x522 <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
    14da:	80 91 82 0d 	lds	r24, 0x0D82	; 0x800d82 <uxDeletedTasksWaitingCleanUp>
    14de:	8f 5f       	subi	r24, 0xFF	; 255
    14e0:	80 93 82 0d 	sts	0x0D82, r24	; 0x800d82 <uxDeletedTasksWaitingCleanUp>
    14e4:	0e c0       	rjmp	.+28     	; 0x1502 <vTaskDelete+0x82>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
    14e6:	80 91 81 0d 	lds	r24, 0x0D81	; 0x800d81 <uxCurrentNumberOfTasks>
    14ea:	81 50       	subi	r24, 0x01	; 1
    14ec:	80 93 81 0d 	sts	0x0D81, r24	; 0x800d81 <uxCurrentNumberOfTasks>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
    14f0:	8f 89       	ldd	r24, Y+23	; 0x17
    14f2:	98 8d       	ldd	r25, Y+24	; 0x18
    14f4:	0e 94 99 04 	call	0x932	; 0x932 <vPortFree>
			vPortFree( pxTCB );
    14f8:	ce 01       	movw	r24, r28
    14fa:	0e 94 99 04 	call	0x932	; 0x932 <vPortFree>
				--uxCurrentNumberOfTasks;
				prvDeleteTCB( pxTCB );

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
    14fe:	0e 94 d5 08 	call	0x11aa	; 0x11aa <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    1502:	0f 90       	pop	r0
    1504:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    1506:	80 91 7d 0d 	lds	r24, 0x0D7D	; 0x800d7d <xSchedulerRunning>
    150a:	88 23       	and	r24, r24
    150c:	49 f0       	breq	.+18     	; 0x1520 <vTaskDelete+0xa0>
		{
			if( pxTCB == pxCurrentTCB )
    150e:	80 91 72 0d 	lds	r24, 0x0D72	; 0x800d72 <pxCurrentTCB>
    1512:	90 91 73 0d 	lds	r25, 0x0D73	; 0x800d73 <pxCurrentTCB+0x1>
    1516:	c8 17       	cp	r28, r24
    1518:	d9 07       	cpc	r29, r25
    151a:	11 f4       	brne	.+4      	; 0x1520 <vTaskDelete+0xa0>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    151c:	0e 94 ac 03 	call	0x758	; 0x758 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    1520:	df 91       	pop	r29
    1522:	cf 91       	pop	r28
    1524:	1f 91       	pop	r17
    1526:	0f 91       	pop	r16
    1528:	08 95       	ret

0000152a <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    152a:	ef 92       	push	r14
    152c:	ff 92       	push	r15
    152e:	0f 93       	push	r16
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    1530:	0f 2e       	mov	r0, r31
    1532:	f5 e7       	ldi	r31, 0x75	; 117
    1534:	ef 2e       	mov	r14, r31
    1536:	fd e0       	ldi	r31, 0x0D	; 13
    1538:	ff 2e       	mov	r15, r31
    153a:	f0 2d       	mov	r31, r0
    153c:	00 e0       	ldi	r16, 0x00	; 0
    153e:	20 e0       	ldi	r18, 0x00	; 0
    1540:	30 e0       	ldi	r19, 0x00	; 0
    1542:	45 e5       	ldi	r20, 0x55	; 85
    1544:	50 e0       	ldi	r21, 0x00	; 0
    1546:	68 e0       	ldi	r22, 0x08	; 8
    1548:	71 e0       	ldi	r23, 0x01	; 1
    154a:	81 e7       	ldi	r24, 0x71	; 113
    154c:	9c e0       	ldi	r25, 0x0C	; 12
    154e:	0e 94 38 09 	call	0x1270	; 0x1270 <xTaskCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    1552:	81 30       	cpi	r24, 0x01	; 1
    1554:	81 f4       	brne	.+32     	; 0x1576 <vTaskStartScheduler+0x4c>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    1556:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    1558:	8f ef       	ldi	r24, 0xFF	; 255
    155a:	9f ef       	ldi	r25, 0xFF	; 255
    155c:	90 93 78 0d 	sts	0x0D78, r25	; 0x800d78 <xNextTaskUnblockTime+0x1>
    1560:	80 93 77 0d 	sts	0x0D77, r24	; 0x800d77 <xNextTaskUnblockTime>
		xSchedulerRunning = pdTRUE;
    1564:	81 e0       	ldi	r24, 0x01	; 1
    1566:	80 93 7d 0d 	sts	0x0D7D, r24	; 0x800d7d <xSchedulerRunning>
		xTickCount = ( TickType_t ) 0U;
    156a:	10 92 80 0d 	sts	0x0D80, r1	; 0x800d80 <xTickCount+0x1>
    156e:	10 92 7f 0d 	sts	0x0D7F, r1	; 0x800d7f <xTickCount>
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    1572:	0e 94 75 03 	call	0x6ea	; 0x6ea <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    1576:	0f 91       	pop	r16
    1578:	ff 90       	pop	r15
    157a:	ef 90       	pop	r14
    157c:	08 95       	ret

0000157e <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    157e:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    1580:	10 92 7d 0d 	sts	0x0D7D, r1	; 0x800d7d <xSchedulerRunning>
	vPortEndScheduler();
    1584:	0e 94 ab 03 	call	0x756	; 0x756 <vPortEndScheduler>
    1588:	08 95       	ret

0000158a <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    158a:	80 91 74 0d 	lds	r24, 0x0D74	; 0x800d74 <uxSchedulerSuspended>
    158e:	8f 5f       	subi	r24, 0xFF	; 255
    1590:	80 93 74 0d 	sts	0x0D74, r24	; 0x800d74 <uxSchedulerSuspended>
    1594:	08 95       	ret

00001596 <xTaskGetTickCount>:
TickType_t xTaskGetTickCount( void )
{
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    1596:	0f b6       	in	r0, 0x3f	; 63
    1598:	f8 94       	cli
    159a:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    159c:	80 91 7f 0d 	lds	r24, 0x0D7F	; 0x800d7f <xTickCount>
    15a0:	90 91 80 0d 	lds	r25, 0x0D80	; 0x800d80 <xTickCount+0x1>
	}
	portTICK_TYPE_EXIT_CRITICAL();
    15a4:	0f 90       	pop	r0
    15a6:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    15a8:	08 95       	ret

000015aa <xTaskGetTickCountFromISR>:
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
	{
		xReturn = xTickCount;
    15aa:	80 91 7f 0d 	lds	r24, 0x0D7F	; 0x800d7f <xTickCount>
    15ae:	90 91 80 0d 	lds	r25, 0x0D80	; 0x800d80 <xTickCount+0x1>
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    15b2:	08 95       	ret

000015b4 <uxTaskGetNumberOfTasks>:

UBaseType_t uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    15b4:	80 91 81 0d 	lds	r24, 0x0D81	; 0x800d81 <uxCurrentNumberOfTasks>
}
    15b8:	08 95       	ret

000015ba <pcTaskGetName>:
{
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    15ba:	00 97       	sbiw	r24, 0x00	; 0
    15bc:	21 f4       	brne	.+8      	; 0x15c6 <pcTaskGetName+0xc>
    15be:	80 91 72 0d 	lds	r24, 0x0D72	; 0x800d72 <pxCurrentTCB>
    15c2:	90 91 73 0d 	lds	r25, 0x0D73	; 0x800d73 <pxCurrentTCB+0x1>
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
}
    15c6:	49 96       	adiw	r24, 0x19	; 25
    15c8:	08 95       	ret

000015ca <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    15ca:	cf 92       	push	r12
    15cc:	df 92       	push	r13
    15ce:	ef 92       	push	r14
    15d0:	ff 92       	push	r15
    15d2:	0f 93       	push	r16
    15d4:	1f 93       	push	r17
    15d6:	cf 93       	push	r28
    15d8:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    15da:	80 91 74 0d 	lds	r24, 0x0D74	; 0x800d74 <uxSchedulerSuspended>
    15de:	81 11       	cpse	r24, r1
    15e0:	99 c0       	rjmp	.+306    	; 0x1714 <xTaskIncrementTick+0x14a>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + 1;
    15e2:	e0 90 7f 0d 	lds	r14, 0x0D7F	; 0x800d7f <xTickCount>
    15e6:	f0 90 80 0d 	lds	r15, 0x0D80	; 0x800d80 <xTickCount+0x1>
    15ea:	8f ef       	ldi	r24, 0xFF	; 255
    15ec:	e8 1a       	sub	r14, r24
    15ee:	f8 0a       	sbc	r15, r24

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    15f0:	f0 92 80 0d 	sts	0x0D80, r15	; 0x800d80 <xTickCount+0x1>
    15f4:	e0 92 7f 0d 	sts	0x0D7F, r14	; 0x800d7f <xTickCount>

		if( xConstTickCount == ( TickType_t ) 0U )
    15f8:	e1 14       	cp	r14, r1
    15fa:	f1 04       	cpc	r15, r1
    15fc:	b9 f4       	brne	.+46     	; 0x162c <xTaskIncrementTick+0x62>
		{
			taskSWITCH_DELAYED_LISTS();
    15fe:	80 91 97 0d 	lds	r24, 0x0D97	; 0x800d97 <pxDelayedTaskList>
    1602:	90 91 98 0d 	lds	r25, 0x0D98	; 0x800d98 <pxDelayedTaskList+0x1>
    1606:	20 91 95 0d 	lds	r18, 0x0D95	; 0x800d95 <pxOverflowDelayedTaskList>
    160a:	30 91 96 0d 	lds	r19, 0x0D96	; 0x800d96 <pxOverflowDelayedTaskList+0x1>
    160e:	30 93 98 0d 	sts	0x0D98, r19	; 0x800d98 <pxDelayedTaskList+0x1>
    1612:	20 93 97 0d 	sts	0x0D97, r18	; 0x800d97 <pxDelayedTaskList>
    1616:	90 93 96 0d 	sts	0x0D96, r25	; 0x800d96 <pxOverflowDelayedTaskList+0x1>
    161a:	80 93 95 0d 	sts	0x0D95, r24	; 0x800d95 <pxOverflowDelayedTaskList>
    161e:	80 91 7a 0d 	lds	r24, 0x0D7A	; 0x800d7a <xNumOfOverflows>
    1622:	8f 5f       	subi	r24, 0xFF	; 255
    1624:	80 93 7a 0d 	sts	0x0D7A, r24	; 0x800d7a <xNumOfOverflows>
    1628:	0e 94 d5 08 	call	0x11aa	; 0x11aa <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    162c:	80 91 77 0d 	lds	r24, 0x0D77	; 0x800d77 <xNextTaskUnblockTime>
    1630:	90 91 78 0d 	lds	r25, 0x0D78	; 0x800d78 <xNextTaskUnblockTime+0x1>
    1634:	e8 16       	cp	r14, r24
    1636:	f9 06       	cpc	r15, r25
    1638:	10 f4       	brcc	.+4      	; 0x163e <xTaskIncrementTick+0x74>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    163a:	d1 2c       	mov	r13, r1
    163c:	53 c0       	rjmp	.+166    	; 0x16e4 <xTaskIncrementTick+0x11a>
    163e:	d1 2c       	mov	r13, r1
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
						{
							xSwitchRequired = pdTRUE;
    1640:	cc 24       	eor	r12, r12
    1642:	c3 94       	inc	r12
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    1644:	e0 91 97 0d 	lds	r30, 0x0D97	; 0x800d97 <pxDelayedTaskList>
    1648:	f0 91 98 0d 	lds	r31, 0x0D98	; 0x800d98 <pxDelayedTaskList+0x1>
    164c:	80 81       	ld	r24, Z
    164e:	81 11       	cpse	r24, r1
    1650:	07 c0       	rjmp	.+14     	; 0x1660 <xTaskIncrementTick+0x96>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1652:	8f ef       	ldi	r24, 0xFF	; 255
    1654:	9f ef       	ldi	r25, 0xFF	; 255
    1656:	90 93 78 0d 	sts	0x0D78, r25	; 0x800d78 <xNextTaskUnblockTime+0x1>
    165a:	80 93 77 0d 	sts	0x0D77, r24	; 0x800d77 <xNextTaskUnblockTime>
					break;
    165e:	42 c0       	rjmp	.+132    	; 0x16e4 <xTaskIncrementTick+0x11a>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    1660:	e0 91 97 0d 	lds	r30, 0x0D97	; 0x800d97 <pxDelayedTaskList>
    1664:	f0 91 98 0d 	lds	r31, 0x0D98	; 0x800d98 <pxDelayedTaskList+0x1>
    1668:	05 80       	ldd	r0, Z+5	; 0x05
    166a:	f6 81       	ldd	r31, Z+6	; 0x06
    166c:	e0 2d       	mov	r30, r0
    166e:	c6 81       	ldd	r28, Z+6	; 0x06
    1670:	d7 81       	ldd	r29, Z+7	; 0x07
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    1672:	8a 81       	ldd	r24, Y+2	; 0x02
    1674:	9b 81       	ldd	r25, Y+3	; 0x03

					if( xConstTickCount < xItemValue )
    1676:	e8 16       	cp	r14, r24
    1678:	f9 06       	cpc	r15, r25
    167a:	28 f4       	brcc	.+10     	; 0x1686 <xTaskIncrementTick+0xbc>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    167c:	90 93 78 0d 	sts	0x0D78, r25	; 0x800d78 <xNextTaskUnblockTime+0x1>
    1680:	80 93 77 0d 	sts	0x0D77, r24	; 0x800d77 <xNextTaskUnblockTime>
						break;
    1684:	2f c0       	rjmp	.+94     	; 0x16e4 <xTaskIncrementTick+0x11a>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1686:	8e 01       	movw	r16, r28
    1688:	0e 5f       	subi	r16, 0xFE	; 254
    168a:	1f 4f       	sbci	r17, 0xFF	; 255
    168c:	c8 01       	movw	r24, r16
    168e:	0e 94 e3 02 	call	0x5c6	; 0x5c6 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    1692:	8c 89       	ldd	r24, Y+20	; 0x14
    1694:	9d 89       	ldd	r25, Y+21	; 0x15
    1696:	89 2b       	or	r24, r25
    1698:	21 f0       	breq	.+8      	; 0x16a2 <xTaskIncrementTick+0xd8>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    169a:	ce 01       	movw	r24, r28
    169c:	0c 96       	adiw	r24, 0x0c	; 12
    169e:	0e 94 e3 02 	call	0x5c6	; 0x5c6 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    16a2:	8e 89       	ldd	r24, Y+22	; 0x16
    16a4:	90 91 7e 0d 	lds	r25, 0x0D7E	; 0x800d7e <uxTopReadyPriority>
    16a8:	98 17       	cp	r25, r24
    16aa:	10 f4       	brcc	.+4      	; 0x16b0 <xTaskIncrementTick+0xe6>
    16ac:	80 93 7e 0d 	sts	0x0D7E, r24	; 0x800d7e <uxTopReadyPriority>
    16b0:	90 e0       	ldi	r25, 0x00	; 0
    16b2:	9c 01       	movw	r18, r24
    16b4:	22 0f       	add	r18, r18
    16b6:	33 1f       	adc	r19, r19
    16b8:	22 0f       	add	r18, r18
    16ba:	33 1f       	adc	r19, r19
    16bc:	22 0f       	add	r18, r18
    16be:	33 1f       	adc	r19, r19
    16c0:	82 0f       	add	r24, r18
    16c2:	93 1f       	adc	r25, r19
    16c4:	b8 01       	movw	r22, r16
    16c6:	85 55       	subi	r24, 0x55	; 85
    16c8:	92 4f       	sbci	r25, 0xF2	; 242
    16ca:	0e 94 91 02 	call	0x522	; 0x522 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    16ce:	e0 91 72 0d 	lds	r30, 0x0D72	; 0x800d72 <pxCurrentTCB>
    16d2:	f0 91 73 0d 	lds	r31, 0x0D73	; 0x800d73 <pxCurrentTCB+0x1>
    16d6:	9e 89       	ldd	r25, Y+22	; 0x16
    16d8:	86 89       	ldd	r24, Z+22	; 0x16
    16da:	98 17       	cp	r25, r24
    16dc:	08 f4       	brcc	.+2      	; 0x16e0 <xTaskIncrementTick+0x116>
    16de:	b2 cf       	rjmp	.-156    	; 0x1644 <xTaskIncrementTick+0x7a>
						{
							xSwitchRequired = pdTRUE;
    16e0:	dc 2c       	mov	r13, r12
    16e2:	b0 cf       	rjmp	.-160    	; 0x1644 <xTaskIncrementTick+0x7a>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    16e4:	e0 91 72 0d 	lds	r30, 0x0D72	; 0x800d72 <pxCurrentTCB>
    16e8:	f0 91 73 0d 	lds	r31, 0x0D73	; 0x800d73 <pxCurrentTCB+0x1>
    16ec:	86 89       	ldd	r24, Z+22	; 0x16
    16ee:	90 e0       	ldi	r25, 0x00	; 0
    16f0:	fc 01       	movw	r30, r24
    16f2:	ee 0f       	add	r30, r30
    16f4:	ff 1f       	adc	r31, r31
    16f6:	ee 0f       	add	r30, r30
    16f8:	ff 1f       	adc	r31, r31
    16fa:	ee 0f       	add	r30, r30
    16fc:	ff 1f       	adc	r31, r31
    16fe:	8e 0f       	add	r24, r30
    1700:	9f 1f       	adc	r25, r31
    1702:	fc 01       	movw	r30, r24
    1704:	e5 55       	subi	r30, 0x55	; 85
    1706:	f2 4f       	sbci	r31, 0xF2	; 242
    1708:	80 81       	ld	r24, Z
    170a:	82 30       	cpi	r24, 0x02	; 2
    170c:	48 f0       	brcs	.+18     	; 0x1720 <xTaskIncrementTick+0x156>
			{
				xSwitchRequired = pdTRUE;
    170e:	dd 24       	eor	r13, r13
    1710:	d3 94       	inc	r13
    1712:	06 c0       	rjmp	.+12     	; 0x1720 <xTaskIncrementTick+0x156>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    1714:	80 91 7c 0d 	lds	r24, 0x0D7C	; 0x800d7c <uxPendedTicks>
    1718:	8f 5f       	subi	r24, 0xFF	; 255
    171a:	80 93 7c 0d 	sts	0x0D7C, r24	; 0x800d7c <uxPendedTicks>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    171e:	d1 2c       	mov	r13, r1
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    1720:	80 91 7b 0d 	lds	r24, 0x0D7B	; 0x800d7b <xYieldPending>
    1724:	88 23       	and	r24, r24
    1726:	11 f0       	breq	.+4      	; 0x172c <xTaskIncrementTick+0x162>
		{
			xSwitchRequired = pdTRUE;
    1728:	dd 24       	eor	r13, r13
    172a:	d3 94       	inc	r13
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
    172c:	8d 2d       	mov	r24, r13
    172e:	df 91       	pop	r29
    1730:	cf 91       	pop	r28
    1732:	1f 91       	pop	r17
    1734:	0f 91       	pop	r16
    1736:	ff 90       	pop	r15
    1738:	ef 90       	pop	r14
    173a:	df 90       	pop	r13
    173c:	cf 90       	pop	r12
    173e:	08 95       	ret

00001740 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    1740:	df 92       	push	r13
    1742:	ef 92       	push	r14
    1744:	ff 92       	push	r15
    1746:	0f 93       	push	r16
    1748:	1f 93       	push	r17
    174a:	cf 93       	push	r28
    174c:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    174e:	0f b6       	in	r0, 0x3f	; 63
    1750:	f8 94       	cli
    1752:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    1754:	80 91 74 0d 	lds	r24, 0x0D74	; 0x800d74 <uxSchedulerSuspended>
    1758:	81 50       	subi	r24, 0x01	; 1
    175a:	80 93 74 0d 	sts	0x0D74, r24	; 0x800d74 <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    175e:	80 91 74 0d 	lds	r24, 0x0D74	; 0x800d74 <uxSchedulerSuspended>
    1762:	81 11       	cpse	r24, r1
    1764:	5f c0       	rjmp	.+190    	; 0x1824 <xTaskResumeAll+0xe4>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    1766:	80 91 81 0d 	lds	r24, 0x0D81	; 0x800d81 <uxCurrentNumberOfTasks>
    176a:	81 11       	cpse	r24, r1
    176c:	33 c0       	rjmp	.+102    	; 0x17d4 <xTaskResumeAll+0x94>
    176e:	5d c0       	rjmp	.+186    	; 0x182a <xTaskResumeAll+0xea>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    1770:	d7 01       	movw	r26, r14
    1772:	15 96       	adiw	r26, 0x05	; 5
    1774:	ed 91       	ld	r30, X+
    1776:	fc 91       	ld	r31, X
    1778:	16 97       	sbiw	r26, 0x06	; 6
    177a:	c6 81       	ldd	r28, Z+6	; 0x06
    177c:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    177e:	ce 01       	movw	r24, r28
    1780:	0c 96       	adiw	r24, 0x0c	; 12
    1782:	0e 94 e3 02 	call	0x5c6	; 0x5c6 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1786:	8e 01       	movw	r16, r28
    1788:	0e 5f       	subi	r16, 0xFE	; 254
    178a:	1f 4f       	sbci	r17, 0xFF	; 255
    178c:	c8 01       	movw	r24, r16
    178e:	0e 94 e3 02 	call	0x5c6	; 0x5c6 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    1792:	8e 89       	ldd	r24, Y+22	; 0x16
    1794:	90 91 7e 0d 	lds	r25, 0x0D7E	; 0x800d7e <uxTopReadyPriority>
    1798:	98 17       	cp	r25, r24
    179a:	10 f4       	brcc	.+4      	; 0x17a0 <xTaskResumeAll+0x60>
    179c:	80 93 7e 0d 	sts	0x0D7E, r24	; 0x800d7e <uxTopReadyPriority>
    17a0:	90 e0       	ldi	r25, 0x00	; 0
    17a2:	9c 01       	movw	r18, r24
    17a4:	22 0f       	add	r18, r18
    17a6:	33 1f       	adc	r19, r19
    17a8:	22 0f       	add	r18, r18
    17aa:	33 1f       	adc	r19, r19
    17ac:	22 0f       	add	r18, r18
    17ae:	33 1f       	adc	r19, r19
    17b0:	82 0f       	add	r24, r18
    17b2:	93 1f       	adc	r25, r19
    17b4:	b8 01       	movw	r22, r16
    17b6:	85 55       	subi	r24, 0x55	; 85
    17b8:	92 4f       	sbci	r25, 0xF2	; 242
    17ba:	0e 94 91 02 	call	0x522	; 0x522 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    17be:	e0 91 72 0d 	lds	r30, 0x0D72	; 0x800d72 <pxCurrentTCB>
    17c2:	f0 91 73 0d 	lds	r31, 0x0D73	; 0x800d73 <pxCurrentTCB+0x1>
    17c6:	9e 89       	ldd	r25, Y+22	; 0x16
    17c8:	86 89       	ldd	r24, Z+22	; 0x16
    17ca:	98 17       	cp	r25, r24
    17cc:	68 f0       	brcs	.+26     	; 0x17e8 <xTaskResumeAll+0xa8>
					{
						xYieldPending = pdTRUE;
    17ce:	d0 92 7b 0d 	sts	0x0D7B, r13	; 0x800d7b <xYieldPending>
    17d2:	0a c0       	rjmp	.+20     	; 0x17e8 <xTaskResumeAll+0xa8>
    17d4:	c0 e0       	ldi	r28, 0x00	; 0
    17d6:	d0 e0       	ldi	r29, 0x00	; 0
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    17d8:	0f 2e       	mov	r0, r31
    17da:	fc e8       	ldi	r31, 0x8C	; 140
    17dc:	ef 2e       	mov	r14, r31
    17de:	fd e0       	ldi	r31, 0x0D	; 13
    17e0:	ff 2e       	mov	r15, r31
    17e2:	f0 2d       	mov	r31, r0

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
    17e4:	dd 24       	eor	r13, r13
    17e6:	d3 94       	inc	r13
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    17e8:	f7 01       	movw	r30, r14
    17ea:	80 81       	ld	r24, Z
    17ec:	81 11       	cpse	r24, r1
    17ee:	c0 cf       	rjmp	.-128    	; 0x1770 <xTaskResumeAll+0x30>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    17f0:	cd 2b       	or	r28, r29
    17f2:	11 f0       	breq	.+4      	; 0x17f8 <xTaskResumeAll+0xb8>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    17f4:	0e 94 d5 08 	call	0x11aa	; 0x11aa <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    17f8:	c0 91 7c 0d 	lds	r28, 0x0D7C	; 0x800d7c <uxPendedTicks>

					if( uxPendedCounts > ( UBaseType_t ) 0U )
    17fc:	cc 23       	and	r28, r28
    17fe:	51 f0       	breq	.+20     	; 0x1814 <xTaskResumeAll+0xd4>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
							{
								xYieldPending = pdTRUE;
    1800:	d1 e0       	ldi	r29, 0x01	; 1

					if( uxPendedCounts > ( UBaseType_t ) 0U )
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    1802:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <xTaskIncrementTick>
    1806:	81 11       	cpse	r24, r1
							{
								xYieldPending = pdTRUE;
    1808:	d0 93 7b 0d 	sts	0x0D7B, r29	; 0x800d7b <xYieldPending>
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
    180c:	c1 50       	subi	r28, 0x01	; 1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    180e:	c9 f7       	brne	.-14     	; 0x1802 <xTaskResumeAll+0xc2>

						uxPendedTicks = 0;
    1810:	10 92 7c 0d 	sts	0x0D7C, r1	; 0x800d7c <uxPendedTicks>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    1814:	80 91 7b 0d 	lds	r24, 0x0D7B	; 0x800d7b <xYieldPending>
    1818:	88 23       	and	r24, r24
    181a:	31 f0       	breq	.+12     	; 0x1828 <xTaskResumeAll+0xe8>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    181c:	0e 94 ac 03 	call	0x758	; 0x758 <vPortYield>

				if( xYieldPending != pdFALSE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    1820:	81 e0       	ldi	r24, 0x01	; 1
    1822:	03 c0       	rjmp	.+6      	; 0x182a <xTaskResumeAll+0xea>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB = NULL;
BaseType_t xAlreadyYielded = pdFALSE;
    1824:	80 e0       	ldi	r24, 0x00	; 0
    1826:	01 c0       	rjmp	.+2      	; 0x182a <xTaskResumeAll+0xea>
    1828:	80 e0       	ldi	r24, 0x00	; 0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    182a:	0f 90       	pop	r0
    182c:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    182e:	df 91       	pop	r29
    1830:	cf 91       	pop	r28
    1832:	1f 91       	pop	r17
    1834:	0f 91       	pop	r16
    1836:	ff 90       	pop	r15
    1838:	ef 90       	pop	r14
    183a:	df 90       	pop	r13
    183c:	08 95       	ret

0000183e <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    183e:	0f 93       	push	r16
    1840:	1f 93       	push	r17
    1842:	cf 93       	push	r28
    1844:	df 93       	push	r29
    1846:	8c 01       	movw	r16, r24
    1848:	eb 01       	movw	r28, r22

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    184a:	0e 94 c5 0a 	call	0x158a	; 0x158a <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    184e:	40 91 7f 0d 	lds	r20, 0x0D7F	; 0x800d7f <xTickCount>
    1852:	50 91 80 0d 	lds	r21, 0x0D80	; 0x800d80 <xTickCount+0x1>

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    1856:	f8 01       	movw	r30, r16
    1858:	20 81       	ld	r18, Z
    185a:	31 81       	ldd	r19, Z+1	; 0x01
    185c:	c9 01       	movw	r24, r18
    185e:	8c 0f       	add	r24, r28
    1860:	9d 1f       	adc	r25, r29

			if( xConstTickCount < *pxPreviousWakeTime )
    1862:	42 17       	cp	r20, r18
    1864:	53 07       	cpc	r21, r19
    1866:	48 f4       	brcc	.+18     	; 0x187a <vTaskDelayUntil+0x3c>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    1868:	82 17       	cp	r24, r18
    186a:	93 07       	cpc	r25, r19
    186c:	e8 f4       	brcc	.+58     	; 0x18a8 <vTaskDelayUntil+0x6a>
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    186e:	91 83       	std	Z+1, r25	; 0x01
    1870:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    1872:	48 17       	cp	r20, r24
    1874:	59 07       	cpc	r21, r25
    1876:	68 f4       	brcc	.+26     	; 0x1892 <vTaskDelayUntil+0x54>
    1878:	07 c0       	rjmp	.+14     	; 0x1888 <vTaskDelayUntil+0x4a>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    187a:	82 17       	cp	r24, r18
    187c:	93 07       	cpc	r25, r19
    187e:	80 f0       	brcs	.+32     	; 0x18a0 <vTaskDelayUntil+0x62>
    1880:	48 17       	cp	r20, r24
    1882:	59 07       	cpc	r21, r25
    1884:	68 f0       	brcs	.+26     	; 0x18a0 <vTaskDelayUntil+0x62>
    1886:	10 c0       	rjmp	.+32     	; 0x18a8 <vTaskDelayUntil+0x6a>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    1888:	60 e0       	ldi	r22, 0x00	; 0
    188a:	84 1b       	sub	r24, r20
    188c:	95 0b       	sbc	r25, r21
    188e:	0e 94 f4 08 	call	0x11e8	; 0x11e8 <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    1892:	0e 94 a0 0b 	call	0x1740	; 0x1740 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1896:	81 11       	cpse	r24, r1
    1898:	0b c0       	rjmp	.+22     	; 0x18b0 <vTaskDelayUntil+0x72>
		{
			portYIELD_WITHIN_API();
    189a:	0e 94 ac 03 	call	0x758	; 0x758 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    189e:	08 c0       	rjmp	.+16     	; 0x18b0 <vTaskDelayUntil+0x72>
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    18a0:	f8 01       	movw	r30, r16
    18a2:	91 83       	std	Z+1, r25	; 0x01
    18a4:	80 83       	st	Z, r24
    18a6:	f0 cf       	rjmp	.-32     	; 0x1888 <vTaskDelayUntil+0x4a>
    18a8:	f8 01       	movw	r30, r16
    18aa:	91 83       	std	Z+1, r25	; 0x01
    18ac:	80 83       	st	Z, r24
    18ae:	f1 cf       	rjmp	.-30     	; 0x1892 <vTaskDelayUntil+0x54>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    18b0:	df 91       	pop	r29
    18b2:	cf 91       	pop	r28
    18b4:	1f 91       	pop	r17
    18b6:	0f 91       	pop	r16
    18b8:	08 95       	ret

000018ba <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    18ba:	cf 93       	push	r28
    18bc:	df 93       	push	r29
    18be:	ec 01       	movw	r28, r24
	BaseType_t xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    18c0:	89 2b       	or	r24, r25
    18c2:	51 f0       	breq	.+20     	; 0x18d8 <vTaskDelay+0x1e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    18c4:	0e 94 c5 0a 	call	0x158a	; 0x158a <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    18c8:	60 e0       	ldi	r22, 0x00	; 0
    18ca:	ce 01       	movw	r24, r28
    18cc:	0e 94 f4 08 	call	0x11e8	; 0x11e8 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    18d0:	0e 94 a0 0b 	call	0x1740	; 0x1740 <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    18d4:	81 11       	cpse	r24, r1
    18d6:	02 c0       	rjmp	.+4      	; 0x18dc <vTaskDelay+0x22>
		{
			portYIELD_WITHIN_API();
    18d8:	0e 94 ac 03 	call	0x758	; 0x758 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    18dc:	df 91       	pop	r29
    18de:	cf 91       	pop	r28
    18e0:	08 95       	ret

000018e2 <prvIdleTask>:
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    18e2:	03 e8       	ldi	r16, 0x83	; 131
    18e4:	1d e0       	ldi	r17, 0x0D	; 13

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    18e6:	0f 2e       	mov	r0, r31
    18e8:	fb ea       	ldi	r31, 0xAB	; 171
    18ea:	ef 2e       	mov	r14, r31
    18ec:	fd e0       	ldi	r31, 0x0D	; 13
    18ee:	ff 2e       	mov	r15, r31
    18f0:	f0 2d       	mov	r31, r0
    18f2:	29 c0       	rjmp	.+82     	; 0x1946 <prvIdleTask+0x64>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
    18f4:	0e 94 c5 0a 	call	0x158a	; 0x158a <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    18f8:	d8 01       	movw	r26, r16
    18fa:	cc 91       	ld	r28, X
			}
			( void ) xTaskResumeAll();
    18fc:	0e 94 a0 0b 	call	0x1740	; 0x1740 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    1900:	cc 23       	and	r28, r28
    1902:	09 f1       	breq	.+66     	; 0x1946 <prvIdleTask+0x64>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
    1904:	0f b6       	in	r0, 0x3f	; 63
    1906:	f8 94       	cli
    1908:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    190a:	d8 01       	movw	r26, r16
    190c:	15 96       	adiw	r26, 0x05	; 5
    190e:	ed 91       	ld	r30, X+
    1910:	fc 91       	ld	r31, X
    1912:	16 97       	sbiw	r26, 0x06	; 6
    1914:	c6 81       	ldd	r28, Z+6	; 0x06
    1916:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1918:	ce 01       	movw	r24, r28
    191a:	02 96       	adiw	r24, 0x02	; 2
    191c:	0e 94 e3 02 	call	0x5c6	; 0x5c6 <uxListRemove>
					--uxCurrentNumberOfTasks;
    1920:	80 91 81 0d 	lds	r24, 0x0D81	; 0x800d81 <uxCurrentNumberOfTasks>
    1924:	81 50       	subi	r24, 0x01	; 1
    1926:	80 93 81 0d 	sts	0x0D81, r24	; 0x800d81 <uxCurrentNumberOfTasks>
					--uxDeletedTasksWaitingCleanUp;
    192a:	80 91 82 0d 	lds	r24, 0x0D82	; 0x800d82 <uxDeletedTasksWaitingCleanUp>
    192e:	81 50       	subi	r24, 0x01	; 1
    1930:	80 93 82 0d 	sts	0x0D82, r24	; 0x800d82 <uxDeletedTasksWaitingCleanUp>
				}
				taskEXIT_CRITICAL();
    1934:	0f 90       	pop	r0
    1936:	0f be       	out	0x3f, r0	; 63

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
    1938:	8f 89       	ldd	r24, Y+23	; 0x17
    193a:	98 8d       	ldd	r25, Y+24	; 0x18
    193c:	0e 94 99 04 	call	0x932	; 0x932 <vPortFree>
			vPortFree( pxTCB );
    1940:	ce 01       	movw	r24, r28
    1942:	0e 94 99 04 	call	0x932	; 0x932 <vPortFree>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    1946:	80 91 82 0d 	lds	r24, 0x0D82	; 0x800d82 <uxDeletedTasksWaitingCleanUp>
    194a:	81 11       	cpse	r24, r1
    194c:	d3 cf       	rjmp	.-90     	; 0x18f4 <prvIdleTask+0x12>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    194e:	f7 01       	movw	r30, r14
    1950:	80 81       	ld	r24, Z
    1952:	82 30       	cpi	r24, 0x02	; 2
    1954:	10 f0       	brcs	.+4      	; 0x195a <prvIdleTask+0x78>
			{
				taskYIELD();
    1956:	0e 94 ac 03 	call	0x758	; 0x758 <vPortYield>
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
    195a:	0e 94 5b 11 	call	0x22b6	; 0x22b6 <vApplicationIdleHook>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
    195e:	f3 cf       	rjmp	.-26     	; 0x1946 <prvIdleTask+0x64>

00001960 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    1960:	80 91 74 0d 	lds	r24, 0x0D74	; 0x800d74 <uxSchedulerSuspended>
    1964:	88 23       	and	r24, r24
    1966:	21 f0       	breq	.+8      	; 0x1970 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    1968:	81 e0       	ldi	r24, 0x01	; 1
    196a:	80 93 7b 0d 	sts	0x0D7B, r24	; 0x800d7b <xYieldPending>
    196e:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
    1970:	10 92 7b 0d 	sts	0x0D7B, r1	; 0x800d7b <xYieldPending>
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    1974:	20 91 7e 0d 	lds	r18, 0x0D7E	; 0x800d7e <uxTopReadyPriority>
    1978:	82 2f       	mov	r24, r18
    197a:	90 e0       	ldi	r25, 0x00	; 0
    197c:	fc 01       	movw	r30, r24
    197e:	ee 0f       	add	r30, r30
    1980:	ff 1f       	adc	r31, r31
    1982:	ee 0f       	add	r30, r30
    1984:	ff 1f       	adc	r31, r31
    1986:	ee 0f       	add	r30, r30
    1988:	ff 1f       	adc	r31, r31
    198a:	e8 0f       	add	r30, r24
    198c:	f9 1f       	adc	r31, r25
    198e:	e5 55       	subi	r30, 0x55	; 85
    1990:	f2 4f       	sbci	r31, 0xF2	; 242
    1992:	30 81       	ld	r19, Z
    1994:	31 11       	cpse	r19, r1
    1996:	11 c0       	rjmp	.+34     	; 0x19ba <vTaskSwitchContext+0x5a>
    1998:	21 50       	subi	r18, 0x01	; 1
    199a:	82 2f       	mov	r24, r18
    199c:	90 e0       	ldi	r25, 0x00	; 0
    199e:	fc 01       	movw	r30, r24
    19a0:	ee 0f       	add	r30, r30
    19a2:	ff 1f       	adc	r31, r31
    19a4:	ee 0f       	add	r30, r30
    19a6:	ff 1f       	adc	r31, r31
    19a8:	ee 0f       	add	r30, r30
    19aa:	ff 1f       	adc	r31, r31
    19ac:	e8 0f       	add	r30, r24
    19ae:	f9 1f       	adc	r31, r25
    19b0:	e5 55       	subi	r30, 0x55	; 85
    19b2:	f2 4f       	sbci	r31, 0xF2	; 242
    19b4:	30 81       	ld	r19, Z
    19b6:	33 23       	and	r19, r19
    19b8:	79 f3       	breq	.-34     	; 0x1998 <vTaskSwitchContext+0x38>
    19ba:	ac 01       	movw	r20, r24
    19bc:	44 0f       	add	r20, r20
    19be:	55 1f       	adc	r21, r21
    19c0:	44 0f       	add	r20, r20
    19c2:	55 1f       	adc	r21, r21
    19c4:	44 0f       	add	r20, r20
    19c6:	55 1f       	adc	r21, r21
    19c8:	48 0f       	add	r20, r24
    19ca:	59 1f       	adc	r21, r25
    19cc:	da 01       	movw	r26, r20
    19ce:	a5 55       	subi	r26, 0x55	; 85
    19d0:	b2 4f       	sbci	r27, 0xF2	; 242
    19d2:	11 96       	adiw	r26, 0x01	; 1
    19d4:	ed 91       	ld	r30, X+
    19d6:	fc 91       	ld	r31, X
    19d8:	12 97       	sbiw	r26, 0x02	; 2
    19da:	02 80       	ldd	r0, Z+2	; 0x02
    19dc:	f3 81       	ldd	r31, Z+3	; 0x03
    19de:	e0 2d       	mov	r30, r0
    19e0:	12 96       	adiw	r26, 0x02	; 2
    19e2:	fc 93       	st	X, r31
    19e4:	ee 93       	st	-X, r30
    19e6:	11 97       	sbiw	r26, 0x01	; 1
    19e8:	42 55       	subi	r20, 0x52	; 82
    19ea:	52 4f       	sbci	r21, 0xF2	; 242
    19ec:	e4 17       	cp	r30, r20
    19ee:	f5 07       	cpc	r31, r21
    19f0:	29 f4       	brne	.+10     	; 0x19fc <vTaskSwitchContext+0x9c>
    19f2:	42 81       	ldd	r20, Z+2	; 0x02
    19f4:	53 81       	ldd	r21, Z+3	; 0x03
    19f6:	fd 01       	movw	r30, r26
    19f8:	52 83       	std	Z+2, r21	; 0x02
    19fa:	41 83       	std	Z+1, r20	; 0x01
    19fc:	fc 01       	movw	r30, r24
    19fe:	ee 0f       	add	r30, r30
    1a00:	ff 1f       	adc	r31, r31
    1a02:	ee 0f       	add	r30, r30
    1a04:	ff 1f       	adc	r31, r31
    1a06:	ee 0f       	add	r30, r30
    1a08:	ff 1f       	adc	r31, r31
    1a0a:	8e 0f       	add	r24, r30
    1a0c:	9f 1f       	adc	r25, r31
    1a0e:	fc 01       	movw	r30, r24
    1a10:	e5 55       	subi	r30, 0x55	; 85
    1a12:	f2 4f       	sbci	r31, 0xF2	; 242
    1a14:	01 80       	ldd	r0, Z+1	; 0x01
    1a16:	f2 81       	ldd	r31, Z+2	; 0x02
    1a18:	e0 2d       	mov	r30, r0
    1a1a:	86 81       	ldd	r24, Z+6	; 0x06
    1a1c:	97 81       	ldd	r25, Z+7	; 0x07
    1a1e:	90 93 73 0d 	sts	0x0D73, r25	; 0x800d73 <pxCurrentTCB+0x1>
    1a22:	80 93 72 0d 	sts	0x0D72, r24	; 0x800d72 <pxCurrentTCB>
    1a26:	20 93 7e 0d 	sts	0x0D7E, r18	; 0x800d7e <uxTopReadyPriority>
    1a2a:	08 95       	ret

00001a2c <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    1a2c:	cf 93       	push	r28
    1a2e:	df 93       	push	r29
    1a30:	eb 01       	movw	r28, r22

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    1a32:	60 91 72 0d 	lds	r22, 0x0D72	; 0x800d72 <pxCurrentTCB>
    1a36:	70 91 73 0d 	lds	r23, 0x0D73	; 0x800d73 <pxCurrentTCB+0x1>
    1a3a:	64 5f       	subi	r22, 0xF4	; 244
    1a3c:	7f 4f       	sbci	r23, 0xFF	; 255
    1a3e:	0e 94 b2 02 	call	0x564	; 0x564 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    1a42:	61 e0       	ldi	r22, 0x01	; 1
    1a44:	ce 01       	movw	r24, r28
    1a46:	0e 94 f4 08 	call	0x11e8	; 0x11e8 <prvAddCurrentTaskToDelayedList>
}
    1a4a:	df 91       	pop	r29
    1a4c:	cf 91       	pop	r28
    1a4e:	08 95       	ret

00001a50 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    1a50:	cf 93       	push	r28
    1a52:	df 93       	push	r29
    1a54:	ea 01       	movw	r28, r20
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    1a56:	e0 91 72 0d 	lds	r30, 0x0D72	; 0x800d72 <pxCurrentTCB>
    1a5a:	f0 91 73 0d 	lds	r31, 0x0D73	; 0x800d73 <pxCurrentTCB+0x1>
    1a5e:	70 68       	ori	r23, 0x80	; 128
    1a60:	75 87       	std	Z+13, r23	; 0x0d
    1a62:	64 87       	std	Z+12, r22	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    1a64:	60 91 72 0d 	lds	r22, 0x0D72	; 0x800d72 <pxCurrentTCB>
    1a68:	70 91 73 0d 	lds	r23, 0x0D73	; 0x800d73 <pxCurrentTCB+0x1>
    1a6c:	64 5f       	subi	r22, 0xF4	; 244
    1a6e:	7f 4f       	sbci	r23, 0xFF	; 255
    1a70:	0e 94 91 02 	call	0x522	; 0x522 <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    1a74:	61 e0       	ldi	r22, 0x01	; 1
    1a76:	ce 01       	movw	r24, r28
    1a78:	0e 94 f4 08 	call	0x11e8	; 0x11e8 <prvAddCurrentTaskToDelayedList>
}
    1a7c:	df 91       	pop	r29
    1a7e:	cf 91       	pop	r28
    1a80:	08 95       	ret

00001a82 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    1a82:	0f 93       	push	r16
    1a84:	1f 93       	push	r17
    1a86:	cf 93       	push	r28
    1a88:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1a8a:	dc 01       	movw	r26, r24
    1a8c:	15 96       	adiw	r26, 0x05	; 5
    1a8e:	ed 91       	ld	r30, X+
    1a90:	fc 91       	ld	r31, X
    1a92:	16 97       	sbiw	r26, 0x06	; 6
    1a94:	c6 81       	ldd	r28, Z+6	; 0x06
    1a96:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    1a98:	8e 01       	movw	r16, r28
    1a9a:	04 5f       	subi	r16, 0xF4	; 244
    1a9c:	1f 4f       	sbci	r17, 0xFF	; 255
    1a9e:	c8 01       	movw	r24, r16
    1aa0:	0e 94 e3 02 	call	0x5c6	; 0x5c6 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1aa4:	80 91 74 0d 	lds	r24, 0x0D74	; 0x800d74 <uxSchedulerSuspended>
    1aa8:	81 11       	cpse	r24, r1
    1aaa:	1c c0       	rjmp	.+56     	; 0x1ae4 <xTaskRemoveFromEventList+0x62>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    1aac:	0a 50       	subi	r16, 0x0A	; 10
    1aae:	11 09       	sbc	r17, r1
    1ab0:	c8 01       	movw	r24, r16
    1ab2:	0e 94 e3 02 	call	0x5c6	; 0x5c6 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    1ab6:	8e 89       	ldd	r24, Y+22	; 0x16
    1ab8:	90 91 7e 0d 	lds	r25, 0x0D7E	; 0x800d7e <uxTopReadyPriority>
    1abc:	98 17       	cp	r25, r24
    1abe:	10 f4       	brcc	.+4      	; 0x1ac4 <xTaskRemoveFromEventList+0x42>
    1ac0:	80 93 7e 0d 	sts	0x0D7E, r24	; 0x800d7e <uxTopReadyPriority>
    1ac4:	90 e0       	ldi	r25, 0x00	; 0
    1ac6:	9c 01       	movw	r18, r24
    1ac8:	22 0f       	add	r18, r18
    1aca:	33 1f       	adc	r19, r19
    1acc:	22 0f       	add	r18, r18
    1ace:	33 1f       	adc	r19, r19
    1ad0:	22 0f       	add	r18, r18
    1ad2:	33 1f       	adc	r19, r19
    1ad4:	82 0f       	add	r24, r18
    1ad6:	93 1f       	adc	r25, r19
    1ad8:	b8 01       	movw	r22, r16
    1ada:	85 55       	subi	r24, 0x55	; 85
    1adc:	92 4f       	sbci	r25, 0xF2	; 242
    1ade:	0e 94 91 02 	call	0x522	; 0x522 <vListInsertEnd>
    1ae2:	05 c0       	rjmp	.+10     	; 0x1aee <xTaskRemoveFromEventList+0x6c>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    1ae4:	b8 01       	movw	r22, r16
    1ae6:	8c e8       	ldi	r24, 0x8C	; 140
    1ae8:	9d e0       	ldi	r25, 0x0D	; 13
    1aea:	0e 94 91 02 	call	0x522	; 0x522 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    1aee:	e0 91 72 0d 	lds	r30, 0x0D72	; 0x800d72 <pxCurrentTCB>
    1af2:	f0 91 73 0d 	lds	r31, 0x0D73	; 0x800d73 <pxCurrentTCB+0x1>
    1af6:	9e 89       	ldd	r25, Y+22	; 0x16
    1af8:	86 89       	ldd	r24, Z+22	; 0x16
    1afa:	89 17       	cp	r24, r25
    1afc:	20 f4       	brcc	.+8      	; 0x1b06 <xTaskRemoveFromEventList+0x84>
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    1afe:	81 e0       	ldi	r24, 0x01	; 1
    1b00:	80 93 7b 0d 	sts	0x0D7B, r24	; 0x800d7b <xYieldPending>
    1b04:	01 c0       	rjmp	.+2      	; 0x1b08 <xTaskRemoveFromEventList+0x86>
	}
	else
	{
		xReturn = pdFALSE;
    1b06:	80 e0       	ldi	r24, 0x00	; 0
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
}
    1b08:	df 91       	pop	r29
    1b0a:	cf 91       	pop	r28
    1b0c:	1f 91       	pop	r17
    1b0e:	0f 91       	pop	r16
    1b10:	08 95       	ret

00001b12 <xTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    1b12:	0f 93       	push	r16
    1b14:	1f 93       	push	r17
    1b16:	cf 93       	push	r28
    1b18:	df 93       	push	r29
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    1b1a:	70 68       	ori	r23, 0x80	; 128
    1b1c:	fc 01       	movw	r30, r24
    1b1e:	71 83       	std	Z+1, r23	; 0x01
    1b20:	60 83       	st	Z, r22

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
    1b22:	c6 81       	ldd	r28, Z+6	; 0x06
    1b24:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    1b26:	0e 94 e3 02 	call	0x5c6	; 0x5c6 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    1b2a:	8e 01       	movw	r16, r28
    1b2c:	0e 5f       	subi	r16, 0xFE	; 254
    1b2e:	1f 4f       	sbci	r17, 0xFF	; 255
    1b30:	c8 01       	movw	r24, r16
    1b32:	0e 94 e3 02 	call	0x5c6	; 0x5c6 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    1b36:	8e 89       	ldd	r24, Y+22	; 0x16
    1b38:	90 91 7e 0d 	lds	r25, 0x0D7E	; 0x800d7e <uxTopReadyPriority>
    1b3c:	98 17       	cp	r25, r24
    1b3e:	10 f4       	brcc	.+4      	; 0x1b44 <xTaskRemoveFromUnorderedEventList+0x32>
    1b40:	80 93 7e 0d 	sts	0x0D7E, r24	; 0x800d7e <uxTopReadyPriority>
    1b44:	90 e0       	ldi	r25, 0x00	; 0
    1b46:	9c 01       	movw	r18, r24
    1b48:	22 0f       	add	r18, r18
    1b4a:	33 1f       	adc	r19, r19
    1b4c:	22 0f       	add	r18, r18
    1b4e:	33 1f       	adc	r19, r19
    1b50:	22 0f       	add	r18, r18
    1b52:	33 1f       	adc	r19, r19
    1b54:	82 0f       	add	r24, r18
    1b56:	93 1f       	adc	r25, r19
    1b58:	b8 01       	movw	r22, r16
    1b5a:	85 55       	subi	r24, 0x55	; 85
    1b5c:	92 4f       	sbci	r25, 0xF2	; 242
    1b5e:	0e 94 91 02 	call	0x522	; 0x522 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    1b62:	e0 91 72 0d 	lds	r30, 0x0D72	; 0x800d72 <pxCurrentTCB>
    1b66:	f0 91 73 0d 	lds	r31, 0x0D73	; 0x800d73 <pxCurrentTCB+0x1>
    1b6a:	9e 89       	ldd	r25, Y+22	; 0x16
    1b6c:	86 89       	ldd	r24, Z+22	; 0x16
    1b6e:	89 17       	cp	r24, r25
    1b70:	20 f4       	brcc	.+8      	; 0x1b7a <xTaskRemoveFromUnorderedEventList+0x68>
		switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    1b72:	81 e0       	ldi	r24, 0x01	; 1
    1b74:	80 93 7b 0d 	sts	0x0D7B, r24	; 0x800d7b <xYieldPending>
    1b78:	01 c0       	rjmp	.+2      	; 0x1b7c <xTaskRemoveFromUnorderedEventList+0x6a>
	}
	else
	{
		xReturn = pdFALSE;
    1b7a:	80 e0       	ldi	r24, 0x00	; 0
	}

	return xReturn;
}
    1b7c:	df 91       	pop	r29
    1b7e:	cf 91       	pop	r28
    1b80:	1f 91       	pop	r17
    1b82:	0f 91       	pop	r16
    1b84:	08 95       	ret

00001b86 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    1b86:	20 91 7a 0d 	lds	r18, 0x0D7A	; 0x800d7a <xNumOfOverflows>
    1b8a:	fc 01       	movw	r30, r24
    1b8c:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    1b8e:	20 91 7f 0d 	lds	r18, 0x0D7F	; 0x800d7f <xTickCount>
    1b92:	30 91 80 0d 	lds	r19, 0x0D80	; 0x800d80 <xTickCount+0x1>
    1b96:	32 83       	std	Z+2, r19	; 0x02
    1b98:	21 83       	std	Z+1, r18	; 0x01
    1b9a:	08 95       	ret

00001b9c <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    1b9c:	cf 93       	push	r28
    1b9e:	df 93       	push	r29
    1ba0:	fc 01       	movw	r30, r24
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    1ba2:	0f b6       	in	r0, 0x3f	; 63
    1ba4:	f8 94       	cli
    1ba6:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    1ba8:	20 91 7f 0d 	lds	r18, 0x0D7F	; 0x800d7f <xTickCount>
    1bac:	30 91 80 0d 	lds	r19, 0x0D80	; 0x800d80 <xTickCount+0x1>
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    1bb0:	80 91 7a 0d 	lds	r24, 0x0D7A	; 0x800d7a <xNumOfOverflows>
    1bb4:	90 81       	ld	r25, Z
    1bb6:	98 17       	cp	r25, r24
    1bb8:	29 f0       	breq	.+10     	; 0x1bc4 <xTaskCheckForTimeOut+0x28>
    1bba:	81 81       	ldd	r24, Z+1	; 0x01
    1bbc:	92 81       	ldd	r25, Z+2	; 0x02
    1bbe:	28 17       	cp	r18, r24
    1bc0:	39 07       	cpc	r19, r25
    1bc2:	b0 f4       	brcc	.+44     	; 0x1bf0 <xTaskCheckForTimeOut+0x54>
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    1bc4:	a1 81       	ldd	r26, Z+1	; 0x01
    1bc6:	b2 81       	ldd	r27, Z+2	; 0x02
    1bc8:	eb 01       	movw	r28, r22
    1bca:	48 81       	ld	r20, Y
    1bcc:	59 81       	ldd	r21, Y+1	; 0x01
    1bce:	c9 01       	movw	r24, r18
    1bd0:	8a 1b       	sub	r24, r26
    1bd2:	9b 0b       	sbc	r25, r27
    1bd4:	84 17       	cp	r24, r20
    1bd6:	95 07       	cpc	r25, r21
    1bd8:	68 f4       	brcc	.+26     	; 0x1bf4 <xTaskCheckForTimeOut+0x58>
    1bda:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
    1bdc:	a2 1b       	sub	r26, r18
    1bde:	b3 0b       	sbc	r27, r19
    1be0:	4a 0f       	add	r20, r26
    1be2:	5b 1f       	adc	r21, r27
    1be4:	59 83       	std	Y+1, r21	; 0x01
    1be6:	48 83       	st	Y, r20
			vTaskSetTimeOutState( pxTimeOut );
    1be8:	0e 94 c3 0d 	call	0x1b86	; 0x1b86 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    1bec:	80 e0       	ldi	r24, 0x00	; 0
    1bee:	03 c0       	rjmp	.+6      	; 0x1bf6 <xTaskCheckForTimeOut+0x5a>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    1bf0:	81 e0       	ldi	r24, 0x01	; 1
    1bf2:	01 c0       	rjmp	.+2      	; 0x1bf6 <xTaskCheckForTimeOut+0x5a>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    1bf4:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    1bf6:	0f 90       	pop	r0
    1bf8:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    1bfa:	df 91       	pop	r29
    1bfc:	cf 91       	pop	r28
    1bfe:	08 95       	ret

00001c00 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    1c00:	81 e0       	ldi	r24, 0x01	; 1
    1c02:	80 93 7b 0d 	sts	0x0D7B, r24	; 0x800d7b <xYieldPending>
    1c06:	08 95       	ret

00001c08 <uxTaskResetEventItemValue>:

TickType_t uxTaskResetEventItemValue( void )
{
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    1c08:	e0 91 72 0d 	lds	r30, 0x0D72	; 0x800d72 <pxCurrentTCB>
    1c0c:	f0 91 73 0d 	lds	r31, 0x0D73	; 0x800d73 <pxCurrentTCB+0x1>
    1c10:	84 85       	ldd	r24, Z+12	; 0x0c
    1c12:	95 85       	ldd	r25, Z+13	; 0x0d

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1c14:	e0 91 72 0d 	lds	r30, 0x0D72	; 0x800d72 <pxCurrentTCB>
    1c18:	f0 91 73 0d 	lds	r31, 0x0D73	; 0x800d73 <pxCurrentTCB+0x1>
    1c1c:	a0 91 72 0d 	lds	r26, 0x0D72	; 0x800d72 <pxCurrentTCB>
    1c20:	b0 91 73 0d 	lds	r27, 0x0D73	; 0x800d73 <pxCurrentTCB+0x1>
    1c24:	56 96       	adiw	r26, 0x16	; 22
    1c26:	4c 91       	ld	r20, X
    1c28:	24 e0       	ldi	r18, 0x04	; 4
    1c2a:	30 e0       	ldi	r19, 0x00	; 0
    1c2c:	24 1b       	sub	r18, r20
    1c2e:	31 09       	sbc	r19, r1
    1c30:	35 87       	std	Z+13, r19	; 0x0d
    1c32:	24 87       	std	Z+12, r18	; 0x0c

	return uxReturn;
}
    1c34:	08 95       	ret

00001c36 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    1c36:	0f 93       	push	r16
    1c38:	1f 93       	push	r17
    1c3a:	cf 93       	push	r28
    1c3c:	c8 2f       	mov	r28, r24
    1c3e:	cb 01       	movw	r24, r22
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    1c40:	0f b6       	in	r0, 0x3f	; 63
    1c42:	f8 94       	cli
    1c44:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    1c46:	e0 91 72 0d 	lds	r30, 0x0D72	; 0x800d72 <pxCurrentTCB>
    1c4a:	f0 91 73 0d 	lds	r31, 0x0D73	; 0x800d73 <pxCurrentTCB+0x1>
    1c4e:	41 a1       	ldd	r20, Z+33	; 0x21
    1c50:	52 a1       	ldd	r21, Z+34	; 0x22
    1c52:	63 a1       	ldd	r22, Z+35	; 0x23
    1c54:	74 a1       	ldd	r23, Z+36	; 0x24
    1c56:	45 2b       	or	r20, r21
    1c58:	46 2b       	or	r20, r22
    1c5a:	47 2b       	or	r20, r23
    1c5c:	69 f4       	brne	.+26     	; 0x1c78 <ulTaskNotifyTake+0x42>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    1c5e:	e0 91 72 0d 	lds	r30, 0x0D72	; 0x800d72 <pxCurrentTCB>
    1c62:	f0 91 73 0d 	lds	r31, 0x0D73	; 0x800d73 <pxCurrentTCB+0x1>
    1c66:	21 e0       	ldi	r18, 0x01	; 1
    1c68:	25 a3       	std	Z+37, r18	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    1c6a:	00 97       	sbiw	r24, 0x00	; 0
    1c6c:	29 f0       	breq	.+10     	; 0x1c78 <ulTaskNotifyTake+0x42>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    1c6e:	61 e0       	ldi	r22, 0x01	; 1
    1c70:	0e 94 f4 08 	call	0x11e8	; 0x11e8 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    1c74:	0e 94 ac 03 	call	0x758	; 0x758 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    1c78:	0f 90       	pop	r0
    1c7a:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    1c7c:	0f b6       	in	r0, 0x3f	; 63
    1c7e:	f8 94       	cli
    1c80:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    1c82:	e0 91 72 0d 	lds	r30, 0x0D72	; 0x800d72 <pxCurrentTCB>
    1c86:	f0 91 73 0d 	lds	r31, 0x0D73	; 0x800d73 <pxCurrentTCB+0x1>
    1c8a:	61 a1       	ldd	r22, Z+33	; 0x21
    1c8c:	72 a1       	ldd	r23, Z+34	; 0x22
    1c8e:	83 a1       	ldd	r24, Z+35	; 0x23
    1c90:	94 a1       	ldd	r25, Z+36	; 0x24

			if( ulReturn != 0UL )
    1c92:	61 15       	cp	r22, r1
    1c94:	71 05       	cpc	r23, r1
    1c96:	81 05       	cpc	r24, r1
    1c98:	91 05       	cpc	r25, r1
    1c9a:	c9 f0       	breq	.+50     	; 0x1cce <ulTaskNotifyTake+0x98>
			{
				if( xClearCountOnExit != pdFALSE )
    1c9c:	cc 23       	and	r28, r28
    1c9e:	49 f0       	breq	.+18     	; 0x1cb2 <ulTaskNotifyTake+0x7c>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    1ca0:	e0 91 72 0d 	lds	r30, 0x0D72	; 0x800d72 <pxCurrentTCB>
    1ca4:	f0 91 73 0d 	lds	r31, 0x0D73	; 0x800d73 <pxCurrentTCB+0x1>
    1ca8:	11 a2       	std	Z+33, r1	; 0x21
    1caa:	12 a2       	std	Z+34, r1	; 0x22
    1cac:	13 a2       	std	Z+35, r1	; 0x23
    1cae:	14 a2       	std	Z+36, r1	; 0x24
    1cb0:	0e c0       	rjmp	.+28     	; 0x1cce <ulTaskNotifyTake+0x98>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - 1;
    1cb2:	e0 91 72 0d 	lds	r30, 0x0D72	; 0x800d72 <pxCurrentTCB>
    1cb6:	f0 91 73 0d 	lds	r31, 0x0D73	; 0x800d73 <pxCurrentTCB+0x1>
    1cba:	8b 01       	movw	r16, r22
    1cbc:	9c 01       	movw	r18, r24
    1cbe:	01 50       	subi	r16, 0x01	; 1
    1cc0:	11 09       	sbc	r17, r1
    1cc2:	21 09       	sbc	r18, r1
    1cc4:	31 09       	sbc	r19, r1
    1cc6:	01 a3       	std	Z+33, r16	; 0x21
    1cc8:	12 a3       	std	Z+34, r17	; 0x22
    1cca:	23 a3       	std	Z+35, r18	; 0x23
    1ccc:	34 a3       	std	Z+36, r19	; 0x24
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    1cce:	e0 91 72 0d 	lds	r30, 0x0D72	; 0x800d72 <pxCurrentTCB>
    1cd2:	f0 91 73 0d 	lds	r31, 0x0D73	; 0x800d73 <pxCurrentTCB+0x1>
    1cd6:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    1cd8:	0f 90       	pop	r0
    1cda:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
	}
    1cdc:	cf 91       	pop	r28
    1cde:	1f 91       	pop	r17
    1ce0:	0f 91       	pop	r16
    1ce2:	08 95       	ret

00001ce4 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    1ce4:	4f 92       	push	r4
    1ce6:	5f 92       	push	r5
    1ce8:	6f 92       	push	r6
    1cea:	7f 92       	push	r7
    1cec:	8f 92       	push	r8
    1cee:	9f 92       	push	r9
    1cf0:	af 92       	push	r10
    1cf2:	bf 92       	push	r11
    1cf4:	ef 92       	push	r14
    1cf6:	ff 92       	push	r15
    1cf8:	0f 93       	push	r16
    1cfa:	1f 93       	push	r17
    1cfc:	49 01       	movw	r8, r18
    1cfe:	5a 01       	movw	r10, r20
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    1d00:	0f b6       	in	r0, 0x3f	; 63
    1d02:	f8 94       	cli
    1d04:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    1d06:	e0 91 72 0d 	lds	r30, 0x0D72	; 0x800d72 <pxCurrentTCB>
    1d0a:	f0 91 73 0d 	lds	r31, 0x0D73	; 0x800d73 <pxCurrentTCB+0x1>
    1d0e:	25 a1       	ldd	r18, Z+37	; 0x25
    1d10:	22 30       	cpi	r18, 0x02	; 2
    1d12:	29 f1       	breq	.+74     	; 0x1d5e <xTaskNotifyWait+0x7a>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    1d14:	e0 91 72 0d 	lds	r30, 0x0D72	; 0x800d72 <pxCurrentTCB>
    1d18:	f0 91 73 0d 	lds	r31, 0x0D73	; 0x800d73 <pxCurrentTCB+0x1>
    1d1c:	41 a0       	ldd	r4, Z+33	; 0x21
    1d1e:	52 a0       	ldd	r5, Z+34	; 0x22
    1d20:	63 a0       	ldd	r6, Z+35	; 0x23
    1d22:	74 a0       	ldd	r7, Z+36	; 0x24
    1d24:	dc 01       	movw	r26, r24
    1d26:	cb 01       	movw	r24, r22
    1d28:	80 95       	com	r24
    1d2a:	90 95       	com	r25
    1d2c:	a0 95       	com	r26
    1d2e:	b0 95       	com	r27
    1d30:	84 21       	and	r24, r4
    1d32:	95 21       	and	r25, r5
    1d34:	a6 21       	and	r26, r6
    1d36:	b7 21       	and	r27, r7
    1d38:	81 a3       	std	Z+33, r24	; 0x21
    1d3a:	92 a3       	std	Z+34, r25	; 0x22
    1d3c:	a3 a3       	std	Z+35, r26	; 0x23
    1d3e:	b4 a3       	std	Z+36, r27	; 0x24

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    1d40:	e0 91 72 0d 	lds	r30, 0x0D72	; 0x800d72 <pxCurrentTCB>
    1d44:	f0 91 73 0d 	lds	r31, 0x0D73	; 0x800d73 <pxCurrentTCB+0x1>
    1d48:	81 e0       	ldi	r24, 0x01	; 1
    1d4a:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    1d4c:	e1 14       	cp	r14, r1
    1d4e:	f1 04       	cpc	r15, r1
    1d50:	31 f0       	breq	.+12     	; 0x1d5e <xTaskNotifyWait+0x7a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    1d52:	61 e0       	ldi	r22, 0x01	; 1
    1d54:	c7 01       	movw	r24, r14
    1d56:	0e 94 f4 08 	call	0x11e8	; 0x11e8 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    1d5a:	0e 94 ac 03 	call	0x758	; 0x758 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    1d5e:	0f 90       	pop	r0
    1d60:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    1d62:	0f b6       	in	r0, 0x3f	; 63
    1d64:	f8 94       	cli
    1d66:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    1d68:	01 15       	cp	r16, r1
    1d6a:	11 05       	cpc	r17, r1
    1d6c:	69 f0       	breq	.+26     	; 0x1d88 <xTaskNotifyWait+0xa4>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    1d6e:	e0 91 72 0d 	lds	r30, 0x0D72	; 0x800d72 <pxCurrentTCB>
    1d72:	f0 91 73 0d 	lds	r31, 0x0D73	; 0x800d73 <pxCurrentTCB+0x1>
    1d76:	81 a1       	ldd	r24, Z+33	; 0x21
    1d78:	92 a1       	ldd	r25, Z+34	; 0x22
    1d7a:	a3 a1       	ldd	r26, Z+35	; 0x23
    1d7c:	b4 a1       	ldd	r27, Z+36	; 0x24
    1d7e:	f8 01       	movw	r30, r16
    1d80:	80 83       	st	Z, r24
    1d82:	91 83       	std	Z+1, r25	; 0x01
    1d84:	a2 83       	std	Z+2, r26	; 0x02
    1d86:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState == taskWAITING_NOTIFICATION )
    1d88:	e0 91 72 0d 	lds	r30, 0x0D72	; 0x800d72 <pxCurrentTCB>
    1d8c:	f0 91 73 0d 	lds	r31, 0x0D73	; 0x800d73 <pxCurrentTCB+0x1>
    1d90:	85 a1       	ldd	r24, Z+37	; 0x25
    1d92:	81 30       	cpi	r24, 0x01	; 1
    1d94:	b1 f0       	breq	.+44     	; 0x1dc2 <xTaskNotifyWait+0xde>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    1d96:	e0 91 72 0d 	lds	r30, 0x0D72	; 0x800d72 <pxCurrentTCB>
    1d9a:	f0 91 73 0d 	lds	r31, 0x0D73	; 0x800d73 <pxCurrentTCB+0x1>
    1d9e:	81 a1       	ldd	r24, Z+33	; 0x21
    1da0:	92 a1       	ldd	r25, Z+34	; 0x22
    1da2:	a3 a1       	ldd	r26, Z+35	; 0x23
    1da4:	b4 a1       	ldd	r27, Z+36	; 0x24
    1da6:	80 94       	com	r8
    1da8:	90 94       	com	r9
    1daa:	a0 94       	com	r10
    1dac:	b0 94       	com	r11
    1dae:	88 22       	and	r8, r24
    1db0:	99 22       	and	r9, r25
    1db2:	aa 22       	and	r10, r26
    1db4:	bb 22       	and	r11, r27
    1db6:	81 a2       	std	Z+33, r8	; 0x21
    1db8:	92 a2       	std	Z+34, r9	; 0x22
    1dba:	a3 a2       	std	Z+35, r10	; 0x23
    1dbc:	b4 a2       	std	Z+36, r11	; 0x24
				xReturn = pdTRUE;
    1dbe:	81 e0       	ldi	r24, 0x01	; 1
    1dc0:	01 c0       	rjmp	.+2      	; 0x1dc4 <xTaskNotifyWait+0xe0>
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState == taskWAITING_NOTIFICATION )
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    1dc2:	80 e0       	ldi	r24, 0x00	; 0
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
				xReturn = pdTRUE;
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    1dc4:	e0 91 72 0d 	lds	r30, 0x0D72	; 0x800d72 <pxCurrentTCB>
    1dc8:	f0 91 73 0d 	lds	r31, 0x0D73	; 0x800d73 <pxCurrentTCB+0x1>
    1dcc:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    1dce:	0f 90       	pop	r0
    1dd0:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    1dd2:	1f 91       	pop	r17
    1dd4:	0f 91       	pop	r16
    1dd6:	ff 90       	pop	r15
    1dd8:	ef 90       	pop	r14
    1dda:	bf 90       	pop	r11
    1ddc:	af 90       	pop	r10
    1dde:	9f 90       	pop	r9
    1de0:	8f 90       	pop	r8
    1de2:	7f 90       	pop	r7
    1de4:	6f 90       	pop	r6
    1de6:	5f 90       	pop	r5
    1de8:	4f 90       	pop	r4
    1dea:	08 95       	ret

00001dec <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    1dec:	0f 93       	push	r16
    1dee:	1f 93       	push	r17
    1df0:	cf 93       	push	r28
    1df2:	df 93       	push	r29
    1df4:	fc 01       	movw	r30, r24
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = ( TCB_t * ) xTaskToNotify;

		taskENTER_CRITICAL();
    1df6:	0f b6       	in	r0, 0x3f	; 63
    1df8:	f8 94       	cli
    1dfa:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    1dfc:	01 15       	cp	r16, r1
    1dfe:	11 05       	cpc	r17, r1
    1e00:	49 f0       	breq	.+18     	; 0x1e14 <xTaskGenericNotify+0x28>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    1e02:	81 a1       	ldd	r24, Z+33	; 0x21
    1e04:	92 a1       	ldd	r25, Z+34	; 0x22
    1e06:	a3 a1       	ldd	r26, Z+35	; 0x23
    1e08:	b4 a1       	ldd	r27, Z+36	; 0x24
    1e0a:	e8 01       	movw	r28, r16
    1e0c:	88 83       	st	Y, r24
    1e0e:	99 83       	std	Y+1, r25	; 0x01
    1e10:	aa 83       	std	Y+2, r26	; 0x02
    1e12:	bb 83       	std	Y+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    1e14:	85 a1       	ldd	r24, Z+37	; 0x25

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    1e16:	92 e0       	ldi	r25, 0x02	; 2
    1e18:	95 a3       	std	Z+37, r25	; 0x25

			switch( eAction )
    1e1a:	22 30       	cpi	r18, 0x02	; 2
    1e1c:	b1 f0       	breq	.+44     	; 0x1e4a <xTaskGenericNotify+0x5e>
    1e1e:	18 f4       	brcc	.+6      	; 0x1e26 <xTaskGenericNotify+0x3a>
    1e20:	21 30       	cpi	r18, 0x01	; 1
    1e22:	31 f0       	breq	.+12     	; 0x1e30 <xTaskGenericNotify+0x44>
    1e24:	2a c0       	rjmp	.+84     	; 0x1e7a <xTaskGenericNotify+0x8e>
    1e26:	23 30       	cpi	r18, 0x03	; 3
    1e28:	e9 f0       	breq	.+58     	; 0x1e64 <xTaskGenericNotify+0x78>
    1e2a:	24 30       	cpi	r18, 0x04	; 4
    1e2c:	01 f1       	breq	.+64     	; 0x1e6e <xTaskGenericNotify+0x82>
    1e2e:	25 c0       	rjmp	.+74     	; 0x1e7a <xTaskGenericNotify+0x8e>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    1e30:	01 a1       	ldd	r16, Z+33	; 0x21
    1e32:	12 a1       	ldd	r17, Z+34	; 0x22
    1e34:	23 a1       	ldd	r18, Z+35	; 0x23
    1e36:	34 a1       	ldd	r19, Z+36	; 0x24
    1e38:	40 2b       	or	r20, r16
    1e3a:	51 2b       	or	r21, r17
    1e3c:	62 2b       	or	r22, r18
    1e3e:	73 2b       	or	r23, r19
    1e40:	41 a3       	std	Z+33, r20	; 0x21
    1e42:	52 a3       	std	Z+34, r21	; 0x22
    1e44:	63 a3       	std	Z+35, r22	; 0x23
    1e46:	74 a3       	std	Z+36, r23	; 0x24
					break;
    1e48:	18 c0       	rjmp	.+48     	; 0x1e7a <xTaskGenericNotify+0x8e>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    1e4a:	41 a1       	ldd	r20, Z+33	; 0x21
    1e4c:	52 a1       	ldd	r21, Z+34	; 0x22
    1e4e:	63 a1       	ldd	r22, Z+35	; 0x23
    1e50:	74 a1       	ldd	r23, Z+36	; 0x24
    1e52:	4f 5f       	subi	r20, 0xFF	; 255
    1e54:	5f 4f       	sbci	r21, 0xFF	; 255
    1e56:	6f 4f       	sbci	r22, 0xFF	; 255
    1e58:	7f 4f       	sbci	r23, 0xFF	; 255
    1e5a:	41 a3       	std	Z+33, r20	; 0x21
    1e5c:	52 a3       	std	Z+34, r21	; 0x22
    1e5e:	63 a3       	std	Z+35, r22	; 0x23
    1e60:	74 a3       	std	Z+36, r23	; 0x24
					break;
    1e62:	0b c0       	rjmp	.+22     	; 0x1e7a <xTaskGenericNotify+0x8e>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    1e64:	41 a3       	std	Z+33, r20	; 0x21
    1e66:	52 a3       	std	Z+34, r21	; 0x22
    1e68:	63 a3       	std	Z+35, r22	; 0x23
    1e6a:	74 a3       	std	Z+36, r23	; 0x24
					break;
    1e6c:	06 c0       	rjmp	.+12     	; 0x1e7a <xTaskGenericNotify+0x8e>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    1e6e:	82 30       	cpi	r24, 0x02	; 2
    1e70:	79 f1       	breq	.+94     	; 0x1ed0 <xTaskGenericNotify+0xe4>
					{
						pxTCB->ulNotifiedValue = ulValue;
    1e72:	41 a3       	std	Z+33, r20	; 0x21
    1e74:	52 a3       	std	Z+34, r21	; 0x22
    1e76:	63 a3       	std	Z+35, r22	; 0x23
    1e78:	74 a3       	std	Z+36, r23	; 0x24

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    1e7a:	81 30       	cpi	r24, 0x01	; 1
    1e7c:	59 f5       	brne	.+86     	; 0x1ed4 <xTaskGenericNotify+0xe8>
    1e7e:	ef 01       	movw	r28, r30
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1e80:	8f 01       	movw	r16, r30
    1e82:	0e 5f       	subi	r16, 0xFE	; 254
    1e84:	1f 4f       	sbci	r17, 0xFF	; 255
    1e86:	c8 01       	movw	r24, r16
    1e88:	0e 94 e3 02 	call	0x5c6	; 0x5c6 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    1e8c:	8e 89       	ldd	r24, Y+22	; 0x16
    1e8e:	90 91 7e 0d 	lds	r25, 0x0D7E	; 0x800d7e <uxTopReadyPriority>
    1e92:	98 17       	cp	r25, r24
    1e94:	10 f4       	brcc	.+4      	; 0x1e9a <xTaskGenericNotify+0xae>
    1e96:	80 93 7e 0d 	sts	0x0D7E, r24	; 0x800d7e <uxTopReadyPriority>
    1e9a:	90 e0       	ldi	r25, 0x00	; 0
    1e9c:	9c 01       	movw	r18, r24
    1e9e:	22 0f       	add	r18, r18
    1ea0:	33 1f       	adc	r19, r19
    1ea2:	22 0f       	add	r18, r18
    1ea4:	33 1f       	adc	r19, r19
    1ea6:	22 0f       	add	r18, r18
    1ea8:	33 1f       	adc	r19, r19
    1eaa:	82 0f       	add	r24, r18
    1eac:	93 1f       	adc	r25, r19
    1eae:	b8 01       	movw	r22, r16
    1eb0:	85 55       	subi	r24, 0x55	; 85
    1eb2:	92 4f       	sbci	r25, 0xF2	; 242
    1eb4:	0e 94 91 02 	call	0x522	; 0x522 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    1eb8:	e0 91 72 0d 	lds	r30, 0x0D72	; 0x800d72 <pxCurrentTCB>
    1ebc:	f0 91 73 0d 	lds	r31, 0x0D73	; 0x800d73 <pxCurrentTCB+0x1>
    1ec0:	9e 89       	ldd	r25, Y+22	; 0x16
    1ec2:	86 89       	ldd	r24, Z+22	; 0x16
    1ec4:	89 17       	cp	r24, r25
    1ec6:	40 f4       	brcc	.+16     	; 0x1ed8 <xTaskGenericNotify+0xec>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    1ec8:	0e 94 ac 03 	call	0x758	; 0x758 <vPortYield>
    1ecc:	81 e0       	ldi	r24, 0x01	; 1
    1ece:	05 c0       	rjmp	.+10     	; 0x1eda <xTaskGenericNotify+0xee>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    1ed0:	80 e0       	ldi	r24, 0x00	; 0
    1ed2:	03 c0       	rjmp	.+6      	; 0x1eda <xTaskGenericNotify+0xee>
    1ed4:	81 e0       	ldi	r24, 0x01	; 1
    1ed6:	01 c0       	rjmp	.+2      	; 0x1eda <xTaskGenericNotify+0xee>
    1ed8:	81 e0       	ldi	r24, 0x01	; 1
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    1eda:	0f 90       	pop	r0
    1edc:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    1ede:	df 91       	pop	r29
    1ee0:	cf 91       	pop	r28
    1ee2:	1f 91       	pop	r17
    1ee4:	0f 91       	pop	r16
    1ee6:	08 95       	ret

00001ee8 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    1ee8:	ef 92       	push	r14
    1eea:	ff 92       	push	r15
    1eec:	0f 93       	push	r16
    1eee:	1f 93       	push	r17
    1ef0:	cf 93       	push	r28
    1ef2:	df 93       	push	r29
    1ef4:	fc 01       	movw	r30, r24

		pxTCB = ( TCB_t * ) xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			if( pulPreviousNotificationValue != NULL )
    1ef6:	01 15       	cp	r16, r1
    1ef8:	11 05       	cpc	r17, r1
    1efa:	49 f0       	breq	.+18     	; 0x1f0e <xTaskGenericNotifyFromISR+0x26>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    1efc:	81 a1       	ldd	r24, Z+33	; 0x21
    1efe:	92 a1       	ldd	r25, Z+34	; 0x22
    1f00:	a3 a1       	ldd	r26, Z+35	; 0x23
    1f02:	b4 a1       	ldd	r27, Z+36	; 0x24
    1f04:	e8 01       	movw	r28, r16
    1f06:	88 83       	st	Y, r24
    1f08:	99 83       	std	Y+1, r25	; 0x01
    1f0a:	aa 83       	std	Y+2, r26	; 0x02
    1f0c:	bb 83       	std	Y+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    1f0e:	85 a1       	ldd	r24, Z+37	; 0x25
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    1f10:	92 e0       	ldi	r25, 0x02	; 2
    1f12:	95 a3       	std	Z+37, r25	; 0x25

			switch( eAction )
    1f14:	22 30       	cpi	r18, 0x02	; 2
    1f16:	b1 f0       	breq	.+44     	; 0x1f44 <xTaskGenericNotifyFromISR+0x5c>
    1f18:	18 f4       	brcc	.+6      	; 0x1f20 <xTaskGenericNotifyFromISR+0x38>
    1f1a:	21 30       	cpi	r18, 0x01	; 1
    1f1c:	31 f0       	breq	.+12     	; 0x1f2a <xTaskGenericNotifyFromISR+0x42>
    1f1e:	2b c0       	rjmp	.+86     	; 0x1f76 <xTaskGenericNotifyFromISR+0x8e>
    1f20:	23 30       	cpi	r18, 0x03	; 3
    1f22:	e9 f0       	breq	.+58     	; 0x1f5e <xTaskGenericNotifyFromISR+0x76>
    1f24:	24 30       	cpi	r18, 0x04	; 4
    1f26:	01 f1       	breq	.+64     	; 0x1f68 <xTaskGenericNotifyFromISR+0x80>
    1f28:	26 c0       	rjmp	.+76     	; 0x1f76 <xTaskGenericNotifyFromISR+0x8e>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    1f2a:	01 a1       	ldd	r16, Z+33	; 0x21
    1f2c:	12 a1       	ldd	r17, Z+34	; 0x22
    1f2e:	23 a1       	ldd	r18, Z+35	; 0x23
    1f30:	34 a1       	ldd	r19, Z+36	; 0x24
    1f32:	40 2b       	or	r20, r16
    1f34:	51 2b       	or	r21, r17
    1f36:	62 2b       	or	r22, r18
    1f38:	73 2b       	or	r23, r19
    1f3a:	41 a3       	std	Z+33, r20	; 0x21
    1f3c:	52 a3       	std	Z+34, r21	; 0x22
    1f3e:	63 a3       	std	Z+35, r22	; 0x23
    1f40:	74 a3       	std	Z+36, r23	; 0x24
					break;
    1f42:	19 c0       	rjmp	.+50     	; 0x1f76 <xTaskGenericNotifyFromISR+0x8e>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    1f44:	41 a1       	ldd	r20, Z+33	; 0x21
    1f46:	52 a1       	ldd	r21, Z+34	; 0x22
    1f48:	63 a1       	ldd	r22, Z+35	; 0x23
    1f4a:	74 a1       	ldd	r23, Z+36	; 0x24
    1f4c:	4f 5f       	subi	r20, 0xFF	; 255
    1f4e:	5f 4f       	sbci	r21, 0xFF	; 255
    1f50:	6f 4f       	sbci	r22, 0xFF	; 255
    1f52:	7f 4f       	sbci	r23, 0xFF	; 255
    1f54:	41 a3       	std	Z+33, r20	; 0x21
    1f56:	52 a3       	std	Z+34, r21	; 0x22
    1f58:	63 a3       	std	Z+35, r22	; 0x23
    1f5a:	74 a3       	std	Z+36, r23	; 0x24
					break;
    1f5c:	0c c0       	rjmp	.+24     	; 0x1f76 <xTaskGenericNotifyFromISR+0x8e>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    1f5e:	41 a3       	std	Z+33, r20	; 0x21
    1f60:	52 a3       	std	Z+34, r21	; 0x22
    1f62:	63 a3       	std	Z+35, r22	; 0x23
    1f64:	74 a3       	std	Z+36, r23	; 0x24
					break;
    1f66:	07 c0       	rjmp	.+14     	; 0x1f76 <xTaskGenericNotifyFromISR+0x8e>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    1f68:	82 30       	cpi	r24, 0x02	; 2
    1f6a:	09 f4       	brne	.+2      	; 0x1f6e <xTaskGenericNotifyFromISR+0x86>
    1f6c:	42 c0       	rjmp	.+132    	; 0x1ff2 <xTaskGenericNotifyFromISR+0x10a>
					{
						pxTCB->ulNotifiedValue = ulValue;
    1f6e:	41 a3       	std	Z+33, r20	; 0x21
    1f70:	52 a3       	std	Z+34, r21	; 0x22
    1f72:	63 a3       	std	Z+35, r22	; 0x23
    1f74:	74 a3       	std	Z+36, r23	; 0x24

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    1f76:	81 30       	cpi	r24, 0x01	; 1
    1f78:	f1 f5       	brne	.+124    	; 0x1ff6 <xTaskGenericNotifyFromISR+0x10e>
    1f7a:	ef 01       	movw	r28, r30
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1f7c:	80 91 74 0d 	lds	r24, 0x0D74	; 0x800d74 <uxSchedulerSuspended>
    1f80:	81 11       	cpse	r24, r1
    1f82:	1d c0       	rjmp	.+58     	; 0x1fbe <xTaskGenericNotifyFromISR+0xd6>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1f84:	8f 01       	movw	r16, r30
    1f86:	0e 5f       	subi	r16, 0xFE	; 254
    1f88:	1f 4f       	sbci	r17, 0xFF	; 255
    1f8a:	c8 01       	movw	r24, r16
    1f8c:	0e 94 e3 02 	call	0x5c6	; 0x5c6 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    1f90:	8e 89       	ldd	r24, Y+22	; 0x16
    1f92:	90 91 7e 0d 	lds	r25, 0x0D7E	; 0x800d7e <uxTopReadyPriority>
    1f96:	98 17       	cp	r25, r24
    1f98:	10 f4       	brcc	.+4      	; 0x1f9e <xTaskGenericNotifyFromISR+0xb6>
    1f9a:	80 93 7e 0d 	sts	0x0D7E, r24	; 0x800d7e <uxTopReadyPriority>
    1f9e:	90 e0       	ldi	r25, 0x00	; 0
    1fa0:	9c 01       	movw	r18, r24
    1fa2:	22 0f       	add	r18, r18
    1fa4:	33 1f       	adc	r19, r19
    1fa6:	22 0f       	add	r18, r18
    1fa8:	33 1f       	adc	r19, r19
    1faa:	22 0f       	add	r18, r18
    1fac:	33 1f       	adc	r19, r19
    1fae:	82 0f       	add	r24, r18
    1fb0:	93 1f       	adc	r25, r19
    1fb2:	b8 01       	movw	r22, r16
    1fb4:	85 55       	subi	r24, 0x55	; 85
    1fb6:	92 4f       	sbci	r25, 0xF2	; 242
    1fb8:	0e 94 91 02 	call	0x522	; 0x522 <vListInsertEnd>
    1fbc:	07 c0       	rjmp	.+14     	; 0x1fcc <xTaskGenericNotifyFromISR+0xe4>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    1fbe:	bf 01       	movw	r22, r30
    1fc0:	64 5f       	subi	r22, 0xF4	; 244
    1fc2:	7f 4f       	sbci	r23, 0xFF	; 255
    1fc4:	8c e8       	ldi	r24, 0x8C	; 140
    1fc6:	9d e0       	ldi	r25, 0x0D	; 13
    1fc8:	0e 94 91 02 	call	0x522	; 0x522 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    1fcc:	e0 91 72 0d 	lds	r30, 0x0D72	; 0x800d72 <pxCurrentTCB>
    1fd0:	f0 91 73 0d 	lds	r31, 0x0D73	; 0x800d73 <pxCurrentTCB+0x1>
    1fd4:	9e 89       	ldd	r25, Y+22	; 0x16
    1fd6:	86 89       	ldd	r24, Z+22	; 0x16
    1fd8:	89 17       	cp	r24, r25
    1fda:	78 f4       	brcc	.+30     	; 0x1ffa <xTaskGenericNotifyFromISR+0x112>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    1fdc:	e1 14       	cp	r14, r1
    1fde:	f1 04       	cpc	r15, r1
    1fe0:	21 f0       	breq	.+8      	; 0x1fea <xTaskGenericNotifyFromISR+0x102>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    1fe2:	81 e0       	ldi	r24, 0x01	; 1
    1fe4:	f7 01       	movw	r30, r14
    1fe6:	80 83       	st	Z, r24
    1fe8:	09 c0       	rjmp	.+18     	; 0x1ffc <xTaskGenericNotifyFromISR+0x114>
					else
					{
						/* Mark that a yield is pending in case the user is not
						using the "xHigherPriorityTaskWoken" parameter to an ISR
						safe FreeRTOS function. */
						xYieldPending = pdTRUE;
    1fea:	81 e0       	ldi	r24, 0x01	; 1
    1fec:	80 93 7b 0d 	sts	0x0D7B, r24	; 0x800d7b <xYieldPending>
    1ff0:	05 c0       	rjmp	.+10     	; 0x1ffc <xTaskGenericNotifyFromISR+0x114>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    1ff2:	80 e0       	ldi	r24, 0x00	; 0
    1ff4:	03 c0       	rjmp	.+6      	; 0x1ffc <xTaskGenericNotifyFromISR+0x114>
    1ff6:	81 e0       	ldi	r24, 0x01	; 1
    1ff8:	01 c0       	rjmp	.+2      	; 0x1ffc <xTaskGenericNotifyFromISR+0x114>
    1ffa:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
	}
    1ffc:	df 91       	pop	r29
    1ffe:	cf 91       	pop	r28
    2000:	1f 91       	pop	r17
    2002:	0f 91       	pop	r16
    2004:	ff 90       	pop	r15
    2006:	ef 90       	pop	r14
    2008:	08 95       	ret

0000200a <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    200a:	ef 92       	push	r14
    200c:	ff 92       	push	r15
    200e:	0f 93       	push	r16
    2010:	1f 93       	push	r17
    2012:	cf 93       	push	r28
    2014:	df 93       	push	r29
    2016:	fc 01       	movw	r30, r24

		pxTCB = ( TCB_t * ) xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    2018:	25 a1       	ldd	r18, Z+37	; 0x25
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    201a:	82 e0       	ldi	r24, 0x02	; 2
    201c:	85 a3       	std	Z+37, r24	; 0x25

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    201e:	81 a1       	ldd	r24, Z+33	; 0x21
    2020:	92 a1       	ldd	r25, Z+34	; 0x22
    2022:	a3 a1       	ldd	r26, Z+35	; 0x23
    2024:	b4 a1       	ldd	r27, Z+36	; 0x24
    2026:	01 96       	adiw	r24, 0x01	; 1
    2028:	a1 1d       	adc	r26, r1
    202a:	b1 1d       	adc	r27, r1
    202c:	81 a3       	std	Z+33, r24	; 0x21
    202e:	92 a3       	std	Z+34, r25	; 0x22
    2030:	a3 a3       	std	Z+35, r26	; 0x23
    2032:	b4 a3       	std	Z+36, r27	; 0x24

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    2034:	21 30       	cpi	r18, 0x01	; 1
    2036:	e9 f5       	brne	.+122    	; 0x20b2 <vTaskNotifyGiveFromISR+0xa8>
    2038:	8b 01       	movw	r16, r22
    203a:	ef 01       	movw	r28, r30
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    203c:	80 91 74 0d 	lds	r24, 0x0D74	; 0x800d74 <uxSchedulerSuspended>
    2040:	81 11       	cpse	r24, r1
    2042:	1e c0       	rjmp	.+60     	; 0x2080 <vTaskNotifyGiveFromISR+0x76>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    2044:	7f 01       	movw	r14, r30
    2046:	82 e0       	ldi	r24, 0x02	; 2
    2048:	e8 0e       	add	r14, r24
    204a:	f1 1c       	adc	r15, r1
    204c:	c7 01       	movw	r24, r14
    204e:	0e 94 e3 02 	call	0x5c6	; 0x5c6 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    2052:	8e 89       	ldd	r24, Y+22	; 0x16
    2054:	90 91 7e 0d 	lds	r25, 0x0D7E	; 0x800d7e <uxTopReadyPriority>
    2058:	98 17       	cp	r25, r24
    205a:	10 f4       	brcc	.+4      	; 0x2060 <vTaskNotifyGiveFromISR+0x56>
    205c:	80 93 7e 0d 	sts	0x0D7E, r24	; 0x800d7e <uxTopReadyPriority>
    2060:	90 e0       	ldi	r25, 0x00	; 0
    2062:	9c 01       	movw	r18, r24
    2064:	22 0f       	add	r18, r18
    2066:	33 1f       	adc	r19, r19
    2068:	22 0f       	add	r18, r18
    206a:	33 1f       	adc	r19, r19
    206c:	22 0f       	add	r18, r18
    206e:	33 1f       	adc	r19, r19
    2070:	82 0f       	add	r24, r18
    2072:	93 1f       	adc	r25, r19
    2074:	b7 01       	movw	r22, r14
    2076:	85 55       	subi	r24, 0x55	; 85
    2078:	92 4f       	sbci	r25, 0xF2	; 242
    207a:	0e 94 91 02 	call	0x522	; 0x522 <vListInsertEnd>
    207e:	07 c0       	rjmp	.+14     	; 0x208e <vTaskNotifyGiveFromISR+0x84>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    2080:	bf 01       	movw	r22, r30
    2082:	64 5f       	subi	r22, 0xF4	; 244
    2084:	7f 4f       	sbci	r23, 0xFF	; 255
    2086:	8c e8       	ldi	r24, 0x8C	; 140
    2088:	9d e0       	ldi	r25, 0x0D	; 13
    208a:	0e 94 91 02 	call	0x522	; 0x522 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    208e:	e0 91 72 0d 	lds	r30, 0x0D72	; 0x800d72 <pxCurrentTCB>
    2092:	f0 91 73 0d 	lds	r31, 0x0D73	; 0x800d73 <pxCurrentTCB+0x1>
    2096:	9e 89       	ldd	r25, Y+22	; 0x16
    2098:	86 89       	ldd	r24, Z+22	; 0x16
    209a:	89 17       	cp	r24, r25
    209c:	50 f4       	brcc	.+20     	; 0x20b2 <vTaskNotifyGiveFromISR+0xa8>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    209e:	01 15       	cp	r16, r1
    20a0:	11 05       	cpc	r17, r1
    20a2:	21 f0       	breq	.+8      	; 0x20ac <vTaskNotifyGiveFromISR+0xa2>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    20a4:	81 e0       	ldi	r24, 0x01	; 1
    20a6:	f8 01       	movw	r30, r16
    20a8:	80 83       	st	Z, r24
    20aa:	03 c0       	rjmp	.+6      	; 0x20b2 <vTaskNotifyGiveFromISR+0xa8>
					else
					{
						/* Mark that a yield is pending in case the user is not
						using the "xHigherPriorityTaskWoken" parameter in an ISR
						safe FreeRTOS function. */
						xYieldPending = pdTRUE;
    20ac:	81 e0       	ldi	r24, 0x01	; 1
    20ae:	80 93 7b 0d 	sts	0x0D7B, r24	; 0x800d7b <xYieldPending>
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    20b2:	df 91       	pop	r29
    20b4:	cf 91       	pop	r28
    20b6:	1f 91       	pop	r17
    20b8:	0f 91       	pop	r16
    20ba:	ff 90       	pop	r15
    20bc:	ef 90       	pop	r14
    20be:	08 95       	ret

000020c0 <xTaskNotifyStateClear>:
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    20c0:	00 97       	sbiw	r24, 0x00	; 0
    20c2:	21 f4       	brne	.+8      	; 0x20cc <xTaskNotifyStateClear+0xc>
    20c4:	80 91 72 0d 	lds	r24, 0x0D72	; 0x800d72 <pxCurrentTCB>
    20c8:	90 91 73 0d 	lds	r25, 0x0D73	; 0x800d73 <pxCurrentTCB+0x1>

		taskENTER_CRITICAL();
    20cc:	0f b6       	in	r0, 0x3f	; 63
    20ce:	f8 94       	cli
    20d0:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    20d2:	fc 01       	movw	r30, r24
    20d4:	25 a1       	ldd	r18, Z+37	; 0x25
    20d6:	22 30       	cpi	r18, 0x02	; 2
    20d8:	19 f4       	brne	.+6      	; 0x20e0 <xTaskNotifyStateClear+0x20>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    20da:	15 a2       	std	Z+37, r1	; 0x25
				xReturn = pdPASS;
    20dc:	81 e0       	ldi	r24, 0x01	; 1
    20de:	01 c0       	rjmp	.+2      	; 0x20e2 <xTaskNotifyStateClear+0x22>
			}
			else
			{
				xReturn = pdFAIL;
    20e0:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		taskEXIT_CRITICAL();
    20e2:	0f 90       	pop	r0
    20e4:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    20e6:	08 95       	ret

000020e8 <vUART1ReceiveService>:
	for( ;; ) {
		/* Waits for bufferReceiveUART1 to fill, then pops first byte of data and
		   copies it to UART1 data register UDR1 effectively transmitting it. 
		   Test code - writes back to terminal. */ 
		xQueueReceive( bufferReceiveUART1Bluetooth, &UDR1, portMAX_DELAY );
		while(!( UCSR1A & (1<<UDRE1)));		// Wait for transmit to finish
    20e8:	cb e9       	ldi	r28, 0x9B	; 155
    20ea:	d0 e0       	ldi	r29, 0x00	; 0
	
	for( ;; ) {
		/* Waits for bufferReceiveUART1 to fill, then pops first byte of data and
		   copies it to UART1 data register UDR1 effectively transmitting it. 
		   Test code - writes back to terminal. */ 
		xQueueReceive( bufferReceiveUART1Bluetooth, &UDR1, portMAX_DELAY );
    20ec:	20 e0       	ldi	r18, 0x00	; 0
    20ee:	4f ef       	ldi	r20, 0xFF	; 255
    20f0:	5f ef       	ldi	r21, 0xFF	; 255
    20f2:	6c e9       	ldi	r22, 0x9C	; 156
    20f4:	70 e0       	ldi	r23, 0x00	; 0
    20f6:	80 91 d3 0d 	lds	r24, 0x0DD3	; 0x800dd3 <bufferReceiveUART1Bluetooth>
    20fa:	90 91 d4 0d 	lds	r25, 0x0DD4	; 0x800dd4 <bufferReceiveUART1Bluetooth+0x1>
    20fe:	0e 94 c6 06 	call	0xd8c	; 0xd8c <xQueueGenericReceive>
		while(!( UCSR1A & (1<<UDRE1)));		// Wait for transmit to finish
    2102:	88 81       	ld	r24, Y
    2104:	85 ff       	sbrs	r24, 5
    2106:	fd cf       	rjmp	.-6      	; 0x2102 <vUART1ReceiveService+0x1a>
    2108:	f1 cf       	rjmp	.-30     	; 0x20ec <vUART1ReceiveService+0x4>

0000210a <vUART0ReceiveService>:
	
	for( ;; ) {
		/* Waits for bufferReceiveUART0 to fill, then pops first byte of data and
		   copies it to UART0 data register UDR0 effectively transmitting it. 
		   Test code - writes back to terminal. */ 
		xQueueReceive( bufferReceiveUART0Serial, &UDR0, portMAX_DELAY );
    210a:	20 e0       	ldi	r18, 0x00	; 0
    210c:	4f ef       	ldi	r20, 0xFF	; 255
    210e:	5f ef       	ldi	r21, 0xFF	; 255
    2110:	6c e2       	ldi	r22, 0x2C	; 44
    2112:	70 e0       	ldi	r23, 0x00	; 0
    2114:	80 91 f5 0d 	lds	r24, 0x0DF5	; 0x800df5 <bufferReceiveUART0Serial>
    2118:	90 91 f6 0d 	lds	r25, 0x0DF6	; 0x800df6 <bufferReceiveUART0Serial+0x1>
    211c:	0e 94 c6 06 	call	0xd8c	; 0xd8c <xQueueGenericReceive>
		while(!( UCSR0A & (1<<UDRE0)));		// Wait for transmit to finish
    2120:	5d 9b       	sbis	0x0b, 5	; 11
    2122:	fe cf       	rjmp	.-4      	; 0x2120 <vUART0ReceiveService+0x16>
    2124:	f2 cf       	rjmp	.-28     	; 0x210a <vUART0ReceiveService>

00002126 <vUART1TransmitService>:
	
	for( ;; ) {
		/* Waits for bufferSendUART1 to fill, then pops first byte of data and
		   copies it to UART1 data register UDR1 effectively transmitting it. */ 
		xQueueReceive( bufferSendUART1Bluetooth, &UDR1, portMAX_DELAY );
		while(!( UCSR1A & (1<<UDRE1)));		// Wait for transmit to finish
    2126:	cb e9       	ldi	r28, 0x9B	; 155
    2128:	d0 e0       	ldi	r29, 0x00	; 0
	( void ) pvParameters;
	
	for( ;; ) {
		/* Waits for bufferSendUART1 to fill, then pops first byte of data and
		   copies it to UART1 data register UDR1 effectively transmitting it. */ 
		xQueueReceive( bufferSendUART1Bluetooth, &UDR1, portMAX_DELAY );
    212a:	20 e0       	ldi	r18, 0x00	; 0
    212c:	4f ef       	ldi	r20, 0xFF	; 255
    212e:	5f ef       	ldi	r21, 0xFF	; 255
    2130:	6c e9       	ldi	r22, 0x9C	; 156
    2132:	70 e0       	ldi	r23, 0x00	; 0
    2134:	80 91 f9 0d 	lds	r24, 0x0DF9	; 0x800df9 <bufferSendUART1Bluetooth>
    2138:	90 91 fa 0d 	lds	r25, 0x0DFA	; 0x800dfa <bufferSendUART1Bluetooth+0x1>
    213c:	0e 94 c6 06 	call	0xd8c	; 0xd8c <xQueueGenericReceive>
		while(!( UCSR1A & (1<<UDRE1)));		// Wait for transmit to finish
    2140:	88 81       	ld	r24, Y
    2142:	85 ff       	sbrs	r24, 5
    2144:	fd cf       	rjmp	.-6      	; 0x2140 <vUART1TransmitService+0x1a>
    2146:	f1 cf       	rjmp	.-30     	; 0x212a <vUART1TransmitService+0x4>

00002148 <vUART0TransmitService>:
	( void ) pvParameters;
	
	for( ;; ) {
		/* Waits for bufferSendUART0 to fill, then pops first byte of data and
		   copies it to UART0 data register UDR0 effectively transmitting it. */ 
		xQueueReceive( bufferSendUART0Serial, &UDR0, portMAX_DELAY );
    2148:	20 e0       	ldi	r18, 0x00	; 0
    214a:	4f ef       	ldi	r20, 0xFF	; 255
    214c:	5f ef       	ldi	r21, 0xFF	; 255
    214e:	6c e2       	ldi	r22, 0x2C	; 44
    2150:	70 e0       	ldi	r23, 0x00	; 0
    2152:	80 91 f7 0d 	lds	r24, 0x0DF7	; 0x800df7 <bufferSendUART0Serial>
    2156:	90 91 f8 0d 	lds	r25, 0x0DF8	; 0x800df8 <bufferSendUART0Serial+0x1>
    215a:	0e 94 c6 06 	call	0xd8c	; 0xd8c <xQueueGenericReceive>
		while(!( UCSR0A & (1<<UDRE0)));		// Wait for transmit to finish
    215e:	5d 9b       	sbis	0x0b, 5	; 11
    2160:	fe cf       	rjmp	.-4      	; 0x215e <vUART0TransmitService+0x16>
    2162:	f2 cf       	rjmp	.-28     	; 0x2148 <vUART0TransmitService>

00002164 <vRedLED>:

	/* The parameters are not used. */
	( void ) pvParameters;

	for( ;; ) {
		PORTB ^= (1 << PB0);
    2164:	d1 e0       	ldi	r29, 0x01	; 1

static void sendMessage( unsigned char *message, QueueHandle_t queue) {
	/* Receives a message and pushes it on UART send queue character by character.
	   Limited to 255 characters for efficiency (counter i takes one byte). 
	   Message must be null terminated. */
	for(uint8_t i = 0; message[i] != '\0'; ++i) {
    2166:	0f 2e       	mov	r0, r31
    2168:	f5 ed       	ldi	r31, 0xD5	; 213
    216a:	ef 2e       	mov	r14, r31
    216c:	fd e0       	ldi	r31, 0x0D	; 13
    216e:	ff 2e       	mov	r15, r31
    2170:	f0 2d       	mov	r31, r0

	/* The parameters are not used. */
	( void ) pvParameters;

	for( ;; ) {
		PORTB ^= (1 << PB0);
    2172:	88 b3       	in	r24, 0x18	; 24
    2174:	8d 27       	eor	r24, r29
    2176:	88 bb       	out	0x18, r24	; 24
		sendMessage(message2, bufferSendUART0Serial);
    2178:	00 91 f7 0d 	lds	r16, 0x0DF7	; 0x800df7 <bufferSendUART0Serial>
    217c:	10 91 f8 0d 	lds	r17, 0x0DF8	; 0x800df8 <bufferSendUART0Serial+0x1>

static void sendMessage( unsigned char *message, QueueHandle_t queue) {
	/* Receives a message and pushes it on UART send queue character by character.
	   Limited to 255 characters for efficiency (counter i takes one byte). 
	   Message must be null terminated. */
	for(uint8_t i = 0; message[i] != '\0'; ++i) {
    2180:	f7 01       	movw	r30, r14
    2182:	80 81       	ld	r24, Z
    2184:	88 23       	and	r24, r24
    2186:	89 f0       	breq	.+34     	; 0x21aa <vRedLED+0x46>
    2188:	c0 e0       	ldi	r28, 0x00	; 0
    218a:	b7 01       	movw	r22, r14
		xQueueSendToBack( queue, message+i, pdMS_TO_TICKS(50));
    218c:	20 e0       	ldi	r18, 0x00	; 0
    218e:	45 e0       	ldi	r20, 0x05	; 5
    2190:	50 e0       	ldi	r21, 0x00	; 0
    2192:	c8 01       	movw	r24, r16
    2194:	0e 94 c2 05 	call	0xb84	; 0xb84 <xQueueGenericSend>

static void sendMessage( unsigned char *message, QueueHandle_t queue) {
	/* Receives a message and pushes it on UART send queue character by character.
	   Limited to 255 characters for efficiency (counter i takes one byte). 
	   Message must be null terminated. */
	for(uint8_t i = 0; message[i] != '\0'; ++i) {
    2198:	cf 5f       	subi	r28, 0xFF	; 255
    219a:	6c 2f       	mov	r22, r28
    219c:	70 e0       	ldi	r23, 0x00	; 0
    219e:	6b 52       	subi	r22, 0x2B	; 43
    21a0:	72 4f       	sbci	r23, 0xF2	; 242
    21a2:	fb 01       	movw	r30, r22
    21a4:	80 81       	ld	r24, Z
    21a6:	81 11       	cpse	r24, r1
    21a8:	f1 cf       	rjmp	.-30     	; 0x218c <vRedLED+0x28>
	( void ) pvParameters;

	for( ;; ) {
		PORTB ^= (1 << PB0);
		sendMessage(message2, bufferSendUART0Serial);
		PORTB ^= (1 << PB0);
    21aa:	88 b3       	in	r24, 0x18	; 24
    21ac:	8d 27       	eor	r24, r29
    21ae:	88 bb       	out	0x18, r24	; 24
		vTaskDelay( 400 );
    21b0:	80 e9       	ldi	r24, 0x90	; 144
    21b2:	91 e0       	ldi	r25, 0x01	; 1
    21b4:	0e 94 5d 0c 	call	0x18ba	; 0x18ba <vTaskDelay>
	}
    21b8:	dc cf       	rjmp	.-72     	; 0x2172 <vRedLED+0xe>

000021ba <main>:
/* -- UART0: SERIAL; UART1: BLUETOOTH -- */

QueueHandle_t bufferSendUART0Serial, bufferReceiveUART0Serial, bufferSendUART1Bluetooth, bufferReceiveUART1Bluetooth;
Message msg;

int main( void ) {
    21ba:	ef 92       	push	r14
    21bc:	ff 92       	push	r15
    21be:	0f 93       	push	r16

	bufferSendUART0Serial = xQueueCreate(16, sizeof(unsigned char));
    21c0:	40 e0       	ldi	r20, 0x00	; 0
    21c2:	61 e0       	ldi	r22, 0x01	; 1
    21c4:	80 e1       	ldi	r24, 0x10	; 16
    21c6:	0e 94 95 05 	call	0xb2a	; 0xb2a <xQueueGenericCreate>
    21ca:	90 93 f8 0d 	sts	0x0DF8, r25	; 0x800df8 <bufferSendUART0Serial+0x1>
    21ce:	80 93 f7 0d 	sts	0x0DF7, r24	; 0x800df7 <bufferSendUART0Serial>
	bufferReceiveUART0Serial = xQueueCreate(16, sizeof(unsigned char));
    21d2:	40 e0       	ldi	r20, 0x00	; 0
    21d4:	61 e0       	ldi	r22, 0x01	; 1
    21d6:	80 e1       	ldi	r24, 0x10	; 16
    21d8:	0e 94 95 05 	call	0xb2a	; 0xb2a <xQueueGenericCreate>
    21dc:	90 93 f6 0d 	sts	0x0DF6, r25	; 0x800df6 <bufferReceiveUART0Serial+0x1>
    21e0:	80 93 f5 0d 	sts	0x0DF5, r24	; 0x800df5 <bufferReceiveUART0Serial>
	bufferSendUART1Bluetooth = xQueueCreate(16, sizeof(unsigned char));
    21e4:	40 e0       	ldi	r20, 0x00	; 0
    21e6:	61 e0       	ldi	r22, 0x01	; 1
    21e8:	80 e1       	ldi	r24, 0x10	; 16
    21ea:	0e 94 95 05 	call	0xb2a	; 0xb2a <xQueueGenericCreate>
    21ee:	90 93 fa 0d 	sts	0x0DFA, r25	; 0x800dfa <bufferSendUART1Bluetooth+0x1>
    21f2:	80 93 f9 0d 	sts	0x0DF9, r24	; 0x800df9 <bufferSendUART1Bluetooth>
	bufferReceiveUART1Bluetooth = xQueueCreate(16, sizeof(unsigned char));
    21f6:	40 e0       	ldi	r20, 0x00	; 0
    21f8:	61 e0       	ldi	r22, 0x01	; 1
    21fa:	80 e1       	ldi	r24, 0x10	; 16
    21fc:	0e 94 95 05 	call	0xb2a	; 0xb2a <xQueueGenericCreate>
    2200:	90 93 d4 0d 	sts	0x0DD4, r25	; 0x800dd4 <bufferReceiveUART1Bluetooth+0x1>
    2204:	80 93 d3 0d 	sts	0x0DD3, r24	; 0x800dd3 <bufferReceiveUART1Bluetooth>

	DDRB |= (1 << PB0);
    2208:	b8 9a       	sbi	0x17, 0	; 23
	DDRB |= (1 << PB1);
    220a:	b9 9a       	sbi	0x17, 1	; 23


	USART_Init();
    220c:	0e 94 ba 11 	call	0x2374	; 0x2374 <USART_Init>

	/* Enable interrupts */
	UCSR0B |= (1 << RXCIE0);
    2210:	57 9a       	sbi	0x0a, 7	; 10
	UCSR1B |= (1 << RXCIE1);
    2212:	ea e9       	ldi	r30, 0x9A	; 154
    2214:	f0 e0       	ldi	r31, 0x00	; 0
    2216:	80 81       	ld	r24, Z
    2218:	80 68       	ori	r24, 0x80	; 128
    221a:	80 83       	st	Z, r24
	sei();
    221c:	78 94       	sei

	makeMessage(&msg, TEXT, '1', message1);
    221e:	20 e0       	ldi	r18, 0x00	; 0
    2220:	31 e0       	ldi	r19, 0x01	; 1
    2222:	41 e3       	ldi	r20, 0x31	; 49
    2224:	61 e4       	ldi	r22, 0x41	; 65
    2226:	8f ec       	ldi	r24, 0xCF	; 207
    2228:	9d e0       	ldi	r25, 0x0D	; 13
    222a:	0e 94 e0 11 	call	0x23c0	; 0x23c0 <makeMessage>
	getMessage(&msg, message2);
    222e:	65 ed       	ldi	r22, 0xD5	; 213
    2230:	7d e0       	ldi	r23, 0x0D	; 13
    2232:	8f ec       	ldi	r24, 0xCF	; 207
    2234:	9d e0       	ldi	r25, 0x0D	; 13
    2236:	0e 94 e6 11 	call	0x23cc	; 0x23cc <getMessage>

	/* Create the tasks defined within this file. */
	xTaskCreate( vRedLED, "RedLED", configMINIMAL_STACK_SIZE, NULL, mainLED_TASK_PRIORITY, NULL );
    223a:	e1 2c       	mov	r14, r1
    223c:	f1 2c       	mov	r15, r1
    223e:	01 e0       	ldi	r16, 0x01	; 1
    2240:	20 e0       	ldi	r18, 0x00	; 0
    2242:	30 e0       	ldi	r19, 0x00	; 0
    2244:	45 e5       	ldi	r20, 0x55	; 85
    2246:	50 e0       	ldi	r21, 0x00	; 0
    2248:	6d e0       	ldi	r22, 0x0D	; 13
    224a:	71 e0       	ldi	r23, 0x01	; 1
    224c:	82 eb       	ldi	r24, 0xB2	; 178
    224e:	90 e1       	ldi	r25, 0x10	; 16
    2250:	0e 94 38 09 	call	0x1270	; 0x1270 <xTaskCreate>
	//xTaskCreate( vGreenLED, "GreenLED", configMINIMAL_STACK_SIZE, NULL, mainLED_TASK_PRIORITY, NULL );
	xTaskCreate( vUART0TransmitService, "UART0Tx", configMINIMAL_STACK_SIZE, NULL, mainUART_PRIORITY, NULL );
    2254:	02 e0       	ldi	r16, 0x02	; 2
    2256:	20 e0       	ldi	r18, 0x00	; 0
    2258:	30 e0       	ldi	r19, 0x00	; 0
    225a:	45 e5       	ldi	r20, 0x55	; 85
    225c:	50 e0       	ldi	r21, 0x00	; 0
    225e:	64 e1       	ldi	r22, 0x14	; 20
    2260:	71 e0       	ldi	r23, 0x01	; 1
    2262:	84 ea       	ldi	r24, 0xA4	; 164
    2264:	90 e1       	ldi	r25, 0x10	; 16
    2266:	0e 94 38 09 	call	0x1270	; 0x1270 <xTaskCreate>
	xTaskCreate( vUART1TransmitService, "UART1Tx", configMINIMAL_STACK_SIZE, NULL, mainUART_PRIORITY, NULL );
    226a:	20 e0       	ldi	r18, 0x00	; 0
    226c:	30 e0       	ldi	r19, 0x00	; 0
    226e:	45 e5       	ldi	r20, 0x55	; 85
    2270:	50 e0       	ldi	r21, 0x00	; 0
    2272:	6c e1       	ldi	r22, 0x1C	; 28
    2274:	71 e0       	ldi	r23, 0x01	; 1
    2276:	83 e9       	ldi	r24, 0x93	; 147
    2278:	90 e1       	ldi	r25, 0x10	; 16
    227a:	0e 94 38 09 	call	0x1270	; 0x1270 <xTaskCreate>
	xTaskCreate( vUART0ReceiveService, "UART0Rx", configMINIMAL_STACK_SIZE, NULL, mainUART_PRIORITY, NULL );
    227e:	20 e0       	ldi	r18, 0x00	; 0
    2280:	30 e0       	ldi	r19, 0x00	; 0
    2282:	45 e5       	ldi	r20, 0x55	; 85
    2284:	50 e0       	ldi	r21, 0x00	; 0
    2286:	64 e2       	ldi	r22, 0x24	; 36
    2288:	71 e0       	ldi	r23, 0x01	; 1
    228a:	85 e8       	ldi	r24, 0x85	; 133
    228c:	90 e1       	ldi	r25, 0x10	; 16
    228e:	0e 94 38 09 	call	0x1270	; 0x1270 <xTaskCreate>
	xTaskCreate( vUART1ReceiveService, "UART1Rx", configMINIMAL_STACK_SIZE, NULL, mainUART_PRIORITY, NULL );
    2292:	20 e0       	ldi	r18, 0x00	; 0
    2294:	30 e0       	ldi	r19, 0x00	; 0
    2296:	45 e5       	ldi	r20, 0x55	; 85
    2298:	50 e0       	ldi	r21, 0x00	; 0
    229a:	6c e2       	ldi	r22, 0x2C	; 44
    229c:	71 e0       	ldi	r23, 0x01	; 1
    229e:	84 e7       	ldi	r24, 0x74	; 116
    22a0:	90 e1       	ldi	r25, 0x10	; 16
    22a2:	0e 94 38 09 	call	0x1270	; 0x1270 <xTaskCreate>

	vTaskStartScheduler();
    22a6:	0e 94 95 0a 	call	0x152a	; 0x152a <vTaskStartScheduler>

	return 0;
}
    22aa:	80 e0       	ldi	r24, 0x00	; 0
    22ac:	90 e0       	ldi	r25, 0x00	; 0
    22ae:	0f 91       	pop	r16
    22b0:	ff 90       	pop	r15
    22b2:	ef 90       	pop	r14
    22b4:	08 95       	ret

000022b6 <vApplicationIdleHook>:
		xQueueSendToBack( queue, message+i, pdMS_TO_TICKS(50));
	}
}

void vApplicationIdleHook( void ) {
	PORTB ^= (1 << PB1);
    22b6:	98 b3       	in	r25, 0x18	; 24
    22b8:	82 e0       	ldi	r24, 0x02	; 2
    22ba:	89 27       	eor	r24, r25
    22bc:	88 bb       	out	0x18, r24	; 24
    22be:	08 95       	ret

000022c0 <__vector_18>:
}

ISR(USART0_RX_vect) {
    22c0:	1f 92       	push	r1
    22c2:	0f 92       	push	r0
    22c4:	0f b6       	in	r0, 0x3f	; 63
    22c6:	0f 92       	push	r0
    22c8:	11 24       	eor	r1, r1
    22ca:	2f 93       	push	r18
    22cc:	3f 93       	push	r19
    22ce:	4f 93       	push	r20
    22d0:	5f 93       	push	r21
    22d2:	6f 93       	push	r22
    22d4:	7f 93       	push	r23
    22d6:	8f 93       	push	r24
    22d8:	9f 93       	push	r25
    22da:	af 93       	push	r26
    22dc:	bf 93       	push	r27
    22de:	ef 93       	push	r30
    22e0:	ff 93       	push	r31
	xQueueSendToBackFromISR( bufferReceiveUART0Serial, &UDR0, NULL);
    22e2:	20 e0       	ldi	r18, 0x00	; 0
    22e4:	40 e0       	ldi	r20, 0x00	; 0
    22e6:	50 e0       	ldi	r21, 0x00	; 0
    22e8:	6c e2       	ldi	r22, 0x2C	; 44
    22ea:	70 e0       	ldi	r23, 0x00	; 0
    22ec:	80 91 f5 0d 	lds	r24, 0x0DF5	; 0x800df5 <bufferReceiveUART0Serial>
    22f0:	90 91 f6 0d 	lds	r25, 0x0DF6	; 0x800df6 <bufferReceiveUART0Serial+0x1>
    22f4:	0e 94 63 06 	call	0xcc6	; 0xcc6 <xQueueGenericSendFromISR>
}
    22f8:	ff 91       	pop	r31
    22fa:	ef 91       	pop	r30
    22fc:	bf 91       	pop	r27
    22fe:	af 91       	pop	r26
    2300:	9f 91       	pop	r25
    2302:	8f 91       	pop	r24
    2304:	7f 91       	pop	r23
    2306:	6f 91       	pop	r22
    2308:	5f 91       	pop	r21
    230a:	4f 91       	pop	r20
    230c:	3f 91       	pop	r19
    230e:	2f 91       	pop	r18
    2310:	0f 90       	pop	r0
    2312:	0f be       	out	0x3f, r0	; 63
    2314:	0f 90       	pop	r0
    2316:	1f 90       	pop	r1
    2318:	18 95       	reti

0000231a <__vector_30>:

ISR(USART1_RX_vect) {
    231a:	1f 92       	push	r1
    231c:	0f 92       	push	r0
    231e:	0f b6       	in	r0, 0x3f	; 63
    2320:	0f 92       	push	r0
    2322:	11 24       	eor	r1, r1
    2324:	2f 93       	push	r18
    2326:	3f 93       	push	r19
    2328:	4f 93       	push	r20
    232a:	5f 93       	push	r21
    232c:	6f 93       	push	r22
    232e:	7f 93       	push	r23
    2330:	8f 93       	push	r24
    2332:	9f 93       	push	r25
    2334:	af 93       	push	r26
    2336:	bf 93       	push	r27
    2338:	ef 93       	push	r30
    233a:	ff 93       	push	r31
	xQueueSendToBackFromISR( bufferReceiveUART1Bluetooth, &UDR1, NULL);
    233c:	20 e0       	ldi	r18, 0x00	; 0
    233e:	40 e0       	ldi	r20, 0x00	; 0
    2340:	50 e0       	ldi	r21, 0x00	; 0
    2342:	6c e9       	ldi	r22, 0x9C	; 156
    2344:	70 e0       	ldi	r23, 0x00	; 0
    2346:	80 91 d3 0d 	lds	r24, 0x0DD3	; 0x800dd3 <bufferReceiveUART1Bluetooth>
    234a:	90 91 d4 0d 	lds	r25, 0x0DD4	; 0x800dd4 <bufferReceiveUART1Bluetooth+0x1>
    234e:	0e 94 63 06 	call	0xcc6	; 0xcc6 <xQueueGenericSendFromISR>
}
    2352:	ff 91       	pop	r31
    2354:	ef 91       	pop	r30
    2356:	bf 91       	pop	r27
    2358:	af 91       	pop	r26
    235a:	9f 91       	pop	r25
    235c:	8f 91       	pop	r24
    235e:	7f 91       	pop	r23
    2360:	6f 91       	pop	r22
    2362:	5f 91       	pop	r21
    2364:	4f 91       	pop	r20
    2366:	3f 91       	pop	r19
    2368:	2f 91       	pop	r18
    236a:	0f 90       	pop	r0
    236c:	0f be       	out	0x3f, r0	; 63
    236e:	0f 90       	pop	r0
    2370:	1f 90       	pop	r1
    2372:	18 95       	reti

00002374 <USART_Init>:
#define UBRR_UART0 (uint16_t)(F_CPU/(16*BAUD_UART0)-1)
#define UBRR_UART1 (uint16_t)(F_CPU/(16*BAUD_UART1)-1)

void USART_Init(void) {
	/* Set baud rate UART0 */
	UBRR0H = (uint8_t)(UBRR_UART0>>8);
    2374:	10 92 90 00 	sts	0x0090, r1	; 0x800090 <__TEXT_REGION_LENGTH__+0x7e0090>
	UBRR0L = (uint8_t)UBRR_UART0;
    2378:	85 e0       	ldi	r24, 0x05	; 5
    237a:	89 b9       	out	0x09, r24	; 9
	/* Set baud rate UART1 */
	UBRR1H = (uint8_t)(UBRR_UART1>>8);
    237c:	10 92 98 00 	sts	0x0098, r1	; 0x800098 <__TEXT_REGION_LENGTH__+0x7e0098>
	UBRR1L = (uint8_t)UBRR_UART1;
    2380:	87 e4       	ldi	r24, 0x47	; 71
    2382:	80 93 99 00 	sts	0x0099, r24	; 0x800099 <__TEXT_REGION_LENGTH__+0x7e0099>

	/* Enable receiver and transmitter UART0 */
	UCSR0B = (1<<RXEN0)|(1<<TXEN0);
    2386:	88 e1       	ldi	r24, 0x18	; 24
    2388:	8a b9       	out	0x0a, r24	; 10
	/* Enable receiver and transmitter UART1 */
	UCSR1B = (1<<RXEN1)|(1<<TXEN1);
    238a:	80 93 9a 00 	sts	0x009A, r24	; 0x80009a <__TEXT_REGION_LENGTH__+0x7e009a>
    238e:	08 95       	ret

00002390 <USART_SendByte>:
	/* Wait for empty transmit buffer */
	//while ( !( UCSR0A & (1<<UDRE0)) );
	while(!UDRE0);

	/* Put data into buffer, sends the data */
	UDR0 = data;
    2390:	8c b9       	out	0x0c, r24	; 12
    2392:	08 95       	ret

00002394 <USART0_SendChar>:

	/* Wait for empty transmit buffer */
	while(!UDRE0);

	/* Put data into buffer, sends the data */
	UDR0 = c;
    2394:	8c b9       	out	0x0c, r24	; 12
    2396:	08 95       	ret

00002398 <USART0_SendString>:
}

// Max 256 characters
void USART0_SendString(unsigned char *str) {
    2398:	dc 01       	movw	r26, r24

	for(uint8_t i = 0; str[i] != '\0'; ++i) {
    239a:	9c 91       	ld	r25, X
    239c:	99 23       	and	r25, r25
    239e:	59 f0       	breq	.+22     	; 0x23b6 <USART0_SendString+0x1e>
    23a0:	20 e0       	ldi	r18, 0x00	; 0
		while(!( UCSR0A & (1<<UDRE0)));		// Wait for empty transmit buffer
    23a2:	5d 9b       	sbis	0x0b, 5	; 11
    23a4:	fe cf       	rjmp	.-4      	; 0x23a2 <USART0_SendString+0xa>
		UDR0 = str[i];						// Put character into buffer and send
    23a6:	9c b9       	out	0x0c, r25	; 12
}

// Max 256 characters
void USART0_SendString(unsigned char *str) {

	for(uint8_t i = 0; str[i] != '\0'; ++i) {
    23a8:	2f 5f       	subi	r18, 0xFF	; 255
    23aa:	fd 01       	movw	r30, r26
    23ac:	e2 0f       	add	r30, r18
    23ae:	f1 1d       	adc	r31, r1
    23b0:	90 81       	ld	r25, Z
    23b2:	91 11       	cpse	r25, r1
    23b4:	f6 cf       	rjmp	.-20     	; 0x23a2 <USART0_SendString+0xa>
    23b6:	08 95       	ret

000023b8 <USART_ReceiveByte>:
	}
}

// Wait until a byte has been received and return received data
uint8_t USART_ReceiveByte() {
	while((UCSR0A &(1<<RXC)) == 0);
    23b8:	5f 9b       	sbis	0x0b, 7	; 11
    23ba:	fe cf       	rjmp	.-4      	; 0x23b8 <USART_ReceiveByte>
	return UDR0;
    23bc:	8c b1       	in	r24, 0x0c	; 12
    23be:	08 95       	ret

000023c0 <makeMessage>:
#include "message.h"
#include "msgHeaders.h"

void makeMessage(Message* message, uint8_t type, uint8_t id, uint8_t* data) {
    23c0:	fc 01       	movw	r30, r24
	message->type = type;
    23c2:	60 83       	st	Z, r22
	message->id = id;
    23c4:	41 83       	std	Z+1, r20	; 0x01
	message->data = data;
    23c6:	33 83       	std	Z+3, r19	; 0x03
    23c8:	22 83       	std	Z+2, r18	; 0x02
    23ca:	08 95       	ret

000023cc <getMessage>:
}

void getMessage(Message* message, uint8_t* buffer) {
    23cc:	cf 93       	push	r28
    23ce:	df 93       	push	r29
    23d0:	ec 01       	movw	r28, r24
    23d2:	db 01       	movw	r26, r22
	uint8_t c = 0;
	buffer[c++] = START;
    23d4:	8b e7       	ldi	r24, 0x7B	; 123
    23d6:	8c 93       	st	X, r24
	buffer[c++] = message->type;
    23d8:	88 81       	ld	r24, Y
    23da:	11 96       	adiw	r26, 0x01	; 1
    23dc:	8c 93       	st	X, r24
    23de:	11 97       	sbiw	r26, 0x01	; 1
	buffer[c++] = message->id;
    23e0:	89 81       	ldd	r24, Y+1	; 0x01
    23e2:	12 96       	adiw	r26, 0x02	; 2
    23e4:	8c 93       	st	X, r24
    23e6:	12 97       	sbiw	r26, 0x02	; 2
	switch(message->type) {
    23e8:	88 81       	ld	r24, Y
    23ea:	81 34       	cpi	r24, 0x41	; 65
    23ec:	c9 f4       	brne	.+50     	; 0x2420 <getMessage+0x54>
		case TEXT:
			for(int i = 0; message->data[i] != 0; ++i) {
    23ee:	ea 81       	ldd	r30, Y+2	; 0x02
    23f0:	fb 81       	ldd	r31, Y+3	; 0x03
    23f2:	90 81       	ld	r25, Z
    23f4:	99 23       	and	r25, r25
    23f6:	e1 f0       	breq	.+56     	; 0x2430 <getMessage+0x64>
    23f8:	40 e0       	ldi	r20, 0x00	; 0
    23fa:	50 e0       	ldi	r21, 0x00	; 0
    23fc:	23 e0       	ldi	r18, 0x03	; 3
				buffer[c++] = message->data[i];
    23fe:	31 e0       	ldi	r19, 0x01	; 1
    2400:	32 0f       	add	r19, r18
    2402:	fd 01       	movw	r30, r26
    2404:	e2 0f       	add	r30, r18
    2406:	f1 1d       	adc	r31, r1
    2408:	90 83       	st	Z, r25
	buffer[c++] = START;
	buffer[c++] = message->type;
	buffer[c++] = message->id;
	switch(message->type) {
		case TEXT:
			for(int i = 0; message->data[i] != 0; ++i) {
    240a:	4f 5f       	subi	r20, 0xFF	; 255
    240c:	5f 4f       	sbci	r21, 0xFF	; 255
    240e:	ea 81       	ldd	r30, Y+2	; 0x02
    2410:	fb 81       	ldd	r31, Y+3	; 0x03
    2412:	e4 0f       	add	r30, r20
    2414:	f5 1f       	adc	r31, r21
    2416:	90 81       	ld	r25, Z
				buffer[c++] = message->data[i];
    2418:	23 2f       	mov	r18, r19
	buffer[c++] = START;
	buffer[c++] = message->type;
	buffer[c++] = message->id;
	switch(message->type) {
		case TEXT:
			for(int i = 0; message->data[i] != 0; ++i) {
    241a:	91 11       	cpse	r25, r1
    241c:	f0 cf       	rjmp	.-32     	; 0x23fe <getMessage+0x32>
    241e:	09 c0       	rjmp	.+18     	; 0x2432 <getMessage+0x66>
			}
			break;
		case LIGHT_SENSOR:
		case SOUND_SENSOR:
		default:
			buffer[c++] = *(message->data);
    2420:	ea 81       	ldd	r30, Y+2	; 0x02
    2422:	fb 81       	ldd	r31, Y+3	; 0x03
    2424:	80 81       	ld	r24, Z
    2426:	13 96       	adiw	r26, 0x03	; 3
    2428:	8c 93       	st	X, r24
    242a:	13 97       	sbiw	r26, 0x03	; 3
    242c:	34 e0       	ldi	r19, 0x04	; 4
			break;
    242e:	01 c0       	rjmp	.+2      	; 0x2432 <getMessage+0x66>
	buffer[c++] = START;
	buffer[c++] = message->type;
	buffer[c++] = message->id;
	switch(message->type) {
		case TEXT:
			for(int i = 0; message->data[i] != 0; ++i) {
    2430:	33 e0       	ldi	r19, 0x03	; 3
		case SOUND_SENSOR:
		default:
			buffer[c++] = *(message->data);
			break;
	}
	buffer[c++] = END;
    2432:	fd 01       	movw	r30, r26
    2434:	e3 0f       	add	r30, r19
    2436:	f1 1d       	adc	r31, r1
    2438:	8d e7       	ldi	r24, 0x7D	; 125
    243a:	80 83       	st	Z, r24
	buffer[c] = 0;
    243c:	3f 5f       	subi	r19, 0xFF	; 255
    243e:	a3 0f       	add	r26, r19
    2440:	b1 1d       	adc	r27, r1
    2442:	1c 92       	st	X, r1
}
    2444:	df 91       	pop	r29
    2446:	cf 91       	pop	r28
    2448:	08 95       	ret

0000244a <memcpy>:
    244a:	fb 01       	movw	r30, r22
    244c:	dc 01       	movw	r26, r24
    244e:	02 c0       	rjmp	.+4      	; 0x2454 <memcpy+0xa>
    2450:	01 90       	ld	r0, Z+
    2452:	0d 92       	st	X+, r0
    2454:	41 50       	subi	r20, 0x01	; 1
    2456:	50 40       	sbci	r21, 0x00	; 0
    2458:	d8 f7       	brcc	.-10     	; 0x2450 <memcpy+0x6>
    245a:	08 95       	ret

0000245c <_exit>:
    245c:	f8 94       	cli

0000245e <__stop_program>:
    245e:	ff cf       	rjmp	.-2      	; 0x245e <__stop_program>
