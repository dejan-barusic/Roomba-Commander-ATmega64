
RoombaCommander_ATmega64.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000040  00800100  00002a66  00002afa  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002a66  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000ce3  00800140  00800140  00002b3a  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002b3a  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00002b6c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000004b8  00000000  00000000  00002ba8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00005883  00000000  00000000  00003060  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000183b  00000000  00000000  000088e3  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000306a  00000000  00000000  0000a11e  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000ef4  00000000  00000000  0000d188  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001a02  00000000  00000000  0000e07c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000050e6  00000000  00000000  0000fa7e  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000004a8  00000000  00000000  00014b64  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 46 00 	jmp	0x8c	; 0x8c <__ctors_end>
       4:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
       8:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
       c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      10:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      14:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      18:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      1c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      20:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      24:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      28:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      2c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      30:	0c 94 e9 05 	jmp	0xbd2	; 0xbd2 <__vector_12>
      34:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      38:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      3c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      40:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      44:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      48:	0c 94 48 13 	jmp	0x2690	; 0x2690 <__vector_18>
      4c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      50:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      54:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      58:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      5c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      60:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      64:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      68:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      6c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      70:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      74:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      78:	0c 94 75 13 	jmp	0x26ea	; 0x26ea <__vector_30>
      7c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      80:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      84:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
      88:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>

0000008c <__ctors_end>:
      8c:	11 24       	eor	r1, r1
      8e:	1f be       	out	0x3f, r1	; 63
      90:	cf ef       	ldi	r28, 0xFF	; 255
      92:	d0 e1       	ldi	r29, 0x10	; 16
      94:	de bf       	out	0x3e, r29	; 62
      96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
      98:	11 e0       	ldi	r17, 0x01	; 1
      9a:	a0 e0       	ldi	r26, 0x00	; 0
      9c:	b1 e0       	ldi	r27, 0x01	; 1
      9e:	e6 e6       	ldi	r30, 0x66	; 102
      a0:	fa e2       	ldi	r31, 0x2A	; 42
      a2:	02 c0       	rjmp	.+4      	; 0xa8 <__do_copy_data+0x10>
      a4:	05 90       	lpm	r0, Z+
      a6:	0d 92       	st	X+, r0
      a8:	a0 34       	cpi	r26, 0x40	; 64
      aa:	b1 07       	cpc	r27, r17
      ac:	d9 f7       	brne	.-10     	; 0xa4 <__do_copy_data+0xc>

000000ae <__do_clear_bss>:
      ae:	2e e0       	ldi	r18, 0x0E	; 14
      b0:	a0 e4       	ldi	r26, 0x40	; 64
      b2:	b1 e0       	ldi	r27, 0x01	; 1
      b4:	01 c0       	rjmp	.+2      	; 0xb8 <.do_clear_bss_start>

000000b6 <.do_clear_bss_loop>:
      b6:	1d 92       	st	X+, r1

000000b8 <.do_clear_bss_start>:
      b8:	a3 32       	cpi	r26, 0x23	; 35
      ba:	b2 07       	cpc	r27, r18
      bc:	e1 f7       	brne	.-8      	; 0xb6 <.do_clear_bss_loop>
      be:	0e 94 88 12 	call	0x2510	; 0x2510 <main>
      c2:	0c 94 31 15 	jmp	0x2a62	; 0x2a62 <_exit>

000000c6 <__bad_interrupt>:
      c6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ca <prvInitialiseCoRoutineLists>:
	return;
}
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
      ca:	cf 93       	push	r28
UBaseType_t uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
      cc:	c0 e0       	ldi	r28, 0x00	; 0
      ce:	10 c0       	rjmp	.+32     	; 0xf0 <prvInitialiseCoRoutineLists+0x26>
	{
		vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
      d0:	8c 2f       	mov	r24, r28
      d2:	90 e0       	ldi	r25, 0x00	; 0
      d4:	9c 01       	movw	r18, r24
      d6:	22 0f       	add	r18, r18
      d8:	33 1f       	adc	r19, r19
      da:	22 0f       	add	r18, r18
      dc:	33 1f       	adc	r19, r19
      de:	22 0f       	add	r18, r18
      e0:	33 1f       	adc	r19, r19
      e2:	82 0f       	add	r24, r18
      e4:	93 1f       	adc	r25, r19
      e6:	88 59       	subi	r24, 0x98	; 152
      e8:	9e 4f       	sbci	r25, 0xFE	; 254
      ea:	0e 94 04 04 	call	0x808	; 0x808 <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
      ee:	cf 5f       	subi	r28, 0xFF	; 255
      f0:	c2 30       	cpi	r28, 0x02	; 2
      f2:	70 f3       	brcs	.-36     	; 0xd0 <prvInitialiseCoRoutineLists+0x6>
	{
		vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
      f4:	8f e5       	ldi	r24, 0x5F	; 95
      f6:	91 e0       	ldi	r25, 0x01	; 1
      f8:	0e 94 04 04 	call	0x808	; 0x808 <vListInitialise>
	vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
      fc:	86 e5       	ldi	r24, 0x56	; 86
      fe:	91 e0       	ldi	r25, 0x01	; 1
     100:	0e 94 04 04 	call	0x808	; 0x808 <vListInitialise>
	vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
     104:	89 e4       	ldi	r24, 0x49	; 73
     106:	91 e0       	ldi	r25, 0x01	; 1
     108:	0e 94 04 04 	call	0x808	; 0x808 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
     10c:	8f e5       	ldi	r24, 0x5F	; 95
     10e:	91 e0       	ldi	r25, 0x01	; 1
     110:	90 93 55 01 	sts	0x0155, r25	; 0x800155 <pxDelayedCoRoutineList+0x1>
     114:	80 93 54 01 	sts	0x0154, r24	; 0x800154 <pxDelayedCoRoutineList>
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
     118:	86 e5       	ldi	r24, 0x56	; 86
     11a:	91 e0       	ldi	r25, 0x01	; 1
     11c:	90 93 53 01 	sts	0x0153, r25	; 0x800153 <pxOverflowDelayedCoRoutineList+0x1>
     120:	80 93 52 01 	sts	0x0152, r24	; 0x800152 <pxOverflowDelayedCoRoutineList>
}
     124:	cf 91       	pop	r28
     126:	08 95       	ret

00000128 <prvCheckPendingReadyList>:
	}
}
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
     128:	0f 93       	push	r16
     12a:	1f 93       	push	r17
     12c:	cf 93       	push	r28
     12e:	df 93       	push	r29
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     130:	28 c0       	rjmp	.+80     	; 0x182 <prvCheckPendingReadyList+0x5a>
	{
		CRCB_t *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
     132:	f8 94       	cli
		{
			pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
     134:	e0 91 4e 01 	lds	r30, 0x014E	; 0x80014e <xPendingReadyCoRoutineList+0x5>
     138:	f0 91 4f 01 	lds	r31, 0x014F	; 0x80014f <xPendingReadyCoRoutineList+0x6>
     13c:	c6 81       	ldd	r28, Z+6	; 0x06
     13e:	d7 81       	ldd	r29, Z+7	; 0x07
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     140:	ce 01       	movw	r24, r28
     142:	0c 96       	adiw	r24, 0x0c	; 12
     144:	0e 94 68 04 	call	0x8d0	; 0x8d0 <uxListRemove>
		}
		portENABLE_INTERRUPTS();
     148:	78 94       	sei

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
     14a:	8e 01       	movw	r16, r28
     14c:	0e 5f       	subi	r16, 0xFE	; 254
     14e:	1f 4f       	sbci	r17, 0xFF	; 255
     150:	c8 01       	movw	r24, r16
     152:	0e 94 68 04 	call	0x8d0	; 0x8d0 <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
     156:	8e 89       	ldd	r24, Y+22	; 0x16
     158:	90 91 46 01 	lds	r25, 0x0146	; 0x800146 <uxTopCoRoutineReadyPriority>
     15c:	98 17       	cp	r25, r24
     15e:	10 f4       	brcc	.+4      	; 0x164 <prvCheckPendingReadyList+0x3c>
     160:	80 93 46 01 	sts	0x0146, r24	; 0x800146 <uxTopCoRoutineReadyPriority>
     164:	90 e0       	ldi	r25, 0x00	; 0
     166:	9c 01       	movw	r18, r24
     168:	22 0f       	add	r18, r18
     16a:	33 1f       	adc	r19, r19
     16c:	22 0f       	add	r18, r18
     16e:	33 1f       	adc	r19, r19
     170:	22 0f       	add	r18, r18
     172:	33 1f       	adc	r19, r19
     174:	82 0f       	add	r24, r18
     176:	93 1f       	adc	r25, r19
     178:	b8 01       	movw	r22, r16
     17a:	88 59       	subi	r24, 0x98	; 152
     17c:	9e 4f       	sbci	r25, 0xFE	; 254
     17e:	0e 94 16 04 	call	0x82c	; 0x82c <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     182:	80 91 49 01 	lds	r24, 0x0149	; 0x800149 <xPendingReadyCoRoutineList>
     186:	81 11       	cpse	r24, r1
     188:	d4 cf       	rjmp	.-88     	; 0x132 <prvCheckPendingReadyList+0xa>
		portENABLE_INTERRUPTS();

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
	}
}
     18a:	df 91       	pop	r29
     18c:	cf 91       	pop	r28
     18e:	1f 91       	pop	r17
     190:	0f 91       	pop	r16
     192:	08 95       	ret

00000194 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
     194:	0f 93       	push	r16
     196:	1f 93       	push	r17
     198:	cf 93       	push	r28
     19a:	df 93       	push	r29
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
     19c:	0e 94 56 0c 	call	0x18ac	; 0x18ac <xTaskGetTickCount>
     1a0:	20 91 42 01 	lds	r18, 0x0142	; 0x800142 <xLastTickCount>
     1a4:	30 91 43 01 	lds	r19, 0x0143	; 0x800143 <xLastTickCount+0x1>
     1a8:	82 1b       	sub	r24, r18
     1aa:	93 0b       	sbc	r25, r19
     1ac:	90 93 41 01 	sts	0x0141, r25	; 0x800141 <__data_end+0x1>
     1b0:	80 93 40 01 	sts	0x0140, r24	; 0x800140 <__data_end>
	while( xPassedTicks )
     1b4:	5e c0       	rjmp	.+188    	; 0x272 <prvCheckDelayedList+0xde>
	{
		xCoRoutineTickCount++;
     1b6:	20 91 44 01 	lds	r18, 0x0144	; 0x800144 <xCoRoutineTickCount>
     1ba:	30 91 45 01 	lds	r19, 0x0145	; 0x800145 <xCoRoutineTickCount+0x1>
     1be:	2f 5f       	subi	r18, 0xFF	; 255
     1c0:	3f 4f       	sbci	r19, 0xFF	; 255
     1c2:	30 93 45 01 	sts	0x0145, r19	; 0x800145 <xCoRoutineTickCount+0x1>
     1c6:	20 93 44 01 	sts	0x0144, r18	; 0x800144 <xCoRoutineTickCount>
		xPassedTicks--;
     1ca:	01 97       	sbiw	r24, 0x01	; 1
     1cc:	90 93 41 01 	sts	0x0141, r25	; 0x800141 <__data_end+0x1>
     1d0:	80 93 40 01 	sts	0x0140, r24	; 0x800140 <__data_end>

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
     1d4:	23 2b       	or	r18, r19
     1d6:	09 f0       	breq	.+2      	; 0x1da <prvCheckDelayedList+0x46>
     1d8:	45 c0       	rjmp	.+138    	; 0x264 <prvCheckDelayedList+0xd0>
		{
			List_t * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
     1da:	80 91 54 01 	lds	r24, 0x0154	; 0x800154 <pxDelayedCoRoutineList>
     1de:	90 91 55 01 	lds	r25, 0x0155	; 0x800155 <pxDelayedCoRoutineList+0x1>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
     1e2:	20 91 52 01 	lds	r18, 0x0152	; 0x800152 <pxOverflowDelayedCoRoutineList>
     1e6:	30 91 53 01 	lds	r19, 0x0153	; 0x800153 <pxOverflowDelayedCoRoutineList+0x1>
     1ea:	30 93 55 01 	sts	0x0155, r19	; 0x800155 <pxDelayedCoRoutineList+0x1>
     1ee:	20 93 54 01 	sts	0x0154, r18	; 0x800154 <pxDelayedCoRoutineList>
			pxOverflowDelayedCoRoutineList = pxTemp;
     1f2:	90 93 53 01 	sts	0x0153, r25	; 0x800153 <pxOverflowDelayedCoRoutineList+0x1>
     1f6:	80 93 52 01 	sts	0x0152, r24	; 0x800152 <pxOverflowDelayedCoRoutineList>
     1fa:	34 c0       	rjmp	.+104    	; 0x264 <prvCheckDelayedList+0xd0>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     1fc:	05 80       	ldd	r0, Z+5	; 0x05
     1fe:	f6 81       	ldd	r31, Z+6	; 0x06
     200:	e0 2d       	mov	r30, r0
     202:	c6 81       	ldd	r28, Z+6	; 0x06
     204:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
     206:	2a 81       	ldd	r18, Y+2	; 0x02
     208:	3b 81       	ldd	r19, Y+3	; 0x03
     20a:	80 91 44 01 	lds	r24, 0x0144	; 0x800144 <xCoRoutineTickCount>
     20e:	90 91 45 01 	lds	r25, 0x0145	; 0x800145 <xCoRoutineTickCount+0x1>
     212:	82 17       	cp	r24, r18
     214:	93 07       	cpc	r25, r19
     216:	68 f1       	brcs	.+90     	; 0x272 <prvCheckDelayedList+0xde>
			{
				/* Timeout not yet expired. */
				break;
			}

			portDISABLE_INTERRUPTS();
     218:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
     21a:	8e 01       	movw	r16, r28
     21c:	0e 5f       	subi	r16, 0xFE	; 254
     21e:	1f 4f       	sbci	r17, 0xFF	; 255
     220:	c8 01       	movw	r24, r16
     222:	0e 94 68 04 	call	0x8d0	; 0x8d0 <uxListRemove>

				/* Is the co-routine waiting on an event also? */
				if( pxCRCB->xEventListItem.pvContainer )
     226:	8c 89       	ldd	r24, Y+20	; 0x14
     228:	9d 89       	ldd	r25, Y+21	; 0x15
     22a:	89 2b       	or	r24, r25
     22c:	21 f0       	breq	.+8      	; 0x236 <prvCheckDelayedList+0xa2>
				{
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
     22e:	ce 01       	movw	r24, r28
     230:	0c 96       	adiw	r24, 0x0c	; 12
     232:	0e 94 68 04 	call	0x8d0	; 0x8d0 <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
     236:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );
     238:	8e 89       	ldd	r24, Y+22	; 0x16
     23a:	90 91 46 01 	lds	r25, 0x0146	; 0x800146 <uxTopCoRoutineReadyPriority>
     23e:	98 17       	cp	r25, r24
     240:	10 f4       	brcc	.+4      	; 0x246 <prvCheckDelayedList+0xb2>
     242:	80 93 46 01 	sts	0x0146, r24	; 0x800146 <uxTopCoRoutineReadyPriority>
     246:	90 e0       	ldi	r25, 0x00	; 0
     248:	9c 01       	movw	r18, r24
     24a:	22 0f       	add	r18, r18
     24c:	33 1f       	adc	r19, r19
     24e:	22 0f       	add	r18, r18
     250:	33 1f       	adc	r19, r19
     252:	22 0f       	add	r18, r18
     254:	33 1f       	adc	r19, r19
     256:	82 0f       	add	r24, r18
     258:	93 1f       	adc	r25, r19
     25a:	b8 01       	movw	r22, r16
     25c:	88 59       	subi	r24, 0x98	; 152
     25e:	9e 4f       	sbci	r25, 0xFE	; 254
     260:	0e 94 16 04 	call	0x82c	; 0x82c <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     264:	e0 91 54 01 	lds	r30, 0x0154	; 0x800154 <pxDelayedCoRoutineList>
     268:	f0 91 55 01 	lds	r31, 0x0155	; 0x800155 <pxDelayedCoRoutineList+0x1>
     26c:	80 81       	ld	r24, Z
     26e:	81 11       	cpse	r24, r1
     270:	c5 cf       	rjmp	.-118    	; 0x1fc <prvCheckDelayedList+0x68>
static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
     272:	80 91 40 01 	lds	r24, 0x0140	; 0x800140 <__data_end>
     276:	90 91 41 01 	lds	r25, 0x0141	; 0x800141 <__data_end+0x1>
     27a:	00 97       	sbiw	r24, 0x00	; 0
     27c:	09 f0       	breq	.+2      	; 0x280 <prvCheckDelayedList+0xec>
     27e:	9b cf       	rjmp	.-202    	; 0x1b6 <prvCheckDelayedList+0x22>

			prvAddCoRoutineToReadyQueue( pxCRCB );
		}
	}

	xLastTickCount = xCoRoutineTickCount;
     280:	80 91 44 01 	lds	r24, 0x0144	; 0x800144 <xCoRoutineTickCount>
     284:	90 91 45 01 	lds	r25, 0x0145	; 0x800145 <xCoRoutineTickCount+0x1>
     288:	90 93 43 01 	sts	0x0143, r25	; 0x800143 <xLastTickCount+0x1>
     28c:	80 93 42 01 	sts	0x0142, r24	; 0x800142 <xLastTickCount>
}
     290:	df 91       	pop	r29
     292:	cf 91       	pop	r28
     294:	1f 91       	pop	r17
     296:	0f 91       	pop	r16
     298:	08 95       	ret

0000029a <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, UBaseType_t uxPriority, UBaseType_t uxIndex )
{
     29a:	cf 92       	push	r12
     29c:	df 92       	push	r13
     29e:	ff 92       	push	r15
     2a0:	0f 93       	push	r16
     2a2:	1f 93       	push	r17
     2a4:	cf 93       	push	r28
     2a6:	df 93       	push	r29
     2a8:	6c 01       	movw	r12, r24
     2aa:	f6 2e       	mov	r15, r22
     2ac:	14 2f       	mov	r17, r20
BaseType_t xReturn;
CRCB_t *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
     2ae:	8a e1       	ldi	r24, 0x1A	; 26
     2b0:	90 e0       	ldi	r25, 0x00	; 0
     2b2:	0e 94 ec 05 	call	0xbd8	; 0xbd8 <pvPortMalloc>
     2b6:	ec 01       	movw	r28, r24
	if( pxCoRoutine )
     2b8:	89 2b       	or	r24, r25
     2ba:	09 f4       	brne	.+2      	; 0x2be <xCoRoutineCreate+0x24>
     2bc:	42 c0       	rjmp	.+132    	; 0x342 <xCoRoutineCreate+0xa8>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
     2be:	80 91 47 01 	lds	r24, 0x0147	; 0x800147 <pxCurrentCoRoutine>
     2c2:	90 91 48 01 	lds	r25, 0x0148	; 0x800148 <pxCurrentCoRoutine+0x1>
     2c6:	89 2b       	or	r24, r25
     2c8:	31 f4       	brne	.+12     	; 0x2d6 <xCoRoutineCreate+0x3c>
		{
			pxCurrentCoRoutine = pxCoRoutine;
     2ca:	d0 93 48 01 	sts	0x0148, r29	; 0x800148 <pxCurrentCoRoutine+0x1>
     2ce:	c0 93 47 01 	sts	0x0147, r28	; 0x800147 <pxCurrentCoRoutine>
			prvInitialiseCoRoutineLists();
     2d2:	0e 94 65 00 	call	0xca	; 0xca <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
     2d6:	81 e0       	ldi	r24, 0x01	; 1
     2d8:	8f 15       	cp	r24, r15
     2da:	10 f4       	brcc	.+4      	; 0x2e0 <xCoRoutineCreate+0x46>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
     2dc:	ff 24       	eor	r15, r15
     2de:	f3 94       	inc	r15
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
     2e0:	19 8e       	std	Y+25, r1	; 0x19
     2e2:	18 8e       	std	Y+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
     2e4:	fe 8a       	std	Y+22, r15	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
     2e6:	1f 8b       	std	Y+23, r17	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     2e8:	fe 01       	movw	r30, r28
     2ea:	c1 92       	st	Z+, r12
     2ec:	d1 92       	st	Z+, r13
     2ee:	8f 01       	movw	r16, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     2f0:	cf 01       	movw	r24, r30
     2f2:	0e 94 12 04 	call	0x824	; 0x824 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     2f6:	ce 01       	movw	r24, r28
     2f8:	0c 96       	adiw	r24, 0x0c	; 12
     2fa:	0e 94 12 04 	call	0x824	; 0x824 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the ListItem_t.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     2fe:	d9 87       	std	Y+9, r29	; 0x09
     300:	c8 87       	std	Y+8, r28	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     302:	db 8b       	std	Y+19, r29	; 0x13
     304:	ca 8b       	std	Y+18, r28	; 0x12

		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
     306:	82 e0       	ldi	r24, 0x02	; 2
     308:	90 e0       	ldi	r25, 0x00	; 0
     30a:	8f 19       	sub	r24, r15
     30c:	91 09       	sbc	r25, r1
     30e:	9d 87       	std	Y+13, r25	; 0x0d
     310:	8c 87       	std	Y+12, r24	; 0x0c

		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
     312:	8e 89       	ldd	r24, Y+22	; 0x16
     314:	90 91 46 01 	lds	r25, 0x0146	; 0x800146 <uxTopCoRoutineReadyPriority>
     318:	98 17       	cp	r25, r24
     31a:	10 f4       	brcc	.+4      	; 0x320 <xCoRoutineCreate+0x86>
     31c:	80 93 46 01 	sts	0x0146, r24	; 0x800146 <uxTopCoRoutineReadyPriority>
     320:	90 e0       	ldi	r25, 0x00	; 0
     322:	9c 01       	movw	r18, r24
     324:	22 0f       	add	r18, r18
     326:	33 1f       	adc	r19, r19
     328:	22 0f       	add	r18, r18
     32a:	33 1f       	adc	r19, r19
     32c:	22 0f       	add	r18, r18
     32e:	33 1f       	adc	r19, r19
     330:	82 0f       	add	r24, r18
     332:	93 1f       	adc	r25, r19
     334:	b8 01       	movw	r22, r16
     336:	88 59       	subi	r24, 0x98	; 152
     338:	9e 4f       	sbci	r25, 0xFE	; 254
     33a:	0e 94 16 04 	call	0x82c	; 0x82c <vListInsertEnd>

		xReturn = pdPASS;
     33e:	81 e0       	ldi	r24, 0x01	; 1
     340:	01 c0       	rjmp	.+2      	; 0x344 <xCoRoutineCreate+0xaa>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     342:	8f ef       	ldi	r24, 0xFF	; 255
	}

	return xReturn;
}
     344:	df 91       	pop	r29
     346:	cf 91       	pop	r28
     348:	1f 91       	pop	r17
     34a:	0f 91       	pop	r16
     34c:	ff 90       	pop	r15
     34e:	df 90       	pop	r13
     350:	cf 90       	pop	r12
     352:	08 95       	ret

00000354 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay, List_t *pxEventList )
{
     354:	0f 93       	push	r16
     356:	1f 93       	push	r17
     358:	cf 93       	push	r28
     35a:	df 93       	push	r29
     35c:	8b 01       	movw	r16, r22
TickType_t xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     35e:	c0 91 44 01 	lds	r28, 0x0144	; 0x800144 <xCoRoutineTickCount>
     362:	d0 91 45 01 	lds	r29, 0x0145	; 0x800145 <xCoRoutineTickCount+0x1>
     366:	c8 0f       	add	r28, r24
     368:	d9 1f       	adc	r29, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     36a:	80 91 47 01 	lds	r24, 0x0147	; 0x800147 <pxCurrentCoRoutine>
     36e:	90 91 48 01 	lds	r25, 0x0148	; 0x800148 <pxCurrentCoRoutine+0x1>
     372:	02 96       	adiw	r24, 0x02	; 2
     374:	0e 94 68 04 	call	0x8d0	; 0x8d0 <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     378:	e0 91 47 01 	lds	r30, 0x0147	; 0x800147 <pxCurrentCoRoutine>
     37c:	f0 91 48 01 	lds	r31, 0x0148	; 0x800148 <pxCurrentCoRoutine+0x1>
     380:	d3 83       	std	Z+3, r29	; 0x03
     382:	c2 83       	std	Z+2, r28	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
     384:	80 91 44 01 	lds	r24, 0x0144	; 0x800144 <xCoRoutineTickCount>
     388:	90 91 45 01 	lds	r25, 0x0145	; 0x800145 <xCoRoutineTickCount+0x1>
     38c:	c8 17       	cp	r28, r24
     38e:	d9 07       	cpc	r29, r25
     390:	50 f4       	brcc	.+20     	; 0x3a6 <vCoRoutineAddToDelayedList+0x52>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     392:	bf 01       	movw	r22, r30
     394:	6e 5f       	subi	r22, 0xFE	; 254
     396:	7f 4f       	sbci	r23, 0xFF	; 255
     398:	80 91 52 01 	lds	r24, 0x0152	; 0x800152 <pxOverflowDelayedCoRoutineList>
     39c:	90 91 53 01 	lds	r25, 0x0153	; 0x800153 <pxOverflowDelayedCoRoutineList+0x1>
     3a0:	0e 94 37 04 	call	0x86e	; 0x86e <vListInsert>
     3a4:	09 c0       	rjmp	.+18     	; 0x3b8 <vCoRoutineAddToDelayedList+0x64>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     3a6:	bf 01       	movw	r22, r30
     3a8:	6e 5f       	subi	r22, 0xFE	; 254
     3aa:	7f 4f       	sbci	r23, 0xFF	; 255
     3ac:	80 91 54 01 	lds	r24, 0x0154	; 0x800154 <pxDelayedCoRoutineList>
     3b0:	90 91 55 01 	lds	r25, 0x0155	; 0x800155 <pxDelayedCoRoutineList+0x1>
     3b4:	0e 94 37 04 	call	0x86e	; 0x86e <vListInsert>
	}

	if( pxEventList )
     3b8:	01 15       	cp	r16, r1
     3ba:	11 05       	cpc	r17, r1
     3bc:	49 f0       	breq	.+18     	; 0x3d0 <vCoRoutineAddToDelayedList+0x7c>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     3be:	60 91 47 01 	lds	r22, 0x0147	; 0x800147 <pxCurrentCoRoutine>
     3c2:	70 91 48 01 	lds	r23, 0x0148	; 0x800148 <pxCurrentCoRoutine+0x1>
     3c6:	64 5f       	subi	r22, 0xF4	; 244
     3c8:	7f 4f       	sbci	r23, 0xFF	; 255
     3ca:	c8 01       	movw	r24, r16
     3cc:	0e 94 37 04 	call	0x86e	; 0x86e <vListInsert>
	}
}
     3d0:	df 91       	pop	r29
     3d2:	cf 91       	pop	r28
     3d4:	1f 91       	pop	r17
     3d6:	0f 91       	pop	r16
     3d8:	08 95       	ret

000003da <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
     3da:	0e 94 94 00 	call	0x128	; 0x128 <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
     3de:	0e 94 ca 00 	call	0x194	; 0x194 <prvCheckDelayedList>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     3e2:	06 c0       	rjmp	.+12     	; 0x3f0 <vCoRoutineSchedule+0x16>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
     3e4:	88 23       	and	r24, r24
     3e6:	09 f4       	brne	.+2      	; 0x3ea <vCoRoutineSchedule+0x10>
     3e8:	4f c0       	rjmp	.+158    	; 0x488 <__LOCK_REGION_LENGTH__+0x88>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
     3ea:	81 50       	subi	r24, 0x01	; 1
     3ec:	80 93 46 01 	sts	0x0146, r24	; 0x800146 <uxTopCoRoutineReadyPriority>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     3f0:	80 91 46 01 	lds	r24, 0x0146	; 0x800146 <uxTopCoRoutineReadyPriority>
     3f4:	28 2f       	mov	r18, r24
     3f6:	30 e0       	ldi	r19, 0x00	; 0
     3f8:	f9 01       	movw	r30, r18
     3fa:	ee 0f       	add	r30, r30
     3fc:	ff 1f       	adc	r31, r31
     3fe:	ee 0f       	add	r30, r30
     400:	ff 1f       	adc	r31, r31
     402:	ee 0f       	add	r30, r30
     404:	ff 1f       	adc	r31, r31
     406:	e2 0f       	add	r30, r18
     408:	f3 1f       	adc	r31, r19
     40a:	e8 59       	subi	r30, 0x98	; 152
     40c:	fe 4f       	sbci	r31, 0xFE	; 254
     40e:	90 81       	ld	r25, Z
     410:	99 23       	and	r25, r25
     412:	41 f3       	breq	.-48     	; 0x3e4 <vCoRoutineSchedule+0xa>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
     414:	c9 01       	movw	r24, r18
     416:	88 0f       	add	r24, r24
     418:	99 1f       	adc	r25, r25
     41a:	88 0f       	add	r24, r24
     41c:	99 1f       	adc	r25, r25
     41e:	88 0f       	add	r24, r24
     420:	99 1f       	adc	r25, r25
     422:	82 0f       	add	r24, r18
     424:	93 1f       	adc	r25, r19
     426:	df 01       	movw	r26, r30
     428:	01 80       	ldd	r0, Z+1	; 0x01
     42a:	f2 81       	ldd	r31, Z+2	; 0x02
     42c:	e0 2d       	mov	r30, r0
     42e:	02 80       	ldd	r0, Z+2	; 0x02
     430:	f3 81       	ldd	r31, Z+3	; 0x03
     432:	e0 2d       	mov	r30, r0
     434:	12 96       	adiw	r26, 0x02	; 2
     436:	fc 93       	st	X, r31
     438:	ee 93       	st	-X, r30
     43a:	11 97       	sbiw	r26, 0x01	; 1
     43c:	85 59       	subi	r24, 0x95	; 149
     43e:	9e 4f       	sbci	r25, 0xFE	; 254
     440:	e8 17       	cp	r30, r24
     442:	f9 07       	cpc	r31, r25
     444:	29 f4       	brne	.+10     	; 0x450 <__LOCK_REGION_LENGTH__+0x50>
     446:	82 81       	ldd	r24, Z+2	; 0x02
     448:	93 81       	ldd	r25, Z+3	; 0x03
     44a:	fd 01       	movw	r30, r26
     44c:	92 83       	std	Z+2, r25	; 0x02
     44e:	81 83       	std	Z+1, r24	; 0x01
     450:	f9 01       	movw	r30, r18
     452:	ee 0f       	add	r30, r30
     454:	ff 1f       	adc	r31, r31
     456:	ee 0f       	add	r30, r30
     458:	ff 1f       	adc	r31, r31
     45a:	ee 0f       	add	r30, r30
     45c:	ff 1f       	adc	r31, r31
     45e:	2e 0f       	add	r18, r30
     460:	3f 1f       	adc	r19, r31
     462:	f9 01       	movw	r30, r18
     464:	e8 59       	subi	r30, 0x98	; 152
     466:	fe 4f       	sbci	r31, 0xFE	; 254
     468:	01 80       	ldd	r0, Z+1	; 0x01
     46a:	f2 81       	ldd	r31, Z+2	; 0x02
     46c:	e0 2d       	mov	r30, r0
     46e:	86 81       	ldd	r24, Z+6	; 0x06
     470:	97 81       	ldd	r25, Z+7	; 0x07
     472:	90 93 48 01 	sts	0x0148, r25	; 0x800148 <pxCurrentCoRoutine+0x1>
     476:	80 93 47 01 	sts	0x0147, r24	; 0x800147 <pxCurrentCoRoutine>

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
     47a:	dc 01       	movw	r26, r24
     47c:	ed 91       	ld	r30, X+
     47e:	fc 91       	ld	r31, X
     480:	11 97       	sbiw	r26, 0x01	; 1
     482:	57 96       	adiw	r26, 0x17	; 23
     484:	6c 91       	ld	r22, X
     486:	09 95       	icall
     488:	08 95       	ret

0000048a <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

BaseType_t xCoRoutineRemoveFromEventList( const List_t *pxEventList )
{
     48a:	0f 93       	push	r16
     48c:	1f 93       	push	r17
     48e:	cf 93       	push	r28
     490:	df 93       	push	r29
BaseType_t xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     492:	dc 01       	movw	r26, r24
     494:	15 96       	adiw	r26, 0x05	; 5
     496:	ed 91       	ld	r30, X+
     498:	fc 91       	ld	r31, X
     49a:	16 97       	sbiw	r26, 0x06	; 6
     49c:	c6 81       	ldd	r28, Z+6	; 0x06
     49e:	d7 81       	ldd	r29, Z+7	; 0x07
	( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     4a0:	8e 01       	movw	r16, r28
     4a2:	04 5f       	subi	r16, 0xF4	; 244
     4a4:	1f 4f       	sbci	r17, 0xFF	; 255
     4a6:	c8 01       	movw	r24, r16
     4a8:	0e 94 68 04 	call	0x8d0	; 0x8d0 <uxListRemove>
	vListInsertEnd( ( List_t * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
     4ac:	b8 01       	movw	r22, r16
     4ae:	89 e4       	ldi	r24, 0x49	; 73
     4b0:	91 e0       	ldi	r25, 0x01	; 1
     4b2:	0e 94 16 04 	call	0x82c	; 0x82c <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
     4b6:	9e 89       	ldd	r25, Y+22	; 0x16
     4b8:	e0 91 47 01 	lds	r30, 0x0147	; 0x800147 <pxCurrentCoRoutine>
     4bc:	f0 91 48 01 	lds	r31, 0x0148	; 0x800148 <pxCurrentCoRoutine+0x1>
     4c0:	86 89       	ldd	r24, Z+22	; 0x16
     4c2:	98 17       	cp	r25, r24
     4c4:	10 f0       	brcs	.+4      	; 0x4ca <xCoRoutineRemoveFromEventList+0x40>
	{
		xReturn = pdTRUE;
     4c6:	81 e0       	ldi	r24, 0x01	; 1
     4c8:	01 c0       	rjmp	.+2      	; 0x4cc <xCoRoutineRemoveFromEventList+0x42>
	}
	else
	{
		xReturn = pdFALSE;
     4ca:	80 e0       	ldi	r24, 0x00	; 0
	}

	return xReturn;
}
     4cc:	df 91       	pop	r29
     4ce:	cf 91       	pop	r28
     4d0:	1f 91       	pop	r17
     4d2:	0f 91       	pop	r16
     4d4:	08 95       	ret

000004d6 <prvTestWaitCondition>:

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
BaseType_t xWaitConditionMet = pdFALSE;

	if( xWaitForAllBits == pdFALSE )
     4d6:	41 11       	cpse	r20, r1
     4d8:	06 c0       	rjmp	.+12     	; 0x4e6 <prvTestWaitCondition+0x10>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
     4da:	68 23       	and	r22, r24
     4dc:	79 23       	and	r23, r25
     4de:	67 2b       	or	r22, r23
     4e0:	49 f4       	brne	.+18     	; 0x4f4 <prvTestWaitCondition+0x1e>
}
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
BaseType_t xWaitConditionMet = pdFALSE;
     4e2:	80 e0       	ldi	r24, 0x00	; 0
     4e4:	08 95       	ret
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
     4e6:	86 23       	and	r24, r22
     4e8:	97 23       	and	r25, r23
     4ea:	68 17       	cp	r22, r24
     4ec:	79 07       	cpc	r23, r25
     4ee:	21 f0       	breq	.+8      	; 0x4f8 <prvTestWaitCondition+0x22>
}
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
BaseType_t xWaitConditionMet = pdFALSE;
     4f0:	80 e0       	ldi	r24, 0x00	; 0
     4f2:	08 95       	ret
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
		{
			xWaitConditionMet = pdTRUE;
     4f4:	81 e0       	ldi	r24, 0x01	; 1
     4f6:	08 95       	ret
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
		{
			xWaitConditionMet = pdTRUE;
     4f8:	81 e0       	ldi	r24, 0x01	; 1
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
}
     4fa:	08 95       	ret

000004fc <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	EventGroupHandle_t xEventGroupCreate( void )
	{
     4fc:	cf 93       	push	r28
     4fe:	df 93       	push	r29
	EventGroup_t *pxEventBits;

		/* Allocate the event group. */
		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) );
     500:	8b e0       	ldi	r24, 0x0B	; 11
     502:	90 e0       	ldi	r25, 0x00	; 0
     504:	0e 94 ec 05 	call	0xbd8	; 0xbd8 <pvPortMalloc>
     508:	ec 01       	movw	r28, r24

		if( pxEventBits != NULL )
     50a:	00 97       	sbiw	r24, 0x00	; 0
     50c:	31 f0       	breq	.+12     	; 0x51a <xEventGroupCreate+0x1e>
		{
			pxEventBits->uxEventBits = 0;
     50e:	fc 01       	movw	r30, r24
     510:	11 92       	st	Z+, r1
     512:	11 92       	st	Z+, r1
     514:	cf 01       	movw	r24, r30
			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
     516:	0e 94 04 04 	call	0x808	; 0x808 <vListInitialise>
		{
			traceEVENT_GROUP_CREATE_FAILED();
		}

		return ( EventGroupHandle_t ) pxEventBits;
	}
     51a:	ce 01       	movw	r24, r28
     51c:	df 91       	pop	r29
     51e:	cf 91       	pop	r28
     520:	08 95       	ret

00000522 <xEventGroupWaitBits>:
	return uxReturn;
}
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
     522:	af 92       	push	r10
     524:	bf 92       	push	r11
     526:	cf 92       	push	r12
     528:	df 92       	push	r13
     52a:	ef 92       	push	r14
     52c:	ff 92       	push	r15
     52e:	0f 93       	push	r16
     530:	1f 93       	push	r17
     532:	cf 93       	push	r28
     534:	df 93       	push	r29
     536:	7c 01       	movw	r14, r24
     538:	5b 01       	movw	r10, r22
     53a:	c4 2e       	mov	r12, r20
     53c:	d2 2e       	mov	r13, r18
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     53e:	0e 94 50 0c 	call	0x18a0	; 0x18a0 <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
     542:	f7 01       	movw	r30, r14
     544:	c0 81       	ld	r28, Z
     546:	d1 81       	ldd	r29, Z+1	; 0x01

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
     548:	4d 2d       	mov	r20, r13
     54a:	b5 01       	movw	r22, r10
     54c:	ce 01       	movw	r24, r28
     54e:	0e 94 6b 02 	call	0x4d6	; 0x4d6 <prvTestWaitCondition>

		if( xWaitConditionMet != pdFALSE )
     552:	88 23       	and	r24, r24
     554:	69 f0       	breq	.+26     	; 0x570 <xEventGroupWaitBits+0x4e>
			block. */
			uxReturn = uxCurrentEventBits;
			xTicksToWait = ( TickType_t ) 0;

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
     556:	cc 20       	and	r12, r12
     558:	09 f1       	breq	.+66     	; 0x59c <xEventGroupWaitBits+0x7a>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     55a:	c5 01       	movw	r24, r10
     55c:	80 95       	com	r24
     55e:	90 95       	com	r25
     560:	8c 23       	and	r24, r28
     562:	9d 23       	and	r25, r29
     564:	f7 01       	movw	r30, r14
     566:	91 83       	std	Z+1, r25	; 0x01
     568:	80 83       	st	Z, r24
		if( xWaitConditionMet != pdFALSE )
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
			xTicksToWait = ( TickType_t ) 0;
     56a:	00 e0       	ldi	r16, 0x00	; 0
     56c:	10 e0       	ldi	r17, 0x00	; 0
     56e:	18 c0       	rjmp	.+48     	; 0x5a0 <xEventGroupWaitBits+0x7e>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
     570:	01 15       	cp	r16, r1
     572:	11 05       	cpc	r17, r1
     574:	a9 f0       	breq	.+42     	; 0x5a0 <xEventGroupWaitBits+0x7e>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
     576:	c1 10       	cpse	r12, r1
     578:	03 c0       	rjmp	.+6      	; 0x580 <xEventGroupWaitBits+0x5e>
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
EventBits_t uxReturn, uxControlBits = 0;
     57a:	60 e0       	ldi	r22, 0x00	; 0
     57c:	70 e0       	ldi	r23, 0x00	; 0
     57e:	02 c0       	rjmp	.+4      	; 0x584 <xEventGroupWaitBits+0x62>
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
     580:	60 e0       	ldi	r22, 0x00	; 0
     582:	71 e0       	ldi	r23, 0x01	; 1
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
     584:	d1 10       	cpse	r13, r1
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
     586:	74 60       	ori	r23, 0x04	; 4
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
     588:	6a 29       	or	r22, r10
     58a:	7b 29       	or	r23, r11
     58c:	a8 01       	movw	r20, r16
     58e:	c7 01       	movw	r24, r14
     590:	02 96       	adiw	r24, 0x02	; 2
     592:	0e 94 59 0e 	call	0x1cb2	; 0x1cb2 <vTaskPlaceOnUnorderedEventList>

			/* This is obsolete as it will get set after the task unblocks, but
			some compilers mistakenly generate a warning about the variable
			being returned without being set if it is not done. */
			uxReturn = 0;
     596:	c0 e0       	ldi	r28, 0x00	; 0
     598:	d0 e0       	ldi	r29, 0x00	; 0
     59a:	02 c0       	rjmp	.+4      	; 0x5a0 <xEventGroupWaitBits+0x7e>
		if( xWaitConditionMet != pdFALSE )
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
			xTicksToWait = ( TickType_t ) 0;
     59c:	00 e0       	ldi	r16, 0x00	; 0
     59e:	10 e0       	ldi	r17, 0x00	; 0
			uxReturn = 0;

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     5a0:	0e 94 2a 0d 	call	0x1a54	; 0x1a54 <xTaskResumeAll>

	if( xTicksToWait != ( TickType_t ) 0 )
     5a4:	01 2b       	or	r16, r17
     5a6:	19 f1       	breq	.+70     	; 0x5ee <xEventGroupWaitBits+0xcc>
	{
		if( xAlreadyYielded == pdFALSE )
     5a8:	81 11       	cpse	r24, r1
     5aa:	02 c0       	rjmp	.+4      	; 0x5b0 <xEventGroupWaitBits+0x8e>
		{
			portYIELD_WITHIN_API();
     5ac:	0e 94 34 05 	call	0xa68	; 0xa68 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     5b0:	0e 94 35 0f 	call	0x1e6a	; 0x1e6a <uxTaskResetEventItemValue>
     5b4:	ec 01       	movw	r28, r24

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     5b6:	91 fd       	sbrc	r25, 1
     5b8:	19 c0       	rjmp	.+50     	; 0x5ec <xEventGroupWaitBits+0xca>
		{
			taskENTER_CRITICAL();
     5ba:	0f b6       	in	r0, 0x3f	; 63
     5bc:	f8 94       	cli
     5be:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     5c0:	f7 01       	movw	r30, r14
     5c2:	c0 81       	ld	r28, Z
     5c4:	d1 81       	ldd	r29, Z+1	; 0x01

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
     5c6:	4d 2d       	mov	r20, r13
     5c8:	b5 01       	movw	r22, r10
     5ca:	ce 01       	movw	r24, r28
     5cc:	0e 94 6b 02 	call	0x4d6	; 0x4d6 <prvTestWaitCondition>
     5d0:	88 23       	and	r24, r24
     5d2:	51 f0       	breq	.+20     	; 0x5e8 <xEventGroupWaitBits+0xc6>
				{
					if( xClearOnExit != pdFALSE )
     5d4:	cc 20       	and	r12, r12
     5d6:	41 f0       	breq	.+16     	; 0x5e8 <xEventGroupWaitBits+0xc6>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     5d8:	b5 01       	movw	r22, r10
     5da:	60 95       	com	r22
     5dc:	70 95       	com	r23
     5de:	6c 23       	and	r22, r28
     5e0:	7d 23       	and	r23, r29
     5e2:	f7 01       	movw	r30, r14
     5e4:	71 83       	std	Z+1, r23	; 0x01
     5e6:	60 83       	st	Z, r22
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
     5e8:	0f 90       	pop	r0
     5ea:	0f be       	out	0x3f, r0	; 63
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     5ec:	dd 27       	eor	r29, r29
	}
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
}
     5ee:	ce 01       	movw	r24, r28
     5f0:	df 91       	pop	r29
     5f2:	cf 91       	pop	r28
     5f4:	1f 91       	pop	r17
     5f6:	0f 91       	pop	r16
     5f8:	ff 90       	pop	r15
     5fa:	ef 90       	pop	r14
     5fc:	df 90       	pop	r13
     5fe:	cf 90       	pop	r12
     600:	bf 90       	pop	r11
     602:	af 90       	pop	r10
     604:	08 95       	ret

00000606 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
     606:	fc 01       	movw	r30, r24
	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
     608:	0f b6       	in	r0, 0x3f	; 63
     60a:	f8 94       	cli
     60c:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
     60e:	80 81       	ld	r24, Z
     610:	91 81       	ldd	r25, Z+1	; 0x01

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     612:	60 95       	com	r22
     614:	70 95       	com	r23
     616:	68 23       	and	r22, r24
     618:	79 23       	and	r23, r25
     61a:	71 83       	std	Z+1, r23	; 0x01
     61c:	60 83       	st	Z, r22
	}
	taskEXIT_CRITICAL();
     61e:	0f 90       	pop	r0
     620:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
     622:	08 95       	ret

00000624 <xEventGroupGetBitsFromISR>:
		uxReturn = pxEventBits->uxEventBits;
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
}
     624:	fc 01       	movw	r30, r24
     626:	80 81       	ld	r24, Z
     628:	91 81       	ldd	r25, Z+1	; 0x01
     62a:	08 95       	ret

0000062c <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
     62c:	cf 92       	push	r12
     62e:	df 92       	push	r13
     630:	ef 92       	push	r14
     632:	ff 92       	push	r15
     634:	0f 93       	push	r16
     636:	1f 93       	push	r17
     638:	cf 93       	push	r28
     63a:	df 93       	push	r29
     63c:	7c 01       	movw	r14, r24
     63e:	8b 01       	movw	r16, r22
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     640:	ec 01       	movw	r28, r24
     642:	25 96       	adiw	r28, 0x05	; 5
	vTaskSuspendAll();
     644:	0e 94 50 0c 	call	0x18a0	; 0x18a0 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
     648:	d7 01       	movw	r26, r14
     64a:	17 96       	adiw	r26, 0x07	; 7
     64c:	ed 91       	ld	r30, X+
     64e:	fc 91       	ld	r31, X
     650:	18 97       	sbiw	r26, 0x08	; 8

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
     652:	8d 91       	ld	r24, X+
     654:	9c 91       	ld	r25, X
     656:	11 97       	sbiw	r26, 0x01	; 1
     658:	08 2b       	or	r16, r24
     65a:	19 2b       	or	r17, r25
     65c:	0d 93       	st	X+, r16
     65e:	1c 93       	st	X, r17
EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t *pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
     660:	00 e0       	ldi	r16, 0x00	; 0
     662:	10 e0       	ldi	r17, 0x00	; 0

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     664:	2d c0       	rjmp	.+90     	; 0x6c0 <xEventGroupSetBits+0x94>
		{
			pxNext = listGET_NEXT( pxListItem );
     666:	c2 80       	ldd	r12, Z+2	; 0x02
     668:	d3 80       	ldd	r13, Z+3	; 0x03
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
     66a:	80 81       	ld	r24, Z
     66c:	91 81       	ldd	r25, Z+1	; 0x01
			xMatchFound = pdFALSE;

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
     66e:	9c 01       	movw	r18, r24
     670:	33 27       	eor	r19, r19

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
     672:	92 fd       	sbrc	r25, 2
     674:	09 c0       	rjmp	.+18     	; 0x688 <xEventGroupSetBits+0x5c>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
     676:	d7 01       	movw	r26, r14
     678:	4d 91       	ld	r20, X+
     67a:	5c 91       	ld	r21, X
     67c:	42 23       	and	r20, r18
     67e:	53 23       	and	r21, r19
     680:	45 2b       	or	r20, r21
     682:	61 f4       	brne	.+24     	; 0x69c <xEventGroupSetBits+0x70>
		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
			xMatchFound = pdFALSE;
     684:	40 e0       	ldi	r20, 0x00	; 0
     686:	0d c0       	rjmp	.+26     	; 0x6a2 <xEventGroupSetBits+0x76>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
     688:	d7 01       	movw	r26, r14
     68a:	4d 91       	ld	r20, X+
     68c:	5c 91       	ld	r21, X
     68e:	42 23       	and	r20, r18
     690:	53 23       	and	r21, r19
     692:	24 17       	cp	r18, r20
     694:	35 07       	cpc	r19, r21
     696:	21 f0       	breq	.+8      	; 0x6a0 <xEventGroupSetBits+0x74>
		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
			xMatchFound = pdFALSE;
     698:	40 e0       	ldi	r20, 0x00	; 0
     69a:	03 c0       	rjmp	.+6      	; 0x6a2 <xEventGroupSetBits+0x76>
			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
				{
					xMatchFound = pdTRUE;
     69c:	41 e0       	ldi	r20, 0x01	; 1
     69e:	01 c0       	rjmp	.+2      	; 0x6a2 <xEventGroupSetBits+0x76>
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
     6a0:	41 e0       	ldi	r20, 0x01	; 1
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
     6a2:	44 23       	and	r20, r20
     6a4:	59 f0       	breq	.+22     	; 0x6bc <xEventGroupSetBits+0x90>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
     6a6:	90 ff       	sbrs	r25, 0
     6a8:	02 c0       	rjmp	.+4      	; 0x6ae <xEventGroupSetBits+0x82>
				{
					uxBitsToClear |= uxBitsWaitedFor;
     6aa:	02 2b       	or	r16, r18
     6ac:	13 2b       	or	r17, r19
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				( void ) xTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
     6ae:	d7 01       	movw	r26, r14
     6b0:	6d 91       	ld	r22, X+
     6b2:	7c 91       	ld	r23, X
     6b4:	72 60       	ori	r23, 0x02	; 2
     6b6:	cf 01       	movw	r24, r30
     6b8:	0e 94 ba 0e 	call	0x1d74	; 0x1d74 <xTaskRemoveFromUnorderedEventList>
		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
			xMatchFound = pdFALSE;
     6bc:	ec 2d       	mov	r30, r12
     6be:	fd 2d       	mov	r31, r13

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     6c0:	ec 17       	cp	r30, r28
     6c2:	fd 07       	cpc	r31, r29
     6c4:	81 f6       	brne	.-96     	; 0x666 <xEventGroupSetBits+0x3a>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     6c6:	00 95       	com	r16
     6c8:	10 95       	com	r17
     6ca:	f7 01       	movw	r30, r14
     6cc:	80 81       	ld	r24, Z
     6ce:	91 81       	ldd	r25, Z+1	; 0x01
     6d0:	08 23       	and	r16, r24
     6d2:	19 23       	and	r17, r25
     6d4:	11 83       	std	Z+1, r17	; 0x01
     6d6:	00 83       	st	Z, r16
	}
	( void ) xTaskResumeAll();
     6d8:	0e 94 2a 0d 	call	0x1a54	; 0x1a54 <xTaskResumeAll>

	return pxEventBits->uxEventBits;
}
     6dc:	d7 01       	movw	r26, r14
     6de:	8d 91       	ld	r24, X+
     6e0:	9c 91       	ld	r25, X
     6e2:	df 91       	pop	r29
     6e4:	cf 91       	pop	r28
     6e6:	1f 91       	pop	r17
     6e8:	0f 91       	pop	r16
     6ea:	ff 90       	pop	r15
     6ec:	ef 90       	pop	r14
     6ee:	df 90       	pop	r13
     6f0:	cf 90       	pop	r12
     6f2:	08 95       	ret

000006f4 <xEventGroupSync>:

#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
     6f4:	af 92       	push	r10
     6f6:	bf 92       	push	r11
     6f8:	cf 92       	push	r12
     6fa:	df 92       	push	r13
     6fc:	ef 92       	push	r14
     6fe:	ff 92       	push	r15
     700:	0f 93       	push	r16
     702:	1f 93       	push	r17
     704:	cf 93       	push	r28
     706:	df 93       	push	r29
     708:	8c 01       	movw	r16, r24
     70a:	eb 01       	movw	r28, r22
     70c:	7a 01       	movw	r14, r20
     70e:	69 01       	movw	r12, r18
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     710:	0e 94 50 0c 	call	0x18a0	; 0x18a0 <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
     714:	f8 01       	movw	r30, r16
     716:	a0 80       	ld	r10, Z
     718:	b1 80       	ldd	r11, Z+1	; 0x01

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
     71a:	be 01       	movw	r22, r28
     71c:	c8 01       	movw	r24, r16
     71e:	0e 94 16 03 	call	0x62c	; 0x62c <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
     722:	ca 29       	or	r28, r10
     724:	db 29       	or	r29, r11
     726:	ce 01       	movw	r24, r28
     728:	8e 21       	and	r24, r14
     72a:	9f 21       	and	r25, r15
     72c:	e8 16       	cp	r14, r24
     72e:	f9 06       	cpc	r15, r25
     730:	69 f4       	brne	.+26     	; 0x74c <xEventGroupSync+0x58>
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     732:	f8 01       	movw	r30, r16
     734:	20 81       	ld	r18, Z
     736:	31 81       	ldd	r19, Z+1	; 0x01
     738:	c7 01       	movw	r24, r14
     73a:	80 95       	com	r24
     73c:	90 95       	com	r25
     73e:	82 23       	and	r24, r18
     740:	93 23       	and	r25, r19
     742:	91 83       	std	Z+1, r25	; 0x01
     744:	80 83       	st	Z, r24

			xTicksToWait = 0;
     746:	c1 2c       	mov	r12, r1
     748:	d1 2c       	mov	r13, r1
     74a:	10 c0       	rjmp	.+32     	; 0x76c <xEventGroupSync+0x78>
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
     74c:	c1 14       	cp	r12, r1
     74e:	d1 04       	cpc	r13, r1
     750:	51 f0       	breq	.+20     	; 0x766 <xEventGroupSync+0x72>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
     752:	a6 01       	movw	r20, r12
     754:	b7 01       	movw	r22, r14
     756:	75 60       	ori	r23, 0x05	; 5
     758:	c8 01       	movw	r24, r16
     75a:	02 96       	adiw	r24, 0x02	; 2
     75c:	0e 94 59 0e 	call	0x1cb2	; 0x1cb2 <vTaskPlaceOnUnorderedEventList>

				/* This assignment is obsolete as uxReturn will get set after
				the task unblocks, but some compilers mistakenly generate a
				warning about uxReturn being returned without being set if the
				assignment is omitted. */
				uxReturn = 0;
     760:	c0 e0       	ldi	r28, 0x00	; 0
     762:	d0 e0       	ldi	r29, 0x00	; 0
     764:	03 c0       	rjmp	.+6      	; 0x76c <xEventGroupSync+0x78>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     766:	f8 01       	movw	r30, r16
     768:	c0 81       	ld	r28, Z
     76a:	d1 81       	ldd	r29, Z+1	; 0x01
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     76c:	0e 94 2a 0d 	call	0x1a54	; 0x1a54 <xTaskResumeAll>

	if( xTicksToWait != ( TickType_t ) 0 )
     770:	cd 28       	or	r12, r13
     772:	f9 f0       	breq	.+62     	; 0x7b2 <xEventGroupSync+0xbe>
	{
		if( xAlreadyYielded == pdFALSE )
     774:	81 11       	cpse	r24, r1
     776:	02 c0       	rjmp	.+4      	; 0x77c <xEventGroupSync+0x88>
		{
			portYIELD_WITHIN_API();
     778:	0e 94 34 05 	call	0xa68	; 0xa68 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     77c:	0e 94 35 0f 	call	0x1e6a	; 0x1e6a <uxTaskResetEventItemValue>

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     780:	91 fd       	sbrc	r25, 1
     782:	15 c0       	rjmp	.+42     	; 0x7ae <xEventGroupSync+0xba>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
     784:	0f b6       	in	r0, 0x3f	; 63
     786:	f8 94       	cli
     788:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
     78a:	f8 01       	movw	r30, r16
     78c:	80 81       	ld	r24, Z
     78e:	91 81       	ldd	r25, Z+1	; 0x01

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
     790:	97 01       	movw	r18, r14
     792:	28 23       	and	r18, r24
     794:	39 23       	and	r19, r25
     796:	e2 16       	cp	r14, r18
     798:	f3 06       	cpc	r15, r19
     79a:	39 f4       	brne	.+14     	; 0x7aa <xEventGroupSync+0xb6>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     79c:	a7 01       	movw	r20, r14
     79e:	40 95       	com	r20
     7a0:	50 95       	com	r21
     7a2:	48 23       	and	r20, r24
     7a4:	59 23       	and	r21, r25
     7a6:	51 83       	std	Z+1, r21	; 0x01
     7a8:	40 83       	st	Z, r20
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
     7aa:	0f 90       	pop	r0
     7ac:	0f be       	out	0x3f, r0	; 63
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     7ae:	ec 01       	movw	r28, r24
     7b0:	dd 27       	eor	r29, r29
	}

	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
}
     7b2:	ce 01       	movw	r24, r28
     7b4:	df 91       	pop	r29
     7b6:	cf 91       	pop	r28
     7b8:	1f 91       	pop	r17
     7ba:	0f 91       	pop	r16
     7bc:	ff 90       	pop	r15
     7be:	ef 90       	pop	r14
     7c0:	df 90       	pop	r13
     7c2:	cf 90       	pop	r12
     7c4:	bf 90       	pop	r11
     7c6:	af 90       	pop	r10
     7c8:	08 95       	ret

000007ca <vEventGroupDelete>:
	return pxEventBits->uxEventBits;
}
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
     7ca:	cf 93       	push	r28
     7cc:	df 93       	push	r29
     7ce:	ec 01       	movw	r28, r24
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );

	vTaskSuspendAll();
     7d0:	0e 94 50 0c 	call	0x18a0	; 0x18a0 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
     7d4:	06 c0       	rjmp	.+12     	; 0x7e2 <vEventGroupDelete+0x18>
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and	cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			( void ) xTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
     7d6:	60 e0       	ldi	r22, 0x00	; 0
     7d8:	72 e0       	ldi	r23, 0x02	; 2
     7da:	8f 81       	ldd	r24, Y+7	; 0x07
     7dc:	98 85       	ldd	r25, Y+8	; 0x08
     7de:	0e 94 ba 0e 	call	0x1d74	; 0x1d74 <xTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
     7e2:	8a 81       	ldd	r24, Y+2	; 0x02
     7e4:	81 11       	cpse	r24, r1
     7e6:	f7 cf       	rjmp	.-18     	; 0x7d6 <vEventGroupDelete+0xc>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
		{
			/* The event group can only have been allocated dynamically - free
			it again. */
			vPortFree( pxEventBits );
     7e8:	ce 01       	movw	r24, r28
     7ea:	0e 94 21 06 	call	0xc42	; 0xc42 <vPortFree>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
     7ee:	0e 94 2a 0d 	call	0x1a54	; 0x1a54 <xTaskResumeAll>
}
     7f2:	df 91       	pop	r29
     7f4:	cf 91       	pop	r28
     7f6:	08 95       	ret

000007f8 <vEventGroupSetBitsCallback>:

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet );
     7f8:	ba 01       	movw	r22, r20
     7fa:	0e 94 16 03 	call	0x62c	; 0x62c <xEventGroupSetBits>
     7fe:	08 95       	ret

00000800 <vEventGroupClearBitsCallback>:

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear );
     800:	ba 01       	movw	r22, r20
     802:	0e 94 03 03 	call	0x606	; 0x606 <xEventGroupClearBits>
     806:	08 95       	ret

00000808 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     808:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     80a:	03 96       	adiw	r24, 0x03	; 3
     80c:	92 83       	std	Z+2, r25	; 0x02
     80e:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     810:	2f ef       	ldi	r18, 0xFF	; 255
     812:	3f ef       	ldi	r19, 0xFF	; 255
     814:	34 83       	std	Z+4, r19	; 0x04
     816:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     818:	96 83       	std	Z+6, r25	; 0x06
     81a:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     81c:	90 87       	std	Z+8, r25	; 0x08
     81e:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     820:	10 82       	st	Z, r1
     822:	08 95       	ret

00000824 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     824:	fc 01       	movw	r30, r24
     826:	11 86       	std	Z+9, r1	; 0x09
     828:	10 86       	std	Z+8, r1	; 0x08
     82a:	08 95       	ret

0000082c <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     82c:	cf 93       	push	r28
     82e:	df 93       	push	r29
     830:	9c 01       	movw	r18, r24
     832:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     834:	dc 01       	movw	r26, r24
     836:	11 96       	adiw	r26, 0x01	; 1
     838:	cd 91       	ld	r28, X+
     83a:	dc 91       	ld	r29, X
     83c:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     83e:	d3 83       	std	Z+3, r29	; 0x03
     840:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     842:	8c 81       	ldd	r24, Y+4	; 0x04
     844:	9d 81       	ldd	r25, Y+5	; 0x05
     846:	95 83       	std	Z+5, r25	; 0x05
     848:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     84a:	8c 81       	ldd	r24, Y+4	; 0x04
     84c:	9d 81       	ldd	r25, Y+5	; 0x05
     84e:	dc 01       	movw	r26, r24
     850:	13 96       	adiw	r26, 0x03	; 3
     852:	7c 93       	st	X, r23
     854:	6e 93       	st	-X, r22
     856:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     858:	7d 83       	std	Y+5, r23	; 0x05
     85a:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     85c:	31 87       	std	Z+9, r19	; 0x09
     85e:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     860:	f9 01       	movw	r30, r18
     862:	80 81       	ld	r24, Z
     864:	8f 5f       	subi	r24, 0xFF	; 255
     866:	80 83       	st	Z, r24
}
     868:	df 91       	pop	r29
     86a:	cf 91       	pop	r28
     86c:	08 95       	ret

0000086e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     86e:	cf 93       	push	r28
     870:	df 93       	push	r29
     872:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     874:	48 81       	ld	r20, Y
     876:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     878:	4f 3f       	cpi	r20, 0xFF	; 255
     87a:	2f ef       	ldi	r18, 0xFF	; 255
     87c:	52 07       	cpc	r21, r18
     87e:	21 f4       	brne	.+8      	; 0x888 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     880:	fc 01       	movw	r30, r24
     882:	a7 81       	ldd	r26, Z+7	; 0x07
     884:	b0 85       	ldd	r27, Z+8	; 0x08
     886:	0d c0       	rjmp	.+26     	; 0x8a2 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     888:	dc 01       	movw	r26, r24
     88a:	13 96       	adiw	r26, 0x03	; 3
     88c:	01 c0       	rjmp	.+2      	; 0x890 <vListInsert+0x22>
     88e:	df 01       	movw	r26, r30
     890:	12 96       	adiw	r26, 0x02	; 2
     892:	ed 91       	ld	r30, X+
     894:	fc 91       	ld	r31, X
     896:	13 97       	sbiw	r26, 0x03	; 3
     898:	20 81       	ld	r18, Z
     89a:	31 81       	ldd	r19, Z+1	; 0x01
     89c:	42 17       	cp	r20, r18
     89e:	53 07       	cpc	r21, r19
     8a0:	b0 f7       	brcc	.-20     	; 0x88e <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     8a2:	12 96       	adiw	r26, 0x02	; 2
     8a4:	ed 91       	ld	r30, X+
     8a6:	fc 91       	ld	r31, X
     8a8:	13 97       	sbiw	r26, 0x03	; 3
     8aa:	fb 83       	std	Y+3, r31	; 0x03
     8ac:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     8ae:	d5 83       	std	Z+5, r29	; 0x05
     8b0:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     8b2:	bd 83       	std	Y+5, r27	; 0x05
     8b4:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     8b6:	13 96       	adiw	r26, 0x03	; 3
     8b8:	dc 93       	st	X, r29
     8ba:	ce 93       	st	-X, r28
     8bc:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     8be:	99 87       	std	Y+9, r25	; 0x09
     8c0:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     8c2:	fc 01       	movw	r30, r24
     8c4:	20 81       	ld	r18, Z
     8c6:	2f 5f       	subi	r18, 0xFF	; 255
     8c8:	20 83       	st	Z, r18
}
     8ca:	df 91       	pop	r29
     8cc:	cf 91       	pop	r28
     8ce:	08 95       	ret

000008d0 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     8d0:	cf 93       	push	r28
     8d2:	df 93       	push	r29
     8d4:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     8d6:	a0 85       	ldd	r26, Z+8	; 0x08
     8d8:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     8da:	c2 81       	ldd	r28, Z+2	; 0x02
     8dc:	d3 81       	ldd	r29, Z+3	; 0x03
     8de:	84 81       	ldd	r24, Z+4	; 0x04
     8e0:	95 81       	ldd	r25, Z+5	; 0x05
     8e2:	9d 83       	std	Y+5, r25	; 0x05
     8e4:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     8e6:	c4 81       	ldd	r28, Z+4	; 0x04
     8e8:	d5 81       	ldd	r29, Z+5	; 0x05
     8ea:	82 81       	ldd	r24, Z+2	; 0x02
     8ec:	93 81       	ldd	r25, Z+3	; 0x03
     8ee:	9b 83       	std	Y+3, r25	; 0x03
     8f0:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     8f2:	11 96       	adiw	r26, 0x01	; 1
     8f4:	8d 91       	ld	r24, X+
     8f6:	9c 91       	ld	r25, X
     8f8:	12 97       	sbiw	r26, 0x02	; 2
     8fa:	e8 17       	cp	r30, r24
     8fc:	f9 07       	cpc	r31, r25
     8fe:	31 f4       	brne	.+12     	; 0x90c <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     900:	84 81       	ldd	r24, Z+4	; 0x04
     902:	95 81       	ldd	r25, Z+5	; 0x05
     904:	12 96       	adiw	r26, 0x02	; 2
     906:	9c 93       	st	X, r25
     908:	8e 93       	st	-X, r24
     90a:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     90c:	11 86       	std	Z+9, r1	; 0x09
     90e:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     910:	8c 91       	ld	r24, X
     912:	81 50       	subi	r24, 0x01	; 1
     914:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     916:	df 91       	pop	r29
     918:	cf 91       	pop	r28
     91a:	08 95       	ret

0000091c <prvSetupTimerInterrupt>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	OCR1AH = ucHighByte;
     91c:	86 e0       	ldi	r24, 0x06	; 6
     91e:	8b bd       	out	0x2b, r24	; 43
	OCR1AL = ucLowByte;
     920:	8f eb       	ldi	r24, 0xBF	; 191
     922:	8a bd       	out	0x2a, r24	; 42

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
     924:	8b e0       	ldi	r24, 0x0B	; 11
     926:	8e bd       	out	0x2e, r24	; 46

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
     928:	87 b7       	in	r24, 0x37	; 55
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     92a:	80 61       	ori	r24, 0x10	; 16
	TIMSK = ucLowByte;
     92c:	87 bf       	out	0x37, r24	; 55
     92e:	08 95       	ret

00000930 <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     930:	31 e1       	ldi	r19, 0x11	; 17
     932:	fc 01       	movw	r30, r24
     934:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
     936:	31 97       	sbiw	r30, 0x01	; 1
     938:	22 e2       	ldi	r18, 0x22	; 34
     93a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
     93c:	31 97       	sbiw	r30, 0x01	; 1
     93e:	a3 e3       	ldi	r26, 0x33	; 51
     940:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     942:	31 97       	sbiw	r30, 0x01	; 1
     944:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     946:	31 97       	sbiw	r30, 0x01	; 1
     948:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
     94a:	31 97       	sbiw	r30, 0x01	; 1
     94c:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     94e:	31 97       	sbiw	r30, 0x01	; 1
     950:	60 e8       	ldi	r22, 0x80	; 128
     952:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
     954:	31 97       	sbiw	r30, 0x01	; 1
     956:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
     958:	31 97       	sbiw	r30, 0x01	; 1
     95a:	62 e0       	ldi	r22, 0x02	; 2
     95c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
     95e:	31 97       	sbiw	r30, 0x01	; 1
     960:	63 e0       	ldi	r22, 0x03	; 3
     962:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
     964:	31 97       	sbiw	r30, 0x01	; 1
     966:	64 e0       	ldi	r22, 0x04	; 4
     968:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
     96a:	31 97       	sbiw	r30, 0x01	; 1
     96c:	65 e0       	ldi	r22, 0x05	; 5
     96e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
     970:	31 97       	sbiw	r30, 0x01	; 1
     972:	66 e0       	ldi	r22, 0x06	; 6
     974:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
     976:	31 97       	sbiw	r30, 0x01	; 1
     978:	67 e0       	ldi	r22, 0x07	; 7
     97a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
     97c:	31 97       	sbiw	r30, 0x01	; 1
     97e:	68 e0       	ldi	r22, 0x08	; 8
     980:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
     982:	31 97       	sbiw	r30, 0x01	; 1
     984:	69 e0       	ldi	r22, 0x09	; 9
     986:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
     988:	31 97       	sbiw	r30, 0x01	; 1
     98a:	60 e1       	ldi	r22, 0x10	; 16
     98c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
     98e:	31 97       	sbiw	r30, 0x01	; 1
     990:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
     992:	31 97       	sbiw	r30, 0x01	; 1
     994:	32 e1       	ldi	r19, 0x12	; 18
     996:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
     998:	31 97       	sbiw	r30, 0x01	; 1
     99a:	33 e1       	ldi	r19, 0x13	; 19
     99c:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
     99e:	31 97       	sbiw	r30, 0x01	; 1
     9a0:	34 e1       	ldi	r19, 0x14	; 20
     9a2:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
     9a4:	31 97       	sbiw	r30, 0x01	; 1
     9a6:	35 e1       	ldi	r19, 0x15	; 21
     9a8:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
     9aa:	31 97       	sbiw	r30, 0x01	; 1
     9ac:	36 e1       	ldi	r19, 0x16	; 22
     9ae:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
     9b0:	31 97       	sbiw	r30, 0x01	; 1
     9b2:	37 e1       	ldi	r19, 0x17	; 23
     9b4:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
     9b6:	31 97       	sbiw	r30, 0x01	; 1
     9b8:	38 e1       	ldi	r19, 0x18	; 24
     9ba:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
     9bc:	31 97       	sbiw	r30, 0x01	; 1
     9be:	39 e1       	ldi	r19, 0x19	; 25
     9c0:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
     9c2:	31 97       	sbiw	r30, 0x01	; 1
     9c4:	30 e2       	ldi	r19, 0x20	; 32
     9c6:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
     9c8:	31 97       	sbiw	r30, 0x01	; 1
     9ca:	31 e2       	ldi	r19, 0x21	; 33
     9cc:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
     9ce:	31 97       	sbiw	r30, 0x01	; 1
     9d0:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
     9d2:	31 97       	sbiw	r30, 0x01	; 1
     9d4:	23 e2       	ldi	r18, 0x23	; 35
     9d6:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     9d8:	31 97       	sbiw	r30, 0x01	; 1
     9da:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     9dc:	31 97       	sbiw	r30, 0x01	; 1
     9de:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
     9e0:	31 97       	sbiw	r30, 0x01	; 1
     9e2:	26 e2       	ldi	r18, 0x26	; 38
     9e4:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
     9e6:	31 97       	sbiw	r30, 0x01	; 1
     9e8:	27 e2       	ldi	r18, 0x27	; 39
     9ea:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
     9ec:	31 97       	sbiw	r30, 0x01	; 1
     9ee:	28 e2       	ldi	r18, 0x28	; 40
     9f0:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
     9f2:	31 97       	sbiw	r30, 0x01	; 1
     9f4:	29 e2       	ldi	r18, 0x29	; 41
     9f6:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
     9f8:	31 97       	sbiw	r30, 0x01	; 1
     9fa:	20 e3       	ldi	r18, 0x30	; 48
     9fc:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
     9fe:	31 97       	sbiw	r30, 0x01	; 1
     a00:	21 e3       	ldi	r18, 0x31	; 49
     a02:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
     a04:	86 97       	sbiw	r24, 0x26	; 38
     a06:	08 95       	ret

00000a08 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
     a08:	0e 94 8e 04 	call	0x91c	; 0x91c <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     a0c:	a0 91 cf 0d 	lds	r26, 0x0DCF	; 0x800dcf <pxCurrentTCB>
     a10:	b0 91 d0 0d 	lds	r27, 0x0DD0	; 0x800dd0 <pxCurrentTCB+0x1>
     a14:	cd 91       	ld	r28, X+
     a16:	cd bf       	out	0x3d, r28	; 61
     a18:	dd 91       	ld	r29, X+
     a1a:	de bf       	out	0x3e, r29	; 62
     a1c:	ff 91       	pop	r31
     a1e:	ef 91       	pop	r30
     a20:	df 91       	pop	r29
     a22:	cf 91       	pop	r28
     a24:	bf 91       	pop	r27
     a26:	af 91       	pop	r26
     a28:	9f 91       	pop	r25
     a2a:	8f 91       	pop	r24
     a2c:	7f 91       	pop	r23
     a2e:	6f 91       	pop	r22
     a30:	5f 91       	pop	r21
     a32:	4f 91       	pop	r20
     a34:	3f 91       	pop	r19
     a36:	2f 91       	pop	r18
     a38:	1f 91       	pop	r17
     a3a:	0f 91       	pop	r16
     a3c:	ff 90       	pop	r15
     a3e:	ef 90       	pop	r14
     a40:	df 90       	pop	r13
     a42:	cf 90       	pop	r12
     a44:	bf 90       	pop	r11
     a46:	af 90       	pop	r10
     a48:	9f 90       	pop	r9
     a4a:	8f 90       	pop	r8
     a4c:	7f 90       	pop	r7
     a4e:	6f 90       	pop	r6
     a50:	5f 90       	pop	r5
     a52:	4f 90       	pop	r4
     a54:	3f 90       	pop	r3
     a56:	2f 90       	pop	r2
     a58:	1f 90       	pop	r1
     a5a:	0f 90       	pop	r0
     a5c:	0f be       	out	0x3f, r0	; 63
     a5e:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     a60:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
     a62:	81 e0       	ldi	r24, 0x01	; 1
     a64:	08 95       	ret

00000a66 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     a66:	08 95       	ret

00000a68 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     a68:	0f 92       	push	r0
     a6a:	0f b6       	in	r0, 0x3f	; 63
     a6c:	f8 94       	cli
     a6e:	0f 92       	push	r0
     a70:	1f 92       	push	r1
     a72:	11 24       	eor	r1, r1
     a74:	2f 92       	push	r2
     a76:	3f 92       	push	r3
     a78:	4f 92       	push	r4
     a7a:	5f 92       	push	r5
     a7c:	6f 92       	push	r6
     a7e:	7f 92       	push	r7
     a80:	8f 92       	push	r8
     a82:	9f 92       	push	r9
     a84:	af 92       	push	r10
     a86:	bf 92       	push	r11
     a88:	cf 92       	push	r12
     a8a:	df 92       	push	r13
     a8c:	ef 92       	push	r14
     a8e:	ff 92       	push	r15
     a90:	0f 93       	push	r16
     a92:	1f 93       	push	r17
     a94:	2f 93       	push	r18
     a96:	3f 93       	push	r19
     a98:	4f 93       	push	r20
     a9a:	5f 93       	push	r21
     a9c:	6f 93       	push	r22
     a9e:	7f 93       	push	r23
     aa0:	8f 93       	push	r24
     aa2:	9f 93       	push	r25
     aa4:	af 93       	push	r26
     aa6:	bf 93       	push	r27
     aa8:	cf 93       	push	r28
     aaa:	df 93       	push	r29
     aac:	ef 93       	push	r30
     aae:	ff 93       	push	r31
     ab0:	a0 91 cf 0d 	lds	r26, 0x0DCF	; 0x800dcf <pxCurrentTCB>
     ab4:	b0 91 d0 0d 	lds	r27, 0x0DD0	; 0x800dd0 <pxCurrentTCB+0x1>
     ab8:	0d b6       	in	r0, 0x3d	; 61
     aba:	0d 92       	st	X+, r0
     abc:	0e b6       	in	r0, 0x3e	; 62
     abe:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     ac0:	0e 94 f3 0d 	call	0x1be6	; 0x1be6 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     ac4:	a0 91 cf 0d 	lds	r26, 0x0DCF	; 0x800dcf <pxCurrentTCB>
     ac8:	b0 91 d0 0d 	lds	r27, 0x0DD0	; 0x800dd0 <pxCurrentTCB+0x1>
     acc:	cd 91       	ld	r28, X+
     ace:	cd bf       	out	0x3d, r28	; 61
     ad0:	dd 91       	ld	r29, X+
     ad2:	de bf       	out	0x3e, r29	; 62
     ad4:	ff 91       	pop	r31
     ad6:	ef 91       	pop	r30
     ad8:	df 91       	pop	r29
     ada:	cf 91       	pop	r28
     adc:	bf 91       	pop	r27
     ade:	af 91       	pop	r26
     ae0:	9f 91       	pop	r25
     ae2:	8f 91       	pop	r24
     ae4:	7f 91       	pop	r23
     ae6:	6f 91       	pop	r22
     ae8:	5f 91       	pop	r21
     aea:	4f 91       	pop	r20
     aec:	3f 91       	pop	r19
     aee:	2f 91       	pop	r18
     af0:	1f 91       	pop	r17
     af2:	0f 91       	pop	r16
     af4:	ff 90       	pop	r15
     af6:	ef 90       	pop	r14
     af8:	df 90       	pop	r13
     afa:	cf 90       	pop	r12
     afc:	bf 90       	pop	r11
     afe:	af 90       	pop	r10
     b00:	9f 90       	pop	r9
     b02:	8f 90       	pop	r8
     b04:	7f 90       	pop	r7
     b06:	6f 90       	pop	r6
     b08:	5f 90       	pop	r5
     b0a:	4f 90       	pop	r4
     b0c:	3f 90       	pop	r3
     b0e:	2f 90       	pop	r2
     b10:	1f 90       	pop	r1
     b12:	0f 90       	pop	r0
     b14:	0f be       	out	0x3f, r0	; 63
     b16:	0f 90       	pop	r0

	asm volatile ( "ret" );
     b18:	08 95       	ret

00000b1a <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     b1a:	0f 92       	push	r0
     b1c:	0f b6       	in	r0, 0x3f	; 63
     b1e:	f8 94       	cli
     b20:	0f 92       	push	r0
     b22:	1f 92       	push	r1
     b24:	11 24       	eor	r1, r1
     b26:	2f 92       	push	r2
     b28:	3f 92       	push	r3
     b2a:	4f 92       	push	r4
     b2c:	5f 92       	push	r5
     b2e:	6f 92       	push	r6
     b30:	7f 92       	push	r7
     b32:	8f 92       	push	r8
     b34:	9f 92       	push	r9
     b36:	af 92       	push	r10
     b38:	bf 92       	push	r11
     b3a:	cf 92       	push	r12
     b3c:	df 92       	push	r13
     b3e:	ef 92       	push	r14
     b40:	ff 92       	push	r15
     b42:	0f 93       	push	r16
     b44:	1f 93       	push	r17
     b46:	2f 93       	push	r18
     b48:	3f 93       	push	r19
     b4a:	4f 93       	push	r20
     b4c:	5f 93       	push	r21
     b4e:	6f 93       	push	r22
     b50:	7f 93       	push	r23
     b52:	8f 93       	push	r24
     b54:	9f 93       	push	r25
     b56:	af 93       	push	r26
     b58:	bf 93       	push	r27
     b5a:	cf 93       	push	r28
     b5c:	df 93       	push	r29
     b5e:	ef 93       	push	r30
     b60:	ff 93       	push	r31
     b62:	a0 91 cf 0d 	lds	r26, 0x0DCF	; 0x800dcf <pxCurrentTCB>
     b66:	b0 91 d0 0d 	lds	r27, 0x0DD0	; 0x800dd0 <pxCurrentTCB+0x1>
     b6a:	0d b6       	in	r0, 0x3d	; 61
     b6c:	0d 92       	st	X+, r0
     b6e:	0e b6       	in	r0, 0x3e	; 62
     b70:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     b72:	0e 94 70 0c 	call	0x18e0	; 0x18e0 <xTaskIncrementTick>
     b76:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     b78:	0e 94 f3 0d 	call	0x1be6	; 0x1be6 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     b7c:	a0 91 cf 0d 	lds	r26, 0x0DCF	; 0x800dcf <pxCurrentTCB>
     b80:	b0 91 d0 0d 	lds	r27, 0x0DD0	; 0x800dd0 <pxCurrentTCB+0x1>
     b84:	cd 91       	ld	r28, X+
     b86:	cd bf       	out	0x3d, r28	; 61
     b88:	dd 91       	ld	r29, X+
     b8a:	de bf       	out	0x3e, r29	; 62
     b8c:	ff 91       	pop	r31
     b8e:	ef 91       	pop	r30
     b90:	df 91       	pop	r29
     b92:	cf 91       	pop	r28
     b94:	bf 91       	pop	r27
     b96:	af 91       	pop	r26
     b98:	9f 91       	pop	r25
     b9a:	8f 91       	pop	r24
     b9c:	7f 91       	pop	r23
     b9e:	6f 91       	pop	r22
     ba0:	5f 91       	pop	r21
     ba2:	4f 91       	pop	r20
     ba4:	3f 91       	pop	r19
     ba6:	2f 91       	pop	r18
     ba8:	1f 91       	pop	r17
     baa:	0f 91       	pop	r16
     bac:	ff 90       	pop	r15
     bae:	ef 90       	pop	r14
     bb0:	df 90       	pop	r13
     bb2:	cf 90       	pop	r12
     bb4:	bf 90       	pop	r11
     bb6:	af 90       	pop	r10
     bb8:	9f 90       	pop	r9
     bba:	8f 90       	pop	r8
     bbc:	7f 90       	pop	r7
     bbe:	6f 90       	pop	r6
     bc0:	5f 90       	pop	r5
     bc2:	4f 90       	pop	r4
     bc4:	3f 90       	pop	r3
     bc6:	2f 90       	pop	r2
     bc8:	1f 90       	pop	r1
     bca:	0f 90       	pop	r0
     bcc:	0f be       	out	0x3f, r0	; 63
     bce:	0f 90       	pop	r0

	asm volatile ( "ret" );
     bd0:	08 95       	ret

00000bd2 <__vector_12>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     bd2:	0e 94 8d 05 	call	0xb1a	; 0xb1a <vPortYieldFromTick>
		asm volatile ( "reti" );
     bd6:	18 95       	reti

00000bd8 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     bd8:	cf 93       	push	r28
     bda:	df 93       	push	r29
     bdc:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
     bde:	0e 94 50 0c 	call	0x18a0	; 0x18a0 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     be2:	80 91 7a 01 	lds	r24, 0x017A	; 0x80017a <pucAlignedHeap.2068>
     be6:	90 91 7b 01 	lds	r25, 0x017B	; 0x80017b <pucAlignedHeap.2068+0x1>
     bea:	89 2b       	or	r24, r25
     bec:	31 f4       	brne	.+12     	; 0xbfa <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     bee:	8f e7       	ldi	r24, 0x7F	; 127
     bf0:	91 e0       	ldi	r25, 0x01	; 1
     bf2:	90 93 7b 01 	sts	0x017B, r25	; 0x80017b <pucAlignedHeap.2068+0x1>
     bf6:	80 93 7a 01 	sts	0x017A, r24	; 0x80017a <pucAlignedHeap.2068>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     bfa:	20 91 7c 01 	lds	r18, 0x017C	; 0x80017c <xNextFreeByte>
     bfe:	30 91 7d 01 	lds	r19, 0x017D	; 0x80017d <xNextFreeByte+0x1>
     c02:	c9 01       	movw	r24, r18
     c04:	8c 0f       	add	r24, r28
     c06:	9d 1f       	adc	r25, r29
     c08:	8f 3f       	cpi	r24, 0xFF	; 255
     c0a:	4b e0       	ldi	r20, 0x0B	; 11
     c0c:	94 07       	cpc	r25, r20
     c0e:	70 f4       	brcc	.+28     	; 0xc2c <pvPortMalloc+0x54>
     c10:	28 17       	cp	r18, r24
     c12:	39 07       	cpc	r19, r25
     c14:	70 f4       	brcc	.+28     	; 0xc32 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     c16:	c0 91 7a 01 	lds	r28, 0x017A	; 0x80017a <pucAlignedHeap.2068>
     c1a:	d0 91 7b 01 	lds	r29, 0x017B	; 0x80017b <pucAlignedHeap.2068+0x1>
     c1e:	c2 0f       	add	r28, r18
     c20:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
     c22:	90 93 7d 01 	sts	0x017D, r25	; 0x80017d <xNextFreeByte+0x1>
     c26:	80 93 7c 01 	sts	0x017C, r24	; 0x80017c <xNextFreeByte>
     c2a:	05 c0       	rjmp	.+10     	; 0xc36 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     c2c:	c0 e0       	ldi	r28, 0x00	; 0
     c2e:	d0 e0       	ldi	r29, 0x00	; 0
     c30:	02 c0       	rjmp	.+4      	; 0xc36 <pvPortMalloc+0x5e>
     c32:	c0 e0       	ldi	r28, 0x00	; 0
     c34:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     c36:	0e 94 2a 0d 	call	0x1a54	; 0x1a54 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     c3a:	ce 01       	movw	r24, r28
     c3c:	df 91       	pop	r29
     c3e:	cf 91       	pop	r28
     c40:	08 95       	ret

00000c42 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     c42:	08 95       	ret

00000c44 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
     c44:	10 92 7d 01 	sts	0x017D, r1	; 0x80017d <xNextFreeByte+0x1>
     c48:	10 92 7c 01 	sts	0x017C, r1	; 0x80017c <xNextFreeByte>
     c4c:	08 95       	ret

00000c4e <xPortGetFreeHeapSize>:
}
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
     c4e:	20 91 7c 01 	lds	r18, 0x017C	; 0x80017c <xNextFreeByte>
     c52:	30 91 7d 01 	lds	r19, 0x017D	; 0x80017d <xNextFreeByte+0x1>
}
     c56:	8f ef       	ldi	r24, 0xFF	; 255
     c58:	9b e0       	ldi	r25, 0x0B	; 11
     c5a:	82 1b       	sub	r24, r18
     c5c:	93 0b       	sbc	r25, r19
     c5e:	08 95       	ret

00000c60 <prvIsQueueEmpty>:

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
     c60:	0f b6       	in	r0, 0x3f	; 63
     c62:	f8 94       	cli
     c64:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
     c66:	fc 01       	movw	r30, r24
     c68:	82 8d       	ldd	r24, Z+26	; 0x1a
     c6a:	81 11       	cpse	r24, r1
     c6c:	02 c0       	rjmp	.+4      	; 0xc72 <prvIsQueueEmpty+0x12>
		{
			xReturn = pdTRUE;
     c6e:	81 e0       	ldi	r24, 0x01	; 1
     c70:	01 c0       	rjmp	.+2      	; 0xc74 <prvIsQueueEmpty+0x14>
		}
		else
		{
			xReturn = pdFALSE;
     c72:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	taskEXIT_CRITICAL();
     c74:	0f 90       	pop	r0
     c76:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
     c78:	08 95       	ret

00000c7a <prvIsQueueFull>:

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
     c7a:	0f b6       	in	r0, 0x3f	; 63
     c7c:	f8 94       	cli
     c7e:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
     c80:	fc 01       	movw	r30, r24
     c82:	22 8d       	ldd	r18, Z+26	; 0x1a
     c84:	83 8d       	ldd	r24, Z+27	; 0x1b
     c86:	28 13       	cpse	r18, r24
     c88:	02 c0       	rjmp	.+4      	; 0xc8e <prvIsQueueFull+0x14>
		{
			xReturn = pdTRUE;
     c8a:	81 e0       	ldi	r24, 0x01	; 1
     c8c:	01 c0       	rjmp	.+2      	; 0xc90 <prvIsQueueFull+0x16>
		}
		else
		{
			xReturn = pdFALSE;
     c8e:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	taskEXIT_CRITICAL();
     c90:	0f 90       	pop	r0
     c92:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
     c94:	08 95       	ret

00000c96 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
     c96:	0f 93       	push	r16
     c98:	1f 93       	push	r17
     c9a:	cf 93       	push	r28
     c9c:	df 93       	push	r29
     c9e:	ec 01       	movw	r28, r24
     ca0:	04 2f       	mov	r16, r20
BaseType_t xReturn = pdFALSE;
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
     ca2:	1a 8d       	ldd	r17, Y+26	; 0x1a

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
     ca4:	4c 8d       	ldd	r20, Y+28	; 0x1c
     ca6:	44 23       	and	r20, r20
     ca8:	b9 f1       	breq	.+110    	; 0xd18 <prvCopyDataToQueue+0x82>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
     caa:	01 11       	cpse	r16, r1
     cac:	16 c0       	rjmp	.+44     	; 0xcda <prvCopyDataToQueue+0x44>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
     cae:	50 e0       	ldi	r21, 0x00	; 0
     cb0:	8c 81       	ldd	r24, Y+4	; 0x04
     cb2:	9d 81       	ldd	r25, Y+5	; 0x05
     cb4:	0e 94 28 15 	call	0x2a50	; 0x2a50 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     cb8:	2c 8d       	ldd	r18, Y+28	; 0x1c
     cba:	8c 81       	ldd	r24, Y+4	; 0x04
     cbc:	9d 81       	ldd	r25, Y+5	; 0x05
     cbe:	82 0f       	add	r24, r18
     cc0:	91 1d       	adc	r25, r1
     cc2:	9d 83       	std	Y+5, r25	; 0x05
     cc4:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     cc6:	2a 81       	ldd	r18, Y+2	; 0x02
     cc8:	3b 81       	ldd	r19, Y+3	; 0x03
     cca:	82 17       	cp	r24, r18
     ccc:	93 07       	cpc	r25, r19
     cce:	20 f1       	brcs	.+72     	; 0xd18 <prvCopyDataToQueue+0x82>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
     cd0:	88 81       	ld	r24, Y
     cd2:	99 81       	ldd	r25, Y+1	; 0x01
     cd4:	9d 83       	std	Y+5, r25	; 0x05
     cd6:	8c 83       	std	Y+4, r24	; 0x04
     cd8:	1f c0       	rjmp	.+62     	; 0xd18 <prvCopyDataToQueue+0x82>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     cda:	50 e0       	ldi	r21, 0x00	; 0
     cdc:	8e 81       	ldd	r24, Y+6	; 0x06
     cde:	9f 81       	ldd	r25, Y+7	; 0x07
     ce0:	0e 94 28 15 	call	0x2a50	; 0x2a50 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
     ce4:	8c 8d       	ldd	r24, Y+28	; 0x1c
     ce6:	90 e0       	ldi	r25, 0x00	; 0
     ce8:	91 95       	neg	r25
     cea:	81 95       	neg	r24
     cec:	91 09       	sbc	r25, r1
     cee:	2e 81       	ldd	r18, Y+6	; 0x06
     cf0:	3f 81       	ldd	r19, Y+7	; 0x07
     cf2:	28 0f       	add	r18, r24
     cf4:	39 1f       	adc	r19, r25
     cf6:	3f 83       	std	Y+7, r19	; 0x07
     cf8:	2e 83       	std	Y+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     cfa:	48 81       	ld	r20, Y
     cfc:	59 81       	ldd	r21, Y+1	; 0x01
     cfe:	24 17       	cp	r18, r20
     d00:	35 07       	cpc	r19, r21
     d02:	30 f4       	brcc	.+12     	; 0xd10 <prvCopyDataToQueue+0x7a>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
     d04:	2a 81       	ldd	r18, Y+2	; 0x02
     d06:	3b 81       	ldd	r19, Y+3	; 0x03
     d08:	82 0f       	add	r24, r18
     d0a:	93 1f       	adc	r25, r19
     d0c:	9f 83       	std	Y+7, r25	; 0x07
     d0e:	8e 83       	std	Y+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
     d10:	02 30       	cpi	r16, 0x02	; 2
     d12:	11 f4       	brne	.+4      	; 0xd18 <prvCopyDataToQueue+0x82>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
     d14:	11 11       	cpse	r17, r1
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
     d16:	11 50       	subi	r17, 0x01	; 1
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
     d18:	1f 5f       	subi	r17, 0xFF	; 255
     d1a:	1a 8f       	std	Y+26, r17	; 0x1a

	return xReturn;
}
     d1c:	80 e0       	ldi	r24, 0x00	; 0
     d1e:	df 91       	pop	r29
     d20:	cf 91       	pop	r28
     d22:	1f 91       	pop	r17
     d24:	0f 91       	pop	r16
     d26:	08 95       	ret

00000d28 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
     d28:	fc 01       	movw	r30, r24
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
     d2a:	44 8d       	ldd	r20, Z+28	; 0x1c
     d2c:	44 23       	and	r20, r20
     d2e:	a9 f0       	breq	.+42     	; 0xd5a <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
     d30:	50 e0       	ldi	r21, 0x00	; 0
     d32:	26 81       	ldd	r18, Z+6	; 0x06
     d34:	37 81       	ldd	r19, Z+7	; 0x07
     d36:	24 0f       	add	r18, r20
     d38:	35 1f       	adc	r19, r21
     d3a:	37 83       	std	Z+7, r19	; 0x07
     d3c:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
     d3e:	82 81       	ldd	r24, Z+2	; 0x02
     d40:	93 81       	ldd	r25, Z+3	; 0x03
     d42:	28 17       	cp	r18, r24
     d44:	39 07       	cpc	r19, r25
     d46:	20 f0       	brcs	.+8      	; 0xd50 <prvCopyDataFromQueue+0x28>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
     d48:	80 81       	ld	r24, Z
     d4a:	91 81       	ldd	r25, Z+1	; 0x01
     d4c:	97 83       	std	Z+7, r25	; 0x07
     d4e:	86 83       	std	Z+6, r24	; 0x06
     d50:	cb 01       	movw	r24, r22
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
     d52:	66 81       	ldd	r22, Z+6	; 0x06
     d54:	77 81       	ldd	r23, Z+7	; 0x07
     d56:	0e 94 28 15 	call	0x2a50	; 0x2a50 <memcpy>
     d5a:	08 95       	ret

00000d5c <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
     d5c:	1f 93       	push	r17
     d5e:	cf 93       	push	r28
     d60:	df 93       	push	r29
     d62:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
     d64:	0f b6       	in	r0, 0x3f	; 63
     d66:	f8 94       	cli
     d68:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
     d6a:	1e 8d       	ldd	r17, Y+30	; 0x1e

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
     d6c:	0b c0       	rjmp	.+22     	; 0xd84 <prvUnlockQueue+0x28>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     d6e:	89 89       	ldd	r24, Y+17	; 0x11
     d70:	88 23       	and	r24, r24
     d72:	51 f0       	breq	.+20     	; 0xd88 <prvUnlockQueue+0x2c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     d74:	ce 01       	movw	r24, r28
     d76:	41 96       	adiw	r24, 0x11	; 17
     d78:	0e 94 72 0e 	call	0x1ce4	; 0x1ce4 <xTaskRemoveFromEventList>
     d7c:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
     d7e:	0e 94 31 0f 	call	0x1e62	; 0x1e62 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
     d82:	11 50       	subi	r17, 0x01	; 1
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
     d84:	11 16       	cp	r1, r17
     d86:	9c f3       	brlt	.-26     	; 0xd6e <prvUnlockQueue+0x12>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
     d88:	8f ef       	ldi	r24, 0xFF	; 255
     d8a:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
     d8c:	0f 90       	pop	r0
     d8e:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
     d90:	0f b6       	in	r0, 0x3f	; 63
     d92:	f8 94       	cli
     d94:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
     d96:	1d 8d       	ldd	r17, Y+29	; 0x1d

		while( cRxLock > queueLOCKED_UNMODIFIED )
     d98:	0b c0       	rjmp	.+22     	; 0xdb0 <prvUnlockQueue+0x54>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     d9a:	88 85       	ldd	r24, Y+8	; 0x08
     d9c:	88 23       	and	r24, r24
     d9e:	51 f0       	breq	.+20     	; 0xdb4 <prvUnlockQueue+0x58>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     da0:	ce 01       	movw	r24, r28
     da2:	08 96       	adiw	r24, 0x08	; 8
     da4:	0e 94 72 0e 	call	0x1ce4	; 0x1ce4 <xTaskRemoveFromEventList>
     da8:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
     daa:	0e 94 31 0f 	call	0x1e62	; 0x1e62 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
     dae:	11 50       	subi	r17, 0x01	; 1
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
     db0:	11 16       	cp	r1, r17
     db2:	9c f3       	brlt	.-26     	; 0xd9a <prvUnlockQueue+0x3e>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
     db4:	8f ef       	ldi	r24, 0xFF	; 255
     db6:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
     db8:	0f 90       	pop	r0
     dba:	0f be       	out	0x3f, r0	; 63
}
     dbc:	df 91       	pop	r29
     dbe:	cf 91       	pop	r28
     dc0:	1f 91       	pop	r17
     dc2:	08 95       	ret

00000dc4 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
     dc4:	cf 93       	push	r28
     dc6:	df 93       	push	r29
     dc8:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
     dca:	0f b6       	in	r0, 0x3f	; 63
     dcc:	f8 94       	cli
     dce:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
     dd0:	e8 81       	ld	r30, Y
     dd2:	f9 81       	ldd	r31, Y+1	; 0x01
     dd4:	8b 8d       	ldd	r24, Y+27	; 0x1b
     dd6:	90 e0       	ldi	r25, 0x00	; 0
     dd8:	2c 8d       	ldd	r18, Y+28	; 0x1c
     dda:	30 e0       	ldi	r19, 0x00	; 0
     ddc:	82 9f       	mul	r24, r18
     dde:	a0 01       	movw	r20, r0
     de0:	83 9f       	mul	r24, r19
     de2:	50 0d       	add	r21, r0
     de4:	92 9f       	mul	r25, r18
     de6:	50 0d       	add	r21, r0
     de8:	11 24       	eor	r1, r1
     dea:	4e 0f       	add	r20, r30
     dec:	5f 1f       	adc	r21, r31
     dee:	5b 83       	std	Y+3, r21	; 0x03
     df0:	4a 83       	std	Y+2, r20	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
     df2:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
     df4:	fd 83       	std	Y+5, r31	; 0x05
     df6:	ec 83       	std	Y+4, r30	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
     df8:	01 97       	sbiw	r24, 0x01	; 1
     dfa:	28 9f       	mul	r18, r24
     dfc:	a0 01       	movw	r20, r0
     dfe:	29 9f       	mul	r18, r25
     e00:	50 0d       	add	r21, r0
     e02:	38 9f       	mul	r19, r24
     e04:	50 0d       	add	r21, r0
     e06:	11 24       	eor	r1, r1
     e08:	cf 01       	movw	r24, r30
     e0a:	84 0f       	add	r24, r20
     e0c:	95 1f       	adc	r25, r21
     e0e:	9f 83       	std	Y+7, r25	; 0x07
     e10:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
     e12:	8f ef       	ldi	r24, 0xFF	; 255
     e14:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
     e16:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
     e18:	61 11       	cpse	r22, r1
     e1a:	0c c0       	rjmp	.+24     	; 0xe34 <xQueueGenericReset+0x70>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     e1c:	88 85       	ldd	r24, Y+8	; 0x08
     e1e:	88 23       	and	r24, r24
     e20:	89 f0       	breq	.+34     	; 0xe44 <xQueueGenericReset+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     e22:	ce 01       	movw	r24, r28
     e24:	08 96       	adiw	r24, 0x08	; 8
     e26:	0e 94 72 0e 	call	0x1ce4	; 0x1ce4 <xTaskRemoveFromEventList>
     e2a:	88 23       	and	r24, r24
     e2c:	59 f0       	breq	.+22     	; 0xe44 <xQueueGenericReset+0x80>
				{
					queueYIELD_IF_USING_PREEMPTION();
     e2e:	0e 94 34 05 	call	0xa68	; 0xa68 <vPortYield>
     e32:	08 c0       	rjmp	.+16     	; 0xe44 <xQueueGenericReset+0x80>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
     e34:	ce 01       	movw	r24, r28
     e36:	08 96       	adiw	r24, 0x08	; 8
     e38:	0e 94 04 04 	call	0x808	; 0x808 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
     e3c:	ce 01       	movw	r24, r28
     e3e:	41 96       	adiw	r24, 0x11	; 17
     e40:	0e 94 04 04 	call	0x808	; 0x808 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
     e44:	0f 90       	pop	r0
     e46:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
     e48:	81 e0       	ldi	r24, 0x01	; 1
     e4a:	df 91       	pop	r29
     e4c:	cf 91       	pop	r28
     e4e:	08 95       	ret

00000e50 <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
     e50:	0f 93       	push	r16
     e52:	1f 93       	push	r17
     e54:	f8 01       	movw	r30, r16
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
     e56:	61 11       	cpse	r22, r1
     e58:	03 c0       	rjmp	.+6      	; 0xe60 <prvInitialiseNewQueue+0x10>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
     e5a:	11 83       	std	Z+1, r17	; 0x01
     e5c:	00 83       	st	Z, r16
     e5e:	02 c0       	rjmp	.+4      	; 0xe64 <prvInitialiseNewQueue+0x14>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
     e60:	51 83       	std	Z+1, r21	; 0x01
     e62:	40 83       	st	Z, r20
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
     e64:	83 8f       	std	Z+27, r24	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
     e66:	64 8f       	std	Z+28, r22	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
     e68:	61 e0       	ldi	r22, 0x01	; 1
     e6a:	cf 01       	movw	r24, r30
     e6c:	0e 94 e2 06 	call	0xdc4	; 0xdc4 <xQueueGenericReset>
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
     e70:	1f 91       	pop	r17
     e72:	0f 91       	pop	r16
     e74:	08 95       	ret

00000e76 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
     e76:	df 92       	push	r13
     e78:	ef 92       	push	r14
     e7a:	ff 92       	push	r15
     e7c:	0f 93       	push	r16
     e7e:	1f 93       	push	r17
     e80:	cf 93       	push	r28
     e82:	df 93       	push	r29
     e84:	e8 2e       	mov	r14, r24
     e86:	f6 2e       	mov	r15, r22
     e88:	d4 2e       	mov	r13, r20
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
     e8a:	66 23       	and	r22, r22
     e8c:	21 f0       	breq	.+8      	; 0xe96 <xQueueGenericCreate+0x20>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     e8e:	86 9f       	mul	r24, r22
     e90:	c0 01       	movw	r24, r0
     e92:	11 24       	eor	r1, r1
     e94:	02 c0       	rjmp	.+4      	; 0xe9a <xQueueGenericCreate+0x24>
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
     e96:	80 e0       	ldi	r24, 0x00	; 0
     e98:	90 e0       	ldi	r25, 0x00	; 0
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
		}

		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
     e9a:	4f 96       	adiw	r24, 0x1f	; 31
     e9c:	0e 94 ec 05 	call	0xbd8	; 0xbd8 <pvPortMalloc>
     ea0:	ec 01       	movw	r28, r24

		if( pxNewQueue != NULL )
     ea2:	00 97       	sbiw	r24, 0x00	; 0
     ea4:	49 f0       	breq	.+18     	; 0xeb8 <xQueueGenericCreate+0x42>
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
     ea6:	8c 01       	movw	r16, r24
     ea8:	2d 2d       	mov	r18, r13
     eaa:	ac 01       	movw	r20, r24
     eac:	41 5e       	subi	r20, 0xE1	; 225
     eae:	5f 4f       	sbci	r21, 0xFF	; 255
     eb0:	6f 2d       	mov	r22, r15
     eb2:	8e 2d       	mov	r24, r14
     eb4:	0e 94 28 07 	call	0xe50	; 0xe50 <prvInitialiseNewQueue>
		}

		return pxNewQueue;
	}
     eb8:	ce 01       	movw	r24, r28
     eba:	df 91       	pop	r29
     ebc:	cf 91       	pop	r28
     ebe:	1f 91       	pop	r17
     ec0:	0f 91       	pop	r16
     ec2:	ff 90       	pop	r15
     ec4:	ef 90       	pop	r14
     ec6:	df 90       	pop	r13
     ec8:	08 95       	ret

00000eca <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
     eca:	cf 92       	push	r12
     ecc:	df 92       	push	r13
     ece:	ef 92       	push	r14
     ed0:	ff 92       	push	r15
     ed2:	0f 93       	push	r16
     ed4:	1f 93       	push	r17
     ed6:	cf 93       	push	r28
     ed8:	df 93       	push	r29
     eda:	00 d0       	rcall	.+0      	; 0xedc <xQueueGenericSend+0x12>
     edc:	00 d0       	rcall	.+0      	; 0xede <xQueueGenericSend+0x14>
     ede:	1f 92       	push	r1
     ee0:	cd b7       	in	r28, 0x3d	; 61
     ee2:	de b7       	in	r29, 0x3e	; 62
     ee4:	8c 01       	movw	r16, r24
     ee6:	7b 01       	movw	r14, r22
     ee8:	5d 83       	std	Y+5, r21	; 0x05
     eea:	4c 83       	std	Y+4, r20	; 0x04
     eec:	c2 2e       	mov	r12, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
     eee:	d1 2c       	mov	r13, r1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
     ef0:	0f b6       	in	r0, 0x3f	; 63
     ef2:	f8 94       	cli
     ef4:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
     ef6:	f8 01       	movw	r30, r16
     ef8:	92 8d       	ldd	r25, Z+26	; 0x1a
     efa:	83 8d       	ldd	r24, Z+27	; 0x1b
     efc:	98 17       	cp	r25, r24
     efe:	18 f0       	brcs	.+6      	; 0xf06 <xQueueGenericSend+0x3c>
     f00:	f2 e0       	ldi	r31, 0x02	; 2
     f02:	cf 12       	cpse	r12, r31
     f04:	19 c0       	rjmp	.+50     	; 0xf38 <xQueueGenericSend+0x6e>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     f06:	4c 2d       	mov	r20, r12
     f08:	b7 01       	movw	r22, r14
     f0a:	c8 01       	movw	r24, r16
     f0c:	0e 94 4b 06 	call	0xc96	; 0xc96 <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     f10:	f8 01       	movw	r30, r16
     f12:	91 89       	ldd	r25, Z+17	; 0x11
     f14:	99 23       	and	r25, r25
     f16:	49 f0       	breq	.+18     	; 0xf2a <xQueueGenericSend+0x60>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     f18:	c8 01       	movw	r24, r16
     f1a:	41 96       	adiw	r24, 0x11	; 17
     f1c:	0e 94 72 0e 	call	0x1ce4	; 0x1ce4 <xTaskRemoveFromEventList>
     f20:	88 23       	and	r24, r24
     f22:	31 f0       	breq	.+12     	; 0xf30 <xQueueGenericSend+0x66>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
     f24:	0e 94 34 05 	call	0xa68	; 0xa68 <vPortYield>
     f28:	03 c0       	rjmp	.+6      	; 0xf30 <xQueueGenericSend+0x66>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
     f2a:	81 11       	cpse	r24, r1
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
     f2c:	0e 94 34 05 	call	0xa68	; 0xa68 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
     f30:	0f 90       	pop	r0
     f32:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     f34:	81 e0       	ldi	r24, 0x01	; 1
     f36:	4d c0       	rjmp	.+154    	; 0xfd2 <xQueueGenericSend+0x108>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
     f38:	8c 81       	ldd	r24, Y+4	; 0x04
     f3a:	9d 81       	ldd	r25, Y+5	; 0x05
     f3c:	89 2b       	or	r24, r25
     f3e:	21 f4       	brne	.+8      	; 0xf48 <xQueueGenericSend+0x7e>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     f40:	0f 90       	pop	r0
     f42:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
     f44:	80 e0       	ldi	r24, 0x00	; 0
     f46:	45 c0       	rjmp	.+138    	; 0xfd2 <xQueueGenericSend+0x108>
				}
				else if( xEntryTimeSet == pdFALSE )
     f48:	d1 10       	cpse	r13, r1
     f4a:	06 c0       	rjmp	.+12     	; 0xf58 <xQueueGenericSend+0x8e>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     f4c:	ce 01       	movw	r24, r28
     f4e:	01 96       	adiw	r24, 0x01	; 1
     f50:	0e 94 f4 0e 	call	0x1de8	; 0x1de8 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     f54:	dd 24       	eor	r13, r13
     f56:	d3 94       	inc	r13
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
     f58:	0f 90       	pop	r0
     f5a:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     f5c:	0e 94 50 0c 	call	0x18a0	; 0x18a0 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     f60:	0f b6       	in	r0, 0x3f	; 63
     f62:	f8 94       	cli
     f64:	0f 92       	push	r0
     f66:	f8 01       	movw	r30, r16
     f68:	85 8d       	ldd	r24, Z+29	; 0x1d
     f6a:	8f 3f       	cpi	r24, 0xFF	; 255
     f6c:	09 f4       	brne	.+2      	; 0xf70 <xQueueGenericSend+0xa6>
     f6e:	15 8e       	std	Z+29, r1	; 0x1d
     f70:	f8 01       	movw	r30, r16
     f72:	86 8d       	ldd	r24, Z+30	; 0x1e
     f74:	8f 3f       	cpi	r24, 0xFF	; 255
     f76:	09 f4       	brne	.+2      	; 0xf7a <xQueueGenericSend+0xb0>
     f78:	16 8e       	std	Z+30, r1	; 0x1e
     f7a:	0f 90       	pop	r0
     f7c:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     f7e:	be 01       	movw	r22, r28
     f80:	6c 5f       	subi	r22, 0xFC	; 252
     f82:	7f 4f       	sbci	r23, 0xFF	; 255
     f84:	ce 01       	movw	r24, r28
     f86:	01 96       	adiw	r24, 0x01	; 1
     f88:	0e 94 ff 0e 	call	0x1dfe	; 0x1dfe <xTaskCheckForTimeOut>
     f8c:	81 11       	cpse	r24, r1
     f8e:	1b c0       	rjmp	.+54     	; 0xfc6 <xQueueGenericSend+0xfc>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
     f90:	c8 01       	movw	r24, r16
     f92:	0e 94 3d 06 	call	0xc7a	; 0xc7a <prvIsQueueFull>
     f96:	88 23       	and	r24, r24
     f98:	81 f0       	breq	.+32     	; 0xfba <xQueueGenericSend+0xf0>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     f9a:	6c 81       	ldd	r22, Y+4	; 0x04
     f9c:	7d 81       	ldd	r23, Y+5	; 0x05
     f9e:	c8 01       	movw	r24, r16
     fa0:	08 96       	adiw	r24, 0x08	; 8
     fa2:	0e 94 47 0e 	call	0x1c8e	; 0x1c8e <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
     fa6:	c8 01       	movw	r24, r16
     fa8:	0e 94 ae 06 	call	0xd5c	; 0xd5c <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
     fac:	0e 94 2a 0d 	call	0x1a54	; 0x1a54 <xTaskResumeAll>
     fb0:	81 11       	cpse	r24, r1
     fb2:	9e cf       	rjmp	.-196    	; 0xef0 <xQueueGenericSend+0x26>
				{
					portYIELD_WITHIN_API();
     fb4:	0e 94 34 05 	call	0xa68	; 0xa68 <vPortYield>
     fb8:	9b cf       	rjmp	.-202    	; 0xef0 <xQueueGenericSend+0x26>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     fba:	c8 01       	movw	r24, r16
     fbc:	0e 94 ae 06 	call	0xd5c	; 0xd5c <prvUnlockQueue>
				( void ) xTaskResumeAll();
     fc0:	0e 94 2a 0d 	call	0x1a54	; 0x1a54 <xTaskResumeAll>
     fc4:	95 cf       	rjmp	.-214    	; 0xef0 <xQueueGenericSend+0x26>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
     fc6:	c8 01       	movw	r24, r16
     fc8:	0e 94 ae 06 	call	0xd5c	; 0xd5c <prvUnlockQueue>
			( void ) xTaskResumeAll();
     fcc:	0e 94 2a 0d 	call	0x1a54	; 0x1a54 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
     fd0:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     fd2:	0f 90       	pop	r0
     fd4:	0f 90       	pop	r0
     fd6:	0f 90       	pop	r0
     fd8:	0f 90       	pop	r0
     fda:	0f 90       	pop	r0
     fdc:	df 91       	pop	r29
     fde:	cf 91       	pop	r28
     fe0:	1f 91       	pop	r17
     fe2:	0f 91       	pop	r16
     fe4:	ff 90       	pop	r15
     fe6:	ef 90       	pop	r14
     fe8:	df 90       	pop	r13
     fea:	cf 90       	pop	r12
     fec:	08 95       	ret

00000fee <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
     fee:	ef 92       	push	r14
     ff0:	ff 92       	push	r15
     ff2:	0f 93       	push	r16
     ff4:	1f 93       	push	r17
     ff6:	cf 93       	push	r28
     ff8:	df 93       	push	r29
     ffa:	8a 01       	movw	r16, r20
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
     ffc:	fc 01       	movw	r30, r24
     ffe:	52 8d       	ldd	r21, Z+26	; 0x1a
    1000:	33 8d       	ldd	r19, Z+27	; 0x1b
    1002:	53 17       	cp	r21, r19
    1004:	10 f0       	brcs	.+4      	; 0x100a <xQueueGenericSendFromISR+0x1c>
    1006:	22 30       	cpi	r18, 0x02	; 2
    1008:	f1 f4       	brne	.+60     	; 0x1046 <xQueueGenericSendFromISR+0x58>
    100a:	42 2f       	mov	r20, r18
    100c:	78 01       	movw	r14, r16
    100e:	ec 01       	movw	r28, r24
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    1010:	1e 8d       	ldd	r17, Y+30	; 0x1e
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1012:	0e 94 4b 06 	call	0xc96	; 0xc96 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    1016:	1f 3f       	cpi	r17, 0xFF	; 255
    1018:	81 f4       	brne	.+32     	; 0x103a <xQueueGenericSendFromISR+0x4c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    101a:	89 89       	ldd	r24, Y+17	; 0x11
    101c:	88 23       	and	r24, r24
    101e:	a9 f0       	breq	.+42     	; 0x104a <xQueueGenericSendFromISR+0x5c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1020:	ce 01       	movw	r24, r28
    1022:	41 96       	adiw	r24, 0x11	; 17
    1024:	0e 94 72 0e 	call	0x1ce4	; 0x1ce4 <xTaskRemoveFromEventList>
    1028:	88 23       	and	r24, r24
    102a:	89 f0       	breq	.+34     	; 0x104e <xQueueGenericSendFromISR+0x60>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    102c:	e1 14       	cp	r14, r1
    102e:	f1 04       	cpc	r15, r1
    1030:	81 f0       	breq	.+32     	; 0x1052 <xQueueGenericSendFromISR+0x64>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1032:	81 e0       	ldi	r24, 0x01	; 1
    1034:	f7 01       	movw	r30, r14
    1036:	80 83       	st	Z, r24
    1038:	0d c0       	rjmp	.+26     	; 0x1054 <xQueueGenericSendFromISR+0x66>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    103a:	ff 24       	eor	r15, r15
    103c:	f3 94       	inc	r15
    103e:	f1 0e       	add	r15, r17
    1040:	fe 8e       	std	Y+30, r15	; 0x1e
			}

			xReturn = pdPASS;
    1042:	81 e0       	ldi	r24, 0x01	; 1
    1044:	07 c0       	rjmp	.+14     	; 0x1054 <xQueueGenericSendFromISR+0x66>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1046:	80 e0       	ldi	r24, 0x00	; 0
    1048:	05 c0       	rjmp	.+10     	; 0x1054 <xQueueGenericSendFromISR+0x66>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
			}

			xReturn = pdPASS;
    104a:	81 e0       	ldi	r24, 0x01	; 1
    104c:	03 c0       	rjmp	.+6      	; 0x1054 <xQueueGenericSendFromISR+0x66>
    104e:	81 e0       	ldi	r24, 0x01	; 1
    1050:	01 c0       	rjmp	.+2      	; 0x1054 <xQueueGenericSendFromISR+0x66>
    1052:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1054:	df 91       	pop	r29
    1056:	cf 91       	pop	r28
    1058:	1f 91       	pop	r17
    105a:	0f 91       	pop	r16
    105c:	ff 90       	pop	r15
    105e:	ef 90       	pop	r14
    1060:	08 95       	ret

00001062 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1062:	cf 93       	push	r28
    1064:	df 93       	push	r29
    1066:	fc 01       	movw	r30, r24
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1068:	82 8d       	ldd	r24, Z+26	; 0x1a

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    106a:	93 8d       	ldd	r25, Z+27	; 0x1b
    106c:	89 17       	cp	r24, r25
    106e:	c0 f4       	brcc	.+48     	; 0x10a0 <xQueueGiveFromISR+0x3e>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    1070:	96 8d       	ldd	r25, Z+30	; 0x1e
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
    1072:	8f 5f       	subi	r24, 0xFF	; 255
    1074:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    1076:	9f 3f       	cpi	r25, 0xFF	; 255
    1078:	79 f4       	brne	.+30     	; 0x1098 <xQueueGiveFromISR+0x36>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    107a:	81 89       	ldd	r24, Z+17	; 0x11
    107c:	88 23       	and	r24, r24
    107e:	91 f0       	breq	.+36     	; 0x10a4 <xQueueGiveFromISR+0x42>
    1080:	eb 01       	movw	r28, r22
    1082:	cf 01       	movw	r24, r30
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1084:	41 96       	adiw	r24, 0x11	; 17
    1086:	0e 94 72 0e 	call	0x1ce4	; 0x1ce4 <xTaskRemoveFromEventList>
    108a:	88 23       	and	r24, r24
    108c:	69 f0       	breq	.+26     	; 0x10a8 <xQueueGiveFromISR+0x46>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    108e:	20 97       	sbiw	r28, 0x00	; 0
    1090:	69 f0       	breq	.+26     	; 0x10ac <xQueueGiveFromISR+0x4a>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1092:	81 e0       	ldi	r24, 0x01	; 1
    1094:	88 83       	st	Y, r24
    1096:	0b c0       	rjmp	.+22     	; 0x10ae <xQueueGiveFromISR+0x4c>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    1098:	9f 5f       	subi	r25, 0xFF	; 255
    109a:	96 8f       	std	Z+30, r25	; 0x1e
			}

			xReturn = pdPASS;
    109c:	81 e0       	ldi	r24, 0x01	; 1
    109e:	07 c0       	rjmp	.+14     	; 0x10ae <xQueueGiveFromISR+0x4c>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    10a0:	80 e0       	ldi	r24, 0x00	; 0
    10a2:	05 c0       	rjmp	.+10     	; 0x10ae <xQueueGiveFromISR+0x4c>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
			}

			xReturn = pdPASS;
    10a4:	81 e0       	ldi	r24, 0x01	; 1
    10a6:	03 c0       	rjmp	.+6      	; 0x10ae <xQueueGiveFromISR+0x4c>
    10a8:	81 e0       	ldi	r24, 0x01	; 1
    10aa:	01 c0       	rjmp	.+2      	; 0x10ae <xQueueGiveFromISR+0x4c>
    10ac:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    10ae:	df 91       	pop	r29
    10b0:	cf 91       	pop	r28
    10b2:	08 95       	ret

000010b4 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    10b4:	8f 92       	push	r8
    10b6:	9f 92       	push	r9
    10b8:	bf 92       	push	r11
    10ba:	cf 92       	push	r12
    10bc:	df 92       	push	r13
    10be:	ef 92       	push	r14
    10c0:	ff 92       	push	r15
    10c2:	0f 93       	push	r16
    10c4:	1f 93       	push	r17
    10c6:	cf 93       	push	r28
    10c8:	df 93       	push	r29
    10ca:	00 d0       	rcall	.+0      	; 0x10cc <xQueueGenericReceive+0x18>
    10cc:	00 d0       	rcall	.+0      	; 0x10ce <xQueueGenericReceive+0x1a>
    10ce:	1f 92       	push	r1
    10d0:	cd b7       	in	r28, 0x3d	; 61
    10d2:	de b7       	in	r29, 0x3e	; 62
    10d4:	8c 01       	movw	r16, r24
    10d6:	6b 01       	movw	r12, r22
    10d8:	5d 83       	std	Y+5, r21	; 0x05
    10da:	4c 83       	std	Y+4, r20	; 0x04
    10dc:	b2 2e       	mov	r11, r18
BaseType_t xEntryTimeSet = pdFALSE;
    10de:	e1 2c       	mov	r14, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    10e0:	0f b6       	in	r0, 0x3f	; 63
    10e2:	f8 94       	cli
    10e4:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    10e6:	f8 01       	movw	r30, r16
    10e8:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    10ea:	ff 20       	and	r15, r15
    10ec:	41 f1       	breq	.+80     	; 0x113e <__stack+0x3f>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    10ee:	86 80       	ldd	r8, Z+6	; 0x06
    10f0:	97 80       	ldd	r9, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    10f2:	b6 01       	movw	r22, r12
    10f4:	c8 01       	movw	r24, r16
    10f6:	0e 94 94 06 	call	0xd28	; 0xd28 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    10fa:	b1 10       	cpse	r11, r1
    10fc:	0f c0       	rjmp	.+30     	; 0x111c <__stack+0x1d>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
    10fe:	fa 94       	dec	r15
    1100:	f8 01       	movw	r30, r16
    1102:	f2 8e       	std	Z+26, r15	; 0x1a
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1104:	80 85       	ldd	r24, Z+8	; 0x08
    1106:	88 23       	and	r24, r24
    1108:	b1 f0       	breq	.+44     	; 0x1136 <__stack+0x37>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    110a:	c8 01       	movw	r24, r16
    110c:	08 96       	adiw	r24, 0x08	; 8
    110e:	0e 94 72 0e 	call	0x1ce4	; 0x1ce4 <xTaskRemoveFromEventList>
    1112:	88 23       	and	r24, r24
    1114:	81 f0       	breq	.+32     	; 0x1136 <__stack+0x37>
						{
							queueYIELD_IF_USING_PREEMPTION();
    1116:	0e 94 34 05 	call	0xa68	; 0xa68 <vPortYield>
    111a:	0d c0       	rjmp	.+26     	; 0x1136 <__stack+0x37>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    111c:	f8 01       	movw	r30, r16
    111e:	97 82       	std	Z+7, r9	; 0x07
    1120:	86 82       	std	Z+6, r8	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1122:	81 89       	ldd	r24, Z+17	; 0x11
    1124:	88 23       	and	r24, r24
    1126:	39 f0       	breq	.+14     	; 0x1136 <__stack+0x37>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1128:	c8 01       	movw	r24, r16
    112a:	41 96       	adiw	r24, 0x11	; 17
    112c:	0e 94 72 0e 	call	0x1ce4	; 0x1ce4 <xTaskRemoveFromEventList>
    1130:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    1132:	0e 94 34 05 	call	0xa68	; 0xa68 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    1136:	0f 90       	pop	r0
    1138:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    113a:	81 e0       	ldi	r24, 0x01	; 1
    113c:	53 c0       	rjmp	.+166    	; 0x11e4 <__stack+0xe5>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    113e:	8c 81       	ldd	r24, Y+4	; 0x04
    1140:	9d 81       	ldd	r25, Y+5	; 0x05
    1142:	89 2b       	or	r24, r25
    1144:	21 f4       	brne	.+8      	; 0x114e <__stack+0x4f>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1146:	0f 90       	pop	r0
    1148:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    114a:	80 e0       	ldi	r24, 0x00	; 0
    114c:	4b c0       	rjmp	.+150    	; 0x11e4 <__stack+0xe5>
				}
				else if( xEntryTimeSet == pdFALSE )
    114e:	e1 10       	cpse	r14, r1
    1150:	06 c0       	rjmp	.+12     	; 0x115e <__stack+0x5f>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1152:	ce 01       	movw	r24, r28
    1154:	01 96       	adiw	r24, 0x01	; 1
    1156:	0e 94 f4 0e 	call	0x1de8	; 0x1de8 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    115a:	ee 24       	eor	r14, r14
    115c:	e3 94       	inc	r14
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    115e:	0f 90       	pop	r0
    1160:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1162:	0e 94 50 0c 	call	0x18a0	; 0x18a0 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1166:	0f b6       	in	r0, 0x3f	; 63
    1168:	f8 94       	cli
    116a:	0f 92       	push	r0
    116c:	f8 01       	movw	r30, r16
    116e:	85 8d       	ldd	r24, Z+29	; 0x1d
    1170:	8f 3f       	cpi	r24, 0xFF	; 255
    1172:	09 f4       	brne	.+2      	; 0x1176 <__stack+0x77>
    1174:	15 8e       	std	Z+29, r1	; 0x1d
    1176:	f8 01       	movw	r30, r16
    1178:	86 8d       	ldd	r24, Z+30	; 0x1e
    117a:	8f 3f       	cpi	r24, 0xFF	; 255
    117c:	09 f4       	brne	.+2      	; 0x1180 <__stack+0x81>
    117e:	16 8e       	std	Z+30, r1	; 0x1e
    1180:	0f 90       	pop	r0
    1182:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1184:	be 01       	movw	r22, r28
    1186:	6c 5f       	subi	r22, 0xFC	; 252
    1188:	7f 4f       	sbci	r23, 0xFF	; 255
    118a:	ce 01       	movw	r24, r28
    118c:	01 96       	adiw	r24, 0x01	; 1
    118e:	0e 94 ff 0e 	call	0x1dfe	; 0x1dfe <xTaskCheckForTimeOut>
    1192:	81 11       	cpse	r24, r1
    1194:	1b c0       	rjmp	.+54     	; 0x11cc <__stack+0xcd>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1196:	c8 01       	movw	r24, r16
    1198:	0e 94 30 06 	call	0xc60	; 0xc60 <prvIsQueueEmpty>
    119c:	88 23       	and	r24, r24
    119e:	81 f0       	breq	.+32     	; 0x11c0 <__stack+0xc1>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    11a0:	6c 81       	ldd	r22, Y+4	; 0x04
    11a2:	7d 81       	ldd	r23, Y+5	; 0x05
    11a4:	c8 01       	movw	r24, r16
    11a6:	41 96       	adiw	r24, 0x11	; 17
    11a8:	0e 94 47 0e 	call	0x1c8e	; 0x1c8e <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    11ac:	c8 01       	movw	r24, r16
    11ae:	0e 94 ae 06 	call	0xd5c	; 0xd5c <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    11b2:	0e 94 2a 0d 	call	0x1a54	; 0x1a54 <xTaskResumeAll>
    11b6:	81 11       	cpse	r24, r1
    11b8:	93 cf       	rjmp	.-218    	; 0x10e0 <xQueueGenericReceive+0x2c>
				{
					portYIELD_WITHIN_API();
    11ba:	0e 94 34 05 	call	0xa68	; 0xa68 <vPortYield>
    11be:	90 cf       	rjmp	.-224    	; 0x10e0 <xQueueGenericReceive+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    11c0:	c8 01       	movw	r24, r16
    11c2:	0e 94 ae 06 	call	0xd5c	; 0xd5c <prvUnlockQueue>
				( void ) xTaskResumeAll();
    11c6:	0e 94 2a 0d 	call	0x1a54	; 0x1a54 <xTaskResumeAll>
    11ca:	8a cf       	rjmp	.-236    	; 0x10e0 <xQueueGenericReceive+0x2c>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    11cc:	c8 01       	movw	r24, r16
    11ce:	0e 94 ae 06 	call	0xd5c	; 0xd5c <prvUnlockQueue>
			( void ) xTaskResumeAll();
    11d2:	0e 94 2a 0d 	call	0x1a54	; 0x1a54 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    11d6:	c8 01       	movw	r24, r16
    11d8:	0e 94 30 06 	call	0xc60	; 0xc60 <prvIsQueueEmpty>
    11dc:	88 23       	and	r24, r24
    11de:	09 f4       	brne	.+2      	; 0x11e2 <__stack+0xe3>
    11e0:	7f cf       	rjmp	.-258    	; 0x10e0 <xQueueGenericReceive+0x2c>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    11e2:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
    11e4:	0f 90       	pop	r0
    11e6:	0f 90       	pop	r0
    11e8:	0f 90       	pop	r0
    11ea:	0f 90       	pop	r0
    11ec:	0f 90       	pop	r0
    11ee:	df 91       	pop	r29
    11f0:	cf 91       	pop	r28
    11f2:	1f 91       	pop	r17
    11f4:	0f 91       	pop	r16
    11f6:	ff 90       	pop	r15
    11f8:	ef 90       	pop	r14
    11fa:	df 90       	pop	r13
    11fc:	cf 90       	pop	r12
    11fe:	bf 90       	pop	r11
    1200:	9f 90       	pop	r9
    1202:	8f 90       	pop	r8
    1204:	08 95       	ret

00001206 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1206:	ef 92       	push	r14
    1208:	ff 92       	push	r15
    120a:	0f 93       	push	r16
    120c:	1f 93       	push	r17
    120e:	cf 93       	push	r28
    1210:	df 93       	push	r29
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1212:	fc 01       	movw	r30, r24
    1214:	c2 8d       	ldd	r28, Z+26	; 0x1a

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1216:	cc 23       	and	r28, r28
    1218:	f9 f0       	breq	.+62     	; 0x1258 <xQueueReceiveFromISR+0x52>
    121a:	7a 01       	movw	r14, r20
    121c:	8c 01       	movw	r16, r24
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    121e:	d5 8d       	ldd	r29, Z+29	; 0x1d

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1220:	0e 94 94 06 	call	0xd28	; 0xd28 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
    1224:	c1 50       	subi	r28, 0x01	; 1
    1226:	f8 01       	movw	r30, r16
    1228:	c2 8f       	std	Z+26, r28	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    122a:	df 3f       	cpi	r29, 0xFF	; 255
    122c:	81 f4       	brne	.+32     	; 0x124e <xQueueReceiveFromISR+0x48>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    122e:	80 85       	ldd	r24, Z+8	; 0x08
    1230:	88 23       	and	r24, r24
    1232:	a1 f0       	breq	.+40     	; 0x125c <xQueueReceiveFromISR+0x56>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1234:	c8 01       	movw	r24, r16
    1236:	08 96       	adiw	r24, 0x08	; 8
    1238:	0e 94 72 0e 	call	0x1ce4	; 0x1ce4 <xTaskRemoveFromEventList>
    123c:	88 23       	and	r24, r24
    123e:	81 f0       	breq	.+32     	; 0x1260 <xQueueReceiveFromISR+0x5a>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    1240:	e1 14       	cp	r14, r1
    1242:	f1 04       	cpc	r15, r1
    1244:	79 f0       	breq	.+30     	; 0x1264 <xQueueReceiveFromISR+0x5e>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    1246:	81 e0       	ldi	r24, 0x01	; 1
    1248:	f7 01       	movw	r30, r14
    124a:	80 83       	st	Z, r24
    124c:	0c c0       	rjmp	.+24     	; 0x1266 <xQueueReceiveFromISR+0x60>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    124e:	df 5f       	subi	r29, 0xFF	; 255
    1250:	f8 01       	movw	r30, r16
    1252:	d5 8f       	std	Z+29, r29	; 0x1d
			}

			xReturn = pdPASS;
    1254:	81 e0       	ldi	r24, 0x01	; 1
    1256:	07 c0       	rjmp	.+14     	; 0x1266 <xQueueReceiveFromISR+0x60>
		}
		else
		{
			xReturn = pdFAIL;
    1258:	80 e0       	ldi	r24, 0x00	; 0
    125a:	05 c0       	rjmp	.+10     	; 0x1266 <xQueueReceiveFromISR+0x60>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
			}

			xReturn = pdPASS;
    125c:	81 e0       	ldi	r24, 0x01	; 1
    125e:	03 c0       	rjmp	.+6      	; 0x1266 <xQueueReceiveFromISR+0x60>
    1260:	81 e0       	ldi	r24, 0x01	; 1
    1262:	01 c0       	rjmp	.+2      	; 0x1266 <xQueueReceiveFromISR+0x60>
    1264:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1266:	df 91       	pop	r29
    1268:	cf 91       	pop	r28
    126a:	1f 91       	pop	r17
    126c:	0f 91       	pop	r16
    126e:	ff 90       	pop	r15
    1270:	ef 90       	pop	r14
    1272:	08 95       	ret

00001274 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    1274:	0f 93       	push	r16
    1276:	1f 93       	push	r17
    1278:	cf 93       	push	r28
    127a:	df 93       	push	r29
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    127c:	fc 01       	movw	r30, r24
    127e:	22 8d       	ldd	r18, Z+26	; 0x1a
    1280:	22 23       	and	r18, r18
    1282:	49 f0       	breq	.+18     	; 0x1296 <xQueuePeekFromISR+0x22>
    1284:	ec 01       	movw	r28, r24
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    1286:	06 81       	ldd	r16, Z+6	; 0x06
    1288:	17 81       	ldd	r17, Z+7	; 0x07
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    128a:	0e 94 94 06 	call	0xd28	; 0xd28 <prvCopyDataFromQueue>
			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    128e:	1f 83       	std	Y+7, r17	; 0x07
    1290:	0e 83       	std	Y+6, r16	; 0x06

			xReturn = pdPASS;
    1292:	81 e0       	ldi	r24, 0x01	; 1
    1294:	01 c0       	rjmp	.+2      	; 0x1298 <xQueuePeekFromISR+0x24>
		}
		else
		{
			xReturn = pdFAIL;
    1296:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1298:	df 91       	pop	r29
    129a:	cf 91       	pop	r28
    129c:	1f 91       	pop	r17
    129e:	0f 91       	pop	r16
    12a0:	08 95       	ret

000012a2 <uxQueueMessagesWaiting>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    12a2:	0f b6       	in	r0, 0x3f	; 63
    12a4:	f8 94       	cli
    12a6:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    12a8:	fc 01       	movw	r30, r24
    12aa:	82 8d       	ldd	r24, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    12ac:	0f 90       	pop	r0
    12ae:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    12b0:	08 95       	ret

000012b2 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    12b2:	fc 01       	movw	r30, r24
Queue_t *pxQueue;

	pxQueue = ( Queue_t * ) xQueue;
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    12b4:	0f b6       	in	r0, 0x3f	; 63
    12b6:	f8 94       	cli
    12b8:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    12ba:	93 8d       	ldd	r25, Z+27	; 0x1b
    12bc:	82 8d       	ldd	r24, Z+26	; 0x1a
    12be:	98 1b       	sub	r25, r24
    12c0:	89 2f       	mov	r24, r25
	}
	taskEXIT_CRITICAL();
    12c2:	0f 90       	pop	r0
    12c4:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    12c6:	08 95       	ret

000012c8 <uxQueueMessagesWaitingFromISR>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    12c8:	fc 01       	movw	r30, r24
    12ca:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    12cc:	08 95       	ret

000012ce <vQueueDelete>:

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    12ce:	0e 94 21 06 	call	0xc42	; 0xc42 <vPortFree>
    12d2:	08 95       	ret

000012d4 <xQueueIsQueueEmptyFromISR>:
BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
    12d4:	fc 01       	movw	r30, r24
    12d6:	82 8d       	ldd	r24, Z+26	; 0x1a
    12d8:	81 11       	cpse	r24, r1
    12da:	02 c0       	rjmp	.+4      	; 0x12e0 <xQueueIsQueueEmptyFromISR+0xc>
	{
		xReturn = pdTRUE;
    12dc:	81 e0       	ldi	r24, 0x01	; 1
    12de:	08 95       	ret
	}
	else
	{
		xReturn = pdFALSE;
    12e0:	80 e0       	ldi	r24, 0x00	; 0
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    12e2:	08 95       	ret

000012e4 <xQueueIsQueueFullFromISR>:
BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
    12e4:	fc 01       	movw	r30, r24
    12e6:	22 8d       	ldd	r18, Z+26	; 0x1a
    12e8:	83 8d       	ldd	r24, Z+27	; 0x1b
    12ea:	28 13       	cpse	r18, r24
    12ec:	02 c0       	rjmp	.+4      	; 0x12f2 <xQueueIsQueueFullFromISR+0xe>
	{
		xReturn = pdTRUE;
    12ee:	81 e0       	ldi	r24, 0x01	; 1
    12f0:	08 95       	ret
	}
	else
	{
		xReturn = pdFALSE;
    12f2:	80 e0       	ldi	r24, 0x00	; 0
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    12f4:	08 95       	ret

000012f6 <xQueueCRSend>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait )
	{
    12f6:	ef 92       	push	r14
    12f8:	ff 92       	push	r15
    12fa:	0f 93       	push	r16
    12fc:	1f 93       	push	r17
    12fe:	cf 93       	push	r28
    1300:	df 93       	push	r29
    1302:	ec 01       	movw	r28, r24
    1304:	7b 01       	movw	r14, r22
    1306:	8a 01       	movw	r16, r20
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;

		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    1308:	f8 94       	cli
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    130a:	0e 94 3d 06 	call	0xc7a	; 0xc7a <prvIsQueueFull>
    130e:	88 23       	and	r24, r24
    1310:	79 f0       	breq	.+30     	; 0x1330 <xQueueCRSend+0x3a>
			{
				/* The queue is full - do we want to block or just leave without
				posting? */
				if( xTicksToWait > ( TickType_t ) 0 )
    1312:	01 15       	cp	r16, r1
    1314:	11 05       	cpc	r17, r1
    1316:	49 f0       	breq	.+18     	; 0x132a <xQueueCRSend+0x34>
				{
					/* As this is called from a coroutine we cannot block directly, but
					return indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    1318:	be 01       	movw	r22, r28
    131a:	68 5f       	subi	r22, 0xF8	; 248
    131c:	7f 4f       	sbci	r23, 0xFF	; 255
    131e:	c8 01       	movw	r24, r16
    1320:	0e 94 aa 01 	call	0x354	; 0x354 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    1324:	78 94       	sei
					return errQUEUE_BLOCKED;
    1326:	8c ef       	ldi	r24, 0xFC	; 252
    1328:	1f c0       	rjmp	.+62     	; 0x1368 <xQueueCRSend+0x72>
				}
				else
				{
					portENABLE_INTERRUPTS();
    132a:	78 94       	sei
					return errQUEUE_FULL;
    132c:	80 e0       	ldi	r24, 0x00	; 0
    132e:	1c c0       	rjmp	.+56     	; 0x1368 <xQueueCRSend+0x72>
				}
			}
		}
		portENABLE_INTERRUPTS();
    1330:	78 94       	sei

		portDISABLE_INTERRUPTS();
    1332:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1334:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1336:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1338:	98 17       	cp	r25, r24
    133a:	80 f4       	brcc	.+32     	; 0x135c <xQueueCRSend+0x66>
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    133c:	40 e0       	ldi	r20, 0x00	; 0
    133e:	b7 01       	movw	r22, r14
    1340:	ce 01       	movw	r24, r28
    1342:	0e 94 4b 06 	call	0xc96	; 0xc96 <prvCopyDataToQueue>
				xReturn = pdPASS;

				/* Were any co-routines waiting for data to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1346:	89 89       	ldd	r24, Y+17	; 0x11
    1348:	88 23       	and	r24, r24
    134a:	51 f0       	breq	.+20     	; 0x1360 <xQueueCRSend+0x6a>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    134c:	ce 01       	movw	r24, r28
    134e:	41 96       	adiw	r24, 0x11	; 17
    1350:	0e 94 45 02 	call	0x48a	; 0x48a <xCoRoutineRemoveFromEventList>
    1354:	81 11       	cpse	r24, r1
    1356:	06 c0       	rjmp	.+12     	; 0x1364 <xQueueCRSend+0x6e>
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
				xReturn = pdPASS;
    1358:	81 e0       	ldi	r24, 0x01	; 1
    135a:	05 c0       	rjmp	.+10     	; 0x1366 <xQueueCRSend+0x70>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = errQUEUE_FULL;
    135c:	80 e0       	ldi	r24, 0x00	; 0
    135e:	03 c0       	rjmp	.+6      	; 0x1366 <xQueueCRSend+0x70>
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
				xReturn = pdPASS;
    1360:	81 e0       	ldi	r24, 0x01	; 1
    1362:	01 c0       	rjmp	.+2      	; 0x1366 <xQueueCRSend+0x70>
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
					{
						/* The co-routine waiting has a higher priority so record
						that a yield might be appropriate. */
						xReturn = errQUEUE_YIELD;
    1364:	8b ef       	ldi	r24, 0xFB	; 251
			else
			{
				xReturn = errQUEUE_FULL;
			}
		}
		portENABLE_INTERRUPTS();
    1366:	78 94       	sei

		return xReturn;
	}
    1368:	df 91       	pop	r29
    136a:	cf 91       	pop	r28
    136c:	1f 91       	pop	r17
    136e:	0f 91       	pop	r16
    1370:	ff 90       	pop	r15
    1372:	ef 90       	pop	r14
    1374:	08 95       	ret

00001376 <xQueueCRReceive>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
	{
    1376:	cf 93       	push	r28
    1378:	df 93       	push	r29
    137a:	ec 01       	movw	r28, r24
    137c:	9b 01       	movw	r18, r22
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;

		/* If the queue is already empty we may have to block.  A critical section
		is required to prevent an interrupt adding something to the queue
		between the check to see if the queue is empty and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    137e:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1380:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1382:	91 11       	cpse	r25, r1
    1384:	0f c0       	rjmp	.+30     	; 0x13a4 <xQueueCRReceive+0x2e>
			{
				/* There are no messages in the queue, do we want to block or just
				leave with nothing? */
				if( xTicksToWait > ( TickType_t ) 0 )
    1386:	41 15       	cp	r20, r1
    1388:	51 05       	cpc	r21, r1
    138a:	49 f0       	breq	.+18     	; 0x139e <xQueueCRReceive+0x28>
				{
					/* As this is a co-routine we cannot block directly, but return
					indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    138c:	be 01       	movw	r22, r28
    138e:	6f 5e       	subi	r22, 0xEF	; 239
    1390:	7f 4f       	sbci	r23, 0xFF	; 255
    1392:	ca 01       	movw	r24, r20
    1394:	0e 94 aa 01 	call	0x354	; 0x354 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    1398:	78 94       	sei
					return errQUEUE_BLOCKED;
    139a:	8c ef       	ldi	r24, 0xFC	; 252
    139c:	32 c0       	rjmp	.+100    	; 0x1402 <xQueueCRReceive+0x8c>
				}
				else
				{
					portENABLE_INTERRUPTS();
    139e:	78 94       	sei
					return errQUEUE_FULL;
    13a0:	80 e0       	ldi	r24, 0x00	; 0
    13a2:	2f c0       	rjmp	.+94     	; 0x1402 <xQueueCRReceive+0x8c>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portENABLE_INTERRUPTS();
    13a4:	78 94       	sei

		portDISABLE_INTERRUPTS();
    13a6:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    13a8:	8a 8d       	ldd	r24, Y+26	; 0x1a
    13aa:	88 23       	and	r24, r24
    13ac:	21 f1       	breq	.+72     	; 0x13f6 <xQueueCRReceive+0x80>
			{
				/* Data is available from the queue. */
				pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    13ae:	4c 8d       	ldd	r20, Y+28	; 0x1c
    13b0:	50 e0       	ldi	r21, 0x00	; 0
    13b2:	8e 81       	ldd	r24, Y+6	; 0x06
    13b4:	9f 81       	ldd	r25, Y+7	; 0x07
    13b6:	84 0f       	add	r24, r20
    13b8:	95 1f       	adc	r25, r21
    13ba:	9f 83       	std	Y+7, r25	; 0x07
    13bc:	8e 83       	std	Y+6, r24	; 0x06
				if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
    13be:	6a 81       	ldd	r22, Y+2	; 0x02
    13c0:	7b 81       	ldd	r23, Y+3	; 0x03
    13c2:	86 17       	cp	r24, r22
    13c4:	97 07       	cpc	r25, r23
    13c6:	20 f0       	brcs	.+8      	; 0x13d0 <xQueueCRReceive+0x5a>
				{
					pxQueue->u.pcReadFrom = pxQueue->pcHead;
    13c8:	88 81       	ld	r24, Y
    13ca:	99 81       	ldd	r25, Y+1	; 0x01
    13cc:	9f 83       	std	Y+7, r25	; 0x07
    13ce:	8e 83       	std	Y+6, r24	; 0x06
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
    13d0:	8a 8d       	ldd	r24, Y+26	; 0x1a
    13d2:	81 50       	subi	r24, 0x01	; 1
    13d4:	8a 8f       	std	Y+26, r24	; 0x1a
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    13d6:	6e 81       	ldd	r22, Y+6	; 0x06
    13d8:	7f 81       	ldd	r23, Y+7	; 0x07
    13da:	c9 01       	movw	r24, r18
    13dc:	0e 94 28 15 	call	0x2a50	; 0x2a50 <memcpy>

				xReturn = pdPASS;

				/* Were any co-routines waiting for space to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    13e0:	88 85       	ldd	r24, Y+8	; 0x08
    13e2:	88 23       	and	r24, r24
    13e4:	51 f0       	breq	.+20     	; 0x13fa <xQueueCRReceive+0x84>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    13e6:	ce 01       	movw	r24, r28
    13e8:	08 96       	adiw	r24, 0x08	; 8
    13ea:	0e 94 45 02 	call	0x48a	; 0x48a <xCoRoutineRemoveFromEventList>
    13ee:	81 11       	cpse	r24, r1
    13f0:	06 c0       	rjmp	.+12     	; 0x13fe <xQueueCRReceive+0x88>
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

				xReturn = pdPASS;
    13f2:	81 e0       	ldi	r24, 0x01	; 1
    13f4:	05 c0       	rjmp	.+10     	; 0x1400 <xQueueCRReceive+0x8a>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = pdFAIL;
    13f6:	80 e0       	ldi	r24, 0x00	; 0
    13f8:	03 c0       	rjmp	.+6      	; 0x1400 <xQueueCRReceive+0x8a>
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

				xReturn = pdPASS;
    13fa:	81 e0       	ldi	r24, 0x01	; 1
    13fc:	01 c0       	rjmp	.+2      	; 0x1400 <xQueueCRReceive+0x8a>
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
					{
						xReturn = errQUEUE_YIELD;
    13fe:	8b ef       	ldi	r24, 0xFB	; 251
			else
			{
				xReturn = pdFAIL;
			}
		}
		portENABLE_INTERRUPTS();
    1400:	78 94       	sei

		return xReturn;
	}
    1402:	df 91       	pop	r29
    1404:	cf 91       	pop	r28
    1406:	08 95       	ret

00001408 <xQueueCRSendFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken )
	{
    1408:	0f 93       	push	r16
    140a:	1f 93       	push	r17
    140c:	cf 93       	push	r28
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;

		/* Cannot block within an ISR so if there is no space on the queue then
		exit without doing anything. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    140e:	fc 01       	movw	r30, r24
    1410:	32 8d       	ldd	r19, Z+26	; 0x1a
    1412:	23 8d       	ldd	r18, Z+27	; 0x1b
    1414:	32 17       	cp	r19, r18
    1416:	98 f4       	brcc	.+38     	; 0x143e <xQueueCRSendFromISR+0x36>
    1418:	c4 2f       	mov	r28, r20
    141a:	8c 01       	movw	r16, r24
		{
			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    141c:	40 e0       	ldi	r20, 0x00	; 0
    141e:	0e 94 4b 06 	call	0xc96	; 0xc96 <prvCopyDataToQueue>

			/* We only want to wake one co-routine per ISR, so check that a
			co-routine has not already been woken. */
			if( xCoRoutinePreviouslyWoken == pdFALSE )
    1422:	c1 11       	cpse	r28, r1
    1424:	0e c0       	rjmp	.+28     	; 0x1442 <xQueueCRSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1426:	f8 01       	movw	r30, r16
    1428:	81 89       	ldd	r24, Z+17	; 0x11
    142a:	88 23       	and	r24, r24
    142c:	61 f0       	breq	.+24     	; 0x1446 <xQueueCRSendFromISR+0x3e>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    142e:	c8 01       	movw	r24, r16
    1430:	41 96       	adiw	r24, 0x11	; 17
    1432:	0e 94 45 02 	call	0x48a	; 0x48a <xCoRoutineRemoveFromEventList>
    1436:	88 23       	and	r24, r24
    1438:	41 f0       	breq	.+16     	; 0x144a <xQueueCRSendFromISR+0x42>
					{
						return pdTRUE;
    143a:	81 e0       	ldi	r24, 0x01	; 1
    143c:	07 c0       	rjmp	.+14     	; 0x144c <xQueueCRSendFromISR+0x44>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xCoRoutinePreviouslyWoken;
    143e:	84 2f       	mov	r24, r20
    1440:	05 c0       	rjmp	.+10     	; 0x144c <xQueueCRSendFromISR+0x44>
    1442:	8c 2f       	mov	r24, r28
    1444:	03 c0       	rjmp	.+6      	; 0x144c <xQueueCRSendFromISR+0x44>
    1446:	8c 2f       	mov	r24, r28
    1448:	01 c0       	rjmp	.+2      	; 0x144c <xQueueCRSendFromISR+0x44>
    144a:	8c 2f       	mov	r24, r28
	}
    144c:	cf 91       	pop	r28
    144e:	1f 91       	pop	r17
    1450:	0f 91       	pop	r16
    1452:	08 95       	ret

00001454 <xQueueCRReceiveFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWoken )
	{
    1454:	0f 93       	push	r16
    1456:	1f 93       	push	r17
    1458:	cf 93       	push	r28
    145a:	df 93       	push	r29
    145c:	fc 01       	movw	r30, r24
	BaseType_t xReturn;
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;

		/* We cannot block from an ISR, so check there is data available. If
		not then just leave without doing anything. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    145e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1460:	88 23       	and	r24, r24
    1462:	69 f1       	breq	.+90     	; 0x14be <xQueueCRReceiveFromISR+0x6a>
		{
			/* Copy the data from the queue. */
			pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    1464:	24 8d       	ldd	r18, Z+28	; 0x1c
    1466:	30 e0       	ldi	r19, 0x00	; 0
    1468:	a6 81       	ldd	r26, Z+6	; 0x06
    146a:	b7 81       	ldd	r27, Z+7	; 0x07
    146c:	a2 0f       	add	r26, r18
    146e:	b3 1f       	adc	r27, r19
    1470:	b7 83       	std	Z+7, r27	; 0x07
    1472:	a6 83       	std	Z+6, r26	; 0x06
			if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
    1474:	82 81       	ldd	r24, Z+2	; 0x02
    1476:	93 81       	ldd	r25, Z+3	; 0x03
    1478:	a8 17       	cp	r26, r24
    147a:	b9 07       	cpc	r27, r25
    147c:	20 f0       	brcs	.+8      	; 0x1486 <xQueueCRReceiveFromISR+0x32>
			{
				pxQueue->u.pcReadFrom = pxQueue->pcHead;
    147e:	80 81       	ld	r24, Z
    1480:	91 81       	ldd	r25, Z+1	; 0x01
    1482:	97 83       	std	Z+7, r25	; 0x07
    1484:	86 83       	std	Z+6, r24	; 0x06
    1486:	8a 01       	movw	r16, r20
    1488:	cb 01       	movw	r24, r22
    148a:	ef 01       	movw	r28, r30
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
			--( pxQueue->uxMessagesWaiting );
    148c:	42 8d       	ldd	r20, Z+26	; 0x1a
    148e:	41 50       	subi	r20, 0x01	; 1
    1490:	42 8f       	std	Z+26, r20	; 0x1a
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1492:	66 81       	ldd	r22, Z+6	; 0x06
    1494:	77 81       	ldd	r23, Z+7	; 0x07
    1496:	a9 01       	movw	r20, r18
    1498:	0e 94 28 15 	call	0x2a50	; 0x2a50 <memcpy>

			if( ( *pxCoRoutineWoken ) == pdFALSE )
    149c:	f8 01       	movw	r30, r16
    149e:	80 81       	ld	r24, Z
    14a0:	81 11       	cpse	r24, r1
    14a2:	0f c0       	rjmp	.+30     	; 0x14c2 <xQueueCRReceiveFromISR+0x6e>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    14a4:	88 85       	ldd	r24, Y+8	; 0x08
    14a6:	88 23       	and	r24, r24
    14a8:	71 f0       	breq	.+28     	; 0x14c6 <xQueueCRReceiveFromISR+0x72>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    14aa:	ce 01       	movw	r24, r28
    14ac:	08 96       	adiw	r24, 0x08	; 8
    14ae:	0e 94 45 02 	call	0x48a	; 0x48a <xCoRoutineRemoveFromEventList>
    14b2:	88 23       	and	r24, r24
    14b4:	51 f0       	breq	.+20     	; 0x14ca <xQueueCRReceiveFromISR+0x76>
					{
						*pxCoRoutineWoken = pdTRUE;
    14b6:	81 e0       	ldi	r24, 0x01	; 1
    14b8:	f8 01       	movw	r30, r16
    14ba:	80 83       	st	Z, r24
    14bc:	07 c0       	rjmp	.+14     	; 0x14cc <xQueueCRReceiveFromISR+0x78>

			xReturn = pdPASS;
		}
		else
		{
			xReturn = pdFAIL;
    14be:	80 e0       	ldi	r24, 0x00	; 0
    14c0:	05 c0       	rjmp	.+10     	; 0x14cc <xQueueCRReceiveFromISR+0x78>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			xReturn = pdPASS;
    14c2:	81 e0       	ldi	r24, 0x01	; 1
    14c4:	03 c0       	rjmp	.+6      	; 0x14cc <xQueueCRReceiveFromISR+0x78>
    14c6:	81 e0       	ldi	r24, 0x01	; 1
    14c8:	01 c0       	rjmp	.+2      	; 0x14cc <xQueueCRReceiveFromISR+0x78>
    14ca:	81 e0       	ldi	r24, 0x01	; 1
		{
			xReturn = pdFAIL;
		}

		return xReturn;
	}
    14cc:	df 91       	pop	r29
    14ce:	cf 91       	pop	r28
    14d0:	1f 91       	pop	r17
    14d2:	0f 91       	pop	r16
    14d4:	08 95       	ret

000014d6 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    14d6:	e0 91 97 0d 	lds	r30, 0x0D97	; 0x800d97 <pxDelayedTaskList>
    14da:	f0 91 98 0d 	lds	r31, 0x0D98	; 0x800d98 <pxDelayedTaskList+0x1>
    14de:	80 81       	ld	r24, Z
    14e0:	81 11       	cpse	r24, r1
    14e2:	07 c0       	rjmp	.+14     	; 0x14f2 <prvResetNextTaskUnblockTime+0x1c>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    14e4:	8f ef       	ldi	r24, 0xFF	; 255
    14e6:	9f ef       	ldi	r25, 0xFF	; 255
    14e8:	90 93 82 0d 	sts	0x0D82, r25	; 0x800d82 <xNextTaskUnblockTime+0x1>
    14ec:	80 93 81 0d 	sts	0x0D81, r24	; 0x800d81 <xNextTaskUnblockTime>
    14f0:	08 95       	ret
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    14f2:	e0 91 97 0d 	lds	r30, 0x0D97	; 0x800d97 <pxDelayedTaskList>
    14f6:	f0 91 98 0d 	lds	r31, 0x0D98	; 0x800d98 <pxDelayedTaskList+0x1>
    14fa:	05 80       	ldd	r0, Z+5	; 0x05
    14fc:	f6 81       	ldd	r31, Z+6	; 0x06
    14fe:	e0 2d       	mov	r30, r0
    1500:	06 80       	ldd	r0, Z+6	; 0x06
    1502:	f7 81       	ldd	r31, Z+7	; 0x07
    1504:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    1506:	82 81       	ldd	r24, Z+2	; 0x02
    1508:	93 81       	ldd	r25, Z+3	; 0x03
    150a:	90 93 82 0d 	sts	0x0D82, r25	; 0x800d82 <xNextTaskUnblockTime+0x1>
    150e:	80 93 81 0d 	sts	0x0D81, r24	; 0x800d81 <xNextTaskUnblockTime>
    1512:	08 95       	ret

00001514 <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    1514:	6f 92       	push	r6
    1516:	7f 92       	push	r7
    1518:	8f 92       	push	r8
    151a:	9f 92       	push	r9
    151c:	af 92       	push	r10
    151e:	bf 92       	push	r11
    1520:	cf 92       	push	r12
    1522:	df 92       	push	r13
    1524:	ef 92       	push	r14
    1526:	0f 93       	push	r16
    1528:	1f 93       	push	r17
    152a:	cf 93       	push	r28
    152c:	df 93       	push	r29
    152e:	cd b7       	in	r28, 0x3d	; 61
    1530:	de b7       	in	r29, 0x3e	; 62
    1532:	4c 01       	movw	r8, r24
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
    1534:	f5 01       	movw	r30, r10
    1536:	87 89       	ldd	r24, Z+23	; 0x17
    1538:	90 8d       	ldd	r25, Z+24	; 0x18
    153a:	21 50       	subi	r18, 0x01	; 1
    153c:	31 09       	sbc	r19, r1
    153e:	3c 01       	movw	r6, r24
    1540:	62 0e       	add	r6, r18
    1542:	73 1e       	adc	r7, r19
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    1544:	20 e0       	ldi	r18, 0x00	; 0
    1546:	0f c0       	rjmp	.+30     	; 0x1566 <prvInitialiseNewTask+0x52>
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    1548:	82 2f       	mov	r24, r18
    154a:	90 e0       	ldi	r25, 0x00	; 0
    154c:	fb 01       	movw	r30, r22
    154e:	e8 0f       	add	r30, r24
    1550:	f9 1f       	adc	r31, r25
    1552:	30 81       	ld	r19, Z
    1554:	d5 01       	movw	r26, r10
    1556:	a8 0f       	add	r26, r24
    1558:	b9 1f       	adc	r27, r25
    155a:	59 96       	adiw	r26, 0x19	; 25
    155c:	3c 93       	st	X, r19

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    155e:	80 81       	ld	r24, Z
    1560:	88 23       	and	r24, r24
    1562:	19 f0       	breq	.+6      	; 0x156a <prvInitialiseNewTask+0x56>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    1564:	2f 5f       	subi	r18, 0xFF	; 255
    1566:	28 30       	cpi	r18, 0x08	; 8
    1568:	78 f3       	brcs	.-34     	; 0x1548 <prvInitialiseNewTask+0x34>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    156a:	f5 01       	movw	r30, r10
    156c:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    156e:	f3 e0       	ldi	r31, 0x03	; 3
    1570:	fe 15       	cp	r31, r14
    1572:	20 f4       	brcc	.+8      	; 0x157c <prvInitialiseNewTask+0x68>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    1574:	0f 2e       	mov	r0, r31
    1576:	f3 e0       	ldi	r31, 0x03	; 3
    1578:	ef 2e       	mov	r14, r31
    157a:	f0 2d       	mov	r31, r0
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    157c:	f5 01       	movw	r30, r10
    157e:	e6 8a       	std	Z+22, r14	; 0x16
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    1580:	c5 01       	movw	r24, r10
    1582:	02 96       	adiw	r24, 0x02	; 2
    1584:	0e 94 12 04 	call	0x824	; 0x824 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    1588:	c5 01       	movw	r24, r10
    158a:	0c 96       	adiw	r24, 0x0c	; 12
    158c:	0e 94 12 04 	call	0x824	; 0x824 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    1590:	f5 01       	movw	r30, r10
    1592:	b1 86       	std	Z+9, r11	; 0x09
    1594:	a0 86       	std	Z+8, r10	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1596:	84 e0       	ldi	r24, 0x04	; 4
    1598:	90 e0       	ldi	r25, 0x00	; 0
    159a:	8e 19       	sub	r24, r14
    159c:	91 09       	sbc	r25, r1
    159e:	95 87       	std	Z+13, r25	; 0x0d
    15a0:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    15a2:	b3 8a       	std	Z+19, r11	; 0x13
    15a4:	a2 8a       	std	Z+18, r10	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    15a6:	11 a2       	std	Z+33, r1	; 0x21
    15a8:	12 a2       	std	Z+34, r1	; 0x22
    15aa:	13 a2       	std	Z+35, r1	; 0x23
    15ac:	14 a2       	std	Z+36, r1	; 0x24
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    15ae:	15 a2       	std	Z+37, r1	; 0x25
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    15b0:	a8 01       	movw	r20, r16
    15b2:	b4 01       	movw	r22, r8
    15b4:	c3 01       	movw	r24, r6
    15b6:	0e 94 98 04 	call	0x930	; 0x930 <pxPortInitialiseStack>
    15ba:	f5 01       	movw	r30, r10
    15bc:	91 83       	std	Z+1, r25	; 0x01
    15be:	80 83       	st	Z, r24
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( ( void * ) pxCreatedTask != NULL )
    15c0:	c1 14       	cp	r12, r1
    15c2:	d1 04       	cpc	r13, r1
    15c4:	19 f0       	breq	.+6      	; 0x15cc <prvInitialiseNewTask+0xb8>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    15c6:	f6 01       	movw	r30, r12
    15c8:	b1 82       	std	Z+1, r11	; 0x01
    15ca:	a0 82       	st	Z, r10
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    15cc:	df 91       	pop	r29
    15ce:	cf 91       	pop	r28
    15d0:	1f 91       	pop	r17
    15d2:	0f 91       	pop	r16
    15d4:	ef 90       	pop	r14
    15d6:	df 90       	pop	r13
    15d8:	cf 90       	pop	r12
    15da:	bf 90       	pop	r11
    15dc:	af 90       	pop	r10
    15de:	9f 90       	pop	r9
    15e0:	8f 90       	pop	r8
    15e2:	7f 90       	pop	r7
    15e4:	6f 90       	pop	r6
    15e6:	08 95       	ret

000015e8 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    15e8:	cf 93       	push	r28
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    15ea:	c0 e0       	ldi	r28, 0x00	; 0
    15ec:	10 c0       	rjmp	.+32     	; 0x160e <prvInitialiseTaskLists+0x26>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    15ee:	8c 2f       	mov	r24, r28
    15f0:	90 e0       	ldi	r25, 0x00	; 0
    15f2:	9c 01       	movw	r18, r24
    15f4:	22 0f       	add	r18, r18
    15f6:	33 1f       	adc	r19, r19
    15f8:	22 0f       	add	r18, r18
    15fa:	33 1f       	adc	r19, r19
    15fc:	22 0f       	add	r18, r18
    15fe:	33 1f       	adc	r19, r19
    1600:	82 0f       	add	r24, r18
    1602:	93 1f       	adc	r25, r19
    1604:	85 55       	subi	r24, 0x55	; 85
    1606:	92 4f       	sbci	r25, 0xF2	; 242
    1608:	0e 94 04 04 	call	0x808	; 0x808 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    160c:	cf 5f       	subi	r28, 0xFF	; 255
    160e:	c4 30       	cpi	r28, 0x04	; 4
    1610:	70 f3       	brcs	.-36     	; 0x15ee <prvInitialiseTaskLists+0x6>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    1612:	82 ea       	ldi	r24, 0xA2	; 162
    1614:	9d e0       	ldi	r25, 0x0D	; 13
    1616:	0e 94 04 04 	call	0x808	; 0x808 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    161a:	89 e9       	ldi	r24, 0x99	; 153
    161c:	9d e0       	ldi	r25, 0x0D	; 13
    161e:	0e 94 04 04 	call	0x808	; 0x808 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    1622:	8c e8       	ldi	r24, 0x8C	; 140
    1624:	9d e0       	ldi	r25, 0x0D	; 13
    1626:	0e 94 04 04 	call	0x808	; 0x808 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    162a:	82 ea       	ldi	r24, 0xA2	; 162
    162c:	9d e0       	ldi	r25, 0x0D	; 13
    162e:	90 93 98 0d 	sts	0x0D98, r25	; 0x800d98 <pxDelayedTaskList+0x1>
    1632:	80 93 97 0d 	sts	0x0D97, r24	; 0x800d97 <pxDelayedTaskList>
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    1636:	89 e9       	ldi	r24, 0x99	; 153
    1638:	9d e0       	ldi	r25, 0x0D	; 13
    163a:	90 93 96 0d 	sts	0x0D96, r25	; 0x800d96 <pxOverflowDelayedTaskList+0x1>
    163e:	80 93 95 0d 	sts	0x0D95, r24	; 0x800d95 <pxOverflowDelayedTaskList>
}
    1642:	cf 91       	pop	r28
    1644:	08 95       	ret

00001646 <prvAddNewTaskToReadyList>:
	}
}
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
    1646:	cf 93       	push	r28
    1648:	df 93       	push	r29
    164a:	ec 01       	movw	r28, r24
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    164c:	0f b6       	in	r0, 0x3f	; 63
    164e:	f8 94       	cli
    1650:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    1652:	80 91 8b 0d 	lds	r24, 0x0D8B	; 0x800d8b <uxCurrentNumberOfTasks>
    1656:	8f 5f       	subi	r24, 0xFF	; 255
    1658:	80 93 8b 0d 	sts	0x0D8B, r24	; 0x800d8b <uxCurrentNumberOfTasks>
		if( pxCurrentTCB == NULL )
    165c:	80 91 cf 0d 	lds	r24, 0x0DCF	; 0x800dcf <pxCurrentTCB>
    1660:	90 91 d0 0d 	lds	r25, 0x0DD0	; 0x800dd0 <pxCurrentTCB+0x1>
    1664:	89 2b       	or	r24, r25
    1666:	59 f4       	brne	.+22     	; 0x167e <prvAddNewTaskToReadyList+0x38>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    1668:	d0 93 d0 0d 	sts	0x0DD0, r29	; 0x800dd0 <pxCurrentTCB+0x1>
    166c:	c0 93 cf 0d 	sts	0x0DCF, r28	; 0x800dcf <pxCurrentTCB>

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    1670:	80 91 8b 0d 	lds	r24, 0x0D8B	; 0x800d8b <uxCurrentNumberOfTasks>
    1674:	81 30       	cpi	r24, 0x01	; 1
    1676:	99 f4       	brne	.+38     	; 0x169e <prvAddNewTaskToReadyList+0x58>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
    1678:	0e 94 f4 0a 	call	0x15e8	; 0x15e8 <prvInitialiseTaskLists>
    167c:	10 c0       	rjmp	.+32     	; 0x169e <prvAddNewTaskToReadyList+0x58>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    167e:	80 91 87 0d 	lds	r24, 0x0D87	; 0x800d87 <xSchedulerRunning>
    1682:	81 11       	cpse	r24, r1
    1684:	0c c0       	rjmp	.+24     	; 0x169e <prvAddNewTaskToReadyList+0x58>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    1686:	e0 91 cf 0d 	lds	r30, 0x0DCF	; 0x800dcf <pxCurrentTCB>
    168a:	f0 91 d0 0d 	lds	r31, 0x0DD0	; 0x800dd0 <pxCurrentTCB+0x1>
    168e:	96 89       	ldd	r25, Z+22	; 0x16
    1690:	8e 89       	ldd	r24, Y+22	; 0x16
    1692:	89 17       	cp	r24, r25
    1694:	20 f0       	brcs	.+8      	; 0x169e <prvAddNewTaskToReadyList+0x58>
				{
					pxCurrentTCB = pxNewTCB;
    1696:	d0 93 d0 0d 	sts	0x0DD0, r29	; 0x800dd0 <pxCurrentTCB+0x1>
    169a:	c0 93 cf 0d 	sts	0x0DCF, r28	; 0x800dcf <pxCurrentTCB>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    169e:	80 91 83 0d 	lds	r24, 0x0D83	; 0x800d83 <uxTaskNumber>
    16a2:	8f 5f       	subi	r24, 0xFF	; 255
    16a4:	80 93 83 0d 	sts	0x0D83, r24	; 0x800d83 <uxTaskNumber>
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    16a8:	8e 89       	ldd	r24, Y+22	; 0x16
    16aa:	90 91 88 0d 	lds	r25, 0x0D88	; 0x800d88 <uxTopReadyPriority>
    16ae:	98 17       	cp	r25, r24
    16b0:	10 f4       	brcc	.+4      	; 0x16b6 <prvAddNewTaskToReadyList+0x70>
    16b2:	80 93 88 0d 	sts	0x0D88, r24	; 0x800d88 <uxTopReadyPriority>
    16b6:	90 e0       	ldi	r25, 0x00	; 0
    16b8:	9c 01       	movw	r18, r24
    16ba:	22 0f       	add	r18, r18
    16bc:	33 1f       	adc	r19, r19
    16be:	22 0f       	add	r18, r18
    16c0:	33 1f       	adc	r19, r19
    16c2:	22 0f       	add	r18, r18
    16c4:	33 1f       	adc	r19, r19
    16c6:	82 0f       	add	r24, r18
    16c8:	93 1f       	adc	r25, r19
    16ca:	be 01       	movw	r22, r28
    16cc:	6e 5f       	subi	r22, 0xFE	; 254
    16ce:	7f 4f       	sbci	r23, 0xFF	; 255
    16d0:	85 55       	subi	r24, 0x55	; 85
    16d2:	92 4f       	sbci	r25, 0xF2	; 242
    16d4:	0e 94 16 04 	call	0x82c	; 0x82c <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    16d8:	0f 90       	pop	r0
    16da:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    16dc:	80 91 87 0d 	lds	r24, 0x0D87	; 0x800d87 <xSchedulerRunning>
    16e0:	88 23       	and	r24, r24
    16e2:	51 f0       	breq	.+20     	; 0x16f8 <prvAddNewTaskToReadyList+0xb2>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    16e4:	e0 91 cf 0d 	lds	r30, 0x0DCF	; 0x800dcf <pxCurrentTCB>
    16e8:	f0 91 d0 0d 	lds	r31, 0x0DD0	; 0x800dd0 <pxCurrentTCB+0x1>
    16ec:	96 89       	ldd	r25, Z+22	; 0x16
    16ee:	8e 89       	ldd	r24, Y+22	; 0x16
    16f0:	98 17       	cp	r25, r24
    16f2:	10 f4       	brcc	.+4      	; 0x16f8 <prvAddNewTaskToReadyList+0xb2>
		{
			taskYIELD_IF_USING_PREEMPTION();
    16f4:	0e 94 34 05 	call	0xa68	; 0xa68 <vPortYield>
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    16f8:	df 91       	pop	r29
    16fa:	cf 91       	pop	r28
    16fc:	08 95       	ret

000016fe <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    16fe:	0f 93       	push	r16
    1700:	1f 93       	push	r17
    1702:	cf 93       	push	r28
    1704:	df 93       	push	r29
    1706:	ec 01       	movw	r28, r24
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    1708:	00 91 89 0d 	lds	r16, 0x0D89	; 0x800d89 <xTickCount>
    170c:	10 91 8a 0d 	lds	r17, 0x0D8A	; 0x800d8a <xTickCount+0x1>
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    1710:	80 91 cf 0d 	lds	r24, 0x0DCF	; 0x800dcf <pxCurrentTCB>
    1714:	90 91 d0 0d 	lds	r25, 0x0DD0	; 0x800dd0 <pxCurrentTCB+0x1>
    1718:	02 96       	adiw	r24, 0x02	; 2
    171a:	0e 94 68 04 	call	0x8d0	; 0x8d0 <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
		/* Calculate the time at which the task should be woken if the event
		does not occur.  This may overflow but this doesn't matter, the kernel
		will manage it correctly. */
		xTimeToWake = xConstTickCount + xTicksToWait;
    171e:	c0 0f       	add	r28, r16
    1720:	d1 1f       	adc	r29, r17

		/* The list item will be inserted in wake time order. */
		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    1722:	e0 91 cf 0d 	lds	r30, 0x0DCF	; 0x800dcf <pxCurrentTCB>
    1726:	f0 91 d0 0d 	lds	r31, 0x0DD0	; 0x800dd0 <pxCurrentTCB+0x1>
    172a:	d3 83       	std	Z+3, r29	; 0x03
    172c:	c2 83       	std	Z+2, r28	; 0x02

		if( xTimeToWake < xConstTickCount )
    172e:	c0 17       	cp	r28, r16
    1730:	d1 07       	cpc	r29, r17
    1732:	68 f4       	brcc	.+26     	; 0x174e <prvAddCurrentTaskToDelayedList+0x50>
		{
			/* Wake time has overflowed.  Place this item in the overflow list. */
			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    1734:	60 91 cf 0d 	lds	r22, 0x0DCF	; 0x800dcf <pxCurrentTCB>
    1738:	70 91 d0 0d 	lds	r23, 0x0DD0	; 0x800dd0 <pxCurrentTCB+0x1>
    173c:	80 91 95 0d 	lds	r24, 0x0D95	; 0x800d95 <pxOverflowDelayedTaskList>
    1740:	90 91 96 0d 	lds	r25, 0x0D96	; 0x800d96 <pxOverflowDelayedTaskList+0x1>
    1744:	6e 5f       	subi	r22, 0xFE	; 254
    1746:	7f 4f       	sbci	r23, 0xFF	; 255
    1748:	0e 94 37 04 	call	0x86e	; 0x86e <vListInsert>
    174c:	17 c0       	rjmp	.+46     	; 0x177c <prvAddCurrentTaskToDelayedList+0x7e>
		}
		else
		{
			/* The wake time has not overflowed, so the current block list is used. */
			vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    174e:	60 91 cf 0d 	lds	r22, 0x0DCF	; 0x800dcf <pxCurrentTCB>
    1752:	70 91 d0 0d 	lds	r23, 0x0DD0	; 0x800dd0 <pxCurrentTCB+0x1>
    1756:	80 91 97 0d 	lds	r24, 0x0D97	; 0x800d97 <pxDelayedTaskList>
    175a:	90 91 98 0d 	lds	r25, 0x0D98	; 0x800d98 <pxDelayedTaskList+0x1>
    175e:	6e 5f       	subi	r22, 0xFE	; 254
    1760:	7f 4f       	sbci	r23, 0xFF	; 255
    1762:	0e 94 37 04 	call	0x86e	; 0x86e <vListInsert>

			/* If the task entering the blocked state was placed at the head of the
			list of blocked tasks then xNextTaskUnblockTime needs to be updated
			too. */
			if( xTimeToWake < xNextTaskUnblockTime )
    1766:	80 91 81 0d 	lds	r24, 0x0D81	; 0x800d81 <xNextTaskUnblockTime>
    176a:	90 91 82 0d 	lds	r25, 0x0D82	; 0x800d82 <xNextTaskUnblockTime+0x1>
    176e:	c8 17       	cp	r28, r24
    1770:	d9 07       	cpc	r29, r25
    1772:	20 f4       	brcc	.+8      	; 0x177c <prvAddCurrentTaskToDelayedList+0x7e>
			{
				xNextTaskUnblockTime = xTimeToWake;
    1774:	d0 93 82 0d 	sts	0x0D82, r29	; 0x800d82 <xNextTaskUnblockTime+0x1>
    1778:	c0 93 81 0d 	sts	0x0D81, r28	; 0x800d81 <xNextTaskUnblockTime>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    177c:	df 91       	pop	r29
    177e:	cf 91       	pop	r28
    1780:	1f 91       	pop	r17
    1782:	0f 91       	pop	r16
    1784:	08 95       	ret

00001786 <prvIdleTask>:

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    1786:	80 91 ab 0d 	lds	r24, 0x0DAB	; 0x800dab <pxReadyTasksLists>
    178a:	82 30       	cpi	r24, 0x02	; 2
    178c:	10 f0       	brcs	.+4      	; 0x1792 <prvIdleTask+0xc>
			{
				taskYIELD();
    178e:	0e 94 34 05 	call	0xa68	; 0xa68 <vPortYield>
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
    1792:	0e 94 47 13 	call	0x268e	; 0x268e <vApplicationIdleHook>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
    1796:	f7 cf       	rjmp	.-18     	; 0x1786 <prvIdleTask>

00001798 <xTaskCreate>:
							const char * const pcName,
							const uint16_t usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
    1798:	2f 92       	push	r2
    179a:	3f 92       	push	r3
    179c:	4f 92       	push	r4
    179e:	5f 92       	push	r5
    17a0:	6f 92       	push	r6
    17a2:	7f 92       	push	r7
    17a4:	8f 92       	push	r8
    17a6:	9f 92       	push	r9
    17a8:	af 92       	push	r10
    17aa:	bf 92       	push	r11
    17ac:	cf 92       	push	r12
    17ae:	df 92       	push	r13
    17b0:	ef 92       	push	r14
    17b2:	ff 92       	push	r15
    17b4:	0f 93       	push	r16
    17b6:	1f 93       	push	r17
    17b8:	cf 93       	push	r28
    17ba:	df 93       	push	r29
    17bc:	3c 01       	movw	r6, r24
    17be:	1b 01       	movw	r2, r22
    17c0:	5a 01       	movw	r10, r20
    17c2:	29 01       	movw	r4, r18
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    17c4:	ca 01       	movw	r24, r20
    17c6:	0e 94 ec 05 	call	0xbd8	; 0xbd8 <pvPortMalloc>
    17ca:	6c 01       	movw	r12, r24

			if( pxStack != NULL )
    17cc:	89 2b       	or	r24, r25
    17ce:	71 f0       	breq	.+28     	; 0x17ec <xTaskCreate+0x54>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
    17d0:	86 e2       	ldi	r24, 0x26	; 38
    17d2:	90 e0       	ldi	r25, 0x00	; 0
    17d4:	0e 94 ec 05 	call	0xbd8	; 0xbd8 <pvPortMalloc>
    17d8:	ec 01       	movw	r28, r24

				if( pxNewTCB != NULL )
    17da:	89 2b       	or	r24, r25
    17dc:	19 f0       	breq	.+6      	; 0x17e4 <xTaskCreate+0x4c>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    17de:	d8 8e       	std	Y+24, r13	; 0x18
    17e0:	cf 8a       	std	Y+23, r12	; 0x17
    17e2:	06 c0       	rjmp	.+12     	; 0x17f0 <xTaskCreate+0x58>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    17e4:	c6 01       	movw	r24, r12
    17e6:	0e 94 21 06 	call	0xc42	; 0xc42 <vPortFree>
    17ea:	02 c0       	rjmp	.+4      	; 0x17f0 <xTaskCreate+0x58>
				}
			}
			else
			{
				pxNewTCB = NULL;
    17ec:	c0 e0       	ldi	r28, 0x00	; 0
    17ee:	d0 e0       	ldi	r29, 0x00	; 0
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
    17f0:	20 97       	sbiw	r28, 0x00	; 0
    17f2:	91 f0       	breq	.+36     	; 0x1818 <xTaskCreate+0x80>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    17f4:	95 01       	movw	r18, r10
    17f6:	40 e0       	ldi	r20, 0x00	; 0
    17f8:	50 e0       	ldi	r21, 0x00	; 0
    17fa:	81 2c       	mov	r8, r1
    17fc:	91 2c       	mov	r9, r1
    17fe:	5e 01       	movw	r10, r28
    1800:	67 01       	movw	r12, r14
    1802:	e0 2e       	mov	r14, r16
    1804:	82 01       	movw	r16, r4
    1806:	b1 01       	movw	r22, r2
    1808:	c3 01       	movw	r24, r6
    180a:	0e 94 8a 0a 	call	0x1514	; 0x1514 <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
    180e:	ce 01       	movw	r24, r28
    1810:	0e 94 23 0b 	call	0x1646	; 0x1646 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
    1814:	81 e0       	ldi	r24, 0x01	; 1
    1816:	01 c0       	rjmp	.+2      	; 0x181a <xTaskCreate+0x82>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1818:	8f ef       	ldi	r24, 0xFF	; 255
		}

		return xReturn;
	}
    181a:	df 91       	pop	r29
    181c:	cf 91       	pop	r28
    181e:	1f 91       	pop	r17
    1820:	0f 91       	pop	r16
    1822:	ff 90       	pop	r15
    1824:	ef 90       	pop	r14
    1826:	df 90       	pop	r13
    1828:	cf 90       	pop	r12
    182a:	bf 90       	pop	r11
    182c:	af 90       	pop	r10
    182e:	9f 90       	pop	r9
    1830:	8f 90       	pop	r8
    1832:	7f 90       	pop	r7
    1834:	6f 90       	pop	r6
    1836:	5f 90       	pop	r5
    1838:	4f 90       	pop	r4
    183a:	3f 90       	pop	r3
    183c:	2f 90       	pop	r2
    183e:	08 95       	ret

00001840 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    1840:	ef 92       	push	r14
    1842:	ff 92       	push	r15
    1844:	0f 93       	push	r16
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    1846:	0f 2e       	mov	r0, r31
    1848:	ff e7       	ldi	r31, 0x7F	; 127
    184a:	ef 2e       	mov	r14, r31
    184c:	fd e0       	ldi	r31, 0x0D	; 13
    184e:	ff 2e       	mov	r15, r31
    1850:	f0 2d       	mov	r31, r0
    1852:	00 e0       	ldi	r16, 0x00	; 0
    1854:	20 e0       	ldi	r18, 0x00	; 0
    1856:	30 e0       	ldi	r19, 0x00	; 0
    1858:	45 e5       	ldi	r20, 0x55	; 85
    185a:	50 e0       	ldi	r21, 0x00	; 0
    185c:	68 e0       	ldi	r22, 0x08	; 8
    185e:	71 e0       	ldi	r23, 0x01	; 1
    1860:	83 ec       	ldi	r24, 0xC3	; 195
    1862:	9b e0       	ldi	r25, 0x0B	; 11
    1864:	0e 94 cc 0b 	call	0x1798	; 0x1798 <xTaskCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    1868:	81 30       	cpi	r24, 0x01	; 1
    186a:	81 f4       	brne	.+32     	; 0x188c <vTaskStartScheduler+0x4c>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    186c:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    186e:	8f ef       	ldi	r24, 0xFF	; 255
    1870:	9f ef       	ldi	r25, 0xFF	; 255
    1872:	90 93 82 0d 	sts	0x0D82, r25	; 0x800d82 <xNextTaskUnblockTime+0x1>
    1876:	80 93 81 0d 	sts	0x0D81, r24	; 0x800d81 <xNextTaskUnblockTime>
		xSchedulerRunning = pdTRUE;
    187a:	81 e0       	ldi	r24, 0x01	; 1
    187c:	80 93 87 0d 	sts	0x0D87, r24	; 0x800d87 <xSchedulerRunning>
		xTickCount = ( TickType_t ) 0U;
    1880:	10 92 8a 0d 	sts	0x0D8A, r1	; 0x800d8a <xTickCount+0x1>
    1884:	10 92 89 0d 	sts	0x0D89, r1	; 0x800d89 <xTickCount>
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    1888:	0e 94 04 05 	call	0xa08	; 0xa08 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    188c:	0f 91       	pop	r16
    188e:	ff 90       	pop	r15
    1890:	ef 90       	pop	r14
    1892:	08 95       	ret

00001894 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    1894:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    1896:	10 92 87 0d 	sts	0x0D87, r1	; 0x800d87 <xSchedulerRunning>
	vPortEndScheduler();
    189a:	0e 94 33 05 	call	0xa66	; 0xa66 <vPortEndScheduler>
    189e:	08 95       	ret

000018a0 <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    18a0:	80 91 7e 0d 	lds	r24, 0x0D7E	; 0x800d7e <uxSchedulerSuspended>
    18a4:	8f 5f       	subi	r24, 0xFF	; 255
    18a6:	80 93 7e 0d 	sts	0x0D7E, r24	; 0x800d7e <uxSchedulerSuspended>
    18aa:	08 95       	ret

000018ac <xTaskGetTickCount>:
TickType_t xTaskGetTickCount( void )
{
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    18ac:	0f b6       	in	r0, 0x3f	; 63
    18ae:	f8 94       	cli
    18b0:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    18b2:	80 91 89 0d 	lds	r24, 0x0D89	; 0x800d89 <xTickCount>
    18b6:	90 91 8a 0d 	lds	r25, 0x0D8A	; 0x800d8a <xTickCount+0x1>
	}
	portTICK_TYPE_EXIT_CRITICAL();
    18ba:	0f 90       	pop	r0
    18bc:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    18be:	08 95       	ret

000018c0 <xTaskGetTickCountFromISR>:
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
	{
		xReturn = xTickCount;
    18c0:	80 91 89 0d 	lds	r24, 0x0D89	; 0x800d89 <xTickCount>
    18c4:	90 91 8a 0d 	lds	r25, 0x0D8A	; 0x800d8a <xTickCount+0x1>
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    18c8:	08 95       	ret

000018ca <uxTaskGetNumberOfTasks>:

UBaseType_t uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    18ca:	80 91 8b 0d 	lds	r24, 0x0D8B	; 0x800d8b <uxCurrentNumberOfTasks>
}
    18ce:	08 95       	ret

000018d0 <pcTaskGetName>:
{
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    18d0:	00 97       	sbiw	r24, 0x00	; 0
    18d2:	21 f4       	brne	.+8      	; 0x18dc <pcTaskGetName+0xc>
    18d4:	80 91 cf 0d 	lds	r24, 0x0DCF	; 0x800dcf <pxCurrentTCB>
    18d8:	90 91 d0 0d 	lds	r25, 0x0DD0	; 0x800dd0 <pxCurrentTCB+0x1>
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
}
    18dc:	49 96       	adiw	r24, 0x19	; 25
    18de:	08 95       	ret

000018e0 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    18e0:	df 92       	push	r13
    18e2:	ef 92       	push	r14
    18e4:	ff 92       	push	r15
    18e6:	0f 93       	push	r16
    18e8:	1f 93       	push	r17
    18ea:	cf 93       	push	r28
    18ec:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    18ee:	80 91 7e 0d 	lds	r24, 0x0D7E	; 0x800d7e <uxSchedulerSuspended>
    18f2:	81 11       	cpse	r24, r1
    18f4:	97 c0       	rjmp	.+302    	; 0x1a24 <xTaskIncrementTick+0x144>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + 1;
    18f6:	e0 90 89 0d 	lds	r14, 0x0D89	; 0x800d89 <xTickCount>
    18fa:	f0 90 8a 0d 	lds	r15, 0x0D8A	; 0x800d8a <xTickCount+0x1>
    18fe:	8f ef       	ldi	r24, 0xFF	; 255
    1900:	e8 1a       	sub	r14, r24
    1902:	f8 0a       	sbc	r15, r24

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    1904:	f0 92 8a 0d 	sts	0x0D8A, r15	; 0x800d8a <xTickCount+0x1>
    1908:	e0 92 89 0d 	sts	0x0D89, r14	; 0x800d89 <xTickCount>

		if( xConstTickCount == ( TickType_t ) 0U )
    190c:	e1 14       	cp	r14, r1
    190e:	f1 04       	cpc	r15, r1
    1910:	b9 f4       	brne	.+46     	; 0x1940 <xTaskIncrementTick+0x60>
		{
			taskSWITCH_DELAYED_LISTS();
    1912:	80 91 97 0d 	lds	r24, 0x0D97	; 0x800d97 <pxDelayedTaskList>
    1916:	90 91 98 0d 	lds	r25, 0x0D98	; 0x800d98 <pxDelayedTaskList+0x1>
    191a:	20 91 95 0d 	lds	r18, 0x0D95	; 0x800d95 <pxOverflowDelayedTaskList>
    191e:	30 91 96 0d 	lds	r19, 0x0D96	; 0x800d96 <pxOverflowDelayedTaskList+0x1>
    1922:	30 93 98 0d 	sts	0x0D98, r19	; 0x800d98 <pxDelayedTaskList+0x1>
    1926:	20 93 97 0d 	sts	0x0D97, r18	; 0x800d97 <pxDelayedTaskList>
    192a:	90 93 96 0d 	sts	0x0D96, r25	; 0x800d96 <pxOverflowDelayedTaskList+0x1>
    192e:	80 93 95 0d 	sts	0x0D95, r24	; 0x800d95 <pxOverflowDelayedTaskList>
    1932:	80 91 84 0d 	lds	r24, 0x0D84	; 0x800d84 <xNumOfOverflows>
    1936:	8f 5f       	subi	r24, 0xFF	; 255
    1938:	80 93 84 0d 	sts	0x0D84, r24	; 0x800d84 <xNumOfOverflows>
    193c:	0e 94 6b 0a 	call	0x14d6	; 0x14d6 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    1940:	80 91 81 0d 	lds	r24, 0x0D81	; 0x800d81 <xNextTaskUnblockTime>
    1944:	90 91 82 0d 	lds	r25, 0x0D82	; 0x800d82 <xNextTaskUnblockTime+0x1>
    1948:	e8 16       	cp	r14, r24
    194a:	f9 06       	cpc	r15, r25
    194c:	28 f4       	brcc	.+10     	; 0x1958 <xTaskIncrementTick+0x78>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    194e:	d1 2c       	mov	r13, r1
    1950:	53 c0       	rjmp	.+166    	; 0x19f8 <xTaskIncrementTick+0x118>
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
						{
							xSwitchRequired = pdTRUE;
    1952:	dd 24       	eor	r13, r13
    1954:	d3 94       	inc	r13
    1956:	01 c0       	rjmp	.+2      	; 0x195a <xTaskIncrementTick+0x7a>
    1958:	d1 2c       	mov	r13, r1
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    195a:	e0 91 97 0d 	lds	r30, 0x0D97	; 0x800d97 <pxDelayedTaskList>
    195e:	f0 91 98 0d 	lds	r31, 0x0D98	; 0x800d98 <pxDelayedTaskList+0x1>
    1962:	80 81       	ld	r24, Z
    1964:	81 11       	cpse	r24, r1
    1966:	07 c0       	rjmp	.+14     	; 0x1976 <xTaskIncrementTick+0x96>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1968:	8f ef       	ldi	r24, 0xFF	; 255
    196a:	9f ef       	ldi	r25, 0xFF	; 255
    196c:	90 93 82 0d 	sts	0x0D82, r25	; 0x800d82 <xNextTaskUnblockTime+0x1>
    1970:	80 93 81 0d 	sts	0x0D81, r24	; 0x800d81 <xNextTaskUnblockTime>
					break;
    1974:	41 c0       	rjmp	.+130    	; 0x19f8 <xTaskIncrementTick+0x118>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    1976:	e0 91 97 0d 	lds	r30, 0x0D97	; 0x800d97 <pxDelayedTaskList>
    197a:	f0 91 98 0d 	lds	r31, 0x0D98	; 0x800d98 <pxDelayedTaskList+0x1>
    197e:	05 80       	ldd	r0, Z+5	; 0x05
    1980:	f6 81       	ldd	r31, Z+6	; 0x06
    1982:	e0 2d       	mov	r30, r0
    1984:	c6 81       	ldd	r28, Z+6	; 0x06
    1986:	d7 81       	ldd	r29, Z+7	; 0x07
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    1988:	8a 81       	ldd	r24, Y+2	; 0x02
    198a:	9b 81       	ldd	r25, Y+3	; 0x03

					if( xConstTickCount < xItemValue )
    198c:	e8 16       	cp	r14, r24
    198e:	f9 06       	cpc	r15, r25
    1990:	28 f4       	brcc	.+10     	; 0x199c <xTaskIncrementTick+0xbc>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    1992:	90 93 82 0d 	sts	0x0D82, r25	; 0x800d82 <xNextTaskUnblockTime+0x1>
    1996:	80 93 81 0d 	sts	0x0D81, r24	; 0x800d81 <xNextTaskUnblockTime>
						break;
    199a:	2e c0       	rjmp	.+92     	; 0x19f8 <xTaskIncrementTick+0x118>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    199c:	8e 01       	movw	r16, r28
    199e:	0e 5f       	subi	r16, 0xFE	; 254
    19a0:	1f 4f       	sbci	r17, 0xFF	; 255
    19a2:	c8 01       	movw	r24, r16
    19a4:	0e 94 68 04 	call	0x8d0	; 0x8d0 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    19a8:	8c 89       	ldd	r24, Y+20	; 0x14
    19aa:	9d 89       	ldd	r25, Y+21	; 0x15
    19ac:	89 2b       	or	r24, r25
    19ae:	21 f0       	breq	.+8      	; 0x19b8 <xTaskIncrementTick+0xd8>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    19b0:	ce 01       	movw	r24, r28
    19b2:	0c 96       	adiw	r24, 0x0c	; 12
    19b4:	0e 94 68 04 	call	0x8d0	; 0x8d0 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    19b8:	8e 89       	ldd	r24, Y+22	; 0x16
    19ba:	90 91 88 0d 	lds	r25, 0x0D88	; 0x800d88 <uxTopReadyPriority>
    19be:	98 17       	cp	r25, r24
    19c0:	10 f4       	brcc	.+4      	; 0x19c6 <xTaskIncrementTick+0xe6>
    19c2:	80 93 88 0d 	sts	0x0D88, r24	; 0x800d88 <uxTopReadyPriority>
    19c6:	90 e0       	ldi	r25, 0x00	; 0
    19c8:	9c 01       	movw	r18, r24
    19ca:	22 0f       	add	r18, r18
    19cc:	33 1f       	adc	r19, r19
    19ce:	22 0f       	add	r18, r18
    19d0:	33 1f       	adc	r19, r19
    19d2:	22 0f       	add	r18, r18
    19d4:	33 1f       	adc	r19, r19
    19d6:	82 0f       	add	r24, r18
    19d8:	93 1f       	adc	r25, r19
    19da:	b8 01       	movw	r22, r16
    19dc:	85 55       	subi	r24, 0x55	; 85
    19de:	92 4f       	sbci	r25, 0xF2	; 242
    19e0:	0e 94 16 04 	call	0x82c	; 0x82c <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    19e4:	9e 89       	ldd	r25, Y+22	; 0x16
    19e6:	e0 91 cf 0d 	lds	r30, 0x0DCF	; 0x800dcf <pxCurrentTCB>
    19ea:	f0 91 d0 0d 	lds	r31, 0x0DD0	; 0x800dd0 <pxCurrentTCB+0x1>
    19ee:	86 89       	ldd	r24, Z+22	; 0x16
    19f0:	98 17       	cp	r25, r24
    19f2:	08 f0       	brcs	.+2      	; 0x19f6 <xTaskIncrementTick+0x116>
    19f4:	ae cf       	rjmp	.-164    	; 0x1952 <xTaskIncrementTick+0x72>
    19f6:	b1 cf       	rjmp	.-158    	; 0x195a <xTaskIncrementTick+0x7a>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    19f8:	e0 91 cf 0d 	lds	r30, 0x0DCF	; 0x800dcf <pxCurrentTCB>
    19fc:	f0 91 d0 0d 	lds	r31, 0x0DD0	; 0x800dd0 <pxCurrentTCB+0x1>
    1a00:	86 89       	ldd	r24, Z+22	; 0x16
    1a02:	90 e0       	ldi	r25, 0x00	; 0
    1a04:	fc 01       	movw	r30, r24
    1a06:	ee 0f       	add	r30, r30
    1a08:	ff 1f       	adc	r31, r31
    1a0a:	ee 0f       	add	r30, r30
    1a0c:	ff 1f       	adc	r31, r31
    1a0e:	ee 0f       	add	r30, r30
    1a10:	ff 1f       	adc	r31, r31
    1a12:	8e 0f       	add	r24, r30
    1a14:	9f 1f       	adc	r25, r31
    1a16:	fc 01       	movw	r30, r24
    1a18:	e5 55       	subi	r30, 0x55	; 85
    1a1a:	f2 4f       	sbci	r31, 0xF2	; 242
    1a1c:	80 81       	ld	r24, Z
    1a1e:	82 30       	cpi	r24, 0x02	; 2
    1a20:	40 f4       	brcc	.+16     	; 0x1a32 <xTaskIncrementTick+0x152>
    1a22:	09 c0       	rjmp	.+18     	; 0x1a36 <xTaskIncrementTick+0x156>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    1a24:	80 91 86 0d 	lds	r24, 0x0D86	; 0x800d86 <uxPendedTicks>
    1a28:	8f 5f       	subi	r24, 0xFF	; 255
    1a2a:	80 93 86 0d 	sts	0x0D86, r24	; 0x800d86 <uxPendedTicks>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    1a2e:	d1 2c       	mov	r13, r1
    1a30:	02 c0       	rjmp	.+4      	; 0x1a36 <xTaskIncrementTick+0x156>
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
			{
				xSwitchRequired = pdTRUE;
    1a32:	dd 24       	eor	r13, r13
    1a34:	d3 94       	inc	r13
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    1a36:	80 91 85 0d 	lds	r24, 0x0D85	; 0x800d85 <xYieldPending>
    1a3a:	88 23       	and	r24, r24
    1a3c:	11 f0       	breq	.+4      	; 0x1a42 <xTaskIncrementTick+0x162>
		{
			xSwitchRequired = pdTRUE;
    1a3e:	dd 24       	eor	r13, r13
    1a40:	d3 94       	inc	r13
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
    1a42:	8d 2d       	mov	r24, r13
    1a44:	df 91       	pop	r29
    1a46:	cf 91       	pop	r28
    1a48:	1f 91       	pop	r17
    1a4a:	0f 91       	pop	r16
    1a4c:	ff 90       	pop	r15
    1a4e:	ef 90       	pop	r14
    1a50:	df 90       	pop	r13
    1a52:	08 95       	ret

00001a54 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    1a54:	0f 93       	push	r16
    1a56:	1f 93       	push	r17
    1a58:	cf 93       	push	r28
    1a5a:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    1a5c:	0f b6       	in	r0, 0x3f	; 63
    1a5e:	f8 94       	cli
    1a60:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    1a62:	80 91 7e 0d 	lds	r24, 0x0D7E	; 0x800d7e <uxSchedulerSuspended>
    1a66:	81 50       	subi	r24, 0x01	; 1
    1a68:	80 93 7e 0d 	sts	0x0D7E, r24	; 0x800d7e <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1a6c:	80 91 7e 0d 	lds	r24, 0x0D7E	; 0x800d7e <uxSchedulerSuspended>
    1a70:	81 11       	cpse	r24, r1
    1a72:	58 c0       	rjmp	.+176    	; 0x1b24 <xTaskResumeAll+0xd0>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    1a74:	80 91 8b 0d 	lds	r24, 0x0D8B	; 0x800d8b <uxCurrentNumberOfTasks>
    1a78:	81 11       	cpse	r24, r1
    1a7a:	33 c0       	rjmp	.+102    	; 0x1ae2 <xTaskResumeAll+0x8e>
    1a7c:	56 c0       	rjmp	.+172    	; 0x1b2a <xTaskResumeAll+0xd6>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    1a7e:	e0 91 91 0d 	lds	r30, 0x0D91	; 0x800d91 <xPendingReadyList+0x5>
    1a82:	f0 91 92 0d 	lds	r31, 0x0D92	; 0x800d92 <xPendingReadyList+0x6>
    1a86:	c6 81       	ldd	r28, Z+6	; 0x06
    1a88:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    1a8a:	ce 01       	movw	r24, r28
    1a8c:	0c 96       	adiw	r24, 0x0c	; 12
    1a8e:	0e 94 68 04 	call	0x8d0	; 0x8d0 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1a92:	8e 01       	movw	r16, r28
    1a94:	0e 5f       	subi	r16, 0xFE	; 254
    1a96:	1f 4f       	sbci	r17, 0xFF	; 255
    1a98:	c8 01       	movw	r24, r16
    1a9a:	0e 94 68 04 	call	0x8d0	; 0x8d0 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    1a9e:	8e 89       	ldd	r24, Y+22	; 0x16
    1aa0:	90 91 88 0d 	lds	r25, 0x0D88	; 0x800d88 <uxTopReadyPriority>
    1aa4:	98 17       	cp	r25, r24
    1aa6:	10 f4       	brcc	.+4      	; 0x1aac <xTaskResumeAll+0x58>
    1aa8:	80 93 88 0d 	sts	0x0D88, r24	; 0x800d88 <uxTopReadyPriority>
    1aac:	90 e0       	ldi	r25, 0x00	; 0
    1aae:	9c 01       	movw	r18, r24
    1ab0:	22 0f       	add	r18, r18
    1ab2:	33 1f       	adc	r19, r19
    1ab4:	22 0f       	add	r18, r18
    1ab6:	33 1f       	adc	r19, r19
    1ab8:	22 0f       	add	r18, r18
    1aba:	33 1f       	adc	r19, r19
    1abc:	82 0f       	add	r24, r18
    1abe:	93 1f       	adc	r25, r19
    1ac0:	b8 01       	movw	r22, r16
    1ac2:	85 55       	subi	r24, 0x55	; 85
    1ac4:	92 4f       	sbci	r25, 0xF2	; 242
    1ac6:	0e 94 16 04 	call	0x82c	; 0x82c <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1aca:	9e 89       	ldd	r25, Y+22	; 0x16
    1acc:	e0 91 cf 0d 	lds	r30, 0x0DCF	; 0x800dcf <pxCurrentTCB>
    1ad0:	f0 91 d0 0d 	lds	r31, 0x0DD0	; 0x800dd0 <pxCurrentTCB+0x1>
    1ad4:	86 89       	ldd	r24, Z+22	; 0x16
    1ad6:	98 17       	cp	r25, r24
    1ad8:	30 f0       	brcs	.+12     	; 0x1ae6 <xTaskResumeAll+0x92>
					{
						xYieldPending = pdTRUE;
    1ada:	81 e0       	ldi	r24, 0x01	; 1
    1adc:	80 93 85 0d 	sts	0x0D85, r24	; 0x800d85 <xYieldPending>
    1ae0:	02 c0       	rjmp	.+4      	; 0x1ae6 <xTaskResumeAll+0x92>
    1ae2:	c0 e0       	ldi	r28, 0x00	; 0
    1ae4:	d0 e0       	ldi	r29, 0x00	; 0
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    1ae6:	80 91 8c 0d 	lds	r24, 0x0D8C	; 0x800d8c <xPendingReadyList>
    1aea:	81 11       	cpse	r24, r1
    1aec:	c8 cf       	rjmp	.-112    	; 0x1a7e <xTaskResumeAll+0x2a>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    1aee:	cd 2b       	or	r28, r29
    1af0:	11 f0       	breq	.+4      	; 0x1af6 <xTaskResumeAll+0xa2>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    1af2:	0e 94 6b 0a 	call	0x14d6	; 0x14d6 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    1af6:	c0 91 86 0d 	lds	r28, 0x0D86	; 0x800d86 <uxPendedTicks>

					if( uxPendedCounts > ( UBaseType_t ) 0U )
    1afa:	cc 23       	and	r28, r28
    1afc:	59 f0       	breq	.+22     	; 0x1b14 <xTaskResumeAll+0xc0>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    1afe:	0e 94 70 0c 	call	0x18e0	; 0x18e0 <xTaskIncrementTick>
    1b02:	88 23       	and	r24, r24
    1b04:	19 f0       	breq	.+6      	; 0x1b0c <xTaskResumeAll+0xb8>
							{
								xYieldPending = pdTRUE;
    1b06:	81 e0       	ldi	r24, 0x01	; 1
    1b08:	80 93 85 0d 	sts	0x0D85, r24	; 0x800d85 <xYieldPending>
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
    1b0c:	c1 50       	subi	r28, 0x01	; 1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    1b0e:	b9 f7       	brne	.-18     	; 0x1afe <xTaskResumeAll+0xaa>

						uxPendedTicks = 0;
    1b10:	10 92 86 0d 	sts	0x0D86, r1	; 0x800d86 <uxPendedTicks>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    1b14:	80 91 85 0d 	lds	r24, 0x0D85	; 0x800d85 <xYieldPending>
    1b18:	88 23       	and	r24, r24
    1b1a:	31 f0       	breq	.+12     	; 0x1b28 <xTaskResumeAll+0xd4>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    1b1c:	0e 94 34 05 	call	0xa68	; 0xa68 <vPortYield>

				if( xYieldPending != pdFALSE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    1b20:	81 e0       	ldi	r24, 0x01	; 1
    1b22:	03 c0       	rjmp	.+6      	; 0x1b2a <xTaskResumeAll+0xd6>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB = NULL;
BaseType_t xAlreadyYielded = pdFALSE;
    1b24:	80 e0       	ldi	r24, 0x00	; 0
    1b26:	01 c0       	rjmp	.+2      	; 0x1b2a <xTaskResumeAll+0xd6>
    1b28:	80 e0       	ldi	r24, 0x00	; 0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    1b2a:	0f 90       	pop	r0
    1b2c:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    1b2e:	df 91       	pop	r29
    1b30:	cf 91       	pop	r28
    1b32:	1f 91       	pop	r17
    1b34:	0f 91       	pop	r16
    1b36:	08 95       	ret

00001b38 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    1b38:	0f 93       	push	r16
    1b3a:	1f 93       	push	r17
    1b3c:	cf 93       	push	r28
    1b3e:	df 93       	push	r29
    1b40:	8c 01       	movw	r16, r24
    1b42:	eb 01       	movw	r28, r22

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    1b44:	0e 94 50 0c 	call	0x18a0	; 0x18a0 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    1b48:	40 91 89 0d 	lds	r20, 0x0D89	; 0x800d89 <xTickCount>
    1b4c:	50 91 8a 0d 	lds	r21, 0x0D8A	; 0x800d8a <xTickCount+0x1>

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    1b50:	f8 01       	movw	r30, r16
    1b52:	20 81       	ld	r18, Z
    1b54:	31 81       	ldd	r19, Z+1	; 0x01
    1b56:	c9 01       	movw	r24, r18
    1b58:	8c 0f       	add	r24, r28
    1b5a:	9d 1f       	adc	r25, r29

			if( xConstTickCount < *pxPreviousWakeTime )
    1b5c:	42 17       	cp	r20, r18
    1b5e:	53 07       	cpc	r21, r19
    1b60:	40 f4       	brcc	.+16     	; 0x1b72 <vTaskDelayUntil+0x3a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    1b62:	82 17       	cp	r24, r18
    1b64:	93 07       	cpc	r25, r19
    1b66:	68 f4       	brcc	.+26     	; 0x1b82 <vTaskDelayUntil+0x4a>
    1b68:	48 17       	cp	r20, r24
    1b6a:	59 07       	cpc	r21, r25
    1b6c:	60 f0       	brcs	.+24     	; 0x1b86 <vTaskDelayUntil+0x4e>
#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    1b6e:	20 e0       	ldi	r18, 0x00	; 0
    1b70:	0f c0       	rjmp	.+30     	; 0x1b90 <vTaskDelayUntil+0x58>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    1b72:	82 17       	cp	r24, r18
    1b74:	93 07       	cpc	r25, r19
    1b76:	48 f0       	brcs	.+18     	; 0x1b8a <vTaskDelayUntil+0x52>
    1b78:	48 17       	cp	r20, r24
    1b7a:	59 07       	cpc	r21, r25
    1b7c:	40 f0       	brcs	.+16     	; 0x1b8e <vTaskDelayUntil+0x56>
#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    1b7e:	20 e0       	ldi	r18, 0x00	; 0
    1b80:	07 c0       	rjmp	.+14     	; 0x1b90 <vTaskDelayUntil+0x58>
    1b82:	20 e0       	ldi	r18, 0x00	; 0
    1b84:	05 c0       	rjmp	.+10     	; 0x1b90 <vTaskDelayUntil+0x58>
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
				{
					xShouldDelay = pdTRUE;
    1b86:	21 e0       	ldi	r18, 0x01	; 1
    1b88:	03 c0       	rjmp	.+6      	; 0x1b90 <vTaskDelayUntil+0x58>
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
				{
					xShouldDelay = pdTRUE;
    1b8a:	21 e0       	ldi	r18, 0x01	; 1
    1b8c:	01 c0       	rjmp	.+2      	; 0x1b90 <vTaskDelayUntil+0x58>
    1b8e:	21 e0       	ldi	r18, 0x01	; 1
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    1b90:	f8 01       	movw	r30, r16
    1b92:	91 83       	std	Z+1, r25	; 0x01
    1b94:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    1b96:	22 23       	and	r18, r18
    1b98:	29 f0       	breq	.+10     	; 0x1ba4 <vTaskDelayUntil+0x6c>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    1b9a:	60 e0       	ldi	r22, 0x00	; 0
    1b9c:	84 1b       	sub	r24, r20
    1b9e:	95 0b       	sbc	r25, r21
    1ba0:	0e 94 7f 0b 	call	0x16fe	; 0x16fe <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    1ba4:	0e 94 2a 0d 	call	0x1a54	; 0x1a54 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1ba8:	81 11       	cpse	r24, r1
    1baa:	02 c0       	rjmp	.+4      	; 0x1bb0 <vTaskDelayUntil+0x78>
		{
			portYIELD_WITHIN_API();
    1bac:	0e 94 34 05 	call	0xa68	; 0xa68 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    1bb0:	df 91       	pop	r29
    1bb2:	cf 91       	pop	r28
    1bb4:	1f 91       	pop	r17
    1bb6:	0f 91       	pop	r16
    1bb8:	08 95       	ret

00001bba <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    1bba:	cf 93       	push	r28
    1bbc:	df 93       	push	r29
    1bbe:	ec 01       	movw	r28, r24
	BaseType_t xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    1bc0:	89 2b       	or	r24, r25
    1bc2:	49 f0       	breq	.+18     	; 0x1bd6 <vTaskDelay+0x1c>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    1bc4:	0e 94 50 0c 	call	0x18a0	; 0x18a0 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    1bc8:	60 e0       	ldi	r22, 0x00	; 0
    1bca:	ce 01       	movw	r24, r28
    1bcc:	0e 94 7f 0b 	call	0x16fe	; 0x16fe <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    1bd0:	0e 94 2a 0d 	call	0x1a54	; 0x1a54 <xTaskResumeAll>
    1bd4:	01 c0       	rjmp	.+2      	; 0x1bd8 <vTaskDelay+0x1e>

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
	BaseType_t xAlreadyYielded = pdFALSE;
    1bd6:	80 e0       	ldi	r24, 0x00	; 0
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1bd8:	81 11       	cpse	r24, r1
    1bda:	02 c0       	rjmp	.+4      	; 0x1be0 <vTaskDelay+0x26>
		{
			portYIELD_WITHIN_API();
    1bdc:	0e 94 34 05 	call	0xa68	; 0xa68 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    1be0:	df 91       	pop	r29
    1be2:	cf 91       	pop	r28
    1be4:	08 95       	ret

00001be6 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    1be6:	80 91 7e 0d 	lds	r24, 0x0D7E	; 0x800d7e <uxSchedulerSuspended>
    1bea:	88 23       	and	r24, r24
    1bec:	21 f0       	breq	.+8      	; 0x1bf6 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    1bee:	81 e0       	ldi	r24, 0x01	; 1
    1bf0:	80 93 85 0d 	sts	0x0D85, r24	; 0x800d85 <xYieldPending>
    1bf4:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
    1bf6:	10 92 85 0d 	sts	0x0D85, r1	; 0x800d85 <xYieldPending>
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    1bfa:	20 91 88 0d 	lds	r18, 0x0D88	; 0x800d88 <uxTopReadyPriority>
    1bfe:	01 c0       	rjmp	.+2      	; 0x1c02 <vTaskSwitchContext+0x1c>
    1c00:	21 50       	subi	r18, 0x01	; 1
    1c02:	82 2f       	mov	r24, r18
    1c04:	90 e0       	ldi	r25, 0x00	; 0
    1c06:	fc 01       	movw	r30, r24
    1c08:	ee 0f       	add	r30, r30
    1c0a:	ff 1f       	adc	r31, r31
    1c0c:	ee 0f       	add	r30, r30
    1c0e:	ff 1f       	adc	r31, r31
    1c10:	ee 0f       	add	r30, r30
    1c12:	ff 1f       	adc	r31, r31
    1c14:	e8 0f       	add	r30, r24
    1c16:	f9 1f       	adc	r31, r25
    1c18:	e5 55       	subi	r30, 0x55	; 85
    1c1a:	f2 4f       	sbci	r31, 0xF2	; 242
    1c1c:	30 81       	ld	r19, Z
    1c1e:	33 23       	and	r19, r19
    1c20:	79 f3       	breq	.-34     	; 0x1c00 <vTaskSwitchContext+0x1a>
    1c22:	ac 01       	movw	r20, r24
    1c24:	44 0f       	add	r20, r20
    1c26:	55 1f       	adc	r21, r21
    1c28:	44 0f       	add	r20, r20
    1c2a:	55 1f       	adc	r21, r21
    1c2c:	44 0f       	add	r20, r20
    1c2e:	55 1f       	adc	r21, r21
    1c30:	48 0f       	add	r20, r24
    1c32:	59 1f       	adc	r21, r25
    1c34:	df 01       	movw	r26, r30
    1c36:	01 80       	ldd	r0, Z+1	; 0x01
    1c38:	f2 81       	ldd	r31, Z+2	; 0x02
    1c3a:	e0 2d       	mov	r30, r0
    1c3c:	02 80       	ldd	r0, Z+2	; 0x02
    1c3e:	f3 81       	ldd	r31, Z+3	; 0x03
    1c40:	e0 2d       	mov	r30, r0
    1c42:	12 96       	adiw	r26, 0x02	; 2
    1c44:	fc 93       	st	X, r31
    1c46:	ee 93       	st	-X, r30
    1c48:	11 97       	sbiw	r26, 0x01	; 1
    1c4a:	42 55       	subi	r20, 0x52	; 82
    1c4c:	52 4f       	sbci	r21, 0xF2	; 242
    1c4e:	e4 17       	cp	r30, r20
    1c50:	f5 07       	cpc	r31, r21
    1c52:	29 f4       	brne	.+10     	; 0x1c5e <vTaskSwitchContext+0x78>
    1c54:	42 81       	ldd	r20, Z+2	; 0x02
    1c56:	53 81       	ldd	r21, Z+3	; 0x03
    1c58:	fd 01       	movw	r30, r26
    1c5a:	52 83       	std	Z+2, r21	; 0x02
    1c5c:	41 83       	std	Z+1, r20	; 0x01
    1c5e:	fc 01       	movw	r30, r24
    1c60:	ee 0f       	add	r30, r30
    1c62:	ff 1f       	adc	r31, r31
    1c64:	ee 0f       	add	r30, r30
    1c66:	ff 1f       	adc	r31, r31
    1c68:	ee 0f       	add	r30, r30
    1c6a:	ff 1f       	adc	r31, r31
    1c6c:	8e 0f       	add	r24, r30
    1c6e:	9f 1f       	adc	r25, r31
    1c70:	fc 01       	movw	r30, r24
    1c72:	e5 55       	subi	r30, 0x55	; 85
    1c74:	f2 4f       	sbci	r31, 0xF2	; 242
    1c76:	01 80       	ldd	r0, Z+1	; 0x01
    1c78:	f2 81       	ldd	r31, Z+2	; 0x02
    1c7a:	e0 2d       	mov	r30, r0
    1c7c:	86 81       	ldd	r24, Z+6	; 0x06
    1c7e:	97 81       	ldd	r25, Z+7	; 0x07
    1c80:	90 93 d0 0d 	sts	0x0DD0, r25	; 0x800dd0 <pxCurrentTCB+0x1>
    1c84:	80 93 cf 0d 	sts	0x0DCF, r24	; 0x800dcf <pxCurrentTCB>
    1c88:	20 93 88 0d 	sts	0x0D88, r18	; 0x800d88 <uxTopReadyPriority>
    1c8c:	08 95       	ret

00001c8e <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    1c8e:	cf 93       	push	r28
    1c90:	df 93       	push	r29
    1c92:	eb 01       	movw	r28, r22

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    1c94:	60 91 cf 0d 	lds	r22, 0x0DCF	; 0x800dcf <pxCurrentTCB>
    1c98:	70 91 d0 0d 	lds	r23, 0x0DD0	; 0x800dd0 <pxCurrentTCB+0x1>
    1c9c:	64 5f       	subi	r22, 0xF4	; 244
    1c9e:	7f 4f       	sbci	r23, 0xFF	; 255
    1ca0:	0e 94 37 04 	call	0x86e	; 0x86e <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    1ca4:	61 e0       	ldi	r22, 0x01	; 1
    1ca6:	ce 01       	movw	r24, r28
    1ca8:	0e 94 7f 0b 	call	0x16fe	; 0x16fe <prvAddCurrentTaskToDelayedList>
}
    1cac:	df 91       	pop	r29
    1cae:	cf 91       	pop	r28
    1cb0:	08 95       	ret

00001cb2 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    1cb2:	cf 93       	push	r28
    1cb4:	df 93       	push	r29
    1cb6:	ea 01       	movw	r28, r20
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    1cb8:	e0 91 cf 0d 	lds	r30, 0x0DCF	; 0x800dcf <pxCurrentTCB>
    1cbc:	f0 91 d0 0d 	lds	r31, 0x0DD0	; 0x800dd0 <pxCurrentTCB+0x1>
    1cc0:	70 68       	ori	r23, 0x80	; 128
    1cc2:	75 87       	std	Z+13, r23	; 0x0d
    1cc4:	64 87       	std	Z+12, r22	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    1cc6:	60 91 cf 0d 	lds	r22, 0x0DCF	; 0x800dcf <pxCurrentTCB>
    1cca:	70 91 d0 0d 	lds	r23, 0x0DD0	; 0x800dd0 <pxCurrentTCB+0x1>
    1cce:	64 5f       	subi	r22, 0xF4	; 244
    1cd0:	7f 4f       	sbci	r23, 0xFF	; 255
    1cd2:	0e 94 16 04 	call	0x82c	; 0x82c <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    1cd6:	61 e0       	ldi	r22, 0x01	; 1
    1cd8:	ce 01       	movw	r24, r28
    1cda:	0e 94 7f 0b 	call	0x16fe	; 0x16fe <prvAddCurrentTaskToDelayedList>
}
    1cde:	df 91       	pop	r29
    1ce0:	cf 91       	pop	r28
    1ce2:	08 95       	ret

00001ce4 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    1ce4:	0f 93       	push	r16
    1ce6:	1f 93       	push	r17
    1ce8:	cf 93       	push	r28
    1cea:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1cec:	dc 01       	movw	r26, r24
    1cee:	15 96       	adiw	r26, 0x05	; 5
    1cf0:	ed 91       	ld	r30, X+
    1cf2:	fc 91       	ld	r31, X
    1cf4:	16 97       	sbiw	r26, 0x06	; 6
    1cf6:	c6 81       	ldd	r28, Z+6	; 0x06
    1cf8:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    1cfa:	8e 01       	movw	r16, r28
    1cfc:	04 5f       	subi	r16, 0xF4	; 244
    1cfe:	1f 4f       	sbci	r17, 0xFF	; 255
    1d00:	c8 01       	movw	r24, r16
    1d02:	0e 94 68 04 	call	0x8d0	; 0x8d0 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1d06:	80 91 7e 0d 	lds	r24, 0x0D7E	; 0x800d7e <uxSchedulerSuspended>
    1d0a:	81 11       	cpse	r24, r1
    1d0c:	1c c0       	rjmp	.+56     	; 0x1d46 <xTaskRemoveFromEventList+0x62>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    1d0e:	0a 50       	subi	r16, 0x0A	; 10
    1d10:	11 09       	sbc	r17, r1
    1d12:	c8 01       	movw	r24, r16
    1d14:	0e 94 68 04 	call	0x8d0	; 0x8d0 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    1d18:	8e 89       	ldd	r24, Y+22	; 0x16
    1d1a:	90 91 88 0d 	lds	r25, 0x0D88	; 0x800d88 <uxTopReadyPriority>
    1d1e:	98 17       	cp	r25, r24
    1d20:	10 f4       	brcc	.+4      	; 0x1d26 <xTaskRemoveFromEventList+0x42>
    1d22:	80 93 88 0d 	sts	0x0D88, r24	; 0x800d88 <uxTopReadyPriority>
    1d26:	90 e0       	ldi	r25, 0x00	; 0
    1d28:	9c 01       	movw	r18, r24
    1d2a:	22 0f       	add	r18, r18
    1d2c:	33 1f       	adc	r19, r19
    1d2e:	22 0f       	add	r18, r18
    1d30:	33 1f       	adc	r19, r19
    1d32:	22 0f       	add	r18, r18
    1d34:	33 1f       	adc	r19, r19
    1d36:	82 0f       	add	r24, r18
    1d38:	93 1f       	adc	r25, r19
    1d3a:	b8 01       	movw	r22, r16
    1d3c:	85 55       	subi	r24, 0x55	; 85
    1d3e:	92 4f       	sbci	r25, 0xF2	; 242
    1d40:	0e 94 16 04 	call	0x82c	; 0x82c <vListInsertEnd>
    1d44:	05 c0       	rjmp	.+10     	; 0x1d50 <xTaskRemoveFromEventList+0x6c>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    1d46:	b8 01       	movw	r22, r16
    1d48:	8c e8       	ldi	r24, 0x8C	; 140
    1d4a:	9d e0       	ldi	r25, 0x0D	; 13
    1d4c:	0e 94 16 04 	call	0x82c	; 0x82c <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    1d50:	9e 89       	ldd	r25, Y+22	; 0x16
    1d52:	e0 91 cf 0d 	lds	r30, 0x0DCF	; 0x800dcf <pxCurrentTCB>
    1d56:	f0 91 d0 0d 	lds	r31, 0x0DD0	; 0x800dd0 <pxCurrentTCB+0x1>
    1d5a:	86 89       	ldd	r24, Z+22	; 0x16
    1d5c:	89 17       	cp	r24, r25
    1d5e:	20 f4       	brcc	.+8      	; 0x1d68 <xTaskRemoveFromEventList+0x84>
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    1d60:	81 e0       	ldi	r24, 0x01	; 1
    1d62:	80 93 85 0d 	sts	0x0D85, r24	; 0x800d85 <xYieldPending>
    1d66:	01 c0       	rjmp	.+2      	; 0x1d6a <xTaskRemoveFromEventList+0x86>
	}
	else
	{
		xReturn = pdFALSE;
    1d68:	80 e0       	ldi	r24, 0x00	; 0
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
}
    1d6a:	df 91       	pop	r29
    1d6c:	cf 91       	pop	r28
    1d6e:	1f 91       	pop	r17
    1d70:	0f 91       	pop	r16
    1d72:	08 95       	ret

00001d74 <xTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    1d74:	0f 93       	push	r16
    1d76:	1f 93       	push	r17
    1d78:	cf 93       	push	r28
    1d7a:	df 93       	push	r29
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    1d7c:	70 68       	ori	r23, 0x80	; 128
    1d7e:	fc 01       	movw	r30, r24
    1d80:	71 83       	std	Z+1, r23	; 0x01
    1d82:	60 83       	st	Z, r22

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
    1d84:	c6 81       	ldd	r28, Z+6	; 0x06
    1d86:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    1d88:	0e 94 68 04 	call	0x8d0	; 0x8d0 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    1d8c:	8e 01       	movw	r16, r28
    1d8e:	0e 5f       	subi	r16, 0xFE	; 254
    1d90:	1f 4f       	sbci	r17, 0xFF	; 255
    1d92:	c8 01       	movw	r24, r16
    1d94:	0e 94 68 04 	call	0x8d0	; 0x8d0 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    1d98:	8e 89       	ldd	r24, Y+22	; 0x16
    1d9a:	90 91 88 0d 	lds	r25, 0x0D88	; 0x800d88 <uxTopReadyPriority>
    1d9e:	98 17       	cp	r25, r24
    1da0:	10 f4       	brcc	.+4      	; 0x1da6 <xTaskRemoveFromUnorderedEventList+0x32>
    1da2:	80 93 88 0d 	sts	0x0D88, r24	; 0x800d88 <uxTopReadyPriority>
    1da6:	90 e0       	ldi	r25, 0x00	; 0
    1da8:	9c 01       	movw	r18, r24
    1daa:	22 0f       	add	r18, r18
    1dac:	33 1f       	adc	r19, r19
    1dae:	22 0f       	add	r18, r18
    1db0:	33 1f       	adc	r19, r19
    1db2:	22 0f       	add	r18, r18
    1db4:	33 1f       	adc	r19, r19
    1db6:	82 0f       	add	r24, r18
    1db8:	93 1f       	adc	r25, r19
    1dba:	b8 01       	movw	r22, r16
    1dbc:	85 55       	subi	r24, 0x55	; 85
    1dbe:	92 4f       	sbci	r25, 0xF2	; 242
    1dc0:	0e 94 16 04 	call	0x82c	; 0x82c <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    1dc4:	9e 89       	ldd	r25, Y+22	; 0x16
    1dc6:	e0 91 cf 0d 	lds	r30, 0x0DCF	; 0x800dcf <pxCurrentTCB>
    1dca:	f0 91 d0 0d 	lds	r31, 0x0DD0	; 0x800dd0 <pxCurrentTCB+0x1>
    1dce:	86 89       	ldd	r24, Z+22	; 0x16
    1dd0:	89 17       	cp	r24, r25
    1dd2:	20 f4       	brcc	.+8      	; 0x1ddc <xTaskRemoveFromUnorderedEventList+0x68>
		switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    1dd4:	81 e0       	ldi	r24, 0x01	; 1
    1dd6:	80 93 85 0d 	sts	0x0D85, r24	; 0x800d85 <xYieldPending>
    1dda:	01 c0       	rjmp	.+2      	; 0x1dde <xTaskRemoveFromUnorderedEventList+0x6a>
	}
	else
	{
		xReturn = pdFALSE;
    1ddc:	80 e0       	ldi	r24, 0x00	; 0
	}

	return xReturn;
}
    1dde:	df 91       	pop	r29
    1de0:	cf 91       	pop	r28
    1de2:	1f 91       	pop	r17
    1de4:	0f 91       	pop	r16
    1de6:	08 95       	ret

00001de8 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    1de8:	20 91 84 0d 	lds	r18, 0x0D84	; 0x800d84 <xNumOfOverflows>
    1dec:	fc 01       	movw	r30, r24
    1dee:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    1df0:	20 91 89 0d 	lds	r18, 0x0D89	; 0x800d89 <xTickCount>
    1df4:	30 91 8a 0d 	lds	r19, 0x0D8A	; 0x800d8a <xTickCount+0x1>
    1df8:	32 83       	std	Z+2, r19	; 0x02
    1dfa:	21 83       	std	Z+1, r18	; 0x01
    1dfc:	08 95       	ret

00001dfe <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    1dfe:	cf 93       	push	r28
    1e00:	df 93       	push	r29
    1e02:	fc 01       	movw	r30, r24
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    1e04:	0f b6       	in	r0, 0x3f	; 63
    1e06:	f8 94       	cli
    1e08:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    1e0a:	40 91 89 0d 	lds	r20, 0x0D89	; 0x800d89 <xTickCount>
    1e0e:	50 91 8a 0d 	lds	r21, 0x0D8A	; 0x800d8a <xTickCount+0x1>
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    1e12:	90 81       	ld	r25, Z
    1e14:	80 91 84 0d 	lds	r24, 0x0D84	; 0x800d84 <xNumOfOverflows>
    1e18:	98 17       	cp	r25, r24
    1e1a:	29 f0       	breq	.+10     	; 0x1e26 <xTaskCheckForTimeOut+0x28>
    1e1c:	81 81       	ldd	r24, Z+1	; 0x01
    1e1e:	92 81       	ldd	r25, Z+2	; 0x02
    1e20:	48 17       	cp	r20, r24
    1e22:	59 07       	cpc	r21, r25
    1e24:	b0 f4       	brcc	.+44     	; 0x1e52 <xTaskCheckForTimeOut+0x54>
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    1e26:	21 81       	ldd	r18, Z+1	; 0x01
    1e28:	32 81       	ldd	r19, Z+2	; 0x02
    1e2a:	ca 01       	movw	r24, r20
    1e2c:	82 1b       	sub	r24, r18
    1e2e:	93 0b       	sbc	r25, r19
    1e30:	eb 01       	movw	r28, r22
    1e32:	a8 81       	ld	r26, Y
    1e34:	b9 81       	ldd	r27, Y+1	; 0x01
    1e36:	8a 17       	cp	r24, r26
    1e38:	9b 07       	cpc	r25, r27
    1e3a:	68 f4       	brcc	.+26     	; 0x1e56 <xTaskCheckForTimeOut+0x58>
    1e3c:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
    1e3e:	24 1b       	sub	r18, r20
    1e40:	35 0b       	sbc	r19, r21
    1e42:	2a 0f       	add	r18, r26
    1e44:	3b 1f       	adc	r19, r27
    1e46:	39 83       	std	Y+1, r19	; 0x01
    1e48:	28 83       	st	Y, r18
			vTaskSetTimeOutState( pxTimeOut );
    1e4a:	0e 94 f4 0e 	call	0x1de8	; 0x1de8 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    1e4e:	80 e0       	ldi	r24, 0x00	; 0
    1e50:	03 c0       	rjmp	.+6      	; 0x1e58 <xTaskCheckForTimeOut+0x5a>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    1e52:	81 e0       	ldi	r24, 0x01	; 1
    1e54:	01 c0       	rjmp	.+2      	; 0x1e58 <xTaskCheckForTimeOut+0x5a>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    1e56:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    1e58:	0f 90       	pop	r0
    1e5a:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    1e5c:	df 91       	pop	r29
    1e5e:	cf 91       	pop	r28
    1e60:	08 95       	ret

00001e62 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    1e62:	81 e0       	ldi	r24, 0x01	; 1
    1e64:	80 93 85 0d 	sts	0x0D85, r24	; 0x800d85 <xYieldPending>
    1e68:	08 95       	ret

00001e6a <uxTaskResetEventItemValue>:

TickType_t uxTaskResetEventItemValue( void )
{
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    1e6a:	e0 91 cf 0d 	lds	r30, 0x0DCF	; 0x800dcf <pxCurrentTCB>
    1e6e:	f0 91 d0 0d 	lds	r31, 0x0DD0	; 0x800dd0 <pxCurrentTCB+0x1>
    1e72:	84 85       	ldd	r24, Z+12	; 0x0c
    1e74:	95 85       	ldd	r25, Z+13	; 0x0d

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1e76:	e0 91 cf 0d 	lds	r30, 0x0DCF	; 0x800dcf <pxCurrentTCB>
    1e7a:	f0 91 d0 0d 	lds	r31, 0x0DD0	; 0x800dd0 <pxCurrentTCB+0x1>
    1e7e:	a0 91 cf 0d 	lds	r26, 0x0DCF	; 0x800dcf <pxCurrentTCB>
    1e82:	b0 91 d0 0d 	lds	r27, 0x0DD0	; 0x800dd0 <pxCurrentTCB+0x1>
    1e86:	56 96       	adiw	r26, 0x16	; 22
    1e88:	4c 91       	ld	r20, X
    1e8a:	24 e0       	ldi	r18, 0x04	; 4
    1e8c:	30 e0       	ldi	r19, 0x00	; 0
    1e8e:	24 1b       	sub	r18, r20
    1e90:	31 09       	sbc	r19, r1
    1e92:	35 87       	std	Z+13, r19	; 0x0d
    1e94:	24 87       	std	Z+12, r18	; 0x0c

	return uxReturn;
}
    1e96:	08 95       	ret

00001e98 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    1e98:	0f 93       	push	r16
    1e9a:	1f 93       	push	r17
    1e9c:	cf 93       	push	r28
    1e9e:	c8 2f       	mov	r28, r24
    1ea0:	cb 01       	movw	r24, r22
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    1ea2:	0f b6       	in	r0, 0x3f	; 63
    1ea4:	f8 94       	cli
    1ea6:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    1ea8:	e0 91 cf 0d 	lds	r30, 0x0DCF	; 0x800dcf <pxCurrentTCB>
    1eac:	f0 91 d0 0d 	lds	r31, 0x0DD0	; 0x800dd0 <pxCurrentTCB+0x1>
    1eb0:	41 a1       	ldd	r20, Z+33	; 0x21
    1eb2:	52 a1       	ldd	r21, Z+34	; 0x22
    1eb4:	63 a1       	ldd	r22, Z+35	; 0x23
    1eb6:	74 a1       	ldd	r23, Z+36	; 0x24
    1eb8:	45 2b       	or	r20, r21
    1eba:	46 2b       	or	r20, r22
    1ebc:	47 2b       	or	r20, r23
    1ebe:	69 f4       	brne	.+26     	; 0x1eda <ulTaskNotifyTake+0x42>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    1ec0:	e0 91 cf 0d 	lds	r30, 0x0DCF	; 0x800dcf <pxCurrentTCB>
    1ec4:	f0 91 d0 0d 	lds	r31, 0x0DD0	; 0x800dd0 <pxCurrentTCB+0x1>
    1ec8:	21 e0       	ldi	r18, 0x01	; 1
    1eca:	25 a3       	std	Z+37, r18	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    1ecc:	00 97       	sbiw	r24, 0x00	; 0
    1ece:	29 f0       	breq	.+10     	; 0x1eda <ulTaskNotifyTake+0x42>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    1ed0:	61 e0       	ldi	r22, 0x01	; 1
    1ed2:	0e 94 7f 0b 	call	0x16fe	; 0x16fe <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    1ed6:	0e 94 34 05 	call	0xa68	; 0xa68 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    1eda:	0f 90       	pop	r0
    1edc:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    1ede:	0f b6       	in	r0, 0x3f	; 63
    1ee0:	f8 94       	cli
    1ee2:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    1ee4:	e0 91 cf 0d 	lds	r30, 0x0DCF	; 0x800dcf <pxCurrentTCB>
    1ee8:	f0 91 d0 0d 	lds	r31, 0x0DD0	; 0x800dd0 <pxCurrentTCB+0x1>
    1eec:	61 a1       	ldd	r22, Z+33	; 0x21
    1eee:	72 a1       	ldd	r23, Z+34	; 0x22
    1ef0:	83 a1       	ldd	r24, Z+35	; 0x23
    1ef2:	94 a1       	ldd	r25, Z+36	; 0x24

			if( ulReturn != 0UL )
    1ef4:	61 15       	cp	r22, r1
    1ef6:	71 05       	cpc	r23, r1
    1ef8:	81 05       	cpc	r24, r1
    1efa:	91 05       	cpc	r25, r1
    1efc:	c9 f0       	breq	.+50     	; 0x1f30 <ulTaskNotifyTake+0x98>
			{
				if( xClearCountOnExit != pdFALSE )
    1efe:	cc 23       	and	r28, r28
    1f00:	49 f0       	breq	.+18     	; 0x1f14 <ulTaskNotifyTake+0x7c>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    1f02:	e0 91 cf 0d 	lds	r30, 0x0DCF	; 0x800dcf <pxCurrentTCB>
    1f06:	f0 91 d0 0d 	lds	r31, 0x0DD0	; 0x800dd0 <pxCurrentTCB+0x1>
    1f0a:	11 a2       	std	Z+33, r1	; 0x21
    1f0c:	12 a2       	std	Z+34, r1	; 0x22
    1f0e:	13 a2       	std	Z+35, r1	; 0x23
    1f10:	14 a2       	std	Z+36, r1	; 0x24
    1f12:	0e c0       	rjmp	.+28     	; 0x1f30 <ulTaskNotifyTake+0x98>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - 1;
    1f14:	e0 91 cf 0d 	lds	r30, 0x0DCF	; 0x800dcf <pxCurrentTCB>
    1f18:	f0 91 d0 0d 	lds	r31, 0x0DD0	; 0x800dd0 <pxCurrentTCB+0x1>
    1f1c:	8b 01       	movw	r16, r22
    1f1e:	9c 01       	movw	r18, r24
    1f20:	01 50       	subi	r16, 0x01	; 1
    1f22:	11 09       	sbc	r17, r1
    1f24:	21 09       	sbc	r18, r1
    1f26:	31 09       	sbc	r19, r1
    1f28:	01 a3       	std	Z+33, r16	; 0x21
    1f2a:	12 a3       	std	Z+34, r17	; 0x22
    1f2c:	23 a3       	std	Z+35, r18	; 0x23
    1f2e:	34 a3       	std	Z+36, r19	; 0x24
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    1f30:	e0 91 cf 0d 	lds	r30, 0x0DCF	; 0x800dcf <pxCurrentTCB>
    1f34:	f0 91 d0 0d 	lds	r31, 0x0DD0	; 0x800dd0 <pxCurrentTCB+0x1>
    1f38:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    1f3a:	0f 90       	pop	r0
    1f3c:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
	}
    1f3e:	cf 91       	pop	r28
    1f40:	1f 91       	pop	r17
    1f42:	0f 91       	pop	r16
    1f44:	08 95       	ret

00001f46 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    1f46:	4f 92       	push	r4
    1f48:	5f 92       	push	r5
    1f4a:	6f 92       	push	r6
    1f4c:	7f 92       	push	r7
    1f4e:	8f 92       	push	r8
    1f50:	9f 92       	push	r9
    1f52:	af 92       	push	r10
    1f54:	bf 92       	push	r11
    1f56:	ef 92       	push	r14
    1f58:	ff 92       	push	r15
    1f5a:	0f 93       	push	r16
    1f5c:	1f 93       	push	r17
    1f5e:	49 01       	movw	r8, r18
    1f60:	5a 01       	movw	r10, r20
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    1f62:	0f b6       	in	r0, 0x3f	; 63
    1f64:	f8 94       	cli
    1f66:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    1f68:	e0 91 cf 0d 	lds	r30, 0x0DCF	; 0x800dcf <pxCurrentTCB>
    1f6c:	f0 91 d0 0d 	lds	r31, 0x0DD0	; 0x800dd0 <pxCurrentTCB+0x1>
    1f70:	25 a1       	ldd	r18, Z+37	; 0x25
    1f72:	22 30       	cpi	r18, 0x02	; 2
    1f74:	29 f1       	breq	.+74     	; 0x1fc0 <xTaskNotifyWait+0x7a>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    1f76:	e0 91 cf 0d 	lds	r30, 0x0DCF	; 0x800dcf <pxCurrentTCB>
    1f7a:	f0 91 d0 0d 	lds	r31, 0x0DD0	; 0x800dd0 <pxCurrentTCB+0x1>
    1f7e:	41 a0       	ldd	r4, Z+33	; 0x21
    1f80:	52 a0       	ldd	r5, Z+34	; 0x22
    1f82:	63 a0       	ldd	r6, Z+35	; 0x23
    1f84:	74 a0       	ldd	r7, Z+36	; 0x24
    1f86:	dc 01       	movw	r26, r24
    1f88:	cb 01       	movw	r24, r22
    1f8a:	80 95       	com	r24
    1f8c:	90 95       	com	r25
    1f8e:	a0 95       	com	r26
    1f90:	b0 95       	com	r27
    1f92:	84 21       	and	r24, r4
    1f94:	95 21       	and	r25, r5
    1f96:	a6 21       	and	r26, r6
    1f98:	b7 21       	and	r27, r7
    1f9a:	81 a3       	std	Z+33, r24	; 0x21
    1f9c:	92 a3       	std	Z+34, r25	; 0x22
    1f9e:	a3 a3       	std	Z+35, r26	; 0x23
    1fa0:	b4 a3       	std	Z+36, r27	; 0x24

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    1fa2:	e0 91 cf 0d 	lds	r30, 0x0DCF	; 0x800dcf <pxCurrentTCB>
    1fa6:	f0 91 d0 0d 	lds	r31, 0x0DD0	; 0x800dd0 <pxCurrentTCB+0x1>
    1faa:	81 e0       	ldi	r24, 0x01	; 1
    1fac:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    1fae:	e1 14       	cp	r14, r1
    1fb0:	f1 04       	cpc	r15, r1
    1fb2:	31 f0       	breq	.+12     	; 0x1fc0 <xTaskNotifyWait+0x7a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    1fb4:	61 e0       	ldi	r22, 0x01	; 1
    1fb6:	c7 01       	movw	r24, r14
    1fb8:	0e 94 7f 0b 	call	0x16fe	; 0x16fe <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    1fbc:	0e 94 34 05 	call	0xa68	; 0xa68 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    1fc0:	0f 90       	pop	r0
    1fc2:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    1fc4:	0f b6       	in	r0, 0x3f	; 63
    1fc6:	f8 94       	cli
    1fc8:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    1fca:	01 15       	cp	r16, r1
    1fcc:	11 05       	cpc	r17, r1
    1fce:	69 f0       	breq	.+26     	; 0x1fea <xTaskNotifyWait+0xa4>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    1fd0:	e0 91 cf 0d 	lds	r30, 0x0DCF	; 0x800dcf <pxCurrentTCB>
    1fd4:	f0 91 d0 0d 	lds	r31, 0x0DD0	; 0x800dd0 <pxCurrentTCB+0x1>
    1fd8:	81 a1       	ldd	r24, Z+33	; 0x21
    1fda:	92 a1       	ldd	r25, Z+34	; 0x22
    1fdc:	a3 a1       	ldd	r26, Z+35	; 0x23
    1fde:	b4 a1       	ldd	r27, Z+36	; 0x24
    1fe0:	f8 01       	movw	r30, r16
    1fe2:	80 83       	st	Z, r24
    1fe4:	91 83       	std	Z+1, r25	; 0x01
    1fe6:	a2 83       	std	Z+2, r26	; 0x02
    1fe8:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState == taskWAITING_NOTIFICATION )
    1fea:	e0 91 cf 0d 	lds	r30, 0x0DCF	; 0x800dcf <pxCurrentTCB>
    1fee:	f0 91 d0 0d 	lds	r31, 0x0DD0	; 0x800dd0 <pxCurrentTCB+0x1>
    1ff2:	85 a1       	ldd	r24, Z+37	; 0x25
    1ff4:	81 30       	cpi	r24, 0x01	; 1
    1ff6:	b1 f0       	breq	.+44     	; 0x2024 <xTaskNotifyWait+0xde>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    1ff8:	e0 91 cf 0d 	lds	r30, 0x0DCF	; 0x800dcf <pxCurrentTCB>
    1ffc:	f0 91 d0 0d 	lds	r31, 0x0DD0	; 0x800dd0 <pxCurrentTCB+0x1>
    2000:	81 a1       	ldd	r24, Z+33	; 0x21
    2002:	92 a1       	ldd	r25, Z+34	; 0x22
    2004:	a3 a1       	ldd	r26, Z+35	; 0x23
    2006:	b4 a1       	ldd	r27, Z+36	; 0x24
    2008:	80 94       	com	r8
    200a:	90 94       	com	r9
    200c:	a0 94       	com	r10
    200e:	b0 94       	com	r11
    2010:	88 22       	and	r8, r24
    2012:	99 22       	and	r9, r25
    2014:	aa 22       	and	r10, r26
    2016:	bb 22       	and	r11, r27
    2018:	81 a2       	std	Z+33, r8	; 0x21
    201a:	92 a2       	std	Z+34, r9	; 0x22
    201c:	a3 a2       	std	Z+35, r10	; 0x23
    201e:	b4 a2       	std	Z+36, r11	; 0x24
				xReturn = pdTRUE;
    2020:	81 e0       	ldi	r24, 0x01	; 1
    2022:	01 c0       	rjmp	.+2      	; 0x2026 <xTaskNotifyWait+0xe0>
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState == taskWAITING_NOTIFICATION )
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    2024:	80 e0       	ldi	r24, 0x00	; 0
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
				xReturn = pdTRUE;
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    2026:	e0 91 cf 0d 	lds	r30, 0x0DCF	; 0x800dcf <pxCurrentTCB>
    202a:	f0 91 d0 0d 	lds	r31, 0x0DD0	; 0x800dd0 <pxCurrentTCB+0x1>
    202e:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    2030:	0f 90       	pop	r0
    2032:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    2034:	1f 91       	pop	r17
    2036:	0f 91       	pop	r16
    2038:	ff 90       	pop	r15
    203a:	ef 90       	pop	r14
    203c:	bf 90       	pop	r11
    203e:	af 90       	pop	r10
    2040:	9f 90       	pop	r9
    2042:	8f 90       	pop	r8
    2044:	7f 90       	pop	r7
    2046:	6f 90       	pop	r6
    2048:	5f 90       	pop	r5
    204a:	4f 90       	pop	r4
    204c:	08 95       	ret

0000204e <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    204e:	ef 92       	push	r14
    2050:	ff 92       	push	r15
    2052:	0f 93       	push	r16
    2054:	1f 93       	push	r17
    2056:	cf 93       	push	r28
    2058:	df 93       	push	r29
    205a:	fc 01       	movw	r30, r24
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = ( TCB_t * ) xTaskToNotify;

		taskENTER_CRITICAL();
    205c:	0f b6       	in	r0, 0x3f	; 63
    205e:	f8 94       	cli
    2060:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    2062:	01 15       	cp	r16, r1
    2064:	11 05       	cpc	r17, r1
    2066:	49 f0       	breq	.+18     	; 0x207a <xTaskGenericNotify+0x2c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    2068:	81 a1       	ldd	r24, Z+33	; 0x21
    206a:	92 a1       	ldd	r25, Z+34	; 0x22
    206c:	a3 a1       	ldd	r26, Z+35	; 0x23
    206e:	b4 a1       	ldd	r27, Z+36	; 0x24
    2070:	e8 01       	movw	r28, r16
    2072:	88 83       	st	Y, r24
    2074:	99 83       	std	Y+1, r25	; 0x01
    2076:	aa 83       	std	Y+2, r26	; 0x02
    2078:	bb 83       	std	Y+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    207a:	85 a1       	ldd	r24, Z+37	; 0x25

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    207c:	92 e0       	ldi	r25, 0x02	; 2
    207e:	95 a3       	std	Z+37, r25	; 0x25

			switch( eAction )
    2080:	22 30       	cpi	r18, 0x02	; 2
    2082:	b9 f0       	breq	.+46     	; 0x20b2 <xTaskGenericNotify+0x64>
    2084:	18 f4       	brcc	.+6      	; 0x208c <xTaskGenericNotify+0x3e>
    2086:	21 30       	cpi	r18, 0x01	; 1
    2088:	31 f0       	breq	.+12     	; 0x2096 <xTaskGenericNotify+0x48>
    208a:	2f c0       	rjmp	.+94     	; 0x20ea <xTaskGenericNotify+0x9c>
    208c:	23 30       	cpi	r18, 0x03	; 3
    208e:	f9 f0       	breq	.+62     	; 0x20ce <xTaskGenericNotify+0x80>
    2090:	24 30       	cpi	r18, 0x04	; 4
    2092:	19 f1       	breq	.+70     	; 0x20da <xTaskGenericNotify+0x8c>
    2094:	2a c0       	rjmp	.+84     	; 0x20ea <xTaskGenericNotify+0x9c>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    2096:	01 a1       	ldd	r16, Z+33	; 0x21
    2098:	12 a1       	ldd	r17, Z+34	; 0x22
    209a:	23 a1       	ldd	r18, Z+35	; 0x23
    209c:	34 a1       	ldd	r19, Z+36	; 0x24
    209e:	40 2b       	or	r20, r16
    20a0:	51 2b       	or	r21, r17
    20a2:	62 2b       	or	r22, r18
    20a4:	73 2b       	or	r23, r19
    20a6:	41 a3       	std	Z+33, r20	; 0x21
    20a8:	52 a3       	std	Z+34, r21	; 0x22
    20aa:	63 a3       	std	Z+35, r22	; 0x23
    20ac:	74 a3       	std	Z+36, r23	; 0x24
#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    20ae:	11 e0       	ldi	r17, 0x01	; 1

			switch( eAction )
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
					break;
    20b0:	1f c0       	rjmp	.+62     	; 0x20f0 <xTaskGenericNotify+0xa2>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    20b2:	41 a1       	ldd	r20, Z+33	; 0x21
    20b4:	52 a1       	ldd	r21, Z+34	; 0x22
    20b6:	63 a1       	ldd	r22, Z+35	; 0x23
    20b8:	74 a1       	ldd	r23, Z+36	; 0x24
    20ba:	4f 5f       	subi	r20, 0xFF	; 255
    20bc:	5f 4f       	sbci	r21, 0xFF	; 255
    20be:	6f 4f       	sbci	r22, 0xFF	; 255
    20c0:	7f 4f       	sbci	r23, 0xFF	; 255
    20c2:	41 a3       	std	Z+33, r20	; 0x21
    20c4:	52 a3       	std	Z+34, r21	; 0x22
    20c6:	63 a3       	std	Z+35, r22	; 0x23
    20c8:	74 a3       	std	Z+36, r23	; 0x24
#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    20ca:	11 e0       	ldi	r17, 0x01	; 1
					pxTCB->ulNotifiedValue |= ulValue;
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
					break;
    20cc:	11 c0       	rjmp	.+34     	; 0x20f0 <xTaskGenericNotify+0xa2>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    20ce:	41 a3       	std	Z+33, r20	; 0x21
    20d0:	52 a3       	std	Z+34, r21	; 0x22
    20d2:	63 a3       	std	Z+35, r22	; 0x23
    20d4:	74 a3       	std	Z+36, r23	; 0x24
#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    20d6:	11 e0       	ldi	r17, 0x01	; 1
					( pxTCB->ulNotifiedValue )++;
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
					break;
    20d8:	0b c0       	rjmp	.+22     	; 0x20f0 <xTaskGenericNotify+0xa2>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    20da:	82 30       	cpi	r24, 0x02	; 2
    20dc:	41 f0       	breq	.+16     	; 0x20ee <xTaskGenericNotify+0xa0>
					{
						pxTCB->ulNotifiedValue = ulValue;
    20de:	41 a3       	std	Z+33, r20	; 0x21
    20e0:	52 a3       	std	Z+34, r21	; 0x22
    20e2:	63 a3       	std	Z+35, r22	; 0x23
    20e4:	74 a3       	std	Z+36, r23	; 0x24
#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    20e6:	11 e0       	ldi	r17, 0x01	; 1
    20e8:	03 c0       	rjmp	.+6      	; 0x20f0 <xTaskGenericNotify+0xa2>
    20ea:	11 e0       	ldi	r17, 0x01	; 1
    20ec:	01 c0       	rjmp	.+2      	; 0x20f0 <xTaskGenericNotify+0xa2>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    20ee:	10 e0       	ldi	r17, 0x00	; 0

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    20f0:	81 30       	cpi	r24, 0x01	; 1
    20f2:	41 f5       	brne	.+80     	; 0x2144 <xTaskGenericNotify+0xf6>
    20f4:	ef 01       	movw	r28, r30
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    20f6:	7f 01       	movw	r14, r30
    20f8:	82 e0       	ldi	r24, 0x02	; 2
    20fa:	e8 0e       	add	r14, r24
    20fc:	f1 1c       	adc	r15, r1
    20fe:	c7 01       	movw	r24, r14
    2100:	0e 94 68 04 	call	0x8d0	; 0x8d0 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    2104:	8e 89       	ldd	r24, Y+22	; 0x16
    2106:	90 91 88 0d 	lds	r25, 0x0D88	; 0x800d88 <uxTopReadyPriority>
    210a:	98 17       	cp	r25, r24
    210c:	10 f4       	brcc	.+4      	; 0x2112 <xTaskGenericNotify+0xc4>
    210e:	80 93 88 0d 	sts	0x0D88, r24	; 0x800d88 <uxTopReadyPriority>
    2112:	90 e0       	ldi	r25, 0x00	; 0
    2114:	9c 01       	movw	r18, r24
    2116:	22 0f       	add	r18, r18
    2118:	33 1f       	adc	r19, r19
    211a:	22 0f       	add	r18, r18
    211c:	33 1f       	adc	r19, r19
    211e:	22 0f       	add	r18, r18
    2120:	33 1f       	adc	r19, r19
    2122:	82 0f       	add	r24, r18
    2124:	93 1f       	adc	r25, r19
    2126:	b7 01       	movw	r22, r14
    2128:	85 55       	subi	r24, 0x55	; 85
    212a:	92 4f       	sbci	r25, 0xF2	; 242
    212c:	0e 94 16 04 	call	0x82c	; 0x82c <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    2130:	9e 89       	ldd	r25, Y+22	; 0x16
    2132:	e0 91 cf 0d 	lds	r30, 0x0DCF	; 0x800dcf <pxCurrentTCB>
    2136:	f0 91 d0 0d 	lds	r31, 0x0DD0	; 0x800dd0 <pxCurrentTCB+0x1>
    213a:	86 89       	ldd	r24, Z+22	; 0x16
    213c:	89 17       	cp	r24, r25
    213e:	10 f4       	brcc	.+4      	; 0x2144 <xTaskGenericNotify+0xf6>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    2140:	0e 94 34 05 	call	0xa68	; 0xa68 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    2144:	0f 90       	pop	r0
    2146:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    2148:	81 2f       	mov	r24, r17
    214a:	df 91       	pop	r29
    214c:	cf 91       	pop	r28
    214e:	1f 91       	pop	r17
    2150:	0f 91       	pop	r16
    2152:	ff 90       	pop	r15
    2154:	ef 90       	pop	r14
    2156:	08 95       	ret

00002158 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    2158:	cf 92       	push	r12
    215a:	df 92       	push	r13
    215c:	ef 92       	push	r14
    215e:	ff 92       	push	r15
    2160:	0f 93       	push	r16
    2162:	1f 93       	push	r17
    2164:	cf 93       	push	r28
    2166:	df 93       	push	r29
    2168:	fc 01       	movw	r30, r24

		pxTCB = ( TCB_t * ) xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			if( pulPreviousNotificationValue != NULL )
    216a:	01 15       	cp	r16, r1
    216c:	11 05       	cpc	r17, r1
    216e:	49 f0       	breq	.+18     	; 0x2182 <xTaskGenericNotifyFromISR+0x2a>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    2170:	81 a1       	ldd	r24, Z+33	; 0x21
    2172:	92 a1       	ldd	r25, Z+34	; 0x22
    2174:	a3 a1       	ldd	r26, Z+35	; 0x23
    2176:	b4 a1       	ldd	r27, Z+36	; 0x24
    2178:	e8 01       	movw	r28, r16
    217a:	88 83       	st	Y, r24
    217c:	99 83       	std	Y+1, r25	; 0x01
    217e:	aa 83       	std	Y+2, r26	; 0x02
    2180:	bb 83       	std	Y+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    2182:	85 a1       	ldd	r24, Z+37	; 0x25
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    2184:	92 e0       	ldi	r25, 0x02	; 2
    2186:	95 a3       	std	Z+37, r25	; 0x25

			switch( eAction )
    2188:	22 30       	cpi	r18, 0x02	; 2
    218a:	b9 f0       	breq	.+46     	; 0x21ba <xTaskGenericNotifyFromISR+0x62>
    218c:	18 f4       	brcc	.+6      	; 0x2194 <xTaskGenericNotifyFromISR+0x3c>
    218e:	21 30       	cpi	r18, 0x01	; 1
    2190:	31 f0       	breq	.+12     	; 0x219e <xTaskGenericNotifyFromISR+0x46>
    2192:	2f c0       	rjmp	.+94     	; 0x21f2 <xTaskGenericNotifyFromISR+0x9a>
    2194:	23 30       	cpi	r18, 0x03	; 3
    2196:	f9 f0       	breq	.+62     	; 0x21d6 <xTaskGenericNotifyFromISR+0x7e>
    2198:	24 30       	cpi	r18, 0x04	; 4
    219a:	19 f1       	breq	.+70     	; 0x21e2 <xTaskGenericNotifyFromISR+0x8a>
    219c:	2a c0       	rjmp	.+84     	; 0x21f2 <xTaskGenericNotifyFromISR+0x9a>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    219e:	01 a1       	ldd	r16, Z+33	; 0x21
    21a0:	12 a1       	ldd	r17, Z+34	; 0x22
    21a2:	23 a1       	ldd	r18, Z+35	; 0x23
    21a4:	34 a1       	ldd	r19, Z+36	; 0x24
    21a6:	40 2b       	or	r20, r16
    21a8:	51 2b       	or	r21, r17
    21aa:	62 2b       	or	r22, r18
    21ac:	73 2b       	or	r23, r19
    21ae:	41 a3       	std	Z+33, r20	; 0x21
    21b0:	52 a3       	std	Z+34, r21	; 0x22
    21b2:	63 a3       	std	Z+35, r22	; 0x23
    21b4:	74 a3       	std	Z+36, r23	; 0x24

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    21b6:	11 e0       	ldi	r17, 0x01	; 1

			switch( eAction )
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
					break;
    21b8:	1f c0       	rjmp	.+62     	; 0x21f8 <xTaskGenericNotifyFromISR+0xa0>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    21ba:	41 a1       	ldd	r20, Z+33	; 0x21
    21bc:	52 a1       	ldd	r21, Z+34	; 0x22
    21be:	63 a1       	ldd	r22, Z+35	; 0x23
    21c0:	74 a1       	ldd	r23, Z+36	; 0x24
    21c2:	4f 5f       	subi	r20, 0xFF	; 255
    21c4:	5f 4f       	sbci	r21, 0xFF	; 255
    21c6:	6f 4f       	sbci	r22, 0xFF	; 255
    21c8:	7f 4f       	sbci	r23, 0xFF	; 255
    21ca:	41 a3       	std	Z+33, r20	; 0x21
    21cc:	52 a3       	std	Z+34, r21	; 0x22
    21ce:	63 a3       	std	Z+35, r22	; 0x23
    21d0:	74 a3       	std	Z+36, r23	; 0x24

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    21d2:	11 e0       	ldi	r17, 0x01	; 1
					pxTCB->ulNotifiedValue |= ulValue;
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
					break;
    21d4:	11 c0       	rjmp	.+34     	; 0x21f8 <xTaskGenericNotifyFromISR+0xa0>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    21d6:	41 a3       	std	Z+33, r20	; 0x21
    21d8:	52 a3       	std	Z+34, r21	; 0x22
    21da:	63 a3       	std	Z+35, r22	; 0x23
    21dc:	74 a3       	std	Z+36, r23	; 0x24

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    21de:	11 e0       	ldi	r17, 0x01	; 1
					( pxTCB->ulNotifiedValue )++;
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
					break;
    21e0:	0b c0       	rjmp	.+22     	; 0x21f8 <xTaskGenericNotifyFromISR+0xa0>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    21e2:	82 30       	cpi	r24, 0x02	; 2
    21e4:	41 f0       	breq	.+16     	; 0x21f6 <xTaskGenericNotifyFromISR+0x9e>
					{
						pxTCB->ulNotifiedValue = ulValue;
    21e6:	41 a3       	std	Z+33, r20	; 0x21
    21e8:	52 a3       	std	Z+34, r21	; 0x22
    21ea:	63 a3       	std	Z+35, r22	; 0x23
    21ec:	74 a3       	std	Z+36, r23	; 0x24

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    21ee:	11 e0       	ldi	r17, 0x01	; 1
    21f0:	03 c0       	rjmp	.+6      	; 0x21f8 <xTaskGenericNotifyFromISR+0xa0>
    21f2:	11 e0       	ldi	r17, 0x01	; 1
    21f4:	01 c0       	rjmp	.+2      	; 0x21f8 <xTaskGenericNotifyFromISR+0xa0>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    21f6:	10 e0       	ldi	r17, 0x00	; 0

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    21f8:	81 30       	cpi	r24, 0x01	; 1
    21fa:	e1 f5       	brne	.+120    	; 0x2274 <xTaskGenericNotifyFromISR+0x11c>
    21fc:	ef 01       	movw	r28, r30
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    21fe:	80 91 7e 0d 	lds	r24, 0x0D7E	; 0x800d7e <uxSchedulerSuspended>
    2202:	81 11       	cpse	r24, r1
    2204:	1e c0       	rjmp	.+60     	; 0x2242 <xTaskGenericNotifyFromISR+0xea>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    2206:	6f 01       	movw	r12, r30
    2208:	e2 e0       	ldi	r30, 0x02	; 2
    220a:	ce 0e       	add	r12, r30
    220c:	d1 1c       	adc	r13, r1
    220e:	c6 01       	movw	r24, r12
    2210:	0e 94 68 04 	call	0x8d0	; 0x8d0 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    2214:	8e 89       	ldd	r24, Y+22	; 0x16
    2216:	90 91 88 0d 	lds	r25, 0x0D88	; 0x800d88 <uxTopReadyPriority>
    221a:	98 17       	cp	r25, r24
    221c:	10 f4       	brcc	.+4      	; 0x2222 <xTaskGenericNotifyFromISR+0xca>
    221e:	80 93 88 0d 	sts	0x0D88, r24	; 0x800d88 <uxTopReadyPriority>
    2222:	90 e0       	ldi	r25, 0x00	; 0
    2224:	9c 01       	movw	r18, r24
    2226:	22 0f       	add	r18, r18
    2228:	33 1f       	adc	r19, r19
    222a:	22 0f       	add	r18, r18
    222c:	33 1f       	adc	r19, r19
    222e:	22 0f       	add	r18, r18
    2230:	33 1f       	adc	r19, r19
    2232:	82 0f       	add	r24, r18
    2234:	93 1f       	adc	r25, r19
    2236:	b6 01       	movw	r22, r12
    2238:	85 55       	subi	r24, 0x55	; 85
    223a:	92 4f       	sbci	r25, 0xF2	; 242
    223c:	0e 94 16 04 	call	0x82c	; 0x82c <vListInsertEnd>
    2240:	07 c0       	rjmp	.+14     	; 0x2250 <xTaskGenericNotifyFromISR+0xf8>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    2242:	bf 01       	movw	r22, r30
    2244:	64 5f       	subi	r22, 0xF4	; 244
    2246:	7f 4f       	sbci	r23, 0xFF	; 255
    2248:	8c e8       	ldi	r24, 0x8C	; 140
    224a:	9d e0       	ldi	r25, 0x0D	; 13
    224c:	0e 94 16 04 	call	0x82c	; 0x82c <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    2250:	9e 89       	ldd	r25, Y+22	; 0x16
    2252:	e0 91 cf 0d 	lds	r30, 0x0DCF	; 0x800dcf <pxCurrentTCB>
    2256:	f0 91 d0 0d 	lds	r31, 0x0DD0	; 0x800dd0 <pxCurrentTCB+0x1>
    225a:	86 89       	ldd	r24, Z+22	; 0x16
    225c:	89 17       	cp	r24, r25
    225e:	50 f4       	brcc	.+20     	; 0x2274 <xTaskGenericNotifyFromISR+0x11c>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    2260:	e1 14       	cp	r14, r1
    2262:	f1 04       	cpc	r15, r1
    2264:	21 f0       	breq	.+8      	; 0x226e <xTaskGenericNotifyFromISR+0x116>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    2266:	81 e0       	ldi	r24, 0x01	; 1
    2268:	e7 01       	movw	r28, r14
    226a:	88 83       	st	Y, r24
    226c:	03 c0       	rjmp	.+6      	; 0x2274 <xTaskGenericNotifyFromISR+0x11c>
					else
					{
						/* Mark that a yield is pending in case the user is not
						using the "xHigherPriorityTaskWoken" parameter to an ISR
						safe FreeRTOS function. */
						xYieldPending = pdTRUE;
    226e:	81 e0       	ldi	r24, 0x01	; 1
    2270:	80 93 85 0d 	sts	0x0D85, r24	; 0x800d85 <xYieldPending>
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
	}
    2274:	81 2f       	mov	r24, r17
    2276:	df 91       	pop	r29
    2278:	cf 91       	pop	r28
    227a:	1f 91       	pop	r17
    227c:	0f 91       	pop	r16
    227e:	ff 90       	pop	r15
    2280:	ef 90       	pop	r14
    2282:	df 90       	pop	r13
    2284:	cf 90       	pop	r12
    2286:	08 95       	ret

00002288 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    2288:	ef 92       	push	r14
    228a:	ff 92       	push	r15
    228c:	0f 93       	push	r16
    228e:	1f 93       	push	r17
    2290:	cf 93       	push	r28
    2292:	df 93       	push	r29
    2294:	fc 01       	movw	r30, r24

		pxTCB = ( TCB_t * ) xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    2296:	25 a1       	ldd	r18, Z+37	; 0x25
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    2298:	82 e0       	ldi	r24, 0x02	; 2
    229a:	85 a3       	std	Z+37, r24	; 0x25

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    229c:	81 a1       	ldd	r24, Z+33	; 0x21
    229e:	92 a1       	ldd	r25, Z+34	; 0x22
    22a0:	a3 a1       	ldd	r26, Z+35	; 0x23
    22a2:	b4 a1       	ldd	r27, Z+36	; 0x24
    22a4:	01 96       	adiw	r24, 0x01	; 1
    22a6:	a1 1d       	adc	r26, r1
    22a8:	b1 1d       	adc	r27, r1
    22aa:	81 a3       	std	Z+33, r24	; 0x21
    22ac:	92 a3       	std	Z+34, r25	; 0x22
    22ae:	a3 a3       	std	Z+35, r26	; 0x23
    22b0:	b4 a3       	std	Z+36, r27	; 0x24

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    22b2:	21 30       	cpi	r18, 0x01	; 1
    22b4:	e9 f5       	brne	.+122    	; 0x2330 <vTaskNotifyGiveFromISR+0xa8>
    22b6:	8b 01       	movw	r16, r22
    22b8:	ef 01       	movw	r28, r30
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    22ba:	80 91 7e 0d 	lds	r24, 0x0D7E	; 0x800d7e <uxSchedulerSuspended>
    22be:	81 11       	cpse	r24, r1
    22c0:	1e c0       	rjmp	.+60     	; 0x22fe <vTaskNotifyGiveFromISR+0x76>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    22c2:	7f 01       	movw	r14, r30
    22c4:	82 e0       	ldi	r24, 0x02	; 2
    22c6:	e8 0e       	add	r14, r24
    22c8:	f1 1c       	adc	r15, r1
    22ca:	c7 01       	movw	r24, r14
    22cc:	0e 94 68 04 	call	0x8d0	; 0x8d0 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    22d0:	8e 89       	ldd	r24, Y+22	; 0x16
    22d2:	90 91 88 0d 	lds	r25, 0x0D88	; 0x800d88 <uxTopReadyPriority>
    22d6:	98 17       	cp	r25, r24
    22d8:	10 f4       	brcc	.+4      	; 0x22de <vTaskNotifyGiveFromISR+0x56>
    22da:	80 93 88 0d 	sts	0x0D88, r24	; 0x800d88 <uxTopReadyPriority>
    22de:	90 e0       	ldi	r25, 0x00	; 0
    22e0:	9c 01       	movw	r18, r24
    22e2:	22 0f       	add	r18, r18
    22e4:	33 1f       	adc	r19, r19
    22e6:	22 0f       	add	r18, r18
    22e8:	33 1f       	adc	r19, r19
    22ea:	22 0f       	add	r18, r18
    22ec:	33 1f       	adc	r19, r19
    22ee:	82 0f       	add	r24, r18
    22f0:	93 1f       	adc	r25, r19
    22f2:	b7 01       	movw	r22, r14
    22f4:	85 55       	subi	r24, 0x55	; 85
    22f6:	92 4f       	sbci	r25, 0xF2	; 242
    22f8:	0e 94 16 04 	call	0x82c	; 0x82c <vListInsertEnd>
    22fc:	07 c0       	rjmp	.+14     	; 0x230c <vTaskNotifyGiveFromISR+0x84>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    22fe:	bf 01       	movw	r22, r30
    2300:	64 5f       	subi	r22, 0xF4	; 244
    2302:	7f 4f       	sbci	r23, 0xFF	; 255
    2304:	8c e8       	ldi	r24, 0x8C	; 140
    2306:	9d e0       	ldi	r25, 0x0D	; 13
    2308:	0e 94 16 04 	call	0x82c	; 0x82c <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    230c:	9e 89       	ldd	r25, Y+22	; 0x16
    230e:	e0 91 cf 0d 	lds	r30, 0x0DCF	; 0x800dcf <pxCurrentTCB>
    2312:	f0 91 d0 0d 	lds	r31, 0x0DD0	; 0x800dd0 <pxCurrentTCB+0x1>
    2316:	86 89       	ldd	r24, Z+22	; 0x16
    2318:	89 17       	cp	r24, r25
    231a:	50 f4       	brcc	.+20     	; 0x2330 <vTaskNotifyGiveFromISR+0xa8>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    231c:	01 15       	cp	r16, r1
    231e:	11 05       	cpc	r17, r1
    2320:	21 f0       	breq	.+8      	; 0x232a <vTaskNotifyGiveFromISR+0xa2>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    2322:	81 e0       	ldi	r24, 0x01	; 1
    2324:	f8 01       	movw	r30, r16
    2326:	80 83       	st	Z, r24
    2328:	03 c0       	rjmp	.+6      	; 0x2330 <vTaskNotifyGiveFromISR+0xa8>
					else
					{
						/* Mark that a yield is pending in case the user is not
						using the "xHigherPriorityTaskWoken" parameter in an ISR
						safe FreeRTOS function. */
						xYieldPending = pdTRUE;
    232a:	81 e0       	ldi	r24, 0x01	; 1
    232c:	80 93 85 0d 	sts	0x0D85, r24	; 0x800d85 <xYieldPending>
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    2330:	df 91       	pop	r29
    2332:	cf 91       	pop	r28
    2334:	1f 91       	pop	r17
    2336:	0f 91       	pop	r16
    2338:	ff 90       	pop	r15
    233a:	ef 90       	pop	r14
    233c:	08 95       	ret

0000233e <xTaskNotifyStateClear>:
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    233e:	00 97       	sbiw	r24, 0x00	; 0
    2340:	21 f4       	brne	.+8      	; 0x234a <xTaskNotifyStateClear+0xc>
    2342:	80 91 cf 0d 	lds	r24, 0x0DCF	; 0x800dcf <pxCurrentTCB>
    2346:	90 91 d0 0d 	lds	r25, 0x0DD0	; 0x800dd0 <pxCurrentTCB+0x1>

		taskENTER_CRITICAL();
    234a:	0f b6       	in	r0, 0x3f	; 63
    234c:	f8 94       	cli
    234e:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    2350:	fc 01       	movw	r30, r24
    2352:	25 a1       	ldd	r18, Z+37	; 0x25
    2354:	22 30       	cpi	r18, 0x02	; 2
    2356:	19 f4       	brne	.+6      	; 0x235e <xTaskNotifyStateClear+0x20>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    2358:	15 a2       	std	Z+37, r1	; 0x25
				xReturn = pdPASS;
    235a:	81 e0       	ldi	r24, 0x01	; 1
    235c:	01 c0       	rjmp	.+2      	; 0x2360 <xTaskNotifyStateClear+0x22>
			}
			else
			{
				xReturn = pdFAIL;
    235e:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		taskEXIT_CRITICAL();
    2360:	0f 90       	pop	r0
    2362:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    2364:	08 95       	ret

00002366 <sendMessage>:
		
	}
}


static void sendMessage( unsigned char *message, QueueHandle_t queue) {
    2366:	ef 92       	push	r14
    2368:	ff 92       	push	r15
    236a:	0f 93       	push	r16
    236c:	1f 93       	push	r17
    236e:	cf 93       	push	r28
    2370:	8c 01       	movw	r16, r24
    2372:	7b 01       	movw	r14, r22
	/* Receives a message and pushes it on UART send queue character by character.
	   Limited to 255 characters for efficiency (counter i takes one byte). 
	   Message must be null terminated. */
	for(uint8_t i = 0; message[i] != '\0'; ++i) {
    2374:	c0 e0       	ldi	r28, 0x00	; 0
    2376:	07 c0       	rjmp	.+14     	; 0x2386 <sendMessage+0x20>
		xQueueSendToBack( queue, message+i, pdMS_TO_TICKS(10));
    2378:	20 e0       	ldi	r18, 0x00	; 0
    237a:	41 e0       	ldi	r20, 0x01	; 1
    237c:	50 e0       	ldi	r21, 0x00	; 0
    237e:	c7 01       	movw	r24, r14
    2380:	0e 94 65 07 	call	0xeca	; 0xeca <xQueueGenericSend>

static void sendMessage( unsigned char *message, QueueHandle_t queue) {
	/* Receives a message and pushes it on UART send queue character by character.
	   Limited to 255 characters for efficiency (counter i takes one byte). 
	   Message must be null terminated. */
	for(uint8_t i = 0; message[i] != '\0'; ++i) {
    2384:	cf 5f       	subi	r28, 0xFF	; 255
    2386:	b8 01       	movw	r22, r16
    2388:	6c 0f       	add	r22, r28
    238a:	71 1d       	adc	r23, r1
    238c:	fb 01       	movw	r30, r22
    238e:	80 81       	ld	r24, Z
    2390:	81 11       	cpse	r24, r1
    2392:	f2 cf       	rjmp	.-28     	; 0x2378 <sendMessage+0x12>
		xQueueSendToBack( queue, message+i, pdMS_TO_TICKS(10));
	}
}
    2394:	cf 91       	pop	r28
    2396:	1f 91       	pop	r17
    2398:	0f 91       	pop	r16
    239a:	ff 90       	pop	r15
    239c:	ef 90       	pop	r14
    239e:	08 95       	ret

000023a0 <sendCharacter>:

static void sendCharacter( unsigned char character, QueueHandle_t queue) {
    23a0:	cf 93       	push	r28
    23a2:	df 93       	push	r29
    23a4:	1f 92       	push	r1
    23a6:	cd b7       	in	r28, 0x3d	; 61
    23a8:	de b7       	in	r29, 0x3e	; 62
    23aa:	89 83       	std	Y+1, r24	; 0x01
    23ac:	cb 01       	movw	r24, r22
	/* Receives a character and pushes it on UART send queue. */
	xQueueSendToBack( queue, &character, pdMS_TO_TICKS(10));
    23ae:	20 e0       	ldi	r18, 0x00	; 0
    23b0:	41 e0       	ldi	r20, 0x01	; 1
    23b2:	50 e0       	ldi	r21, 0x00	; 0
    23b4:	be 01       	movw	r22, r28
    23b6:	6f 5f       	subi	r22, 0xFF	; 255
    23b8:	7f 4f       	sbci	r23, 0xFF	; 255
    23ba:	0e 94 65 07 	call	0xeca	; 0xeca <xQueueGenericSend>
}
    23be:	0f 90       	pop	r0
    23c0:	df 91       	pop	r29
    23c2:	cf 91       	pop	r28
    23c4:	08 95       	ret

000023c6 <vUART1ReceiveService>:
	
	for( ;; ) {
		/* Waits for bufferReceiveUART1 to fill, then pops first byte of data and
		   copies it to UART1 data register UDR1 effectively transmitting it. 
		   Test code - writes back to terminal. */ 
		xQueueReceive( bufferReceiveUART1Bluetooth, &UDR1, portMAX_DELAY );
    23c6:	20 e0       	ldi	r18, 0x00	; 0
    23c8:	4f ef       	ldi	r20, 0xFF	; 255
    23ca:	5f ef       	ldi	r21, 0xFF	; 255
    23cc:	6c e9       	ldi	r22, 0x9C	; 156
    23ce:	70 e0       	ldi	r23, 0x00	; 0
    23d0:	80 91 db 0d 	lds	r24, 0x0DDB	; 0x800ddb <bufferReceiveUART1Bluetooth>
    23d4:	90 91 dc 0d 	lds	r25, 0x0DDC	; 0x800ddc <bufferReceiveUART1Bluetooth+0x1>
    23d8:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <xQueueGenericReceive>
		while(!( UCSR1A & (1<<UDRE1)));		// Wait for transmit to finish
    23dc:	80 91 9b 00 	lds	r24, 0x009B	; 0x80009b <__TEXT_REGION_LENGTH__+0x7e009b>
    23e0:	85 ff       	sbrs	r24, 5
    23e2:	fc cf       	rjmp	.-8      	; 0x23dc <vUART1ReceiveService+0x16>
    23e4:	f0 cf       	rjmp	.-32     	; 0x23c6 <vUART1ReceiveService>

000023e6 <vUART1TransmitService>:
	( void ) pvParameters;
	
	for( ;; ) {
		/* Waits for bufferSendUART1 to fill, then pops first byte of data and
		   copies it to UART1 data register UDR1 effectively transmitting it. */ 
		xQueueReceive( bufferSendUART1Bluetooth, &UDR1, portMAX_DELAY );
    23e6:	20 e0       	ldi	r18, 0x00	; 0
    23e8:	4f ef       	ldi	r20, 0xFF	; 255
    23ea:	5f ef       	ldi	r21, 0xFF	; 255
    23ec:	6c e9       	ldi	r22, 0x9C	; 156
    23ee:	70 e0       	ldi	r23, 0x00	; 0
    23f0:	80 91 21 0e 	lds	r24, 0x0E21	; 0x800e21 <bufferSendUART1Bluetooth>
    23f4:	90 91 22 0e 	lds	r25, 0x0E22	; 0x800e22 <bufferSendUART1Bluetooth+0x1>
    23f8:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <xQueueGenericReceive>
		while(!( UCSR1A & (1<<UDRE1)));		// Wait for transmit to finish
    23fc:	80 91 9b 00 	lds	r24, 0x009B	; 0x80009b <__TEXT_REGION_LENGTH__+0x7e009b>
    2400:	85 ff       	sbrs	r24, 5
    2402:	fc cf       	rjmp	.-8      	; 0x23fc <vUART1TransmitService+0x16>
    2404:	f0 cf       	rjmp	.-32     	; 0x23e6 <vUART1TransmitService>

00002406 <vUART0TransmitService>:
	( void ) pvParameters;
	
	for( ;; ) {
		/* Waits for bufferSendUART0 to fill, then pops first byte of data and
		   copies it to UART0 data register UDR0 effectively transmitting it. */ 
		xQueueReceive( bufferSendUART0Serial, &UDR0, portMAX_DELAY );
    2406:	20 e0       	ldi	r18, 0x00	; 0
    2408:	4f ef       	ldi	r20, 0xFF	; 255
    240a:	5f ef       	ldi	r21, 0xFF	; 255
    240c:	6c e2       	ldi	r22, 0x2C	; 44
    240e:	70 e0       	ldi	r23, 0x00	; 0
    2410:	80 91 1f 0e 	lds	r24, 0x0E1F	; 0x800e1f <bufferSendUART0Serial>
    2414:	90 91 20 0e 	lds	r25, 0x0E20	; 0x800e20 <bufferSendUART0Serial+0x1>
    2418:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <xQueueGenericReceive>
		while(!( UCSR0A & (1<<UDRE0)));		// Wait for transmit to finish
    241c:	5d 9b       	sbis	0x0b, 5	; 11
    241e:	fe cf       	rjmp	.-4      	; 0x241c <vUART0TransmitService+0x16>
    2420:	f2 cf       	rjmp	.-28     	; 0x2406 <vUART0TransmitService>

00002422 <flushQueue>:
static void sendCharacter( unsigned char character, QueueHandle_t queue) {
	/* Receives a character and pushes it on UART send queue. */
	xQueueSendToBack( queue, &character, pdMS_TO_TICKS(10));
}

static void flushQueue( QueueHandle_t queue) {
    2422:	0f 93       	push	r16
    2424:	1f 93       	push	r17
    2426:	cf 93       	push	r28
    2428:	8c 01       	movw	r16, r24
	for(uint8_t i = uxQueueMessagesWaiting(queue); i > 0; ++i) {
    242a:	0e 94 51 09 	call	0x12a2	; 0x12a2 <uxQueueMessagesWaiting>
    242e:	c8 2f       	mov	r28, r24
    2430:	09 c0       	rjmp	.+18     	; 0x2444 <flushQueue+0x22>
		xQueueReceive( queue, NULL, 0 );
    2432:	20 e0       	ldi	r18, 0x00	; 0
    2434:	40 e0       	ldi	r20, 0x00	; 0
    2436:	50 e0       	ldi	r21, 0x00	; 0
    2438:	60 e0       	ldi	r22, 0x00	; 0
    243a:	70 e0       	ldi	r23, 0x00	; 0
    243c:	c8 01       	movw	r24, r16
    243e:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <xQueueGenericReceive>
	/* Receives a character and pushes it on UART send queue. */
	xQueueSendToBack( queue, &character, pdMS_TO_TICKS(10));
}

static void flushQueue( QueueHandle_t queue) {
	for(uint8_t i = uxQueueMessagesWaiting(queue); i > 0; ++i) {
    2442:	cf 5f       	subi	r28, 0xFF	; 255
    2444:	c1 11       	cpse	r28, r1
    2446:	f5 cf       	rjmp	.-22     	; 0x2432 <flushQueue+0x10>
		xQueueReceive( queue, NULL, 0 );
	}
}
    2448:	cf 91       	pop	r28
    244a:	1f 91       	pop	r17
    244c:	0f 91       	pop	r16
    244e:	08 95       	ret

00002450 <vCyclicalTask>:
		xQueueReceive( bufferReceiveUART1Bluetooth, &UDR1, portMAX_DELAY );
		while(!( UCSR1A & (1<<UDRE1)));		// Wait for transmit to finish
	}
}

static void vCyclicalTask( void *pvParameters ) {
    2450:	cf 93       	push	r28
    2452:	df 93       	push	r29
    2454:	1f 92       	push	r1
    2456:	cd b7       	in	r28, 0x3d	; 61
    2458:	de b7       	in	r29, 0x3e	; 62
	( void ) pvParameters;
	
	for( ;; ) {

		/* Send request to Roomba for sensor data (2 bytes). */
		buffer = SCI_SENSORS;
    245a:	8e e8       	ldi	r24, 0x8E	; 142
    245c:	89 83       	std	Y+1, r24	; 0x01
		xQueueSendToBack( bufferSendUART0Serial, &buffer, pdMS_TO_TICKS(10) );
    245e:	20 e0       	ldi	r18, 0x00	; 0
    2460:	41 e0       	ldi	r20, 0x01	; 1
    2462:	50 e0       	ldi	r21, 0x00	; 0
    2464:	be 01       	movw	r22, r28
    2466:	6f 5f       	subi	r22, 0xFF	; 255
    2468:	7f 4f       	sbci	r23, 0xFF	; 255
    246a:	80 91 1f 0e 	lds	r24, 0x0E1F	; 0x800e1f <bufferSendUART0Serial>
    246e:	90 91 20 0e 	lds	r25, 0x0E20	; 0x800e20 <bufferSendUART0Serial+0x1>
    2472:	0e 94 65 07 	call	0xeca	; 0xeca <xQueueGenericSend>
		buffer = SCI_SENSORS_PACKET0;
    2476:	19 82       	std	Y+1, r1	; 0x01
		xQueueSendToBack( bufferSendUART0Serial, &buffer, pdMS_TO_TICKS(10) );
    2478:	20 e0       	ldi	r18, 0x00	; 0
    247a:	41 e0       	ldi	r20, 0x01	; 1
    247c:	50 e0       	ldi	r21, 0x00	; 0
    247e:	be 01       	movw	r22, r28
    2480:	6f 5f       	subi	r22, 0xFF	; 255
    2482:	7f 4f       	sbci	r23, 0xFF	; 255
    2484:	80 91 1f 0e 	lds	r24, 0x0E1F	; 0x800e1f <bufferSendUART0Serial>
    2488:	90 91 20 0e 	lds	r25, 0x0E20	; 0x800e20 <bufferSendUART0Serial+0x1>
    248c:	0e 94 65 07 	call	0xeca	; 0xeca <xQueueGenericSend>

		/* Receive 26 bytes of sensor data from Roomba. */
		for( uint8_t i = 0; i < 26; ++i ) {
    2490:	10 e0       	ldi	r17, 0x00	; 0
    2492:	10 c0       	rjmp	.+32     	; 0x24b4 <vCyclicalTask+0x64>
			if( errQUEUE_EMPTY == xQueueReceive( bufferReceiveUART0Serial, (sensorData + i), pdMS_TO_TICKS(50) ))
    2494:	61 2f       	mov	r22, r17
    2496:	70 e0       	ldi	r23, 0x00	; 0
    2498:	63 52       	subi	r22, 0x23	; 35
    249a:	72 4f       	sbci	r23, 0xF2	; 242
    249c:	20 e0       	ldi	r18, 0x00	; 0
    249e:	45 e0       	ldi	r20, 0x05	; 5
    24a0:	50 e0       	ldi	r21, 0x00	; 0
    24a2:	80 91 1d 0e 	lds	r24, 0x0E1D	; 0x800e1d <bufferReceiveUART0Serial>
    24a6:	90 91 1e 0e 	lds	r25, 0x0E1E	; 0x800e1e <bufferReceiveUART0Serial+0x1>
    24aa:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <xQueueGenericReceive>
    24ae:	88 23       	and	r24, r24
    24b0:	19 f0       	breq	.+6      	; 0x24b8 <vCyclicalTask+0x68>
		xQueueSendToBack( bufferSendUART0Serial, &buffer, pdMS_TO_TICKS(10) );
		buffer = SCI_SENSORS_PACKET0;
		xQueueSendToBack( bufferSendUART0Serial, &buffer, pdMS_TO_TICKS(10) );

		/* Receive 26 bytes of sensor data from Roomba. */
		for( uint8_t i = 0; i < 26; ++i ) {
    24b2:	1f 5f       	subi	r17, 0xFF	; 255
    24b4:	1a 31       	cpi	r17, 0x1A	; 26
    24b6:	70 f3       	brcs	.-36     	; 0x2494 <vCyclicalTask+0x44>
			if( errQUEUE_EMPTY == xQueueReceive( bufferReceiveUART0Serial, (sensorData + i), pdMS_TO_TICKS(50) ))
				break;
		}
		vTaskDelay( pdMS_TO_TICKS(3000) );
    24b8:	8c e2       	ldi	r24, 0x2C	; 44
    24ba:	91 e0       	ldi	r25, 0x01	; 1
    24bc:	0e 94 dd 0d 	call	0x1bba	; 0x1bba <vTaskDelay>
	}
    24c0:	cc cf       	rjmp	.-104    	; 0x245a <vCyclicalTask+0xa>

000024c2 <vRedLED>:

	/* The parameters are not used. */
	( void ) pvParameters;

	for( ;; ) {
		PORTB ^= (1 << PB0);
    24c2:	98 b3       	in	r25, 0x18	; 24
    24c4:	81 e0       	ldi	r24, 0x01	; 1
    24c6:	89 27       	eor	r24, r25
    24c8:	88 bb       	out	0x18, r24	; 24
		sendMessage( "Sensors: ", bufferSendUART1Bluetooth );
    24ca:	60 91 21 0e 	lds	r22, 0x0E21	; 0x800e21 <bufferSendUART1Bluetooth>
    24ce:	70 91 22 0e 	lds	r23, 0x0E22	; 0x800e22 <bufferSendUART1Bluetooth+0x1>
    24d2:	8d e0       	ldi	r24, 0x0D	; 13
    24d4:	91 e0       	ldi	r25, 0x01	; 1
    24d6:	0e 94 b3 11 	call	0x2366	; 0x2366 <sendMessage>
		sendMessage( sensorData, bufferSendUART1Bluetooth );
    24da:	60 91 21 0e 	lds	r22, 0x0E21	; 0x800e21 <bufferSendUART1Bluetooth>
    24de:	70 91 22 0e 	lds	r23, 0x0E22	; 0x800e22 <bufferSendUART1Bluetooth+0x1>
    24e2:	8d ed       	ldi	r24, 0xDD	; 221
    24e4:	9d e0       	ldi	r25, 0x0D	; 13
    24e6:	0e 94 b3 11 	call	0x2366	; 0x2366 <sendMessage>
		sendCharacter( '\r', bufferSendUART1Bluetooth );
    24ea:	60 91 21 0e 	lds	r22, 0x0E21	; 0x800e21 <bufferSendUART1Bluetooth>
    24ee:	70 91 22 0e 	lds	r23, 0x0E22	; 0x800e22 <bufferSendUART1Bluetooth+0x1>
    24f2:	8d e0       	ldi	r24, 0x0D	; 13
    24f4:	0e 94 d0 11 	call	0x23a0	; 0x23a0 <sendCharacter>
		sendCharacter( '\n', bufferSendUART1Bluetooth );
    24f8:	60 91 21 0e 	lds	r22, 0x0E21	; 0x800e21 <bufferSendUART1Bluetooth>
    24fc:	70 91 22 0e 	lds	r23, 0x0E22	; 0x800e22 <bufferSendUART1Bluetooth+0x1>
    2500:	8a e0       	ldi	r24, 0x0A	; 10
    2502:	0e 94 d0 11 	call	0x23a0	; 0x23a0 <sendCharacter>
		//sendMessage(message2, bufferSendUART0Serial);
		//PORTB ^= (1 << PB0);
		vTaskDelay( pdMS_TO_TICKS(3000) );
    2506:	8c e2       	ldi	r24, 0x2C	; 44
    2508:	91 e0       	ldi	r25, 0x01	; 1
    250a:	0e 94 dd 0d 	call	0x1bba	; 0x1bba <vTaskDelay>
    250e:	d9 cf       	rjmp	.-78     	; 0x24c2 <vRedLED>

00002510 <main>:

QueueHandle_t bufferSendUART0Serial, bufferReceiveUART0Serial, bufferSendUART1Bluetooth, bufferReceiveUART1Bluetooth, testQ;
uint8_t sensorData[32];
Message msg;

int main( void ) {
    2510:	ef 92       	push	r14
    2512:	ff 92       	push	r15
    2514:	0f 93       	push	r16
    2516:	cf 93       	push	r28
    2518:	df 93       	push	r29
    251a:	00 d0       	rcall	.+0      	; 0x251c <main+0xc>
    251c:	cd b7       	in	r28, 0x3d	; 61
    251e:	de b7       	in	r29, 0x3e	; 62
	volatile uint8_t no;
	bufferSendUART0Serial = xQueueCreate(32, sizeof(unsigned char));
    2520:	40 e0       	ldi	r20, 0x00	; 0
    2522:	61 e0       	ldi	r22, 0x01	; 1
    2524:	80 e2       	ldi	r24, 0x20	; 32
    2526:	0e 94 3b 07 	call	0xe76	; 0xe76 <xQueueGenericCreate>
    252a:	90 93 20 0e 	sts	0x0E20, r25	; 0x800e20 <bufferSendUART0Serial+0x1>
    252e:	80 93 1f 0e 	sts	0x0E1F, r24	; 0x800e1f <bufferSendUART0Serial>
	bufferReceiveUART0Serial = xQueueCreate(32, sizeof(unsigned char));
    2532:	40 e0       	ldi	r20, 0x00	; 0
    2534:	61 e0       	ldi	r22, 0x01	; 1
    2536:	80 e2       	ldi	r24, 0x20	; 32
    2538:	0e 94 3b 07 	call	0xe76	; 0xe76 <xQueueGenericCreate>
    253c:	90 93 1e 0e 	sts	0x0E1E, r25	; 0x800e1e <bufferReceiveUART0Serial+0x1>
    2540:	80 93 1d 0e 	sts	0x0E1D, r24	; 0x800e1d <bufferReceiveUART0Serial>
	bufferSendUART1Bluetooth = xQueueCreate(32, sizeof(unsigned char));
    2544:	40 e0       	ldi	r20, 0x00	; 0
    2546:	61 e0       	ldi	r22, 0x01	; 1
    2548:	80 e2       	ldi	r24, 0x20	; 32
    254a:	0e 94 3b 07 	call	0xe76	; 0xe76 <xQueueGenericCreate>
    254e:	90 93 22 0e 	sts	0x0E22, r25	; 0x800e22 <bufferSendUART1Bluetooth+0x1>
    2552:	80 93 21 0e 	sts	0x0E21, r24	; 0x800e21 <bufferSendUART1Bluetooth>
	bufferReceiveUART1Bluetooth = xQueueCreate(32, sizeof(unsigned char));
    2556:	40 e0       	ldi	r20, 0x00	; 0
    2558:	61 e0       	ldi	r22, 0x01	; 1
    255a:	80 e2       	ldi	r24, 0x20	; 32
    255c:	0e 94 3b 07 	call	0xe76	; 0xe76 <xQueueGenericCreate>
    2560:	90 93 dc 0d 	sts	0x0DDC, r25	; 0x800ddc <bufferReceiveUART1Bluetooth+0x1>
    2564:	80 93 db 0d 	sts	0x0DDB, r24	; 0x800ddb <bufferReceiveUART1Bluetooth>

	testQ = xQueueCreate(32, sizeof(unsigned char));
    2568:	40 e0       	ldi	r20, 0x00	; 0
    256a:	61 e0       	ldi	r22, 0x01	; 1
    256c:	80 e2       	ldi	r24, 0x20	; 32
    256e:	0e 94 3b 07 	call	0xe76	; 0xe76 <xQueueGenericCreate>
    2572:	90 93 d6 0d 	sts	0x0DD6, r25	; 0x800dd6 <testQ+0x1>
    2576:	80 93 d5 0d 	sts	0x0DD5, r24	; 0x800dd5 <testQ>

	for(uint8_t i=1; i<=10; ++i ) {
    257a:	81 e0       	ldi	r24, 0x01	; 1
    257c:	8a 83       	std	Y+2, r24	; 0x02
    257e:	0f c0       	rjmp	.+30     	; 0x259e <main+0x8e>
		xQueueSendToBack( testQ, &i, pdMS_TO_TICKS(10) );
    2580:	20 e0       	ldi	r18, 0x00	; 0
    2582:	41 e0       	ldi	r20, 0x01	; 1
    2584:	50 e0       	ldi	r21, 0x00	; 0
    2586:	be 01       	movw	r22, r28
    2588:	6e 5f       	subi	r22, 0xFE	; 254
    258a:	7f 4f       	sbci	r23, 0xFF	; 255
    258c:	80 91 d5 0d 	lds	r24, 0x0DD5	; 0x800dd5 <testQ>
    2590:	90 91 d6 0d 	lds	r25, 0x0DD6	; 0x800dd6 <testQ+0x1>
    2594:	0e 94 65 07 	call	0xeca	; 0xeca <xQueueGenericSend>
	bufferSendUART1Bluetooth = xQueueCreate(32, sizeof(unsigned char));
	bufferReceiveUART1Bluetooth = xQueueCreate(32, sizeof(unsigned char));

	testQ = xQueueCreate(32, sizeof(unsigned char));

	for(uint8_t i=1; i<=10; ++i ) {
    2598:	8a 81       	ldd	r24, Y+2	; 0x02
    259a:	8f 5f       	subi	r24, 0xFF	; 255
    259c:	8a 83       	std	Y+2, r24	; 0x02
    259e:	8a 81       	ldd	r24, Y+2	; 0x02
    25a0:	8b 30       	cpi	r24, 0x0B	; 11
    25a2:	70 f3       	brcs	.-36     	; 0x2580 <main+0x70>
		xQueueSendToBack( testQ, &i, pdMS_TO_TICKS(10) );
	}

	no = uxQueueMessagesWaiting(testQ);
    25a4:	80 91 d5 0d 	lds	r24, 0x0DD5	; 0x800dd5 <testQ>
    25a8:	90 91 d6 0d 	lds	r25, 0x0DD6	; 0x800dd6 <testQ+0x1>
    25ac:	0e 94 51 09 	call	0x12a2	; 0x12a2 <uxQueueMessagesWaiting>
    25b0:	89 83       	std	Y+1, r24	; 0x01
	flushQueue(testQ);
    25b2:	80 91 d5 0d 	lds	r24, 0x0DD5	; 0x800dd5 <testQ>
    25b6:	90 91 d6 0d 	lds	r25, 0x0DD6	; 0x800dd6 <testQ+0x1>
    25ba:	0e 94 11 12 	call	0x2422	; 0x2422 <flushQueue>
	no = uxQueueMessagesWaiting(testQ);
    25be:	80 91 d5 0d 	lds	r24, 0x0DD5	; 0x800dd5 <testQ>
    25c2:	90 91 d6 0d 	lds	r25, 0x0DD6	; 0x800dd6 <testQ+0x1>
    25c6:	0e 94 51 09 	call	0x12a2	; 0x12a2 <uxQueueMessagesWaiting>
    25ca:	89 83       	std	Y+1, r24	; 0x01

	DDRB |= (1 << PB0);
    25cc:	87 b3       	in	r24, 0x17	; 23
    25ce:	81 60       	ori	r24, 0x01	; 1
    25d0:	87 bb       	out	0x17, r24	; 23
	DDRB |= (1 << PB1);
    25d2:	87 b3       	in	r24, 0x17	; 23
    25d4:	82 60       	ori	r24, 0x02	; 2
    25d6:	87 bb       	out	0x17, r24	; 23


	USART_Init();
    25d8:	0e 94 a2 13 	call	0x2744	; 0x2744 <USART_Init>

	/* Enable interrupts */
	UCSR0B |= (1 << RXCIE0);
    25dc:	8a b1       	in	r24, 0x0a	; 10
    25de:	80 68       	ori	r24, 0x80	; 128
    25e0:	8a b9       	out	0x0a, r24	; 10
	UCSR1B |= (1 << RXCIE1);
    25e2:	ea e9       	ldi	r30, 0x9A	; 154
    25e4:	f0 e0       	ldi	r31, 0x00	; 0
    25e6:	80 81       	ld	r24, Z
    25e8:	80 68       	ori	r24, 0x80	; 128
    25ea:	80 83       	st	Z, r24
	sei();
    25ec:	78 94       	sei

	makeMessage(&msg, TEXT, '1', message1);
    25ee:	20 e0       	ldi	r18, 0x00	; 0
    25f0:	31 e0       	ldi	r19, 0x01	; 1
    25f2:	41 e3       	ldi	r20, 0x31	; 49
    25f4:	61 e4       	ldi	r22, 0x41	; 65
    25f6:	87 ed       	ldi	r24, 0xD7	; 215
    25f8:	9d e0       	ldi	r25, 0x0D	; 13
    25fa:	0e 94 c6 13 	call	0x278c	; 0x278c <makeMessage>
	getMessage(&msg, message2);
    25fe:	6d ef       	ldi	r22, 0xFD	; 253
    2600:	7d e0       	ldi	r23, 0x0D	; 13
    2602:	87 ed       	ldi	r24, 0xD7	; 215
    2604:	9d e0       	ldi	r25, 0x0D	; 13
    2606:	0e 94 cc 13 	call	0x2798	; 0x2798 <getMessage>

	/* Create the tasks defined within this file. */
	xTaskCreate( vRedLED, "RedLED", configMINIMAL_STACK_SIZE, NULL, mainLED_TASK_PRIORITY, NULL );
    260a:	e1 2c       	mov	r14, r1
    260c:	f1 2c       	mov	r15, r1
    260e:	01 e0       	ldi	r16, 0x01	; 1
    2610:	20 e0       	ldi	r18, 0x00	; 0
    2612:	30 e0       	ldi	r19, 0x00	; 0
    2614:	45 e5       	ldi	r20, 0x55	; 85
    2616:	50 e0       	ldi	r21, 0x00	; 0
    2618:	67 e1       	ldi	r22, 0x17	; 23
    261a:	71 e0       	ldi	r23, 0x01	; 1
    261c:	81 e6       	ldi	r24, 0x61	; 97
    261e:	92 e1       	ldi	r25, 0x12	; 18
    2620:	0e 94 cc 0b 	call	0x1798	; 0x1798 <xTaskCreate>
	//xTaskCreate( vGreenLED, "GreenLED", configMINIMAL_STACK_SIZE, NULL, mainLED_TASK_PRIORITY, NULL );
	xTaskCreate( vUART0TransmitService, "UART0Tx", configMINIMAL_STACK_SIZE, NULL, mainUART_PRIORITY, NULL );
    2624:	02 e0       	ldi	r16, 0x02	; 2
    2626:	20 e0       	ldi	r18, 0x00	; 0
    2628:	30 e0       	ldi	r19, 0x00	; 0
    262a:	45 e5       	ldi	r20, 0x55	; 85
    262c:	50 e0       	ldi	r21, 0x00	; 0
    262e:	6e e1       	ldi	r22, 0x1E	; 30
    2630:	71 e0       	ldi	r23, 0x01	; 1
    2632:	83 e0       	ldi	r24, 0x03	; 3
    2634:	92 e1       	ldi	r25, 0x12	; 18
    2636:	0e 94 cc 0b 	call	0x1798	; 0x1798 <xTaskCreate>
	xTaskCreate( vUART1TransmitService, "UART1Tx", configMINIMAL_STACK_SIZE, NULL, mainUART_PRIORITY, NULL );
    263a:	20 e0       	ldi	r18, 0x00	; 0
    263c:	30 e0       	ldi	r19, 0x00	; 0
    263e:	45 e5       	ldi	r20, 0x55	; 85
    2640:	50 e0       	ldi	r21, 0x00	; 0
    2642:	66 e2       	ldi	r22, 0x26	; 38
    2644:	71 e0       	ldi	r23, 0x01	; 1
    2646:	83 ef       	ldi	r24, 0xF3	; 243
    2648:	91 e1       	ldi	r25, 0x11	; 17
    264a:	0e 94 cc 0b 	call	0x1798	; 0x1798 <xTaskCreate>
	//xTaskCreate( vUART0ReceiveService, "UART0Rx", configMINIMAL_STACK_SIZE, NULL, mainUART_PRIORITY, NULL );
	xTaskCreate( vUART1ReceiveService, "UART1Rx", configMINIMAL_STACK_SIZE, NULL, mainUART_PRIORITY, NULL );
    264e:	20 e0       	ldi	r18, 0x00	; 0
    2650:	30 e0       	ldi	r19, 0x00	; 0
    2652:	45 e5       	ldi	r20, 0x55	; 85
    2654:	50 e0       	ldi	r21, 0x00	; 0
    2656:	6e e2       	ldi	r22, 0x2E	; 46
    2658:	71 e0       	ldi	r23, 0x01	; 1
    265a:	83 ee       	ldi	r24, 0xE3	; 227
    265c:	91 e1       	ldi	r25, 0x11	; 17
    265e:	0e 94 cc 0b 	call	0x1798	; 0x1798 <xTaskCreate>
	xTaskCreate( vCyclicalTask, "Cyclical", configMINIMAL_STACK_SIZE, NULL, mainUART_PRIORITY, NULL );
    2662:	20 e0       	ldi	r18, 0x00	; 0
    2664:	30 e0       	ldi	r19, 0x00	; 0
    2666:	45 e5       	ldi	r20, 0x55	; 85
    2668:	50 e0       	ldi	r21, 0x00	; 0
    266a:	66 e3       	ldi	r22, 0x36	; 54
    266c:	71 e0       	ldi	r23, 0x01	; 1
    266e:	88 e2       	ldi	r24, 0x28	; 40
    2670:	92 e1       	ldi	r25, 0x12	; 18
    2672:	0e 94 cc 0b 	call	0x1798	; 0x1798 <xTaskCreate>

	vTaskStartScheduler();
    2676:	0e 94 20 0c 	call	0x1840	; 0x1840 <vTaskStartScheduler>

	return 0;
}
    267a:	80 e0       	ldi	r24, 0x00	; 0
    267c:	90 e0       	ldi	r25, 0x00	; 0
    267e:	0f 90       	pop	r0
    2680:	0f 90       	pop	r0
    2682:	df 91       	pop	r29
    2684:	cf 91       	pop	r28
    2686:	0f 91       	pop	r16
    2688:	ff 90       	pop	r15
    268a:	ef 90       	pop	r14
    268c:	08 95       	ret

0000268e <vApplicationIdleHook>:
	for(uint8_t i = uxQueueMessagesWaiting(queue); i > 0; ++i) {
		xQueueReceive( queue, NULL, 0 );
	}
}

void vApplicationIdleHook( void ) {
    268e:	08 95       	ret

00002690 <__vector_18>:
	//PORTB ^= (1 << PB1);
}

ISR(USART0_RX_vect) {
    2690:	1f 92       	push	r1
    2692:	0f 92       	push	r0
    2694:	0f b6       	in	r0, 0x3f	; 63
    2696:	0f 92       	push	r0
    2698:	11 24       	eor	r1, r1
    269a:	2f 93       	push	r18
    269c:	3f 93       	push	r19
    269e:	4f 93       	push	r20
    26a0:	5f 93       	push	r21
    26a2:	6f 93       	push	r22
    26a4:	7f 93       	push	r23
    26a6:	8f 93       	push	r24
    26a8:	9f 93       	push	r25
    26aa:	af 93       	push	r26
    26ac:	bf 93       	push	r27
    26ae:	ef 93       	push	r30
    26b0:	ff 93       	push	r31
	xQueueSendToBackFromISR( bufferReceiveUART0Serial, &UDR0, NULL);
    26b2:	20 e0       	ldi	r18, 0x00	; 0
    26b4:	40 e0       	ldi	r20, 0x00	; 0
    26b6:	50 e0       	ldi	r21, 0x00	; 0
    26b8:	6c e2       	ldi	r22, 0x2C	; 44
    26ba:	70 e0       	ldi	r23, 0x00	; 0
    26bc:	80 91 1d 0e 	lds	r24, 0x0E1D	; 0x800e1d <bufferReceiveUART0Serial>
    26c0:	90 91 1e 0e 	lds	r25, 0x0E1E	; 0x800e1e <bufferReceiveUART0Serial+0x1>
    26c4:	0e 94 f7 07 	call	0xfee	; 0xfee <xQueueGenericSendFromISR>
}
    26c8:	ff 91       	pop	r31
    26ca:	ef 91       	pop	r30
    26cc:	bf 91       	pop	r27
    26ce:	af 91       	pop	r26
    26d0:	9f 91       	pop	r25
    26d2:	8f 91       	pop	r24
    26d4:	7f 91       	pop	r23
    26d6:	6f 91       	pop	r22
    26d8:	5f 91       	pop	r21
    26da:	4f 91       	pop	r20
    26dc:	3f 91       	pop	r19
    26de:	2f 91       	pop	r18
    26e0:	0f 90       	pop	r0
    26e2:	0f be       	out	0x3f, r0	; 63
    26e4:	0f 90       	pop	r0
    26e6:	1f 90       	pop	r1
    26e8:	18 95       	reti

000026ea <__vector_30>:

ISR(USART1_RX_vect) {
    26ea:	1f 92       	push	r1
    26ec:	0f 92       	push	r0
    26ee:	0f b6       	in	r0, 0x3f	; 63
    26f0:	0f 92       	push	r0
    26f2:	11 24       	eor	r1, r1
    26f4:	2f 93       	push	r18
    26f6:	3f 93       	push	r19
    26f8:	4f 93       	push	r20
    26fa:	5f 93       	push	r21
    26fc:	6f 93       	push	r22
    26fe:	7f 93       	push	r23
    2700:	8f 93       	push	r24
    2702:	9f 93       	push	r25
    2704:	af 93       	push	r26
    2706:	bf 93       	push	r27
    2708:	ef 93       	push	r30
    270a:	ff 93       	push	r31
	xQueueSendToBackFromISR( bufferReceiveUART1Bluetooth, &UDR1, NULL);
    270c:	20 e0       	ldi	r18, 0x00	; 0
    270e:	40 e0       	ldi	r20, 0x00	; 0
    2710:	50 e0       	ldi	r21, 0x00	; 0
    2712:	6c e9       	ldi	r22, 0x9C	; 156
    2714:	70 e0       	ldi	r23, 0x00	; 0
    2716:	80 91 db 0d 	lds	r24, 0x0DDB	; 0x800ddb <bufferReceiveUART1Bluetooth>
    271a:	90 91 dc 0d 	lds	r25, 0x0DDC	; 0x800ddc <bufferReceiveUART1Bluetooth+0x1>
    271e:	0e 94 f7 07 	call	0xfee	; 0xfee <xQueueGenericSendFromISR>
}
    2722:	ff 91       	pop	r31
    2724:	ef 91       	pop	r30
    2726:	bf 91       	pop	r27
    2728:	af 91       	pop	r26
    272a:	9f 91       	pop	r25
    272c:	8f 91       	pop	r24
    272e:	7f 91       	pop	r23
    2730:	6f 91       	pop	r22
    2732:	5f 91       	pop	r21
    2734:	4f 91       	pop	r20
    2736:	3f 91       	pop	r19
    2738:	2f 91       	pop	r18
    273a:	0f 90       	pop	r0
    273c:	0f be       	out	0x3f, r0	; 63
    273e:	0f 90       	pop	r0
    2740:	1f 90       	pop	r1
    2742:	18 95       	reti

00002744 <USART_Init>:
#define UBRR_UART0 (uint16_t)(F_CPU/(16*BAUD_UART0)-1)
#define UBRR_UART1 (uint16_t)(F_CPU/(16*BAUD_UART1)-1)

void USART_Init(void) {
	/* Set baud rate UART0 */
	UBRR0H = (uint8_t)(UBRR_UART0>>8);
    2744:	10 92 90 00 	sts	0x0090, r1	; 0x800090 <__TEXT_REGION_LENGTH__+0x7e0090>
	UBRR0L = (uint8_t)UBRR_UART0;
    2748:	85 e0       	ldi	r24, 0x05	; 5
    274a:	89 b9       	out	0x09, r24	; 9
	/* Set baud rate UART1 */
	UBRR1H = (uint8_t)(UBRR_UART1>>8);
    274c:	10 92 98 00 	sts	0x0098, r1	; 0x800098 <__TEXT_REGION_LENGTH__+0x7e0098>
	UBRR1L = (uint8_t)UBRR_UART1;
    2750:	87 e4       	ldi	r24, 0x47	; 71
    2752:	80 93 99 00 	sts	0x0099, r24	; 0x800099 <__TEXT_REGION_LENGTH__+0x7e0099>

	/* Enable receiver and transmitter UART0 */
	UCSR0B = (1<<RXEN0)|(1<<TXEN0);
    2756:	88 e1       	ldi	r24, 0x18	; 24
    2758:	8a b9       	out	0x0a, r24	; 10
	/* Enable receiver and transmitter UART1 */
	UCSR1B = (1<<RXEN1)|(1<<TXEN1);
    275a:	80 93 9a 00 	sts	0x009A, r24	; 0x80009a <__TEXT_REGION_LENGTH__+0x7e009a>
    275e:	08 95       	ret

00002760 <USART_SendByte>:
	/* Wait for empty transmit buffer */
	//while ( !( UCSR0A & (1<<UDRE0)) );
	while(!UDRE0);

	/* Put data into buffer, sends the data */
	UDR0 = data;
    2760:	8c b9       	out	0x0c, r24	; 12
    2762:	08 95       	ret

00002764 <USART0_SendChar>:

	/* Wait for empty transmit buffer */
	while(!UDRE0);

	/* Put data into buffer, sends the data */
	UDR0 = c;
    2764:	8c b9       	out	0x0c, r24	; 12
    2766:	08 95       	ret

00002768 <USART0_SendString>:
}

// Max 256 characters
void USART0_SendString(unsigned char *str) {
    2768:	ac 01       	movw	r20, r24

	for(uint8_t i = 0; str[i] != '\0'; ++i) {
    276a:	90 e0       	ldi	r25, 0x00	; 0
    276c:	04 c0       	rjmp	.+8      	; 0x2776 <USART0_SendString+0xe>
		while(!( UCSR0A & (1<<UDRE0)));		// Wait for empty transmit buffer
    276e:	5d 9b       	sbis	0x0b, 5	; 11
    2770:	fe cf       	rjmp	.-4      	; 0x276e <USART0_SendString+0x6>
		UDR0 = str[i];						// Put character into buffer and send
    2772:	2c b9       	out	0x0c, r18	; 12
}

// Max 256 characters
void USART0_SendString(unsigned char *str) {

	for(uint8_t i = 0; str[i] != '\0'; ++i) {
    2774:	9f 5f       	subi	r25, 0xFF	; 255
    2776:	fa 01       	movw	r30, r20
    2778:	e9 0f       	add	r30, r25
    277a:	f1 1d       	adc	r31, r1
    277c:	20 81       	ld	r18, Z
    277e:	21 11       	cpse	r18, r1
    2780:	f6 cf       	rjmp	.-20     	; 0x276e <USART0_SendString+0x6>
		while(!( UCSR0A & (1<<UDRE0)));		// Wait for empty transmit buffer
		UDR0 = str[i];						// Put character into buffer and send
	}
}
    2782:	08 95       	ret

00002784 <USART_ReceiveByte>:

// Wait until a byte has been received and return received data
uint8_t USART_ReceiveByte() {
	while((UCSR0A &(1<<RXC)) == 0);
    2784:	5f 9b       	sbis	0x0b, 7	; 11
    2786:	fe cf       	rjmp	.-4      	; 0x2784 <USART_ReceiveByte>
	return UDR0;
    2788:	8c b1       	in	r24, 0x0c	; 12
    278a:	08 95       	ret

0000278c <makeMessage>:
#include "message.h"
#include "msgHeaders.h"

void makeMessage(Message* message, uint8_t type, uint8_t id, uint8_t* data) {
    278c:	fc 01       	movw	r30, r24
	message->type = type;
    278e:	60 83       	st	Z, r22
	message->id = id;
    2790:	41 83       	std	Z+1, r20	; 0x01
	message->data = data;
    2792:	33 83       	std	Z+3, r19	; 0x03
    2794:	22 83       	std	Z+2, r18	; 0x02
    2796:	08 95       	ret

00002798 <getMessage>:
}

void getMessage(Message* message, uint8_t* buffer) {
    2798:	cf 93       	push	r28
    279a:	df 93       	push	r29
    279c:	ec 01       	movw	r28, r24
    279e:	db 01       	movw	r26, r22
	uint8_t c = 0;
	buffer[c++] = START;
    27a0:	8b e7       	ldi	r24, 0x7B	; 123
    27a2:	8c 93       	st	X, r24
	buffer[c++] = message->type;
    27a4:	88 81       	ld	r24, Y
    27a6:	11 96       	adiw	r26, 0x01	; 1
    27a8:	8c 93       	st	X, r24
    27aa:	11 97       	sbiw	r26, 0x01	; 1
	buffer[c++] = message->id;
    27ac:	89 81       	ldd	r24, Y+1	; 0x01
    27ae:	12 96       	adiw	r26, 0x02	; 2
    27b0:	8c 93       	st	X, r24
    27b2:	12 97       	sbiw	r26, 0x02	; 2
	switch(message->type) {
    27b4:	88 81       	ld	r24, Y
    27b6:	81 34       	cpi	r24, 0x41	; 65
    27b8:	49 f0       	breq	.+18     	; 0x27cc <getMessage+0x34>
    27ba:	13 c0       	rjmp	.+38     	; 0x27e2 <getMessage+0x4a>
		case TEXT:
			for(int i = 0; message->data[i] != 0; ++i) {
				buffer[c++] = message->data[i];
    27bc:	fd 01       	movw	r30, r26
    27be:	e9 0f       	add	r30, r25
    27c0:	f1 1d       	adc	r31, r1
    27c2:	40 83       	st	Z, r20
	buffer[c++] = START;
	buffer[c++] = message->type;
	buffer[c++] = message->id;
	switch(message->type) {
		case TEXT:
			for(int i = 0; message->data[i] != 0; ++i) {
    27c4:	2f 5f       	subi	r18, 0xFF	; 255
    27c6:	3f 4f       	sbci	r19, 0xFF	; 255
				buffer[c++] = message->data[i];
    27c8:	9f 5f       	subi	r25, 0xFF	; 255
    27ca:	03 c0       	rjmp	.+6      	; 0x27d2 <getMessage+0x3a>
void getMessage(Message* message, uint8_t* buffer) {
	uint8_t c = 0;
	buffer[c++] = START;
	buffer[c++] = message->type;
	buffer[c++] = message->id;
	switch(message->type) {
    27cc:	20 e0       	ldi	r18, 0x00	; 0
    27ce:	30 e0       	ldi	r19, 0x00	; 0
    27d0:	93 e0       	ldi	r25, 0x03	; 3
		case TEXT:
			for(int i = 0; message->data[i] != 0; ++i) {
    27d2:	ea 81       	ldd	r30, Y+2	; 0x02
    27d4:	fb 81       	ldd	r31, Y+3	; 0x03
    27d6:	e2 0f       	add	r30, r18
    27d8:	f3 1f       	adc	r31, r19
    27da:	40 81       	ld	r20, Z
    27dc:	41 11       	cpse	r20, r1
    27de:	ee cf       	rjmp	.-36     	; 0x27bc <getMessage+0x24>
    27e0:	07 c0       	rjmp	.+14     	; 0x27f0 <getMessage+0x58>
			}
			break;
		case LIGHT_SENSOR:
		case SOUND_SENSOR:
		default:
			buffer[c++] = *(message->data);
    27e2:	ea 81       	ldd	r30, Y+2	; 0x02
    27e4:	fb 81       	ldd	r31, Y+3	; 0x03
    27e6:	80 81       	ld	r24, Z
    27e8:	13 96       	adiw	r26, 0x03	; 3
    27ea:	8c 93       	st	X, r24
    27ec:	13 97       	sbiw	r26, 0x03	; 3
    27ee:	94 e0       	ldi	r25, 0x04	; 4
			break;
	}
	buffer[c++] = END;
    27f0:	81 e0       	ldi	r24, 0x01	; 1
    27f2:	89 0f       	add	r24, r25
    27f4:	fd 01       	movw	r30, r26
    27f6:	e9 0f       	add	r30, r25
    27f8:	f1 1d       	adc	r31, r1
    27fa:	9d e7       	ldi	r25, 0x7D	; 125
    27fc:	90 83       	st	Z, r25
	buffer[c] = 0;
    27fe:	a8 0f       	add	r26, r24
    2800:	b1 1d       	adc	r27, r1
    2802:	1c 92       	st	X, r1
}
    2804:	df 91       	pop	r29
    2806:	cf 91       	pop	r28
    2808:	08 95       	ret

0000280a <xSerialPortInitMinimal>:
	UCSR0B = ucInByte;										\
}
/*-----------------------------------------------------------*/

xComPortHandle xSerialPortInitMinimal( unsigned long ulWantedBaud, unsigned portBASE_TYPE uxQueueLength )
{
    280a:	cf 92       	push	r12
    280c:	df 92       	push	r13
    280e:	ef 92       	push	r14
    2810:	ff 92       	push	r15
    2812:	cf 93       	push	r28
    2814:	6b 01       	movw	r12, r22
    2816:	7c 01       	movw	r14, r24
    2818:	c4 2f       	mov	r28, r20
unsigned long ulBaudRateCounter;
unsigned char ucByte;

	portENTER_CRITICAL();
    281a:	0f b6       	in	r0, 0x3f	; 63
    281c:	f8 94       	cli
    281e:	0f 92       	push	r0
	{
		/* Create the queues used by the com test task. */
		xRxedChars = xQueueCreate( uxQueueLength, ( unsigned portBASE_TYPE ) sizeof( signed char ) );
    2820:	40 e0       	ldi	r20, 0x00	; 0
    2822:	61 e0       	ldi	r22, 0x01	; 1
    2824:	8c 2f       	mov	r24, r28
    2826:	0e 94 3b 07 	call	0xe76	; 0xe76 <xQueueGenericCreate>
    282a:	90 93 d4 0d 	sts	0x0DD4, r25	; 0x800dd4 <xRxedChars+0x1>
    282e:	80 93 d3 0d 	sts	0x0DD3, r24	; 0x800dd3 <xRxedChars>
		xCharsForTx = xQueueCreate( uxQueueLength, ( unsigned portBASE_TYPE ) sizeof( signed char ) );
    2832:	40 e0       	ldi	r20, 0x00	; 0
    2834:	61 e0       	ldi	r22, 0x01	; 1
    2836:	8c 2f       	mov	r24, r28
    2838:	0e 94 3b 07 	call	0xe76	; 0xe76 <xQueueGenericCreate>
    283c:	90 93 d2 0d 	sts	0x0DD2, r25	; 0x800dd2 <xCharsForTx+0x1>
    2840:	80 93 d1 0d 	sts	0x0DD1, r24	; 0x800dd1 <xCharsForTx>

		/* Calculate the baud rate register value from the equation in the
		data sheet. */
		ulBaudRateCounter = ( configCPU_CLOCK_HZ / ( serBAUD_DIV_CONSTANT * ulWantedBaud ) ) - ( unsigned long ) 1;
    2844:	d7 01       	movw	r26, r14
    2846:	c6 01       	movw	r24, r12
    2848:	88 0f       	add	r24, r24
    284a:	99 1f       	adc	r25, r25
    284c:	aa 1f       	adc	r26, r26
    284e:	bb 1f       	adc	r27, r27
    2850:	88 0f       	add	r24, r24
    2852:	99 1f       	adc	r25, r25
    2854:	aa 1f       	adc	r26, r26
    2856:	bb 1f       	adc	r27, r27
    2858:	9c 01       	movw	r18, r24
    285a:	ad 01       	movw	r20, r26
    285c:	22 0f       	add	r18, r18
    285e:	33 1f       	adc	r19, r19
    2860:	44 1f       	adc	r20, r20
    2862:	55 1f       	adc	r21, r21
    2864:	22 0f       	add	r18, r18
    2866:	33 1f       	adc	r19, r19
    2868:	44 1f       	adc	r20, r20
    286a:	55 1f       	adc	r21, r21
    286c:	60 e0       	ldi	r22, 0x00	; 0
    286e:	70 ec       	ldi	r23, 0xC0	; 192
    2870:	88 ea       	ldi	r24, 0xA8	; 168
    2872:	90 e0       	ldi	r25, 0x00	; 0
    2874:	0e 94 06 15 	call	0x2a0c	; 0x2a0c <__udivmodsi4>
    2878:	da 01       	movw	r26, r20
    287a:	c9 01       	movw	r24, r18
    287c:	01 97       	sbiw	r24, 0x01	; 1
    287e:	a1 09       	sbc	r26, r1
    2880:	b1 09       	sbc	r27, r1

		/* Set the baud rate. */	
		ucByte = ( unsigned char ) ( ulBaudRateCounter & ( unsigned long ) 0xff );	
		UBRR0L = ucByte;
    2882:	89 b9       	out	0x09, r24	; 9

		ulBaudRateCounter >>= ( unsigned long ) 8;
    2884:	89 2f       	mov	r24, r25
    2886:	9a 2f       	mov	r25, r26
    2888:	ab 2f       	mov	r26, r27
    288a:	bb 27       	eor	r27, r27
		ucByte = ( unsigned char ) ( ulBaudRateCounter & ( unsigned long ) 0xff );	
		UBRR0H = ucByte;
    288c:	80 93 90 00 	sts	0x0090, r24	; 0x800090 <__TEXT_REGION_LENGTH__+0x7e0090>

		/* Enable the Rx interrupt.  The Tx interrupt will get enabled
		later. Also enable the Rx and Tx. */
		UCSR0B = ( serRX_INT_ENABLE | serRX_ENABLE | serTX_ENABLE );
    2890:	88 e9       	ldi	r24, 0x98	; 152
    2892:	8a b9       	out	0x0a, r24	; 10

		/* Set the data bits to 8. */
		UCSR0C = ( serUCSRC_SELECT | serEIGHT_DATA_BITS );
    2894:	86 e8       	ldi	r24, 0x86	; 134
    2896:	80 93 95 00 	sts	0x0095, r24	; 0x800095 <__TEXT_REGION_LENGTH__+0x7e0095>
	}
	portEXIT_CRITICAL();
    289a:	0f 90       	pop	r0
    289c:	0f be       	out	0x3f, r0	; 63
	
	/* Unlike other ports, this serial code does not allow for more than one
	com port.  We therefore don't return a pointer to a port structure and can
	instead just return NULL. */
	return NULL;
}
    289e:	80 e0       	ldi	r24, 0x00	; 0
    28a0:	90 e0       	ldi	r25, 0x00	; 0
    28a2:	cf 91       	pop	r28
    28a4:	ff 90       	pop	r15
    28a6:	ef 90       	pop	r14
    28a8:	df 90       	pop	r13
    28aa:	cf 90       	pop	r12
    28ac:	08 95       	ret

000028ae <xSerialGetChar>:
	/* Only one port is supported. */
	( void ) pxPort;

	/* Get the next character from the buffer.  Return false if no characters
	are available, or arrive before xBlockTime expires. */
	if( xQueueReceive( xRxedChars, pcRxedChar, xBlockTime ) )
    28ae:	20 e0       	ldi	r18, 0x00	; 0
    28b0:	80 91 d3 0d 	lds	r24, 0x0DD3	; 0x800dd3 <xRxedChars>
    28b4:	90 91 d4 0d 	lds	r25, 0x0DD4	; 0x800dd4 <xRxedChars+0x1>
    28b8:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <xQueueGenericReceive>
    28bc:	81 11       	cpse	r24, r1
	{
		return pdTRUE;
    28be:	81 e0       	ldi	r24, 0x01	; 1
	}
	else
	{
		return pdFALSE;
	}
}
    28c0:	08 95       	ret

000028c2 <xSerialPutChar>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xSerialPutChar( xComPortHandle pxPort, signed char cOutChar, TickType_t xBlockTime )
{
    28c2:	cf 93       	push	r28
    28c4:	df 93       	push	r29
    28c6:	1f 92       	push	r1
    28c8:	cd b7       	in	r28, 0x3d	; 61
    28ca:	de b7       	in	r29, 0x3e	; 62
    28cc:	69 83       	std	Y+1, r22	; 0x01
	/* Only one port is supported. */
	( void ) pxPort;

	/* Return false if after the block time there is no room on the Tx queue. */
	if( xQueueSend( xCharsForTx, &cOutChar, xBlockTime ) != pdPASS )
    28ce:	20 e0       	ldi	r18, 0x00	; 0
    28d0:	be 01       	movw	r22, r28
    28d2:	6f 5f       	subi	r22, 0xFF	; 255
    28d4:	7f 4f       	sbci	r23, 0xFF	; 255
    28d6:	80 91 d1 0d 	lds	r24, 0x0DD1	; 0x800dd1 <xCharsForTx>
    28da:	90 91 d2 0d 	lds	r25, 0x0DD2	; 0x800dd2 <xCharsForTx+0x1>
    28de:	0e 94 65 07 	call	0xeca	; 0xeca <xQueueGenericSend>
    28e2:	81 30       	cpi	r24, 0x01	; 1
    28e4:	21 f4       	brne	.+8      	; 0x28ee <xSerialPutChar+0x2c>
	{
		return pdFAIL;
	}

	vInterruptOn();
    28e6:	9a b1       	in	r25, 0x0a	; 10
    28e8:	90 62       	ori	r25, 0x20	; 32
    28ea:	9a b9       	out	0x0a, r25	; 10

	return pdPASS;
    28ec:	01 c0       	rjmp	.+2      	; 0x28f0 <xSerialPutChar+0x2e>
	( void ) pxPort;

	/* Return false if after the block time there is no room on the Tx queue. */
	if( xQueueSend( xCharsForTx, &cOutChar, xBlockTime ) != pdPASS )
	{
		return pdFAIL;
    28ee:	80 e0       	ldi	r24, 0x00	; 0
	}

	vInterruptOn();

	return pdPASS;
}
    28f0:	0f 90       	pop	r0
    28f2:	df 91       	pop	r29
    28f4:	cf 91       	pop	r28
    28f6:	08 95       	ret

000028f8 <vSerialClose>:
	( void ) xPort;

	/* Turn off the interrupts.  We may also want to delete the queues and/or
	re-install the original ISR. */

	portENTER_CRITICAL();
    28f8:	0f b6       	in	r0, 0x3f	; 63
    28fa:	f8 94       	cli
    28fc:	0f 92       	push	r0
	{
		vInterruptOff();
    28fe:	8a b1       	in	r24, 0x0a	; 10
    2900:	8f 7d       	andi	r24, 0xDF	; 223
    2902:	8a b9       	out	0x0a, r24	; 10
		ucByte = UCSR0B;
    2904:	8a b1       	in	r24, 0x0a	; 10
		ucByte &= ~serRX_INT_ENABLE;
    2906:	8f 77       	andi	r24, 0x7F	; 127
		UCSR0B = ucByte;
    2908:	8a b9       	out	0x0a, r24	; 10
	}
	portEXIT_CRITICAL();
    290a:	0f 90       	pop	r0
    290c:	0f be       	out	0x3f, r0	; 63
    290e:	08 95       	ret

00002910 <SIG_UART_RECV>:
}
/*-----------------------------------------------------------*/

SIGNAL( SIG_UART_RECV )
{
    2910:	1f 92       	push	r1
    2912:	0f 92       	push	r0
    2914:	0f b6       	in	r0, 0x3f	; 63
    2916:	0f 92       	push	r0
    2918:	11 24       	eor	r1, r1
    291a:	2f 93       	push	r18
    291c:	3f 93       	push	r19
    291e:	4f 93       	push	r20
    2920:	5f 93       	push	r21
    2922:	6f 93       	push	r22
    2924:	7f 93       	push	r23
    2926:	8f 93       	push	r24
    2928:	9f 93       	push	r25
    292a:	af 93       	push	r26
    292c:	bf 93       	push	r27
    292e:	ef 93       	push	r30
    2930:	ff 93       	push	r31
    2932:	cf 93       	push	r28
    2934:	df 93       	push	r29
    2936:	00 d0       	rcall	.+0      	; 0x2938 <SIG_UART_RECV+0x28>
    2938:	cd b7       	in	r28, 0x3d	; 61
    293a:	de b7       	in	r29, 0x3e	; 62
signed char cChar;
signed portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
    293c:	1a 82       	std	Y+2, r1	; 0x02

	/* Get the character and post it on the queue of Rxed characters.
	If the post causes a task to wake force a context switch as the woken task
	may have a higher priority than the task we have interrupted. */
	cChar = UDR0;
    293e:	8c b1       	in	r24, 0x0c	; 12
    2940:	89 83       	std	Y+1, r24	; 0x01

	xQueueSendFromISR( xRxedChars, &cChar, &xHigherPriorityTaskWoken );
    2942:	20 e0       	ldi	r18, 0x00	; 0
    2944:	ae 01       	movw	r20, r28
    2946:	4e 5f       	subi	r20, 0xFE	; 254
    2948:	5f 4f       	sbci	r21, 0xFF	; 255
    294a:	be 01       	movw	r22, r28
    294c:	6f 5f       	subi	r22, 0xFF	; 255
    294e:	7f 4f       	sbci	r23, 0xFF	; 255
    2950:	80 91 d3 0d 	lds	r24, 0x0DD3	; 0x800dd3 <xRxedChars>
    2954:	90 91 d4 0d 	lds	r25, 0x0DD4	; 0x800dd4 <xRxedChars+0x1>
    2958:	0e 94 f7 07 	call	0xfee	; 0xfee <xQueueGenericSendFromISR>

	if( xHigherPriorityTaskWoken != pdFALSE )
    295c:	8a 81       	ldd	r24, Y+2	; 0x02
    295e:	81 11       	cpse	r24, r1
	{
		taskYIELD();
    2960:	0e 94 34 05 	call	0xa68	; 0xa68 <vPortYield>
	}
}
    2964:	0f 90       	pop	r0
    2966:	0f 90       	pop	r0
    2968:	df 91       	pop	r29
    296a:	cf 91       	pop	r28
    296c:	ff 91       	pop	r31
    296e:	ef 91       	pop	r30
    2970:	bf 91       	pop	r27
    2972:	af 91       	pop	r26
    2974:	9f 91       	pop	r25
    2976:	8f 91       	pop	r24
    2978:	7f 91       	pop	r23
    297a:	6f 91       	pop	r22
    297c:	5f 91       	pop	r21
    297e:	4f 91       	pop	r20
    2980:	3f 91       	pop	r19
    2982:	2f 91       	pop	r18
    2984:	0f 90       	pop	r0
    2986:	0f be       	out	0x3f, r0	; 63
    2988:	0f 90       	pop	r0
    298a:	1f 90       	pop	r1
    298c:	18 95       	reti

0000298e <SIG_UART_DATA>:
/*-----------------------------------------------------------*/

SIGNAL( SIG_UART_DATA )
{
    298e:	1f 92       	push	r1
    2990:	0f 92       	push	r0
    2992:	0f b6       	in	r0, 0x3f	; 63
    2994:	0f 92       	push	r0
    2996:	11 24       	eor	r1, r1
    2998:	2f 93       	push	r18
    299a:	3f 93       	push	r19
    299c:	4f 93       	push	r20
    299e:	5f 93       	push	r21
    29a0:	6f 93       	push	r22
    29a2:	7f 93       	push	r23
    29a4:	8f 93       	push	r24
    29a6:	9f 93       	push	r25
    29a8:	af 93       	push	r26
    29aa:	bf 93       	push	r27
    29ac:	ef 93       	push	r30
    29ae:	ff 93       	push	r31
    29b0:	cf 93       	push	r28
    29b2:	df 93       	push	r29
    29b4:	00 d0       	rcall	.+0      	; 0x29b6 <SIG_UART_DATA+0x28>
    29b6:	cd b7       	in	r28, 0x3d	; 61
    29b8:	de b7       	in	r29, 0x3e	; 62
signed char cChar, cTaskWoken;

	if( xQueueReceiveFromISR( xCharsForTx, &cChar, &cTaskWoken ) == pdTRUE )
    29ba:	ae 01       	movw	r20, r28
    29bc:	4e 5f       	subi	r20, 0xFE	; 254
    29be:	5f 4f       	sbci	r21, 0xFF	; 255
    29c0:	be 01       	movw	r22, r28
    29c2:	6f 5f       	subi	r22, 0xFF	; 255
    29c4:	7f 4f       	sbci	r23, 0xFF	; 255
    29c6:	80 91 d1 0d 	lds	r24, 0x0DD1	; 0x800dd1 <xCharsForTx>
    29ca:	90 91 d2 0d 	lds	r25, 0x0DD2	; 0x800dd2 <xCharsForTx+0x1>
    29ce:	0e 94 03 09 	call	0x1206	; 0x1206 <xQueueReceiveFromISR>
    29d2:	81 30       	cpi	r24, 0x01	; 1
    29d4:	19 f4       	brne	.+6      	; 0x29dc <SIG_UART_DATA+0x4e>
	{
		/* Send the next character queued for Tx. */
		UDR0 = cChar;
    29d6:	89 81       	ldd	r24, Y+1	; 0x01
    29d8:	8c b9       	out	0x0c, r24	; 12
    29da:	03 c0       	rjmp	.+6      	; 0x29e2 <SIG_UART_DATA+0x54>
	}
	else
	{
		/* Queue empty, nothing to send. */
		vInterruptOff();
    29dc:	8a b1       	in	r24, 0x0a	; 10
    29de:	8f 7d       	andi	r24, 0xDF	; 223
    29e0:	8a b9       	out	0x0a, r24	; 10
	}
}
    29e2:	0f 90       	pop	r0
    29e4:	0f 90       	pop	r0
    29e6:	df 91       	pop	r29
    29e8:	cf 91       	pop	r28
    29ea:	ff 91       	pop	r31
    29ec:	ef 91       	pop	r30
    29ee:	bf 91       	pop	r27
    29f0:	af 91       	pop	r26
    29f2:	9f 91       	pop	r25
    29f4:	8f 91       	pop	r24
    29f6:	7f 91       	pop	r23
    29f8:	6f 91       	pop	r22
    29fa:	5f 91       	pop	r21
    29fc:	4f 91       	pop	r20
    29fe:	3f 91       	pop	r19
    2a00:	2f 91       	pop	r18
    2a02:	0f 90       	pop	r0
    2a04:	0f be       	out	0x3f, r0	; 63
    2a06:	0f 90       	pop	r0
    2a08:	1f 90       	pop	r1
    2a0a:	18 95       	reti

00002a0c <__udivmodsi4>:
    2a0c:	a1 e2       	ldi	r26, 0x21	; 33
    2a0e:	1a 2e       	mov	r1, r26
    2a10:	aa 1b       	sub	r26, r26
    2a12:	bb 1b       	sub	r27, r27
    2a14:	fd 01       	movw	r30, r26
    2a16:	0d c0       	rjmp	.+26     	; 0x2a32 <__udivmodsi4_ep>

00002a18 <__udivmodsi4_loop>:
    2a18:	aa 1f       	adc	r26, r26
    2a1a:	bb 1f       	adc	r27, r27
    2a1c:	ee 1f       	adc	r30, r30
    2a1e:	ff 1f       	adc	r31, r31
    2a20:	a2 17       	cp	r26, r18
    2a22:	b3 07       	cpc	r27, r19
    2a24:	e4 07       	cpc	r30, r20
    2a26:	f5 07       	cpc	r31, r21
    2a28:	20 f0       	brcs	.+8      	; 0x2a32 <__udivmodsi4_ep>
    2a2a:	a2 1b       	sub	r26, r18
    2a2c:	b3 0b       	sbc	r27, r19
    2a2e:	e4 0b       	sbc	r30, r20
    2a30:	f5 0b       	sbc	r31, r21

00002a32 <__udivmodsi4_ep>:
    2a32:	66 1f       	adc	r22, r22
    2a34:	77 1f       	adc	r23, r23
    2a36:	88 1f       	adc	r24, r24
    2a38:	99 1f       	adc	r25, r25
    2a3a:	1a 94       	dec	r1
    2a3c:	69 f7       	brne	.-38     	; 0x2a18 <__udivmodsi4_loop>
    2a3e:	60 95       	com	r22
    2a40:	70 95       	com	r23
    2a42:	80 95       	com	r24
    2a44:	90 95       	com	r25
    2a46:	9b 01       	movw	r18, r22
    2a48:	ac 01       	movw	r20, r24
    2a4a:	bd 01       	movw	r22, r26
    2a4c:	cf 01       	movw	r24, r30
    2a4e:	08 95       	ret

00002a50 <memcpy>:
    2a50:	fb 01       	movw	r30, r22
    2a52:	dc 01       	movw	r26, r24
    2a54:	02 c0       	rjmp	.+4      	; 0x2a5a <memcpy+0xa>
    2a56:	01 90       	ld	r0, Z+
    2a58:	0d 92       	st	X+, r0
    2a5a:	41 50       	subi	r20, 0x01	; 1
    2a5c:	50 40       	sbci	r21, 0x00	; 0
    2a5e:	d8 f7       	brcc	.-10     	; 0x2a56 <memcpy+0x6>
    2a60:	08 95       	ret

00002a62 <_exit>:
    2a62:	f8 94       	cli

00002a64 <__stop_program>:
    2a64:	ff cf       	rjmp	.-2      	; 0x2a64 <__stop_program>
