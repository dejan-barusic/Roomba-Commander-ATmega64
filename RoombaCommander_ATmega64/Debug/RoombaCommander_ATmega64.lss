
RoombaCommander_ATmega64.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000002a  00800100  00002b04  00002b98  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002b04  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000cbd  0080012a  0080012a  00002bc2  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002bc2  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00002bf4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000468  00000000  00000000  00002c30  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000550c  00000000  00000000  00003098  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001546  00000000  00000000  000085a4  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002eab  00000000  00000000  00009aea  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000e2c  00000000  00000000  0000c998  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001a13  00000000  00000000  0000d7c4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000509a  00000000  00000000  0000f1d7  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000470  00000000  00000000  00014271  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 b7 00 	jmp	0x16e	; 0x16e <__ctors_end>
       4:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
       8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
       c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      10:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      14:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      18:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      1c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      20:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      24:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      28:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      2c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      30:	0c 94 5a 06 	jmp	0xcb4	; 0xcb4 <__vector_12>
      34:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      38:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      3c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      40:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      44:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      48:	0c 94 17 15 	jmp	0x2a2e	; 0x2a2e <__vector_18>
      4c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      50:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      54:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      58:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      5c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      60:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      64:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      68:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      6c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      70:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      74:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      78:	0c 94 44 15 	jmp	0x2a88	; 0x2a88 <__vector_30>
      7c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      80:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      84:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      88:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      8c:	56 14       	cp	r5, r6
      8e:	5a 14       	cp	r5, r10
      90:	56 14       	cp	r5, r6
      92:	56 14       	cp	r5, r6
      94:	56 14       	cp	r5, r6
      96:	56 14       	cp	r5, r6
      98:	56 14       	cp	r5, r6
      9a:	56 14       	cp	r5, r6
      9c:	56 14       	cp	r5, r6
      9e:	62 14       	cp	r6, r2
      a0:	5a 14       	cp	r5, r10
      a2:	5e 14       	cp	r5, r14
      a4:	69 14       	cp	r6, r9
      a6:	5a 14       	cp	r5, r10
      a8:	66 14       	cp	r6, r6
      aa:	56 14       	cp	r5, r6
      ac:	3d 14       	cp	r3, r13
      ae:	3d 14       	cp	r3, r13
      b0:	3d 14       	cp	r3, r13
      b2:	3d 14       	cp	r3, r13
      b4:	3d 14       	cp	r3, r13
      b6:	3d 14       	cp	r3, r13
      b8:	3d 14       	cp	r3, r13
      ba:	3d 14       	cp	r3, r13
      bc:	3d 14       	cp	r3, r13
      be:	3d 14       	cp	r3, r13
      c0:	3d 14       	cp	r3, r13
      c2:	3d 14       	cp	r3, r13
      c4:	3d 14       	cp	r3, r13
      c6:	3d 14       	cp	r3, r13
      c8:	3d 14       	cp	r3, r13
      ca:	3d 14       	cp	r3, r13
      cc:	3d 14       	cp	r3, r13
      ce:	3d 14       	cp	r3, r13
      d0:	3d 14       	cp	r3, r13
      d2:	3d 14       	cp	r3, r13
      d4:	3d 14       	cp	r3, r13
      d6:	3d 14       	cp	r3, r13
      d8:	3d 14       	cp	r3, r13
      da:	3d 14       	cp	r3, r13
      dc:	3d 14       	cp	r3, r13
      de:	3d 14       	cp	r3, r13
      e0:	3d 14       	cp	r3, r13
      e2:	3d 14       	cp	r3, r13
      e4:	3d 14       	cp	r3, r13
      e6:	3d 14       	cp	r3, r13
      e8:	3d 14       	cp	r3, r13
      ea:	3d 14       	cp	r3, r13
      ec:	3d 14       	cp	r3, r13
      ee:	3d 14       	cp	r3, r13
      f0:	3d 14       	cp	r3, r13
      f2:	3d 14       	cp	r3, r13
      f4:	3d 14       	cp	r3, r13
      f6:	3d 14       	cp	r3, r13
      f8:	3d 14       	cp	r3, r13
      fa:	3d 14       	cp	r3, r13
      fc:	3d 14       	cp	r3, r13
      fe:	3d 14       	cp	r3, r13
     100:	3d 14       	cp	r3, r13
     102:	3d 14       	cp	r3, r13
     104:	3d 14       	cp	r3, r13
     106:	3d 14       	cp	r3, r13
     108:	3d 14       	cp	r3, r13
     10a:	3d 14       	cp	r3, r13
     10c:	3d 14       	cp	r3, r13
     10e:	3d 14       	cp	r3, r13
     110:	3d 14       	cp	r3, r13
     112:	3d 14       	cp	r3, r13
     114:	3d 14       	cp	r3, r13
     116:	3d 14       	cp	r3, r13
     118:	3d 14       	cp	r3, r13
     11a:	3d 14       	cp	r3, r13
     11c:	3d 14       	cp	r3, r13
     11e:	3d 14       	cp	r3, r13
     120:	3d 14       	cp	r3, r13
     122:	3d 14       	cp	r3, r13
     124:	3d 14       	cp	r3, r13
     126:	3d 14       	cp	r3, r13
     128:	3d 14       	cp	r3, r13
     12a:	3d 14       	cp	r3, r13
     12c:	3d 14       	cp	r3, r13
     12e:	3d 14       	cp	r3, r13
     130:	3d 14       	cp	r3, r13
     132:	3d 14       	cp	r3, r13
     134:	3d 14       	cp	r3, r13
     136:	3d 14       	cp	r3, r13
     138:	3d 14       	cp	r3, r13
     13a:	3d 14       	cp	r3, r13
     13c:	3d 14       	cp	r3, r13
     13e:	3d 14       	cp	r3, r13
     140:	3d 14       	cp	r3, r13
     142:	3d 14       	cp	r3, r13
     144:	3d 14       	cp	r3, r13
     146:	3d 14       	cp	r3, r13
     148:	3d 14       	cp	r3, r13
     14a:	3d 14       	cp	r3, r13
     14c:	3d 14       	cp	r3, r13
     14e:	3d 14       	cp	r3, r13
     150:	3d 14       	cp	r3, r13
     152:	3d 14       	cp	r3, r13
     154:	3d 14       	cp	r3, r13
     156:	3d 14       	cp	r3, r13
     158:	3d 14       	cp	r3, r13
     15a:	3d 14       	cp	r3, r13
     15c:	3d 14       	cp	r3, r13
     15e:	3d 14       	cp	r3, r13
     160:	3d 14       	cp	r3, r13
     162:	3d 14       	cp	r3, r13
     164:	3d 14       	cp	r3, r13
     166:	3d 14       	cp	r3, r13
     168:	3d 14       	cp	r3, r13
     16a:	3d 14       	cp	r3, r13
     16c:	6c 14       	cp	r6, r12

0000016e <__ctors_end>:
     16e:	11 24       	eor	r1, r1
     170:	1f be       	out	0x3f, r1	; 63
     172:	cf ef       	ldi	r28, 0xFF	; 255
     174:	d0 e1       	ldi	r29, 0x10	; 16
     176:	de bf       	out	0x3e, r29	; 62
     178:	cd bf       	out	0x3d, r28	; 61

0000017a <__do_copy_data>:
     17a:	11 e0       	ldi	r17, 0x01	; 1
     17c:	a0 e0       	ldi	r26, 0x00	; 0
     17e:	b1 e0       	ldi	r27, 0x01	; 1
     180:	e4 e0       	ldi	r30, 0x04	; 4
     182:	fb e2       	ldi	r31, 0x2B	; 43
     184:	02 c0       	rjmp	.+4      	; 0x18a <__do_copy_data+0x10>
     186:	05 90       	lpm	r0, Z+
     188:	0d 92       	st	X+, r0
     18a:	aa 32       	cpi	r26, 0x2A	; 42
     18c:	b1 07       	cpc	r27, r17
     18e:	d9 f7       	brne	.-10     	; 0x186 <__do_copy_data+0xc>

00000190 <__do_clear_bss>:
     190:	2d e0       	ldi	r18, 0x0D	; 13
     192:	aa e2       	ldi	r26, 0x2A	; 42
     194:	b1 e0       	ldi	r27, 0x01	; 1
     196:	01 c0       	rjmp	.+2      	; 0x19a <.do_clear_bss_start>

00000198 <.do_clear_bss_loop>:
     198:	1d 92       	st	X+, r1

0000019a <.do_clear_bss_start>:
     19a:	a7 3e       	cpi	r26, 0xE7	; 231
     19c:	b2 07       	cpc	r27, r18
     19e:	e1 f7       	brne	.-8      	; 0x198 <.do_clear_bss_loop>
     1a0:	0e 94 8e 14 	call	0x291c	; 0x291c <main>
     1a4:	0c 94 80 15 	jmp	0x2b00	; 0x2b00 <_exit>

000001a8 <__bad_interrupt>:
     1a8:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000001ac <prvInitialiseCoRoutineLists>:
	return;
}
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
     1ac:	cf 93       	push	r28
UBaseType_t uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
     1ae:	c0 e0       	ldi	r28, 0x00	; 0
     1b0:	10 c0       	rjmp	.+32     	; 0x1d2 <prvInitialiseCoRoutineLists+0x26>
	{
		vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
     1b2:	8c 2f       	mov	r24, r28
     1b4:	90 e0       	ldi	r25, 0x00	; 0
     1b6:	9c 01       	movw	r18, r24
     1b8:	22 0f       	add	r18, r18
     1ba:	33 1f       	adc	r19, r19
     1bc:	22 0f       	add	r18, r18
     1be:	33 1f       	adc	r19, r19
     1c0:	22 0f       	add	r18, r18
     1c2:	33 1f       	adc	r19, r19
     1c4:	82 0f       	add	r24, r18
     1c6:	93 1f       	adc	r25, r19
     1c8:	8e 5a       	subi	r24, 0xAE	; 174
     1ca:	9e 4f       	sbci	r25, 0xFE	; 254
     1cc:	0e 94 75 04 	call	0x8ea	; 0x8ea <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
     1d0:	cf 5f       	subi	r28, 0xFF	; 255
     1d2:	c2 30       	cpi	r28, 0x02	; 2
     1d4:	70 f3       	brcs	.-36     	; 0x1b2 <prvInitialiseCoRoutineLists+0x6>
	{
		vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
     1d6:	89 e4       	ldi	r24, 0x49	; 73
     1d8:	91 e0       	ldi	r25, 0x01	; 1
     1da:	0e 94 75 04 	call	0x8ea	; 0x8ea <vListInitialise>
	vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
     1de:	80 e4       	ldi	r24, 0x40	; 64
     1e0:	91 e0       	ldi	r25, 0x01	; 1
     1e2:	0e 94 75 04 	call	0x8ea	; 0x8ea <vListInitialise>
	vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
     1e6:	83 e3       	ldi	r24, 0x33	; 51
     1e8:	91 e0       	ldi	r25, 0x01	; 1
     1ea:	0e 94 75 04 	call	0x8ea	; 0x8ea <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
     1ee:	89 e4       	ldi	r24, 0x49	; 73
     1f0:	91 e0       	ldi	r25, 0x01	; 1
     1f2:	90 93 3f 01 	sts	0x013F, r25	; 0x80013f <pxDelayedCoRoutineList+0x1>
     1f6:	80 93 3e 01 	sts	0x013E, r24	; 0x80013e <pxDelayedCoRoutineList>
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
     1fa:	80 e4       	ldi	r24, 0x40	; 64
     1fc:	91 e0       	ldi	r25, 0x01	; 1
     1fe:	90 93 3d 01 	sts	0x013D, r25	; 0x80013d <pxOverflowDelayedCoRoutineList+0x1>
     202:	80 93 3c 01 	sts	0x013C, r24	; 0x80013c <pxOverflowDelayedCoRoutineList>
}
     206:	cf 91       	pop	r28
     208:	08 95       	ret

0000020a <prvCheckPendingReadyList>:
	}
}
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
     20a:	0f 93       	push	r16
     20c:	1f 93       	push	r17
     20e:	cf 93       	push	r28
     210:	df 93       	push	r29
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     212:	28 c0       	rjmp	.+80     	; 0x264 <prvCheckPendingReadyList+0x5a>
	{
		CRCB_t *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
     214:	f8 94       	cli
		{
			pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
     216:	e0 91 38 01 	lds	r30, 0x0138	; 0x800138 <xPendingReadyCoRoutineList+0x5>
     21a:	f0 91 39 01 	lds	r31, 0x0139	; 0x800139 <xPendingReadyCoRoutineList+0x6>
     21e:	c6 81       	ldd	r28, Z+6	; 0x06
     220:	d7 81       	ldd	r29, Z+7	; 0x07
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     222:	ce 01       	movw	r24, r28
     224:	0c 96       	adiw	r24, 0x0c	; 12
     226:	0e 94 d9 04 	call	0x9b2	; 0x9b2 <uxListRemove>
		}
		portENABLE_INTERRUPTS();
     22a:	78 94       	sei

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
     22c:	8e 01       	movw	r16, r28
     22e:	0e 5f       	subi	r16, 0xFE	; 254
     230:	1f 4f       	sbci	r17, 0xFF	; 255
     232:	c8 01       	movw	r24, r16
     234:	0e 94 d9 04 	call	0x9b2	; 0x9b2 <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
     238:	8e 89       	ldd	r24, Y+22	; 0x16
     23a:	90 91 30 01 	lds	r25, 0x0130	; 0x800130 <uxTopCoRoutineReadyPriority>
     23e:	98 17       	cp	r25, r24
     240:	10 f4       	brcc	.+4      	; 0x246 <prvCheckPendingReadyList+0x3c>
     242:	80 93 30 01 	sts	0x0130, r24	; 0x800130 <uxTopCoRoutineReadyPriority>
     246:	90 e0       	ldi	r25, 0x00	; 0
     248:	9c 01       	movw	r18, r24
     24a:	22 0f       	add	r18, r18
     24c:	33 1f       	adc	r19, r19
     24e:	22 0f       	add	r18, r18
     250:	33 1f       	adc	r19, r19
     252:	22 0f       	add	r18, r18
     254:	33 1f       	adc	r19, r19
     256:	82 0f       	add	r24, r18
     258:	93 1f       	adc	r25, r19
     25a:	b8 01       	movw	r22, r16
     25c:	8e 5a       	subi	r24, 0xAE	; 174
     25e:	9e 4f       	sbci	r25, 0xFE	; 254
     260:	0e 94 87 04 	call	0x90e	; 0x90e <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     264:	80 91 33 01 	lds	r24, 0x0133	; 0x800133 <xPendingReadyCoRoutineList>
     268:	81 11       	cpse	r24, r1
     26a:	d4 cf       	rjmp	.-88     	; 0x214 <prvCheckPendingReadyList+0xa>
		portENABLE_INTERRUPTS();

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
	}
}
     26c:	df 91       	pop	r29
     26e:	cf 91       	pop	r28
     270:	1f 91       	pop	r17
     272:	0f 91       	pop	r16
     274:	08 95       	ret

00000276 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
     276:	0f 93       	push	r16
     278:	1f 93       	push	r17
     27a:	cf 93       	push	r28
     27c:	df 93       	push	r29
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
     27e:	0e 94 15 0d 	call	0x1a2a	; 0x1a2a <xTaskGetTickCount>
     282:	20 91 2c 01 	lds	r18, 0x012C	; 0x80012c <xLastTickCount>
     286:	30 91 2d 01 	lds	r19, 0x012D	; 0x80012d <xLastTickCount+0x1>
     28a:	82 1b       	sub	r24, r18
     28c:	93 0b       	sbc	r25, r19
     28e:	90 93 2b 01 	sts	0x012B, r25	; 0x80012b <__data_end+0x1>
     292:	80 93 2a 01 	sts	0x012A, r24	; 0x80012a <__data_end>
	while( xPassedTicks )
     296:	5e c0       	rjmp	.+188    	; 0x354 <prvCheckDelayedList+0xde>
	{
		xCoRoutineTickCount++;
     298:	20 91 2e 01 	lds	r18, 0x012E	; 0x80012e <xCoRoutineTickCount>
     29c:	30 91 2f 01 	lds	r19, 0x012F	; 0x80012f <xCoRoutineTickCount+0x1>
     2a0:	2f 5f       	subi	r18, 0xFF	; 255
     2a2:	3f 4f       	sbci	r19, 0xFF	; 255
     2a4:	30 93 2f 01 	sts	0x012F, r19	; 0x80012f <xCoRoutineTickCount+0x1>
     2a8:	20 93 2e 01 	sts	0x012E, r18	; 0x80012e <xCoRoutineTickCount>
		xPassedTicks--;
     2ac:	01 97       	sbiw	r24, 0x01	; 1
     2ae:	90 93 2b 01 	sts	0x012B, r25	; 0x80012b <__data_end+0x1>
     2b2:	80 93 2a 01 	sts	0x012A, r24	; 0x80012a <__data_end>

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
     2b6:	23 2b       	or	r18, r19
     2b8:	09 f0       	breq	.+2      	; 0x2bc <prvCheckDelayedList+0x46>
     2ba:	45 c0       	rjmp	.+138    	; 0x346 <prvCheckDelayedList+0xd0>
		{
			List_t * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
     2bc:	80 91 3e 01 	lds	r24, 0x013E	; 0x80013e <pxDelayedCoRoutineList>
     2c0:	90 91 3f 01 	lds	r25, 0x013F	; 0x80013f <pxDelayedCoRoutineList+0x1>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
     2c4:	20 91 3c 01 	lds	r18, 0x013C	; 0x80013c <pxOverflowDelayedCoRoutineList>
     2c8:	30 91 3d 01 	lds	r19, 0x013D	; 0x80013d <pxOverflowDelayedCoRoutineList+0x1>
     2cc:	30 93 3f 01 	sts	0x013F, r19	; 0x80013f <pxDelayedCoRoutineList+0x1>
     2d0:	20 93 3e 01 	sts	0x013E, r18	; 0x80013e <pxDelayedCoRoutineList>
			pxOverflowDelayedCoRoutineList = pxTemp;
     2d4:	90 93 3d 01 	sts	0x013D, r25	; 0x80013d <pxOverflowDelayedCoRoutineList+0x1>
     2d8:	80 93 3c 01 	sts	0x013C, r24	; 0x80013c <pxOverflowDelayedCoRoutineList>
     2dc:	34 c0       	rjmp	.+104    	; 0x346 <prvCheckDelayedList+0xd0>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     2de:	05 80       	ldd	r0, Z+5	; 0x05
     2e0:	f6 81       	ldd	r31, Z+6	; 0x06
     2e2:	e0 2d       	mov	r30, r0
     2e4:	c6 81       	ldd	r28, Z+6	; 0x06
     2e6:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
     2e8:	2a 81       	ldd	r18, Y+2	; 0x02
     2ea:	3b 81       	ldd	r19, Y+3	; 0x03
     2ec:	80 91 2e 01 	lds	r24, 0x012E	; 0x80012e <xCoRoutineTickCount>
     2f0:	90 91 2f 01 	lds	r25, 0x012F	; 0x80012f <xCoRoutineTickCount+0x1>
     2f4:	82 17       	cp	r24, r18
     2f6:	93 07       	cpc	r25, r19
     2f8:	68 f1       	brcs	.+90     	; 0x354 <prvCheckDelayedList+0xde>
			{
				/* Timeout not yet expired. */
				break;
			}

			portDISABLE_INTERRUPTS();
     2fa:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
     2fc:	8e 01       	movw	r16, r28
     2fe:	0e 5f       	subi	r16, 0xFE	; 254
     300:	1f 4f       	sbci	r17, 0xFF	; 255
     302:	c8 01       	movw	r24, r16
     304:	0e 94 d9 04 	call	0x9b2	; 0x9b2 <uxListRemove>

				/* Is the co-routine waiting on an event also? */
				if( pxCRCB->xEventListItem.pvContainer )
     308:	8c 89       	ldd	r24, Y+20	; 0x14
     30a:	9d 89       	ldd	r25, Y+21	; 0x15
     30c:	89 2b       	or	r24, r25
     30e:	21 f0       	breq	.+8      	; 0x318 <prvCheckDelayedList+0xa2>
				{
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
     310:	ce 01       	movw	r24, r28
     312:	0c 96       	adiw	r24, 0x0c	; 12
     314:	0e 94 d9 04 	call	0x9b2	; 0x9b2 <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
     318:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );
     31a:	8e 89       	ldd	r24, Y+22	; 0x16
     31c:	90 91 30 01 	lds	r25, 0x0130	; 0x800130 <uxTopCoRoutineReadyPriority>
     320:	98 17       	cp	r25, r24
     322:	10 f4       	brcc	.+4      	; 0x328 <prvCheckDelayedList+0xb2>
     324:	80 93 30 01 	sts	0x0130, r24	; 0x800130 <uxTopCoRoutineReadyPriority>
     328:	90 e0       	ldi	r25, 0x00	; 0
     32a:	9c 01       	movw	r18, r24
     32c:	22 0f       	add	r18, r18
     32e:	33 1f       	adc	r19, r19
     330:	22 0f       	add	r18, r18
     332:	33 1f       	adc	r19, r19
     334:	22 0f       	add	r18, r18
     336:	33 1f       	adc	r19, r19
     338:	82 0f       	add	r24, r18
     33a:	93 1f       	adc	r25, r19
     33c:	b8 01       	movw	r22, r16
     33e:	8e 5a       	subi	r24, 0xAE	; 174
     340:	9e 4f       	sbci	r25, 0xFE	; 254
     342:	0e 94 87 04 	call	0x90e	; 0x90e <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     346:	e0 91 3e 01 	lds	r30, 0x013E	; 0x80013e <pxDelayedCoRoutineList>
     34a:	f0 91 3f 01 	lds	r31, 0x013F	; 0x80013f <pxDelayedCoRoutineList+0x1>
     34e:	80 81       	ld	r24, Z
     350:	81 11       	cpse	r24, r1
     352:	c5 cf       	rjmp	.-118    	; 0x2de <prvCheckDelayedList+0x68>
static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
     354:	80 91 2a 01 	lds	r24, 0x012A	; 0x80012a <__data_end>
     358:	90 91 2b 01 	lds	r25, 0x012B	; 0x80012b <__data_end+0x1>
     35c:	00 97       	sbiw	r24, 0x00	; 0
     35e:	09 f0       	breq	.+2      	; 0x362 <prvCheckDelayedList+0xec>
     360:	9b cf       	rjmp	.-202    	; 0x298 <prvCheckDelayedList+0x22>

			prvAddCoRoutineToReadyQueue( pxCRCB );
		}
	}

	xLastTickCount = xCoRoutineTickCount;
     362:	80 91 2e 01 	lds	r24, 0x012E	; 0x80012e <xCoRoutineTickCount>
     366:	90 91 2f 01 	lds	r25, 0x012F	; 0x80012f <xCoRoutineTickCount+0x1>
     36a:	90 93 2d 01 	sts	0x012D, r25	; 0x80012d <xLastTickCount+0x1>
     36e:	80 93 2c 01 	sts	0x012C, r24	; 0x80012c <xLastTickCount>
}
     372:	df 91       	pop	r29
     374:	cf 91       	pop	r28
     376:	1f 91       	pop	r17
     378:	0f 91       	pop	r16
     37a:	08 95       	ret

0000037c <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, UBaseType_t uxPriority, UBaseType_t uxIndex )
{
     37c:	cf 92       	push	r12
     37e:	df 92       	push	r13
     380:	ff 92       	push	r15
     382:	0f 93       	push	r16
     384:	1f 93       	push	r17
     386:	cf 93       	push	r28
     388:	df 93       	push	r29
     38a:	6c 01       	movw	r12, r24
     38c:	f6 2e       	mov	r15, r22
     38e:	14 2f       	mov	r17, r20
BaseType_t xReturn;
CRCB_t *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
     390:	8a e1       	ldi	r24, 0x1A	; 26
     392:	90 e0       	ldi	r25, 0x00	; 0
     394:	0e 94 5d 06 	call	0xcba	; 0xcba <pvPortMalloc>
     398:	ec 01       	movw	r28, r24
	if( pxCoRoutine )
     39a:	89 2b       	or	r24, r25
     39c:	09 f4       	brne	.+2      	; 0x3a0 <xCoRoutineCreate+0x24>
     39e:	42 c0       	rjmp	.+132    	; 0x424 <__LOCK_REGION_LENGTH__+0x24>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
     3a0:	80 91 31 01 	lds	r24, 0x0131	; 0x800131 <pxCurrentCoRoutine>
     3a4:	90 91 32 01 	lds	r25, 0x0132	; 0x800132 <pxCurrentCoRoutine+0x1>
     3a8:	89 2b       	or	r24, r25
     3aa:	31 f4       	brne	.+12     	; 0x3b8 <xCoRoutineCreate+0x3c>
		{
			pxCurrentCoRoutine = pxCoRoutine;
     3ac:	d0 93 32 01 	sts	0x0132, r29	; 0x800132 <pxCurrentCoRoutine+0x1>
     3b0:	c0 93 31 01 	sts	0x0131, r28	; 0x800131 <pxCurrentCoRoutine>
			prvInitialiseCoRoutineLists();
     3b4:	0e 94 d6 00 	call	0x1ac	; 0x1ac <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
     3b8:	81 e0       	ldi	r24, 0x01	; 1
     3ba:	8f 15       	cp	r24, r15
     3bc:	10 f4       	brcc	.+4      	; 0x3c2 <xCoRoutineCreate+0x46>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
     3be:	ff 24       	eor	r15, r15
     3c0:	f3 94       	inc	r15
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
     3c2:	19 8e       	std	Y+25, r1	; 0x19
     3c4:	18 8e       	std	Y+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
     3c6:	fe 8a       	std	Y+22, r15	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
     3c8:	1f 8b       	std	Y+23, r17	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     3ca:	fe 01       	movw	r30, r28
     3cc:	c1 92       	st	Z+, r12
     3ce:	d1 92       	st	Z+, r13
     3d0:	8f 01       	movw	r16, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     3d2:	cf 01       	movw	r24, r30
     3d4:	0e 94 83 04 	call	0x906	; 0x906 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     3d8:	ce 01       	movw	r24, r28
     3da:	0c 96       	adiw	r24, 0x0c	; 12
     3dc:	0e 94 83 04 	call	0x906	; 0x906 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the ListItem_t.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     3e0:	d9 87       	std	Y+9, r29	; 0x09
     3e2:	c8 87       	std	Y+8, r28	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     3e4:	db 8b       	std	Y+19, r29	; 0x13
     3e6:	ca 8b       	std	Y+18, r28	; 0x12

		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
     3e8:	82 e0       	ldi	r24, 0x02	; 2
     3ea:	90 e0       	ldi	r25, 0x00	; 0
     3ec:	8f 19       	sub	r24, r15
     3ee:	91 09       	sbc	r25, r1
     3f0:	9d 87       	std	Y+13, r25	; 0x0d
     3f2:	8c 87       	std	Y+12, r24	; 0x0c

		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
     3f4:	8e 89       	ldd	r24, Y+22	; 0x16
     3f6:	90 91 30 01 	lds	r25, 0x0130	; 0x800130 <uxTopCoRoutineReadyPriority>
     3fa:	98 17       	cp	r25, r24
     3fc:	10 f4       	brcc	.+4      	; 0x402 <__LOCK_REGION_LENGTH__+0x2>
     3fe:	80 93 30 01 	sts	0x0130, r24	; 0x800130 <uxTopCoRoutineReadyPriority>
     402:	90 e0       	ldi	r25, 0x00	; 0
     404:	9c 01       	movw	r18, r24
     406:	22 0f       	add	r18, r18
     408:	33 1f       	adc	r19, r19
     40a:	22 0f       	add	r18, r18
     40c:	33 1f       	adc	r19, r19
     40e:	22 0f       	add	r18, r18
     410:	33 1f       	adc	r19, r19
     412:	82 0f       	add	r24, r18
     414:	93 1f       	adc	r25, r19
     416:	b8 01       	movw	r22, r16
     418:	8e 5a       	subi	r24, 0xAE	; 174
     41a:	9e 4f       	sbci	r25, 0xFE	; 254
     41c:	0e 94 87 04 	call	0x90e	; 0x90e <vListInsertEnd>

		xReturn = pdPASS;
     420:	81 e0       	ldi	r24, 0x01	; 1
     422:	01 c0       	rjmp	.+2      	; 0x426 <__LOCK_REGION_LENGTH__+0x26>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     424:	8f ef       	ldi	r24, 0xFF	; 255
	}

	return xReturn;
}
     426:	df 91       	pop	r29
     428:	cf 91       	pop	r28
     42a:	1f 91       	pop	r17
     42c:	0f 91       	pop	r16
     42e:	ff 90       	pop	r15
     430:	df 90       	pop	r13
     432:	cf 90       	pop	r12
     434:	08 95       	ret

00000436 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay, List_t *pxEventList )
{
     436:	0f 93       	push	r16
     438:	1f 93       	push	r17
     43a:	cf 93       	push	r28
     43c:	df 93       	push	r29
     43e:	8b 01       	movw	r16, r22
TickType_t xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     440:	c0 91 2e 01 	lds	r28, 0x012E	; 0x80012e <xCoRoutineTickCount>
     444:	d0 91 2f 01 	lds	r29, 0x012F	; 0x80012f <xCoRoutineTickCount+0x1>
     448:	c8 0f       	add	r28, r24
     44a:	d9 1f       	adc	r29, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     44c:	80 91 31 01 	lds	r24, 0x0131	; 0x800131 <pxCurrentCoRoutine>
     450:	90 91 32 01 	lds	r25, 0x0132	; 0x800132 <pxCurrentCoRoutine+0x1>
     454:	02 96       	adiw	r24, 0x02	; 2
     456:	0e 94 d9 04 	call	0x9b2	; 0x9b2 <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     45a:	e0 91 31 01 	lds	r30, 0x0131	; 0x800131 <pxCurrentCoRoutine>
     45e:	f0 91 32 01 	lds	r31, 0x0132	; 0x800132 <pxCurrentCoRoutine+0x1>
     462:	d3 83       	std	Z+3, r29	; 0x03
     464:	c2 83       	std	Z+2, r28	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
     466:	80 91 2e 01 	lds	r24, 0x012E	; 0x80012e <xCoRoutineTickCount>
     46a:	90 91 2f 01 	lds	r25, 0x012F	; 0x80012f <xCoRoutineTickCount+0x1>
     46e:	c8 17       	cp	r28, r24
     470:	d9 07       	cpc	r29, r25
     472:	50 f4       	brcc	.+20     	; 0x488 <vCoRoutineAddToDelayedList+0x52>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     474:	bf 01       	movw	r22, r30
     476:	6e 5f       	subi	r22, 0xFE	; 254
     478:	7f 4f       	sbci	r23, 0xFF	; 255
     47a:	80 91 3c 01 	lds	r24, 0x013C	; 0x80013c <pxOverflowDelayedCoRoutineList>
     47e:	90 91 3d 01 	lds	r25, 0x013D	; 0x80013d <pxOverflowDelayedCoRoutineList+0x1>
     482:	0e 94 a8 04 	call	0x950	; 0x950 <vListInsert>
     486:	09 c0       	rjmp	.+18     	; 0x49a <vCoRoutineAddToDelayedList+0x64>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     488:	bf 01       	movw	r22, r30
     48a:	6e 5f       	subi	r22, 0xFE	; 254
     48c:	7f 4f       	sbci	r23, 0xFF	; 255
     48e:	80 91 3e 01 	lds	r24, 0x013E	; 0x80013e <pxDelayedCoRoutineList>
     492:	90 91 3f 01 	lds	r25, 0x013F	; 0x80013f <pxDelayedCoRoutineList+0x1>
     496:	0e 94 a8 04 	call	0x950	; 0x950 <vListInsert>
	}

	if( pxEventList )
     49a:	01 15       	cp	r16, r1
     49c:	11 05       	cpc	r17, r1
     49e:	49 f0       	breq	.+18     	; 0x4b2 <vCoRoutineAddToDelayedList+0x7c>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     4a0:	60 91 31 01 	lds	r22, 0x0131	; 0x800131 <pxCurrentCoRoutine>
     4a4:	70 91 32 01 	lds	r23, 0x0132	; 0x800132 <pxCurrentCoRoutine+0x1>
     4a8:	64 5f       	subi	r22, 0xF4	; 244
     4aa:	7f 4f       	sbci	r23, 0xFF	; 255
     4ac:	c8 01       	movw	r24, r16
     4ae:	0e 94 a8 04 	call	0x950	; 0x950 <vListInsert>
	}
}
     4b2:	df 91       	pop	r29
     4b4:	cf 91       	pop	r28
     4b6:	1f 91       	pop	r17
     4b8:	0f 91       	pop	r16
     4ba:	08 95       	ret

000004bc <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
     4bc:	0e 94 05 01 	call	0x20a	; 0x20a <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
     4c0:	0e 94 3b 01 	call	0x276	; 0x276 <prvCheckDelayedList>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     4c4:	06 c0       	rjmp	.+12     	; 0x4d2 <vCoRoutineSchedule+0x16>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
     4c6:	88 23       	and	r24, r24
     4c8:	09 f4       	brne	.+2      	; 0x4cc <vCoRoutineSchedule+0x10>
     4ca:	4f c0       	rjmp	.+158    	; 0x56a <vCoRoutineSchedule+0xae>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
     4cc:	81 50       	subi	r24, 0x01	; 1
     4ce:	80 93 30 01 	sts	0x0130, r24	; 0x800130 <uxTopCoRoutineReadyPriority>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     4d2:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <uxTopCoRoutineReadyPriority>
     4d6:	28 2f       	mov	r18, r24
     4d8:	30 e0       	ldi	r19, 0x00	; 0
     4da:	f9 01       	movw	r30, r18
     4dc:	ee 0f       	add	r30, r30
     4de:	ff 1f       	adc	r31, r31
     4e0:	ee 0f       	add	r30, r30
     4e2:	ff 1f       	adc	r31, r31
     4e4:	ee 0f       	add	r30, r30
     4e6:	ff 1f       	adc	r31, r31
     4e8:	e2 0f       	add	r30, r18
     4ea:	f3 1f       	adc	r31, r19
     4ec:	ee 5a       	subi	r30, 0xAE	; 174
     4ee:	fe 4f       	sbci	r31, 0xFE	; 254
     4f0:	90 81       	ld	r25, Z
     4f2:	99 23       	and	r25, r25
     4f4:	41 f3       	breq	.-48     	; 0x4c6 <vCoRoutineSchedule+0xa>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
     4f6:	c9 01       	movw	r24, r18
     4f8:	88 0f       	add	r24, r24
     4fa:	99 1f       	adc	r25, r25
     4fc:	88 0f       	add	r24, r24
     4fe:	99 1f       	adc	r25, r25
     500:	88 0f       	add	r24, r24
     502:	99 1f       	adc	r25, r25
     504:	82 0f       	add	r24, r18
     506:	93 1f       	adc	r25, r19
     508:	df 01       	movw	r26, r30
     50a:	01 80       	ldd	r0, Z+1	; 0x01
     50c:	f2 81       	ldd	r31, Z+2	; 0x02
     50e:	e0 2d       	mov	r30, r0
     510:	02 80       	ldd	r0, Z+2	; 0x02
     512:	f3 81       	ldd	r31, Z+3	; 0x03
     514:	e0 2d       	mov	r30, r0
     516:	12 96       	adiw	r26, 0x02	; 2
     518:	fc 93       	st	X, r31
     51a:	ee 93       	st	-X, r30
     51c:	11 97       	sbiw	r26, 0x01	; 1
     51e:	8b 5a       	subi	r24, 0xAB	; 171
     520:	9e 4f       	sbci	r25, 0xFE	; 254
     522:	e8 17       	cp	r30, r24
     524:	f9 07       	cpc	r31, r25
     526:	29 f4       	brne	.+10     	; 0x532 <vCoRoutineSchedule+0x76>
     528:	82 81       	ldd	r24, Z+2	; 0x02
     52a:	93 81       	ldd	r25, Z+3	; 0x03
     52c:	fd 01       	movw	r30, r26
     52e:	92 83       	std	Z+2, r25	; 0x02
     530:	81 83       	std	Z+1, r24	; 0x01
     532:	f9 01       	movw	r30, r18
     534:	ee 0f       	add	r30, r30
     536:	ff 1f       	adc	r31, r31
     538:	ee 0f       	add	r30, r30
     53a:	ff 1f       	adc	r31, r31
     53c:	ee 0f       	add	r30, r30
     53e:	ff 1f       	adc	r31, r31
     540:	2e 0f       	add	r18, r30
     542:	3f 1f       	adc	r19, r31
     544:	f9 01       	movw	r30, r18
     546:	ee 5a       	subi	r30, 0xAE	; 174
     548:	fe 4f       	sbci	r31, 0xFE	; 254
     54a:	01 80       	ldd	r0, Z+1	; 0x01
     54c:	f2 81       	ldd	r31, Z+2	; 0x02
     54e:	e0 2d       	mov	r30, r0
     550:	86 81       	ldd	r24, Z+6	; 0x06
     552:	97 81       	ldd	r25, Z+7	; 0x07
     554:	90 93 32 01 	sts	0x0132, r25	; 0x800132 <pxCurrentCoRoutine+0x1>
     558:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <pxCurrentCoRoutine>

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
     55c:	dc 01       	movw	r26, r24
     55e:	ed 91       	ld	r30, X+
     560:	fc 91       	ld	r31, X
     562:	11 97       	sbiw	r26, 0x01	; 1
     564:	57 96       	adiw	r26, 0x17	; 23
     566:	6c 91       	ld	r22, X
     568:	09 95       	icall
     56a:	08 95       	ret

0000056c <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

BaseType_t xCoRoutineRemoveFromEventList( const List_t *pxEventList )
{
     56c:	0f 93       	push	r16
     56e:	1f 93       	push	r17
     570:	cf 93       	push	r28
     572:	df 93       	push	r29
BaseType_t xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     574:	dc 01       	movw	r26, r24
     576:	15 96       	adiw	r26, 0x05	; 5
     578:	ed 91       	ld	r30, X+
     57a:	fc 91       	ld	r31, X
     57c:	16 97       	sbiw	r26, 0x06	; 6
     57e:	c6 81       	ldd	r28, Z+6	; 0x06
     580:	d7 81       	ldd	r29, Z+7	; 0x07
	( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     582:	8e 01       	movw	r16, r28
     584:	04 5f       	subi	r16, 0xF4	; 244
     586:	1f 4f       	sbci	r17, 0xFF	; 255
     588:	c8 01       	movw	r24, r16
     58a:	0e 94 d9 04 	call	0x9b2	; 0x9b2 <uxListRemove>
	vListInsertEnd( ( List_t * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
     58e:	b8 01       	movw	r22, r16
     590:	83 e3       	ldi	r24, 0x33	; 51
     592:	91 e0       	ldi	r25, 0x01	; 1
     594:	0e 94 87 04 	call	0x90e	; 0x90e <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
     598:	9e 89       	ldd	r25, Y+22	; 0x16
     59a:	e0 91 31 01 	lds	r30, 0x0131	; 0x800131 <pxCurrentCoRoutine>
     59e:	f0 91 32 01 	lds	r31, 0x0132	; 0x800132 <pxCurrentCoRoutine+0x1>
     5a2:	86 89       	ldd	r24, Z+22	; 0x16
     5a4:	98 17       	cp	r25, r24
     5a6:	10 f0       	brcs	.+4      	; 0x5ac <xCoRoutineRemoveFromEventList+0x40>
	{
		xReturn = pdTRUE;
     5a8:	81 e0       	ldi	r24, 0x01	; 1
     5aa:	01 c0       	rjmp	.+2      	; 0x5ae <xCoRoutineRemoveFromEventList+0x42>
	}
	else
	{
		xReturn = pdFALSE;
     5ac:	80 e0       	ldi	r24, 0x00	; 0
	}

	return xReturn;
}
     5ae:	df 91       	pop	r29
     5b0:	cf 91       	pop	r28
     5b2:	1f 91       	pop	r17
     5b4:	0f 91       	pop	r16
     5b6:	08 95       	ret

000005b8 <prvTestWaitCondition>:

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
BaseType_t xWaitConditionMet = pdFALSE;

	if( xWaitForAllBits == pdFALSE )
     5b8:	41 11       	cpse	r20, r1
     5ba:	06 c0       	rjmp	.+12     	; 0x5c8 <prvTestWaitCondition+0x10>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
     5bc:	68 23       	and	r22, r24
     5be:	79 23       	and	r23, r25
     5c0:	67 2b       	or	r22, r23
     5c2:	49 f4       	brne	.+18     	; 0x5d6 <prvTestWaitCondition+0x1e>
}
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
BaseType_t xWaitConditionMet = pdFALSE;
     5c4:	80 e0       	ldi	r24, 0x00	; 0
     5c6:	08 95       	ret
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
     5c8:	86 23       	and	r24, r22
     5ca:	97 23       	and	r25, r23
     5cc:	68 17       	cp	r22, r24
     5ce:	79 07       	cpc	r23, r25
     5d0:	21 f0       	breq	.+8      	; 0x5da <prvTestWaitCondition+0x22>
}
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
BaseType_t xWaitConditionMet = pdFALSE;
     5d2:	80 e0       	ldi	r24, 0x00	; 0
     5d4:	08 95       	ret
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
		{
			xWaitConditionMet = pdTRUE;
     5d6:	81 e0       	ldi	r24, 0x01	; 1
     5d8:	08 95       	ret
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
		{
			xWaitConditionMet = pdTRUE;
     5da:	81 e0       	ldi	r24, 0x01	; 1
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
}
     5dc:	08 95       	ret

000005de <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	EventGroupHandle_t xEventGroupCreate( void )
	{
     5de:	cf 93       	push	r28
     5e0:	df 93       	push	r29
	EventGroup_t *pxEventBits;

		/* Allocate the event group. */
		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) );
     5e2:	8b e0       	ldi	r24, 0x0B	; 11
     5e4:	90 e0       	ldi	r25, 0x00	; 0
     5e6:	0e 94 5d 06 	call	0xcba	; 0xcba <pvPortMalloc>
     5ea:	ec 01       	movw	r28, r24

		if( pxEventBits != NULL )
     5ec:	00 97       	sbiw	r24, 0x00	; 0
     5ee:	31 f0       	breq	.+12     	; 0x5fc <xEventGroupCreate+0x1e>
		{
			pxEventBits->uxEventBits = 0;
     5f0:	fc 01       	movw	r30, r24
     5f2:	11 92       	st	Z+, r1
     5f4:	11 92       	st	Z+, r1
     5f6:	cf 01       	movw	r24, r30
			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
     5f8:	0e 94 75 04 	call	0x8ea	; 0x8ea <vListInitialise>
		{
			traceEVENT_GROUP_CREATE_FAILED();
		}

		return ( EventGroupHandle_t ) pxEventBits;
	}
     5fc:	ce 01       	movw	r24, r28
     5fe:	df 91       	pop	r29
     600:	cf 91       	pop	r28
     602:	08 95       	ret

00000604 <xEventGroupWaitBits>:
	return uxReturn;
}
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
     604:	af 92       	push	r10
     606:	bf 92       	push	r11
     608:	cf 92       	push	r12
     60a:	df 92       	push	r13
     60c:	ef 92       	push	r14
     60e:	ff 92       	push	r15
     610:	0f 93       	push	r16
     612:	1f 93       	push	r17
     614:	cf 93       	push	r28
     616:	df 93       	push	r29
     618:	7c 01       	movw	r14, r24
     61a:	5b 01       	movw	r10, r22
     61c:	c4 2e       	mov	r12, r20
     61e:	d2 2e       	mov	r13, r18
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     620:	0e 94 0f 0d 	call	0x1a1e	; 0x1a1e <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
     624:	f7 01       	movw	r30, r14
     626:	c0 81       	ld	r28, Z
     628:	d1 81       	ldd	r29, Z+1	; 0x01

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
     62a:	4d 2d       	mov	r20, r13
     62c:	b5 01       	movw	r22, r10
     62e:	ce 01       	movw	r24, r28
     630:	0e 94 dc 02 	call	0x5b8	; 0x5b8 <prvTestWaitCondition>

		if( xWaitConditionMet != pdFALSE )
     634:	88 23       	and	r24, r24
     636:	69 f0       	breq	.+26     	; 0x652 <xEventGroupWaitBits+0x4e>
			block. */
			uxReturn = uxCurrentEventBits;
			xTicksToWait = ( TickType_t ) 0;

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
     638:	cc 20       	and	r12, r12
     63a:	09 f1       	breq	.+66     	; 0x67e <xEventGroupWaitBits+0x7a>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     63c:	c5 01       	movw	r24, r10
     63e:	80 95       	com	r24
     640:	90 95       	com	r25
     642:	8c 23       	and	r24, r28
     644:	9d 23       	and	r25, r29
     646:	f7 01       	movw	r30, r14
     648:	91 83       	std	Z+1, r25	; 0x01
     64a:	80 83       	st	Z, r24
		if( xWaitConditionMet != pdFALSE )
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
			xTicksToWait = ( TickType_t ) 0;
     64c:	00 e0       	ldi	r16, 0x00	; 0
     64e:	10 e0       	ldi	r17, 0x00	; 0
     650:	18 c0       	rjmp	.+48     	; 0x682 <xEventGroupWaitBits+0x7e>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
     652:	01 15       	cp	r16, r1
     654:	11 05       	cpc	r17, r1
     656:	a9 f0       	breq	.+42     	; 0x682 <xEventGroupWaitBits+0x7e>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
     658:	c1 10       	cpse	r12, r1
     65a:	03 c0       	rjmp	.+6      	; 0x662 <xEventGroupWaitBits+0x5e>
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
EventBits_t uxReturn, uxControlBits = 0;
     65c:	60 e0       	ldi	r22, 0x00	; 0
     65e:	70 e0       	ldi	r23, 0x00	; 0
     660:	02 c0       	rjmp	.+4      	; 0x666 <xEventGroupWaitBits+0x62>
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
     662:	60 e0       	ldi	r22, 0x00	; 0
     664:	71 e0       	ldi	r23, 0x01	; 1
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
     666:	d1 10       	cpse	r13, r1
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
     668:	74 60       	ori	r23, 0x04	; 4
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
     66a:	6a 29       	or	r22, r10
     66c:	7b 29       	or	r23, r11
     66e:	a8 01       	movw	r20, r16
     670:	c7 01       	movw	r24, r14
     672:	02 96       	adiw	r24, 0x02	; 2
     674:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <vTaskPlaceOnUnorderedEventList>

			/* This is obsolete as it will get set after the task unblocks, but
			some compilers mistakenly generate a warning about the variable
			being returned without being set if it is not done. */
			uxReturn = 0;
     678:	c0 e0       	ldi	r28, 0x00	; 0
     67a:	d0 e0       	ldi	r29, 0x00	; 0
     67c:	02 c0       	rjmp	.+4      	; 0x682 <xEventGroupWaitBits+0x7e>
		if( xWaitConditionMet != pdFALSE )
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
			xTicksToWait = ( TickType_t ) 0;
     67e:	00 e0       	ldi	r16, 0x00	; 0
     680:	10 e0       	ldi	r17, 0x00	; 0
			uxReturn = 0;

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     682:	0e 94 e9 0d 	call	0x1bd2	; 0x1bd2 <xTaskResumeAll>

	if( xTicksToWait != ( TickType_t ) 0 )
     686:	01 2b       	or	r16, r17
     688:	19 f1       	breq	.+70     	; 0x6d0 <xEventGroupWaitBits+0xcc>
	{
		if( xAlreadyYielded == pdFALSE )
     68a:	81 11       	cpse	r24, r1
     68c:	02 c0       	rjmp	.+4      	; 0x692 <xEventGroupWaitBits+0x8e>
		{
			portYIELD_WITHIN_API();
     68e:	0e 94 a5 05 	call	0xb4a	; 0xb4a <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     692:	0e 94 9b 10 	call	0x2136	; 0x2136 <uxTaskResetEventItemValue>
     696:	ec 01       	movw	r28, r24

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     698:	91 fd       	sbrc	r25, 1
     69a:	19 c0       	rjmp	.+50     	; 0x6ce <xEventGroupWaitBits+0xca>
		{
			taskENTER_CRITICAL();
     69c:	0f b6       	in	r0, 0x3f	; 63
     69e:	f8 94       	cli
     6a0:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     6a2:	f7 01       	movw	r30, r14
     6a4:	c0 81       	ld	r28, Z
     6a6:	d1 81       	ldd	r29, Z+1	; 0x01

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
     6a8:	4d 2d       	mov	r20, r13
     6aa:	b5 01       	movw	r22, r10
     6ac:	ce 01       	movw	r24, r28
     6ae:	0e 94 dc 02 	call	0x5b8	; 0x5b8 <prvTestWaitCondition>
     6b2:	88 23       	and	r24, r24
     6b4:	51 f0       	breq	.+20     	; 0x6ca <xEventGroupWaitBits+0xc6>
				{
					if( xClearOnExit != pdFALSE )
     6b6:	cc 20       	and	r12, r12
     6b8:	41 f0       	breq	.+16     	; 0x6ca <xEventGroupWaitBits+0xc6>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     6ba:	b5 01       	movw	r22, r10
     6bc:	60 95       	com	r22
     6be:	70 95       	com	r23
     6c0:	6c 23       	and	r22, r28
     6c2:	7d 23       	and	r23, r29
     6c4:	f7 01       	movw	r30, r14
     6c6:	71 83       	std	Z+1, r23	; 0x01
     6c8:	60 83       	st	Z, r22
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
     6ca:	0f 90       	pop	r0
     6cc:	0f be       	out	0x3f, r0	; 63
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     6ce:	dd 27       	eor	r29, r29
	}
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
}
     6d0:	ce 01       	movw	r24, r28
     6d2:	df 91       	pop	r29
     6d4:	cf 91       	pop	r28
     6d6:	1f 91       	pop	r17
     6d8:	0f 91       	pop	r16
     6da:	ff 90       	pop	r15
     6dc:	ef 90       	pop	r14
     6de:	df 90       	pop	r13
     6e0:	cf 90       	pop	r12
     6e2:	bf 90       	pop	r11
     6e4:	af 90       	pop	r10
     6e6:	08 95       	ret

000006e8 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
     6e8:	fc 01       	movw	r30, r24
	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
     6ea:	0f b6       	in	r0, 0x3f	; 63
     6ec:	f8 94       	cli
     6ee:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
     6f0:	80 81       	ld	r24, Z
     6f2:	91 81       	ldd	r25, Z+1	; 0x01

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     6f4:	60 95       	com	r22
     6f6:	70 95       	com	r23
     6f8:	68 23       	and	r22, r24
     6fa:	79 23       	and	r23, r25
     6fc:	71 83       	std	Z+1, r23	; 0x01
     6fe:	60 83       	st	Z, r22
	}
	taskEXIT_CRITICAL();
     700:	0f 90       	pop	r0
     702:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
     704:	08 95       	ret

00000706 <xEventGroupGetBitsFromISR>:
		uxReturn = pxEventBits->uxEventBits;
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
}
     706:	fc 01       	movw	r30, r24
     708:	80 81       	ld	r24, Z
     70a:	91 81       	ldd	r25, Z+1	; 0x01
     70c:	08 95       	ret

0000070e <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
     70e:	cf 92       	push	r12
     710:	df 92       	push	r13
     712:	ef 92       	push	r14
     714:	ff 92       	push	r15
     716:	0f 93       	push	r16
     718:	1f 93       	push	r17
     71a:	cf 93       	push	r28
     71c:	df 93       	push	r29
     71e:	7c 01       	movw	r14, r24
     720:	8b 01       	movw	r16, r22
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     722:	ec 01       	movw	r28, r24
     724:	25 96       	adiw	r28, 0x05	; 5
	vTaskSuspendAll();
     726:	0e 94 0f 0d 	call	0x1a1e	; 0x1a1e <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
     72a:	d7 01       	movw	r26, r14
     72c:	17 96       	adiw	r26, 0x07	; 7
     72e:	ed 91       	ld	r30, X+
     730:	fc 91       	ld	r31, X
     732:	18 97       	sbiw	r26, 0x08	; 8

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
     734:	8d 91       	ld	r24, X+
     736:	9c 91       	ld	r25, X
     738:	11 97       	sbiw	r26, 0x01	; 1
     73a:	08 2b       	or	r16, r24
     73c:	19 2b       	or	r17, r25
     73e:	0d 93       	st	X+, r16
     740:	1c 93       	st	X, r17
EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t *pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
     742:	00 e0       	ldi	r16, 0x00	; 0
     744:	10 e0       	ldi	r17, 0x00	; 0

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     746:	2d c0       	rjmp	.+90     	; 0x7a2 <xEventGroupSetBits+0x94>
		{
			pxNext = listGET_NEXT( pxListItem );
     748:	c2 80       	ldd	r12, Z+2	; 0x02
     74a:	d3 80       	ldd	r13, Z+3	; 0x03
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
     74c:	80 81       	ld	r24, Z
     74e:	91 81       	ldd	r25, Z+1	; 0x01
			xMatchFound = pdFALSE;

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
     750:	9c 01       	movw	r18, r24
     752:	33 27       	eor	r19, r19

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
     754:	92 fd       	sbrc	r25, 2
     756:	09 c0       	rjmp	.+18     	; 0x76a <xEventGroupSetBits+0x5c>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
     758:	d7 01       	movw	r26, r14
     75a:	4d 91       	ld	r20, X+
     75c:	5c 91       	ld	r21, X
     75e:	42 23       	and	r20, r18
     760:	53 23       	and	r21, r19
     762:	45 2b       	or	r20, r21
     764:	61 f4       	brne	.+24     	; 0x77e <xEventGroupSetBits+0x70>
		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
			xMatchFound = pdFALSE;
     766:	40 e0       	ldi	r20, 0x00	; 0
     768:	0d c0       	rjmp	.+26     	; 0x784 <xEventGroupSetBits+0x76>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
     76a:	d7 01       	movw	r26, r14
     76c:	4d 91       	ld	r20, X+
     76e:	5c 91       	ld	r21, X
     770:	42 23       	and	r20, r18
     772:	53 23       	and	r21, r19
     774:	24 17       	cp	r18, r20
     776:	35 07       	cpc	r19, r21
     778:	21 f0       	breq	.+8      	; 0x782 <xEventGroupSetBits+0x74>
		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
			xMatchFound = pdFALSE;
     77a:	40 e0       	ldi	r20, 0x00	; 0
     77c:	03 c0       	rjmp	.+6      	; 0x784 <xEventGroupSetBits+0x76>
			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
				{
					xMatchFound = pdTRUE;
     77e:	41 e0       	ldi	r20, 0x01	; 1
     780:	01 c0       	rjmp	.+2      	; 0x784 <xEventGroupSetBits+0x76>
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
     782:	41 e0       	ldi	r20, 0x01	; 1
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
     784:	44 23       	and	r20, r20
     786:	59 f0       	breq	.+22     	; 0x79e <xEventGroupSetBits+0x90>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
     788:	90 ff       	sbrs	r25, 0
     78a:	02 c0       	rjmp	.+4      	; 0x790 <xEventGroupSetBits+0x82>
				{
					uxBitsToClear |= uxBitsWaitedFor;
     78c:	02 2b       	or	r16, r18
     78e:	13 2b       	or	r17, r19
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				( void ) xTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
     790:	d7 01       	movw	r26, r14
     792:	6d 91       	ld	r22, X+
     794:	7c 91       	ld	r23, X
     796:	72 60       	ori	r23, 0x02	; 2
     798:	cf 01       	movw	r24, r30
     79a:	0e 94 79 0f 	call	0x1ef2	; 0x1ef2 <xTaskRemoveFromUnorderedEventList>
		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
			xMatchFound = pdFALSE;
     79e:	ec 2d       	mov	r30, r12
     7a0:	fd 2d       	mov	r31, r13

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     7a2:	ec 17       	cp	r30, r28
     7a4:	fd 07       	cpc	r31, r29
     7a6:	81 f6       	brne	.-96     	; 0x748 <xEventGroupSetBits+0x3a>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     7a8:	00 95       	com	r16
     7aa:	10 95       	com	r17
     7ac:	f7 01       	movw	r30, r14
     7ae:	80 81       	ld	r24, Z
     7b0:	91 81       	ldd	r25, Z+1	; 0x01
     7b2:	08 23       	and	r16, r24
     7b4:	19 23       	and	r17, r25
     7b6:	11 83       	std	Z+1, r17	; 0x01
     7b8:	00 83       	st	Z, r16
	}
	( void ) xTaskResumeAll();
     7ba:	0e 94 e9 0d 	call	0x1bd2	; 0x1bd2 <xTaskResumeAll>

	return pxEventBits->uxEventBits;
}
     7be:	d7 01       	movw	r26, r14
     7c0:	8d 91       	ld	r24, X+
     7c2:	9c 91       	ld	r25, X
     7c4:	df 91       	pop	r29
     7c6:	cf 91       	pop	r28
     7c8:	1f 91       	pop	r17
     7ca:	0f 91       	pop	r16
     7cc:	ff 90       	pop	r15
     7ce:	ef 90       	pop	r14
     7d0:	df 90       	pop	r13
     7d2:	cf 90       	pop	r12
     7d4:	08 95       	ret

000007d6 <xEventGroupSync>:

#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
     7d6:	af 92       	push	r10
     7d8:	bf 92       	push	r11
     7da:	cf 92       	push	r12
     7dc:	df 92       	push	r13
     7de:	ef 92       	push	r14
     7e0:	ff 92       	push	r15
     7e2:	0f 93       	push	r16
     7e4:	1f 93       	push	r17
     7e6:	cf 93       	push	r28
     7e8:	df 93       	push	r29
     7ea:	8c 01       	movw	r16, r24
     7ec:	eb 01       	movw	r28, r22
     7ee:	7a 01       	movw	r14, r20
     7f0:	69 01       	movw	r12, r18
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     7f2:	0e 94 0f 0d 	call	0x1a1e	; 0x1a1e <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
     7f6:	f8 01       	movw	r30, r16
     7f8:	a0 80       	ld	r10, Z
     7fa:	b1 80       	ldd	r11, Z+1	; 0x01

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
     7fc:	be 01       	movw	r22, r28
     7fe:	c8 01       	movw	r24, r16
     800:	0e 94 87 03 	call	0x70e	; 0x70e <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
     804:	ca 29       	or	r28, r10
     806:	db 29       	or	r29, r11
     808:	ce 01       	movw	r24, r28
     80a:	8e 21       	and	r24, r14
     80c:	9f 21       	and	r25, r15
     80e:	e8 16       	cp	r14, r24
     810:	f9 06       	cpc	r15, r25
     812:	69 f4       	brne	.+26     	; 0x82e <xEventGroupSync+0x58>
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     814:	f8 01       	movw	r30, r16
     816:	20 81       	ld	r18, Z
     818:	31 81       	ldd	r19, Z+1	; 0x01
     81a:	c7 01       	movw	r24, r14
     81c:	80 95       	com	r24
     81e:	90 95       	com	r25
     820:	82 23       	and	r24, r18
     822:	93 23       	and	r25, r19
     824:	91 83       	std	Z+1, r25	; 0x01
     826:	80 83       	st	Z, r24

			xTicksToWait = 0;
     828:	c1 2c       	mov	r12, r1
     82a:	d1 2c       	mov	r13, r1
     82c:	10 c0       	rjmp	.+32     	; 0x84e <xEventGroupSync+0x78>
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
     82e:	c1 14       	cp	r12, r1
     830:	d1 04       	cpc	r13, r1
     832:	51 f0       	breq	.+20     	; 0x848 <xEventGroupSync+0x72>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
     834:	a6 01       	movw	r20, r12
     836:	b7 01       	movw	r22, r14
     838:	75 60       	ori	r23, 0x05	; 5
     83a:	c8 01       	movw	r24, r16
     83c:	02 96       	adiw	r24, 0x02	; 2
     83e:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <vTaskPlaceOnUnorderedEventList>

				/* This assignment is obsolete as uxReturn will get set after
				the task unblocks, but some compilers mistakenly generate a
				warning about uxReturn being returned without being set if the
				assignment is omitted. */
				uxReturn = 0;
     842:	c0 e0       	ldi	r28, 0x00	; 0
     844:	d0 e0       	ldi	r29, 0x00	; 0
     846:	03 c0       	rjmp	.+6      	; 0x84e <xEventGroupSync+0x78>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     848:	f8 01       	movw	r30, r16
     84a:	c0 81       	ld	r28, Z
     84c:	d1 81       	ldd	r29, Z+1	; 0x01
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     84e:	0e 94 e9 0d 	call	0x1bd2	; 0x1bd2 <xTaskResumeAll>

	if( xTicksToWait != ( TickType_t ) 0 )
     852:	cd 28       	or	r12, r13
     854:	f9 f0       	breq	.+62     	; 0x894 <xEventGroupSync+0xbe>
	{
		if( xAlreadyYielded == pdFALSE )
     856:	81 11       	cpse	r24, r1
     858:	02 c0       	rjmp	.+4      	; 0x85e <xEventGroupSync+0x88>
		{
			portYIELD_WITHIN_API();
     85a:	0e 94 a5 05 	call	0xb4a	; 0xb4a <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     85e:	0e 94 9b 10 	call	0x2136	; 0x2136 <uxTaskResetEventItemValue>

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     862:	91 fd       	sbrc	r25, 1
     864:	15 c0       	rjmp	.+42     	; 0x890 <xEventGroupSync+0xba>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
     866:	0f b6       	in	r0, 0x3f	; 63
     868:	f8 94       	cli
     86a:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
     86c:	f8 01       	movw	r30, r16
     86e:	80 81       	ld	r24, Z
     870:	91 81       	ldd	r25, Z+1	; 0x01

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
     872:	97 01       	movw	r18, r14
     874:	28 23       	and	r18, r24
     876:	39 23       	and	r19, r25
     878:	e2 16       	cp	r14, r18
     87a:	f3 06       	cpc	r15, r19
     87c:	39 f4       	brne	.+14     	; 0x88c <xEventGroupSync+0xb6>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     87e:	a7 01       	movw	r20, r14
     880:	40 95       	com	r20
     882:	50 95       	com	r21
     884:	48 23       	and	r20, r24
     886:	59 23       	and	r21, r25
     888:	51 83       	std	Z+1, r21	; 0x01
     88a:	40 83       	st	Z, r20
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
     88c:	0f 90       	pop	r0
     88e:	0f be       	out	0x3f, r0	; 63
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     890:	ec 01       	movw	r28, r24
     892:	dd 27       	eor	r29, r29
	}

	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
}
     894:	ce 01       	movw	r24, r28
     896:	df 91       	pop	r29
     898:	cf 91       	pop	r28
     89a:	1f 91       	pop	r17
     89c:	0f 91       	pop	r16
     89e:	ff 90       	pop	r15
     8a0:	ef 90       	pop	r14
     8a2:	df 90       	pop	r13
     8a4:	cf 90       	pop	r12
     8a6:	bf 90       	pop	r11
     8a8:	af 90       	pop	r10
     8aa:	08 95       	ret

000008ac <vEventGroupDelete>:
	return pxEventBits->uxEventBits;
}
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
     8ac:	cf 93       	push	r28
     8ae:	df 93       	push	r29
     8b0:	ec 01       	movw	r28, r24
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );

	vTaskSuspendAll();
     8b2:	0e 94 0f 0d 	call	0x1a1e	; 0x1a1e <vTaskSuspendAll>
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
     8b6:	06 c0       	rjmp	.+12     	; 0x8c4 <vEventGroupDelete+0x18>
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and	cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			( void ) xTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
     8b8:	60 e0       	ldi	r22, 0x00	; 0
     8ba:	72 e0       	ldi	r23, 0x02	; 2
     8bc:	8f 81       	ldd	r24, Y+7	; 0x07
     8be:	98 85       	ldd	r25, Y+8	; 0x08
     8c0:	0e 94 79 0f 	call	0x1ef2	; 0x1ef2 <xTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
     8c4:	8a 81       	ldd	r24, Y+2	; 0x02
     8c6:	81 11       	cpse	r24, r1
     8c8:	f7 cf       	rjmp	.-18     	; 0x8b8 <vEventGroupDelete+0xc>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
		{
			/* The event group can only have been allocated dynamically - free
			it again. */
			vPortFree( pxEventBits );
     8ca:	ce 01       	movw	r24, r28
     8cc:	0e 94 92 06 	call	0xd24	; 0xd24 <vPortFree>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
     8d0:	0e 94 e9 0d 	call	0x1bd2	; 0x1bd2 <xTaskResumeAll>
}
     8d4:	df 91       	pop	r29
     8d6:	cf 91       	pop	r28
     8d8:	08 95       	ret

000008da <vEventGroupSetBitsCallback>:

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet );
     8da:	ba 01       	movw	r22, r20
     8dc:	0e 94 87 03 	call	0x70e	; 0x70e <xEventGroupSetBits>
     8e0:	08 95       	ret

000008e2 <vEventGroupClearBitsCallback>:

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear );
     8e2:	ba 01       	movw	r22, r20
     8e4:	0e 94 74 03 	call	0x6e8	; 0x6e8 <xEventGroupClearBits>
     8e8:	08 95       	ret

000008ea <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     8ea:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     8ec:	03 96       	adiw	r24, 0x03	; 3
     8ee:	92 83       	std	Z+2, r25	; 0x02
     8f0:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     8f2:	2f ef       	ldi	r18, 0xFF	; 255
     8f4:	3f ef       	ldi	r19, 0xFF	; 255
     8f6:	34 83       	std	Z+4, r19	; 0x04
     8f8:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     8fa:	96 83       	std	Z+6, r25	; 0x06
     8fc:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     8fe:	90 87       	std	Z+8, r25	; 0x08
     900:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     902:	10 82       	st	Z, r1
     904:	08 95       	ret

00000906 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     906:	fc 01       	movw	r30, r24
     908:	11 86       	std	Z+9, r1	; 0x09
     90a:	10 86       	std	Z+8, r1	; 0x08
     90c:	08 95       	ret

0000090e <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     90e:	cf 93       	push	r28
     910:	df 93       	push	r29
     912:	9c 01       	movw	r18, r24
     914:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     916:	dc 01       	movw	r26, r24
     918:	11 96       	adiw	r26, 0x01	; 1
     91a:	cd 91       	ld	r28, X+
     91c:	dc 91       	ld	r29, X
     91e:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     920:	d3 83       	std	Z+3, r29	; 0x03
     922:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     924:	8c 81       	ldd	r24, Y+4	; 0x04
     926:	9d 81       	ldd	r25, Y+5	; 0x05
     928:	95 83       	std	Z+5, r25	; 0x05
     92a:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     92c:	8c 81       	ldd	r24, Y+4	; 0x04
     92e:	9d 81       	ldd	r25, Y+5	; 0x05
     930:	dc 01       	movw	r26, r24
     932:	13 96       	adiw	r26, 0x03	; 3
     934:	7c 93       	st	X, r23
     936:	6e 93       	st	-X, r22
     938:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     93a:	7d 83       	std	Y+5, r23	; 0x05
     93c:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     93e:	31 87       	std	Z+9, r19	; 0x09
     940:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     942:	f9 01       	movw	r30, r18
     944:	80 81       	ld	r24, Z
     946:	8f 5f       	subi	r24, 0xFF	; 255
     948:	80 83       	st	Z, r24
}
     94a:	df 91       	pop	r29
     94c:	cf 91       	pop	r28
     94e:	08 95       	ret

00000950 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     950:	cf 93       	push	r28
     952:	df 93       	push	r29
     954:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     956:	48 81       	ld	r20, Y
     958:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     95a:	4f 3f       	cpi	r20, 0xFF	; 255
     95c:	2f ef       	ldi	r18, 0xFF	; 255
     95e:	52 07       	cpc	r21, r18
     960:	21 f4       	brne	.+8      	; 0x96a <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     962:	fc 01       	movw	r30, r24
     964:	a7 81       	ldd	r26, Z+7	; 0x07
     966:	b0 85       	ldd	r27, Z+8	; 0x08
     968:	0d c0       	rjmp	.+26     	; 0x984 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     96a:	dc 01       	movw	r26, r24
     96c:	13 96       	adiw	r26, 0x03	; 3
     96e:	01 c0       	rjmp	.+2      	; 0x972 <vListInsert+0x22>
     970:	df 01       	movw	r26, r30
     972:	12 96       	adiw	r26, 0x02	; 2
     974:	ed 91       	ld	r30, X+
     976:	fc 91       	ld	r31, X
     978:	13 97       	sbiw	r26, 0x03	; 3
     97a:	20 81       	ld	r18, Z
     97c:	31 81       	ldd	r19, Z+1	; 0x01
     97e:	42 17       	cp	r20, r18
     980:	53 07       	cpc	r21, r19
     982:	b0 f7       	brcc	.-20     	; 0x970 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     984:	12 96       	adiw	r26, 0x02	; 2
     986:	ed 91       	ld	r30, X+
     988:	fc 91       	ld	r31, X
     98a:	13 97       	sbiw	r26, 0x03	; 3
     98c:	fb 83       	std	Y+3, r31	; 0x03
     98e:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     990:	d5 83       	std	Z+5, r29	; 0x05
     992:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     994:	bd 83       	std	Y+5, r27	; 0x05
     996:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     998:	13 96       	adiw	r26, 0x03	; 3
     99a:	dc 93       	st	X, r29
     99c:	ce 93       	st	-X, r28
     99e:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     9a0:	99 87       	std	Y+9, r25	; 0x09
     9a2:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     9a4:	fc 01       	movw	r30, r24
     9a6:	20 81       	ld	r18, Z
     9a8:	2f 5f       	subi	r18, 0xFF	; 255
     9aa:	20 83       	st	Z, r18
}
     9ac:	df 91       	pop	r29
     9ae:	cf 91       	pop	r28
     9b0:	08 95       	ret

000009b2 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     9b2:	cf 93       	push	r28
     9b4:	df 93       	push	r29
     9b6:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     9b8:	a0 85       	ldd	r26, Z+8	; 0x08
     9ba:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     9bc:	c2 81       	ldd	r28, Z+2	; 0x02
     9be:	d3 81       	ldd	r29, Z+3	; 0x03
     9c0:	84 81       	ldd	r24, Z+4	; 0x04
     9c2:	95 81       	ldd	r25, Z+5	; 0x05
     9c4:	9d 83       	std	Y+5, r25	; 0x05
     9c6:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     9c8:	c4 81       	ldd	r28, Z+4	; 0x04
     9ca:	d5 81       	ldd	r29, Z+5	; 0x05
     9cc:	82 81       	ldd	r24, Z+2	; 0x02
     9ce:	93 81       	ldd	r25, Z+3	; 0x03
     9d0:	9b 83       	std	Y+3, r25	; 0x03
     9d2:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     9d4:	11 96       	adiw	r26, 0x01	; 1
     9d6:	8d 91       	ld	r24, X+
     9d8:	9c 91       	ld	r25, X
     9da:	12 97       	sbiw	r26, 0x02	; 2
     9dc:	e8 17       	cp	r30, r24
     9de:	f9 07       	cpc	r31, r25
     9e0:	31 f4       	brne	.+12     	; 0x9ee <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     9e2:	84 81       	ldd	r24, Z+4	; 0x04
     9e4:	95 81       	ldd	r25, Z+5	; 0x05
     9e6:	12 96       	adiw	r26, 0x02	; 2
     9e8:	9c 93       	st	X, r25
     9ea:	8e 93       	st	-X, r24
     9ec:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     9ee:	11 86       	std	Z+9, r1	; 0x09
     9f0:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     9f2:	8c 91       	ld	r24, X
     9f4:	81 50       	subi	r24, 0x01	; 1
     9f6:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     9f8:	df 91       	pop	r29
     9fa:	cf 91       	pop	r28
     9fc:	08 95       	ret

000009fe <prvSetupTimerInterrupt>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	OCR1AH = ucHighByte;
     9fe:	86 e0       	ldi	r24, 0x06	; 6
     a00:	8b bd       	out	0x2b, r24	; 43
	OCR1AL = ucLowByte;
     a02:	8f eb       	ldi	r24, 0xBF	; 191
     a04:	8a bd       	out	0x2a, r24	; 42

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
     a06:	8b e0       	ldi	r24, 0x0B	; 11
     a08:	8e bd       	out	0x2e, r24	; 46

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
     a0a:	87 b7       	in	r24, 0x37	; 55
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     a0c:	80 61       	ori	r24, 0x10	; 16
	TIMSK = ucLowByte;
     a0e:	87 bf       	out	0x37, r24	; 55
     a10:	08 95       	ret

00000a12 <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     a12:	31 e1       	ldi	r19, 0x11	; 17
     a14:	fc 01       	movw	r30, r24
     a16:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
     a18:	31 97       	sbiw	r30, 0x01	; 1
     a1a:	22 e2       	ldi	r18, 0x22	; 34
     a1c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
     a1e:	31 97       	sbiw	r30, 0x01	; 1
     a20:	a3 e3       	ldi	r26, 0x33	; 51
     a22:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     a24:	31 97       	sbiw	r30, 0x01	; 1
     a26:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     a28:	31 97       	sbiw	r30, 0x01	; 1
     a2a:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
     a2c:	31 97       	sbiw	r30, 0x01	; 1
     a2e:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     a30:	31 97       	sbiw	r30, 0x01	; 1
     a32:	60 e8       	ldi	r22, 0x80	; 128
     a34:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
     a36:	31 97       	sbiw	r30, 0x01	; 1
     a38:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
     a3a:	31 97       	sbiw	r30, 0x01	; 1
     a3c:	62 e0       	ldi	r22, 0x02	; 2
     a3e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
     a40:	31 97       	sbiw	r30, 0x01	; 1
     a42:	63 e0       	ldi	r22, 0x03	; 3
     a44:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
     a46:	31 97       	sbiw	r30, 0x01	; 1
     a48:	64 e0       	ldi	r22, 0x04	; 4
     a4a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
     a4c:	31 97       	sbiw	r30, 0x01	; 1
     a4e:	65 e0       	ldi	r22, 0x05	; 5
     a50:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
     a52:	31 97       	sbiw	r30, 0x01	; 1
     a54:	66 e0       	ldi	r22, 0x06	; 6
     a56:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
     a58:	31 97       	sbiw	r30, 0x01	; 1
     a5a:	67 e0       	ldi	r22, 0x07	; 7
     a5c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
     a5e:	31 97       	sbiw	r30, 0x01	; 1
     a60:	68 e0       	ldi	r22, 0x08	; 8
     a62:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
     a64:	31 97       	sbiw	r30, 0x01	; 1
     a66:	69 e0       	ldi	r22, 0x09	; 9
     a68:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
     a6a:	31 97       	sbiw	r30, 0x01	; 1
     a6c:	60 e1       	ldi	r22, 0x10	; 16
     a6e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
     a70:	31 97       	sbiw	r30, 0x01	; 1
     a72:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
     a74:	31 97       	sbiw	r30, 0x01	; 1
     a76:	32 e1       	ldi	r19, 0x12	; 18
     a78:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
     a7a:	31 97       	sbiw	r30, 0x01	; 1
     a7c:	33 e1       	ldi	r19, 0x13	; 19
     a7e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
     a80:	31 97       	sbiw	r30, 0x01	; 1
     a82:	34 e1       	ldi	r19, 0x14	; 20
     a84:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
     a86:	31 97       	sbiw	r30, 0x01	; 1
     a88:	35 e1       	ldi	r19, 0x15	; 21
     a8a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
     a8c:	31 97       	sbiw	r30, 0x01	; 1
     a8e:	36 e1       	ldi	r19, 0x16	; 22
     a90:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
     a92:	31 97       	sbiw	r30, 0x01	; 1
     a94:	37 e1       	ldi	r19, 0x17	; 23
     a96:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
     a98:	31 97       	sbiw	r30, 0x01	; 1
     a9a:	38 e1       	ldi	r19, 0x18	; 24
     a9c:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
     a9e:	31 97       	sbiw	r30, 0x01	; 1
     aa0:	39 e1       	ldi	r19, 0x19	; 25
     aa2:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
     aa4:	31 97       	sbiw	r30, 0x01	; 1
     aa6:	30 e2       	ldi	r19, 0x20	; 32
     aa8:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
     aaa:	31 97       	sbiw	r30, 0x01	; 1
     aac:	31 e2       	ldi	r19, 0x21	; 33
     aae:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
     ab0:	31 97       	sbiw	r30, 0x01	; 1
     ab2:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
     ab4:	31 97       	sbiw	r30, 0x01	; 1
     ab6:	23 e2       	ldi	r18, 0x23	; 35
     ab8:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     aba:	31 97       	sbiw	r30, 0x01	; 1
     abc:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     abe:	31 97       	sbiw	r30, 0x01	; 1
     ac0:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
     ac2:	31 97       	sbiw	r30, 0x01	; 1
     ac4:	26 e2       	ldi	r18, 0x26	; 38
     ac6:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
     ac8:	31 97       	sbiw	r30, 0x01	; 1
     aca:	27 e2       	ldi	r18, 0x27	; 39
     acc:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
     ace:	31 97       	sbiw	r30, 0x01	; 1
     ad0:	28 e2       	ldi	r18, 0x28	; 40
     ad2:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
     ad4:	31 97       	sbiw	r30, 0x01	; 1
     ad6:	29 e2       	ldi	r18, 0x29	; 41
     ad8:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
     ada:	31 97       	sbiw	r30, 0x01	; 1
     adc:	20 e3       	ldi	r18, 0x30	; 48
     ade:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
     ae0:	31 97       	sbiw	r30, 0x01	; 1
     ae2:	21 e3       	ldi	r18, 0x31	; 49
     ae4:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
     ae6:	86 97       	sbiw	r24, 0x26	; 38
     ae8:	08 95       	ret

00000aea <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
     aea:	0e 94 ff 04 	call	0x9fe	; 0x9fe <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     aee:	a0 91 b9 0d 	lds	r26, 0x0DB9	; 0x800db9 <pxCurrentTCB>
     af2:	b0 91 ba 0d 	lds	r27, 0x0DBA	; 0x800dba <pxCurrentTCB+0x1>
     af6:	cd 91       	ld	r28, X+
     af8:	cd bf       	out	0x3d, r28	; 61
     afa:	dd 91       	ld	r29, X+
     afc:	de bf       	out	0x3e, r29	; 62
     afe:	ff 91       	pop	r31
     b00:	ef 91       	pop	r30
     b02:	df 91       	pop	r29
     b04:	cf 91       	pop	r28
     b06:	bf 91       	pop	r27
     b08:	af 91       	pop	r26
     b0a:	9f 91       	pop	r25
     b0c:	8f 91       	pop	r24
     b0e:	7f 91       	pop	r23
     b10:	6f 91       	pop	r22
     b12:	5f 91       	pop	r21
     b14:	4f 91       	pop	r20
     b16:	3f 91       	pop	r19
     b18:	2f 91       	pop	r18
     b1a:	1f 91       	pop	r17
     b1c:	0f 91       	pop	r16
     b1e:	ff 90       	pop	r15
     b20:	ef 90       	pop	r14
     b22:	df 90       	pop	r13
     b24:	cf 90       	pop	r12
     b26:	bf 90       	pop	r11
     b28:	af 90       	pop	r10
     b2a:	9f 90       	pop	r9
     b2c:	8f 90       	pop	r8
     b2e:	7f 90       	pop	r7
     b30:	6f 90       	pop	r6
     b32:	5f 90       	pop	r5
     b34:	4f 90       	pop	r4
     b36:	3f 90       	pop	r3
     b38:	2f 90       	pop	r2
     b3a:	1f 90       	pop	r1
     b3c:	0f 90       	pop	r0
     b3e:	0f be       	out	0x3f, r0	; 63
     b40:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     b42:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
     b44:	81 e0       	ldi	r24, 0x01	; 1
     b46:	08 95       	ret

00000b48 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     b48:	08 95       	ret

00000b4a <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     b4a:	0f 92       	push	r0
     b4c:	0f b6       	in	r0, 0x3f	; 63
     b4e:	f8 94       	cli
     b50:	0f 92       	push	r0
     b52:	1f 92       	push	r1
     b54:	11 24       	eor	r1, r1
     b56:	2f 92       	push	r2
     b58:	3f 92       	push	r3
     b5a:	4f 92       	push	r4
     b5c:	5f 92       	push	r5
     b5e:	6f 92       	push	r6
     b60:	7f 92       	push	r7
     b62:	8f 92       	push	r8
     b64:	9f 92       	push	r9
     b66:	af 92       	push	r10
     b68:	bf 92       	push	r11
     b6a:	cf 92       	push	r12
     b6c:	df 92       	push	r13
     b6e:	ef 92       	push	r14
     b70:	ff 92       	push	r15
     b72:	0f 93       	push	r16
     b74:	1f 93       	push	r17
     b76:	2f 93       	push	r18
     b78:	3f 93       	push	r19
     b7a:	4f 93       	push	r20
     b7c:	5f 93       	push	r21
     b7e:	6f 93       	push	r22
     b80:	7f 93       	push	r23
     b82:	8f 93       	push	r24
     b84:	9f 93       	push	r25
     b86:	af 93       	push	r26
     b88:	bf 93       	push	r27
     b8a:	cf 93       	push	r28
     b8c:	df 93       	push	r29
     b8e:	ef 93       	push	r30
     b90:	ff 93       	push	r31
     b92:	a0 91 b9 0d 	lds	r26, 0x0DB9	; 0x800db9 <pxCurrentTCB>
     b96:	b0 91 ba 0d 	lds	r27, 0x0DBA	; 0x800dba <pxCurrentTCB+0x1>
     b9a:	0d b6       	in	r0, 0x3d	; 61
     b9c:	0d 92       	st	X+, r0
     b9e:	0e b6       	in	r0, 0x3e	; 62
     ba0:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     ba2:	0e 94 b2 0e 	call	0x1d64	; 0x1d64 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     ba6:	a0 91 b9 0d 	lds	r26, 0x0DB9	; 0x800db9 <pxCurrentTCB>
     baa:	b0 91 ba 0d 	lds	r27, 0x0DBA	; 0x800dba <pxCurrentTCB+0x1>
     bae:	cd 91       	ld	r28, X+
     bb0:	cd bf       	out	0x3d, r28	; 61
     bb2:	dd 91       	ld	r29, X+
     bb4:	de bf       	out	0x3e, r29	; 62
     bb6:	ff 91       	pop	r31
     bb8:	ef 91       	pop	r30
     bba:	df 91       	pop	r29
     bbc:	cf 91       	pop	r28
     bbe:	bf 91       	pop	r27
     bc0:	af 91       	pop	r26
     bc2:	9f 91       	pop	r25
     bc4:	8f 91       	pop	r24
     bc6:	7f 91       	pop	r23
     bc8:	6f 91       	pop	r22
     bca:	5f 91       	pop	r21
     bcc:	4f 91       	pop	r20
     bce:	3f 91       	pop	r19
     bd0:	2f 91       	pop	r18
     bd2:	1f 91       	pop	r17
     bd4:	0f 91       	pop	r16
     bd6:	ff 90       	pop	r15
     bd8:	ef 90       	pop	r14
     bda:	df 90       	pop	r13
     bdc:	cf 90       	pop	r12
     bde:	bf 90       	pop	r11
     be0:	af 90       	pop	r10
     be2:	9f 90       	pop	r9
     be4:	8f 90       	pop	r8
     be6:	7f 90       	pop	r7
     be8:	6f 90       	pop	r6
     bea:	5f 90       	pop	r5
     bec:	4f 90       	pop	r4
     bee:	3f 90       	pop	r3
     bf0:	2f 90       	pop	r2
     bf2:	1f 90       	pop	r1
     bf4:	0f 90       	pop	r0
     bf6:	0f be       	out	0x3f, r0	; 63
     bf8:	0f 90       	pop	r0

	asm volatile ( "ret" );
     bfa:	08 95       	ret

00000bfc <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     bfc:	0f 92       	push	r0
     bfe:	0f b6       	in	r0, 0x3f	; 63
     c00:	f8 94       	cli
     c02:	0f 92       	push	r0
     c04:	1f 92       	push	r1
     c06:	11 24       	eor	r1, r1
     c08:	2f 92       	push	r2
     c0a:	3f 92       	push	r3
     c0c:	4f 92       	push	r4
     c0e:	5f 92       	push	r5
     c10:	6f 92       	push	r6
     c12:	7f 92       	push	r7
     c14:	8f 92       	push	r8
     c16:	9f 92       	push	r9
     c18:	af 92       	push	r10
     c1a:	bf 92       	push	r11
     c1c:	cf 92       	push	r12
     c1e:	df 92       	push	r13
     c20:	ef 92       	push	r14
     c22:	ff 92       	push	r15
     c24:	0f 93       	push	r16
     c26:	1f 93       	push	r17
     c28:	2f 93       	push	r18
     c2a:	3f 93       	push	r19
     c2c:	4f 93       	push	r20
     c2e:	5f 93       	push	r21
     c30:	6f 93       	push	r22
     c32:	7f 93       	push	r23
     c34:	8f 93       	push	r24
     c36:	9f 93       	push	r25
     c38:	af 93       	push	r26
     c3a:	bf 93       	push	r27
     c3c:	cf 93       	push	r28
     c3e:	df 93       	push	r29
     c40:	ef 93       	push	r30
     c42:	ff 93       	push	r31
     c44:	a0 91 b9 0d 	lds	r26, 0x0DB9	; 0x800db9 <pxCurrentTCB>
     c48:	b0 91 ba 0d 	lds	r27, 0x0DBA	; 0x800dba <pxCurrentTCB+0x1>
     c4c:	0d b6       	in	r0, 0x3d	; 61
     c4e:	0d 92       	st	X+, r0
     c50:	0e b6       	in	r0, 0x3e	; 62
     c52:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     c54:	0e 94 2f 0d 	call	0x1a5e	; 0x1a5e <xTaskIncrementTick>
     c58:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     c5a:	0e 94 b2 0e 	call	0x1d64	; 0x1d64 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     c5e:	a0 91 b9 0d 	lds	r26, 0x0DB9	; 0x800db9 <pxCurrentTCB>
     c62:	b0 91 ba 0d 	lds	r27, 0x0DBA	; 0x800dba <pxCurrentTCB+0x1>
     c66:	cd 91       	ld	r28, X+
     c68:	cd bf       	out	0x3d, r28	; 61
     c6a:	dd 91       	ld	r29, X+
     c6c:	de bf       	out	0x3e, r29	; 62
     c6e:	ff 91       	pop	r31
     c70:	ef 91       	pop	r30
     c72:	df 91       	pop	r29
     c74:	cf 91       	pop	r28
     c76:	bf 91       	pop	r27
     c78:	af 91       	pop	r26
     c7a:	9f 91       	pop	r25
     c7c:	8f 91       	pop	r24
     c7e:	7f 91       	pop	r23
     c80:	6f 91       	pop	r22
     c82:	5f 91       	pop	r21
     c84:	4f 91       	pop	r20
     c86:	3f 91       	pop	r19
     c88:	2f 91       	pop	r18
     c8a:	1f 91       	pop	r17
     c8c:	0f 91       	pop	r16
     c8e:	ff 90       	pop	r15
     c90:	ef 90       	pop	r14
     c92:	df 90       	pop	r13
     c94:	cf 90       	pop	r12
     c96:	bf 90       	pop	r11
     c98:	af 90       	pop	r10
     c9a:	9f 90       	pop	r9
     c9c:	8f 90       	pop	r8
     c9e:	7f 90       	pop	r7
     ca0:	6f 90       	pop	r6
     ca2:	5f 90       	pop	r5
     ca4:	4f 90       	pop	r4
     ca6:	3f 90       	pop	r3
     ca8:	2f 90       	pop	r2
     caa:	1f 90       	pop	r1
     cac:	0f 90       	pop	r0
     cae:	0f be       	out	0x3f, r0	; 63
     cb0:	0f 90       	pop	r0

	asm volatile ( "ret" );
     cb2:	08 95       	ret

00000cb4 <__vector_12>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     cb4:	0e 94 fe 05 	call	0xbfc	; 0xbfc <vPortYieldFromTick>
		asm volatile ( "reti" );
     cb8:	18 95       	reti

00000cba <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     cba:	cf 93       	push	r28
     cbc:	df 93       	push	r29
     cbe:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
     cc0:	0e 94 0f 0d 	call	0x1a1e	; 0x1a1e <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     cc4:	80 91 64 01 	lds	r24, 0x0164	; 0x800164 <pucAlignedHeap.2069>
     cc8:	90 91 65 01 	lds	r25, 0x0165	; 0x800165 <pucAlignedHeap.2069+0x1>
     ccc:	89 2b       	or	r24, r25
     cce:	31 f4       	brne	.+12     	; 0xcdc <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     cd0:	89 e6       	ldi	r24, 0x69	; 105
     cd2:	91 e0       	ldi	r25, 0x01	; 1
     cd4:	90 93 65 01 	sts	0x0165, r25	; 0x800165 <pucAlignedHeap.2069+0x1>
     cd8:	80 93 64 01 	sts	0x0164, r24	; 0x800164 <pucAlignedHeap.2069>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     cdc:	20 91 66 01 	lds	r18, 0x0166	; 0x800166 <xNextFreeByte>
     ce0:	30 91 67 01 	lds	r19, 0x0167	; 0x800167 <xNextFreeByte+0x1>
     ce4:	c9 01       	movw	r24, r18
     ce6:	8c 0f       	add	r24, r28
     ce8:	9d 1f       	adc	r25, r29
     cea:	8f 3f       	cpi	r24, 0xFF	; 255
     cec:	4b e0       	ldi	r20, 0x0B	; 11
     cee:	94 07       	cpc	r25, r20
     cf0:	70 f4       	brcc	.+28     	; 0xd0e <pvPortMalloc+0x54>
     cf2:	28 17       	cp	r18, r24
     cf4:	39 07       	cpc	r19, r25
     cf6:	70 f4       	brcc	.+28     	; 0xd14 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     cf8:	c0 91 64 01 	lds	r28, 0x0164	; 0x800164 <pucAlignedHeap.2069>
     cfc:	d0 91 65 01 	lds	r29, 0x0165	; 0x800165 <pucAlignedHeap.2069+0x1>
     d00:	c2 0f       	add	r28, r18
     d02:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
     d04:	90 93 67 01 	sts	0x0167, r25	; 0x800167 <xNextFreeByte+0x1>
     d08:	80 93 66 01 	sts	0x0166, r24	; 0x800166 <xNextFreeByte>
     d0c:	05 c0       	rjmp	.+10     	; 0xd18 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     d0e:	c0 e0       	ldi	r28, 0x00	; 0
     d10:	d0 e0       	ldi	r29, 0x00	; 0
     d12:	02 c0       	rjmp	.+4      	; 0xd18 <pvPortMalloc+0x5e>
     d14:	c0 e0       	ldi	r28, 0x00	; 0
     d16:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     d18:	0e 94 e9 0d 	call	0x1bd2	; 0x1bd2 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     d1c:	ce 01       	movw	r24, r28
     d1e:	df 91       	pop	r29
     d20:	cf 91       	pop	r28
     d22:	08 95       	ret

00000d24 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     d24:	08 95       	ret

00000d26 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
     d26:	10 92 67 01 	sts	0x0167, r1	; 0x800167 <xNextFreeByte+0x1>
     d2a:	10 92 66 01 	sts	0x0166, r1	; 0x800166 <xNextFreeByte>
     d2e:	08 95       	ret

00000d30 <xPortGetFreeHeapSize>:
}
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
     d30:	20 91 66 01 	lds	r18, 0x0166	; 0x800166 <xNextFreeByte>
     d34:	30 91 67 01 	lds	r19, 0x0167	; 0x800167 <xNextFreeByte+0x1>
}
     d38:	8f ef       	ldi	r24, 0xFF	; 255
     d3a:	9b e0       	ldi	r25, 0x0B	; 11
     d3c:	82 1b       	sub	r24, r18
     d3e:	93 0b       	sbc	r25, r19
     d40:	08 95       	ret

00000d42 <prvIsQueueEmpty>:

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
     d42:	0f b6       	in	r0, 0x3f	; 63
     d44:	f8 94       	cli
     d46:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
     d48:	fc 01       	movw	r30, r24
     d4a:	82 8d       	ldd	r24, Z+26	; 0x1a
     d4c:	81 11       	cpse	r24, r1
     d4e:	02 c0       	rjmp	.+4      	; 0xd54 <prvIsQueueEmpty+0x12>
		{
			xReturn = pdTRUE;
     d50:	81 e0       	ldi	r24, 0x01	; 1
     d52:	01 c0       	rjmp	.+2      	; 0xd56 <prvIsQueueEmpty+0x14>
		}
		else
		{
			xReturn = pdFALSE;
     d54:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	taskEXIT_CRITICAL();
     d56:	0f 90       	pop	r0
     d58:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
     d5a:	08 95       	ret

00000d5c <prvIsQueueFull>:

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
     d5c:	0f b6       	in	r0, 0x3f	; 63
     d5e:	f8 94       	cli
     d60:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
     d62:	fc 01       	movw	r30, r24
     d64:	22 8d       	ldd	r18, Z+26	; 0x1a
     d66:	83 8d       	ldd	r24, Z+27	; 0x1b
     d68:	28 13       	cpse	r18, r24
     d6a:	02 c0       	rjmp	.+4      	; 0xd70 <prvIsQueueFull+0x14>
		{
			xReturn = pdTRUE;
     d6c:	81 e0       	ldi	r24, 0x01	; 1
     d6e:	01 c0       	rjmp	.+2      	; 0xd72 <prvIsQueueFull+0x16>
		}
		else
		{
			xReturn = pdFALSE;
     d70:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	taskEXIT_CRITICAL();
     d72:	0f 90       	pop	r0
     d74:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
     d76:	08 95       	ret

00000d78 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
     d78:	0f 93       	push	r16
     d7a:	1f 93       	push	r17
     d7c:	cf 93       	push	r28
     d7e:	df 93       	push	r29
     d80:	ec 01       	movw	r28, r24
     d82:	04 2f       	mov	r16, r20
BaseType_t xReturn = pdFALSE;
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
     d84:	1a 8d       	ldd	r17, Y+26	; 0x1a

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
     d86:	4c 8d       	ldd	r20, Y+28	; 0x1c
     d88:	41 11       	cpse	r20, r1
     d8a:	0c c0       	rjmp	.+24     	; 0xda4 <prvCopyDataToQueue+0x2c>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     d8c:	88 81       	ld	r24, Y
     d8e:	99 81       	ldd	r25, Y+1	; 0x01
     d90:	89 2b       	or	r24, r25
     d92:	09 f0       	breq	.+2      	; 0xd96 <prvCopyDataToQueue+0x1e>
     d94:	42 c0       	rjmp	.+132    	; 0xe1a <prvCopyDataToQueue+0xa2>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
     d96:	8a 81       	ldd	r24, Y+2	; 0x02
     d98:	9b 81       	ldd	r25, Y+3	; 0x03
     d9a:	0e 94 5b 10 	call	0x20b6	; 0x20b6 <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
     d9e:	1b 82       	std	Y+3, r1	; 0x03
     da0:	1a 82       	std	Y+2, r1	; 0x02
     da2:	42 c0       	rjmp	.+132    	; 0xe28 <prvCopyDataToQueue+0xb0>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
     da4:	01 11       	cpse	r16, r1
     da6:	17 c0       	rjmp	.+46     	; 0xdd6 <prvCopyDataToQueue+0x5e>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
     da8:	50 e0       	ldi	r21, 0x00	; 0
     daa:	8c 81       	ldd	r24, Y+4	; 0x04
     dac:	9d 81       	ldd	r25, Y+5	; 0x05
     dae:	0e 94 77 15 	call	0x2aee	; 0x2aee <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     db2:	2c 8d       	ldd	r18, Y+28	; 0x1c
     db4:	8c 81       	ldd	r24, Y+4	; 0x04
     db6:	9d 81       	ldd	r25, Y+5	; 0x05
     db8:	82 0f       	add	r24, r18
     dba:	91 1d       	adc	r25, r1
     dbc:	9d 83       	std	Y+5, r25	; 0x05
     dbe:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     dc0:	2a 81       	ldd	r18, Y+2	; 0x02
     dc2:	3b 81       	ldd	r19, Y+3	; 0x03
     dc4:	82 17       	cp	r24, r18
     dc6:	93 07       	cpc	r25, r19
     dc8:	50 f1       	brcs	.+84     	; 0xe1e <prvCopyDataToQueue+0xa6>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
     dca:	88 81       	ld	r24, Y
     dcc:	99 81       	ldd	r25, Y+1	; 0x01
     dce:	9d 83       	std	Y+5, r25	; 0x05
     dd0:	8c 83       	std	Y+4, r24	; 0x04
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
     dd2:	80 e0       	ldi	r24, 0x00	; 0
     dd4:	29 c0       	rjmp	.+82     	; 0xe28 <prvCopyDataToQueue+0xb0>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     dd6:	50 e0       	ldi	r21, 0x00	; 0
     dd8:	8e 81       	ldd	r24, Y+6	; 0x06
     dda:	9f 81       	ldd	r25, Y+7	; 0x07
     ddc:	0e 94 77 15 	call	0x2aee	; 0x2aee <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
     de0:	8c 8d       	ldd	r24, Y+28	; 0x1c
     de2:	90 e0       	ldi	r25, 0x00	; 0
     de4:	91 95       	neg	r25
     de6:	81 95       	neg	r24
     de8:	91 09       	sbc	r25, r1
     dea:	2e 81       	ldd	r18, Y+6	; 0x06
     dec:	3f 81       	ldd	r19, Y+7	; 0x07
     dee:	28 0f       	add	r18, r24
     df0:	39 1f       	adc	r19, r25
     df2:	3f 83       	std	Y+7, r19	; 0x07
     df4:	2e 83       	std	Y+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     df6:	48 81       	ld	r20, Y
     df8:	59 81       	ldd	r21, Y+1	; 0x01
     dfa:	24 17       	cp	r18, r20
     dfc:	35 07       	cpc	r19, r21
     dfe:	30 f4       	brcc	.+12     	; 0xe0c <prvCopyDataToQueue+0x94>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
     e00:	2a 81       	ldd	r18, Y+2	; 0x02
     e02:	3b 81       	ldd	r19, Y+3	; 0x03
     e04:	82 0f       	add	r24, r18
     e06:	93 1f       	adc	r25, r19
     e08:	9f 83       	std	Y+7, r25	; 0x07
     e0a:	8e 83       	std	Y+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
     e0c:	02 30       	cpi	r16, 0x02	; 2
     e0e:	49 f4       	brne	.+18     	; 0xe22 <prvCopyDataToQueue+0xaa>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
     e10:	11 23       	and	r17, r17
     e12:	49 f0       	breq	.+18     	; 0xe26 <prvCopyDataToQueue+0xae>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
     e14:	11 50       	subi	r17, 0x01	; 1
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
     e16:	80 e0       	ldi	r24, 0x00	; 0
     e18:	07 c0       	rjmp	.+14     	; 0xe28 <prvCopyDataToQueue+0xb0>
     e1a:	80 e0       	ldi	r24, 0x00	; 0
     e1c:	05 c0       	rjmp	.+10     	; 0xe28 <prvCopyDataToQueue+0xb0>
     e1e:	80 e0       	ldi	r24, 0x00	; 0
     e20:	03 c0       	rjmp	.+6      	; 0xe28 <prvCopyDataToQueue+0xb0>
     e22:	80 e0       	ldi	r24, 0x00	; 0
     e24:	01 c0       	rjmp	.+2      	; 0xe28 <prvCopyDataToQueue+0xb0>
     e26:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
     e28:	1f 5f       	subi	r17, 0xFF	; 255
     e2a:	1a 8f       	std	Y+26, r17	; 0x1a

	return xReturn;
}
     e2c:	df 91       	pop	r29
     e2e:	cf 91       	pop	r28
     e30:	1f 91       	pop	r17
     e32:	0f 91       	pop	r16
     e34:	08 95       	ret

00000e36 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
     e36:	fc 01       	movw	r30, r24
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
     e38:	44 8d       	ldd	r20, Z+28	; 0x1c
     e3a:	44 23       	and	r20, r20
     e3c:	a9 f0       	breq	.+42     	; 0xe68 <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
     e3e:	50 e0       	ldi	r21, 0x00	; 0
     e40:	26 81       	ldd	r18, Z+6	; 0x06
     e42:	37 81       	ldd	r19, Z+7	; 0x07
     e44:	24 0f       	add	r18, r20
     e46:	35 1f       	adc	r19, r21
     e48:	37 83       	std	Z+7, r19	; 0x07
     e4a:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
     e4c:	82 81       	ldd	r24, Z+2	; 0x02
     e4e:	93 81       	ldd	r25, Z+3	; 0x03
     e50:	28 17       	cp	r18, r24
     e52:	39 07       	cpc	r19, r25
     e54:	20 f0       	brcs	.+8      	; 0xe5e <prvCopyDataFromQueue+0x28>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
     e56:	80 81       	ld	r24, Z
     e58:	91 81       	ldd	r25, Z+1	; 0x01
     e5a:	97 83       	std	Z+7, r25	; 0x07
     e5c:	86 83       	std	Z+6, r24	; 0x06
     e5e:	cb 01       	movw	r24, r22
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
     e60:	66 81       	ldd	r22, Z+6	; 0x06
     e62:	77 81       	ldd	r23, Z+7	; 0x07
     e64:	0e 94 77 15 	call	0x2aee	; 0x2aee <memcpy>
     e68:	08 95       	ret

00000e6a <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
     e6a:	1f 93       	push	r17
     e6c:	cf 93       	push	r28
     e6e:	df 93       	push	r29
     e70:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
     e72:	0f b6       	in	r0, 0x3f	; 63
     e74:	f8 94       	cli
     e76:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
     e78:	1e 8d       	ldd	r17, Y+30	; 0x1e

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
     e7a:	0b c0       	rjmp	.+22     	; 0xe92 <prvUnlockQueue+0x28>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     e7c:	89 89       	ldd	r24, Y+17	; 0x11
     e7e:	88 23       	and	r24, r24
     e80:	51 f0       	breq	.+20     	; 0xe96 <prvUnlockQueue+0x2c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     e82:	ce 01       	movw	r24, r28
     e84:	41 96       	adiw	r24, 0x11	; 17
     e86:	0e 94 31 0f 	call	0x1e62	; 0x1e62 <xTaskRemoveFromEventList>
     e8a:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
     e8c:	0e 94 f0 0f 	call	0x1fe0	; 0x1fe0 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
     e90:	11 50       	subi	r17, 0x01	; 1
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
     e92:	11 16       	cp	r1, r17
     e94:	9c f3       	brlt	.-26     	; 0xe7c <prvUnlockQueue+0x12>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
     e96:	8f ef       	ldi	r24, 0xFF	; 255
     e98:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
     e9a:	0f 90       	pop	r0
     e9c:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
     e9e:	0f b6       	in	r0, 0x3f	; 63
     ea0:	f8 94       	cli
     ea2:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
     ea4:	1d 8d       	ldd	r17, Y+29	; 0x1d

		while( cRxLock > queueLOCKED_UNMODIFIED )
     ea6:	0b c0       	rjmp	.+22     	; 0xebe <prvUnlockQueue+0x54>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     ea8:	88 85       	ldd	r24, Y+8	; 0x08
     eaa:	88 23       	and	r24, r24
     eac:	51 f0       	breq	.+20     	; 0xec2 <prvUnlockQueue+0x58>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     eae:	ce 01       	movw	r24, r28
     eb0:	08 96       	adiw	r24, 0x08	; 8
     eb2:	0e 94 31 0f 	call	0x1e62	; 0x1e62 <xTaskRemoveFromEventList>
     eb6:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
     eb8:	0e 94 f0 0f 	call	0x1fe0	; 0x1fe0 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
     ebc:	11 50       	subi	r17, 0x01	; 1
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
     ebe:	11 16       	cp	r1, r17
     ec0:	9c f3       	brlt	.-26     	; 0xea8 <prvUnlockQueue+0x3e>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
     ec2:	8f ef       	ldi	r24, 0xFF	; 255
     ec4:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
     ec6:	0f 90       	pop	r0
     ec8:	0f be       	out	0x3f, r0	; 63
}
     eca:	df 91       	pop	r29
     ecc:	cf 91       	pop	r28
     ece:	1f 91       	pop	r17
     ed0:	08 95       	ret

00000ed2 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
     ed2:	cf 93       	push	r28
     ed4:	df 93       	push	r29
     ed6:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
     ed8:	0f b6       	in	r0, 0x3f	; 63
     eda:	f8 94       	cli
     edc:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
     ede:	e8 81       	ld	r30, Y
     ee0:	f9 81       	ldd	r31, Y+1	; 0x01
     ee2:	8b 8d       	ldd	r24, Y+27	; 0x1b
     ee4:	90 e0       	ldi	r25, 0x00	; 0
     ee6:	2c 8d       	ldd	r18, Y+28	; 0x1c
     ee8:	30 e0       	ldi	r19, 0x00	; 0
     eea:	82 9f       	mul	r24, r18
     eec:	a0 01       	movw	r20, r0
     eee:	83 9f       	mul	r24, r19
     ef0:	50 0d       	add	r21, r0
     ef2:	92 9f       	mul	r25, r18
     ef4:	50 0d       	add	r21, r0
     ef6:	11 24       	eor	r1, r1
     ef8:	4e 0f       	add	r20, r30
     efa:	5f 1f       	adc	r21, r31
     efc:	5b 83       	std	Y+3, r21	; 0x03
     efe:	4a 83       	std	Y+2, r20	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
     f00:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
     f02:	fd 83       	std	Y+5, r31	; 0x05
     f04:	ec 83       	std	Y+4, r30	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
     f06:	01 97       	sbiw	r24, 0x01	; 1
     f08:	28 9f       	mul	r18, r24
     f0a:	a0 01       	movw	r20, r0
     f0c:	29 9f       	mul	r18, r25
     f0e:	50 0d       	add	r21, r0
     f10:	38 9f       	mul	r19, r24
     f12:	50 0d       	add	r21, r0
     f14:	11 24       	eor	r1, r1
     f16:	cf 01       	movw	r24, r30
     f18:	84 0f       	add	r24, r20
     f1a:	95 1f       	adc	r25, r21
     f1c:	9f 83       	std	Y+7, r25	; 0x07
     f1e:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
     f20:	8f ef       	ldi	r24, 0xFF	; 255
     f22:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
     f24:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
     f26:	61 11       	cpse	r22, r1
     f28:	0c c0       	rjmp	.+24     	; 0xf42 <xQueueGenericReset+0x70>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     f2a:	88 85       	ldd	r24, Y+8	; 0x08
     f2c:	88 23       	and	r24, r24
     f2e:	89 f0       	breq	.+34     	; 0xf52 <xQueueGenericReset+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     f30:	ce 01       	movw	r24, r28
     f32:	08 96       	adiw	r24, 0x08	; 8
     f34:	0e 94 31 0f 	call	0x1e62	; 0x1e62 <xTaskRemoveFromEventList>
     f38:	88 23       	and	r24, r24
     f3a:	59 f0       	breq	.+22     	; 0xf52 <xQueueGenericReset+0x80>
				{
					queueYIELD_IF_USING_PREEMPTION();
     f3c:	0e 94 a5 05 	call	0xb4a	; 0xb4a <vPortYield>
     f40:	08 c0       	rjmp	.+16     	; 0xf52 <xQueueGenericReset+0x80>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
     f42:	ce 01       	movw	r24, r28
     f44:	08 96       	adiw	r24, 0x08	; 8
     f46:	0e 94 75 04 	call	0x8ea	; 0x8ea <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
     f4a:	ce 01       	movw	r24, r28
     f4c:	41 96       	adiw	r24, 0x11	; 17
     f4e:	0e 94 75 04 	call	0x8ea	; 0x8ea <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
     f52:	0f 90       	pop	r0
     f54:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
     f56:	81 e0       	ldi	r24, 0x01	; 1
     f58:	df 91       	pop	r29
     f5a:	cf 91       	pop	r28
     f5c:	08 95       	ret

00000f5e <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
     f5e:	0f 93       	push	r16
     f60:	1f 93       	push	r17
     f62:	f8 01       	movw	r30, r16
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
     f64:	61 11       	cpse	r22, r1
     f66:	03 c0       	rjmp	.+6      	; 0xf6e <prvInitialiseNewQueue+0x10>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
     f68:	11 83       	std	Z+1, r17	; 0x01
     f6a:	00 83       	st	Z, r16
     f6c:	02 c0       	rjmp	.+4      	; 0xf72 <prvInitialiseNewQueue+0x14>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
     f6e:	51 83       	std	Z+1, r21	; 0x01
     f70:	40 83       	st	Z, r20
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
     f72:	83 8f       	std	Z+27, r24	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
     f74:	64 8f       	std	Z+28, r22	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
     f76:	61 e0       	ldi	r22, 0x01	; 1
     f78:	cf 01       	movw	r24, r30
     f7a:	0e 94 69 07 	call	0xed2	; 0xed2 <xQueueGenericReset>
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
     f7e:	1f 91       	pop	r17
     f80:	0f 91       	pop	r16
     f82:	08 95       	ret

00000f84 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
     f84:	df 92       	push	r13
     f86:	ef 92       	push	r14
     f88:	ff 92       	push	r15
     f8a:	0f 93       	push	r16
     f8c:	1f 93       	push	r17
     f8e:	cf 93       	push	r28
     f90:	df 93       	push	r29
     f92:	e8 2e       	mov	r14, r24
     f94:	f6 2e       	mov	r15, r22
     f96:	d4 2e       	mov	r13, r20
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
     f98:	66 23       	and	r22, r22
     f9a:	21 f0       	breq	.+8      	; 0xfa4 <xQueueGenericCreate+0x20>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     f9c:	86 9f       	mul	r24, r22
     f9e:	c0 01       	movw	r24, r0
     fa0:	11 24       	eor	r1, r1
     fa2:	02 c0       	rjmp	.+4      	; 0xfa8 <xQueueGenericCreate+0x24>
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
     fa4:	80 e0       	ldi	r24, 0x00	; 0
     fa6:	90 e0       	ldi	r25, 0x00	; 0
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
		}

		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
     fa8:	4f 96       	adiw	r24, 0x1f	; 31
     faa:	0e 94 5d 06 	call	0xcba	; 0xcba <pvPortMalloc>
     fae:	ec 01       	movw	r28, r24

		if( pxNewQueue != NULL )
     fb0:	00 97       	sbiw	r24, 0x00	; 0
     fb2:	49 f0       	breq	.+18     	; 0xfc6 <xQueueGenericCreate+0x42>
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
     fb4:	8c 01       	movw	r16, r24
     fb6:	2d 2d       	mov	r18, r13
     fb8:	ac 01       	movw	r20, r24
     fba:	41 5e       	subi	r20, 0xE1	; 225
     fbc:	5f 4f       	sbci	r21, 0xFF	; 255
     fbe:	6f 2d       	mov	r22, r15
     fc0:	8e 2d       	mov	r24, r14
     fc2:	0e 94 af 07 	call	0xf5e	; 0xf5e <prvInitialiseNewQueue>
		}

		return pxNewQueue;
	}
     fc6:	ce 01       	movw	r24, r28
     fc8:	df 91       	pop	r29
     fca:	cf 91       	pop	r28
     fcc:	1f 91       	pop	r17
     fce:	0f 91       	pop	r16
     fd0:	ff 90       	pop	r15
     fd2:	ef 90       	pop	r14
     fd4:	df 90       	pop	r13
     fd6:	08 95       	ret

00000fd8 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
     fd8:	cf 92       	push	r12
     fda:	df 92       	push	r13
     fdc:	ef 92       	push	r14
     fde:	ff 92       	push	r15
     fe0:	0f 93       	push	r16
     fe2:	1f 93       	push	r17
     fe4:	cf 93       	push	r28
     fe6:	df 93       	push	r29
     fe8:	00 d0       	rcall	.+0      	; 0xfea <xQueueGenericSend+0x12>
     fea:	00 d0       	rcall	.+0      	; 0xfec <xQueueGenericSend+0x14>
     fec:	1f 92       	push	r1
     fee:	cd b7       	in	r28, 0x3d	; 61
     ff0:	de b7       	in	r29, 0x3e	; 62
     ff2:	8c 01       	movw	r16, r24
     ff4:	7b 01       	movw	r14, r22
     ff6:	5d 83       	std	Y+5, r21	; 0x05
     ff8:	4c 83       	std	Y+4, r20	; 0x04
     ffa:	c2 2e       	mov	r12, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
     ffc:	d1 2c       	mov	r13, r1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
     ffe:	0f b6       	in	r0, 0x3f	; 63
    1000:	f8 94       	cli
    1002:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1004:	f8 01       	movw	r30, r16
    1006:	92 8d       	ldd	r25, Z+26	; 0x1a
    1008:	83 8d       	ldd	r24, Z+27	; 0x1b
    100a:	98 17       	cp	r25, r24
    100c:	18 f0       	brcs	.+6      	; 0x1014 <xQueueGenericSend+0x3c>
    100e:	f2 e0       	ldi	r31, 0x02	; 2
    1010:	cf 12       	cpse	r12, r31
    1012:	19 c0       	rjmp	.+50     	; 0x1046 <xQueueGenericSend+0x6e>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1014:	4c 2d       	mov	r20, r12
    1016:	b7 01       	movw	r22, r14
    1018:	c8 01       	movw	r24, r16
    101a:	0e 94 bc 06 	call	0xd78	; 0xd78 <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    101e:	f8 01       	movw	r30, r16
    1020:	91 89       	ldd	r25, Z+17	; 0x11
    1022:	99 23       	and	r25, r25
    1024:	49 f0       	breq	.+18     	; 0x1038 <xQueueGenericSend+0x60>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1026:	c8 01       	movw	r24, r16
    1028:	41 96       	adiw	r24, 0x11	; 17
    102a:	0e 94 31 0f 	call	0x1e62	; 0x1e62 <xTaskRemoveFromEventList>
    102e:	88 23       	and	r24, r24
    1030:	31 f0       	breq	.+12     	; 0x103e <xQueueGenericSend+0x66>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    1032:	0e 94 a5 05 	call	0xb4a	; 0xb4a <vPortYield>
    1036:	03 c0       	rjmp	.+6      	; 0x103e <xQueueGenericSend+0x66>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    1038:	81 11       	cpse	r24, r1
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    103a:	0e 94 a5 05 	call	0xb4a	; 0xb4a <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    103e:	0f 90       	pop	r0
    1040:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1042:	81 e0       	ldi	r24, 0x01	; 1
    1044:	4d c0       	rjmp	.+154    	; 0x10e0 <xQueueGenericSend+0x108>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1046:	8c 81       	ldd	r24, Y+4	; 0x04
    1048:	9d 81       	ldd	r25, Y+5	; 0x05
    104a:	89 2b       	or	r24, r25
    104c:	21 f4       	brne	.+8      	; 0x1056 <xQueueGenericSend+0x7e>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    104e:	0f 90       	pop	r0
    1050:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1052:	80 e0       	ldi	r24, 0x00	; 0
    1054:	45 c0       	rjmp	.+138    	; 0x10e0 <xQueueGenericSend+0x108>
				}
				else if( xEntryTimeSet == pdFALSE )
    1056:	d1 10       	cpse	r13, r1
    1058:	06 c0       	rjmp	.+12     	; 0x1066 <xQueueGenericSend+0x8e>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    105a:	ce 01       	movw	r24, r28
    105c:	01 96       	adiw	r24, 0x01	; 1
    105e:	0e 94 b3 0f 	call	0x1f66	; 0x1f66 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1062:	dd 24       	eor	r13, r13
    1064:	d3 94       	inc	r13
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1066:	0f 90       	pop	r0
    1068:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    106a:	0e 94 0f 0d 	call	0x1a1e	; 0x1a1e <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    106e:	0f b6       	in	r0, 0x3f	; 63
    1070:	f8 94       	cli
    1072:	0f 92       	push	r0
    1074:	f8 01       	movw	r30, r16
    1076:	85 8d       	ldd	r24, Z+29	; 0x1d
    1078:	8f 3f       	cpi	r24, 0xFF	; 255
    107a:	09 f4       	brne	.+2      	; 0x107e <xQueueGenericSend+0xa6>
    107c:	15 8e       	std	Z+29, r1	; 0x1d
    107e:	f8 01       	movw	r30, r16
    1080:	86 8d       	ldd	r24, Z+30	; 0x1e
    1082:	8f 3f       	cpi	r24, 0xFF	; 255
    1084:	09 f4       	brne	.+2      	; 0x1088 <xQueueGenericSend+0xb0>
    1086:	16 8e       	std	Z+30, r1	; 0x1e
    1088:	0f 90       	pop	r0
    108a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    108c:	be 01       	movw	r22, r28
    108e:	6c 5f       	subi	r22, 0xFC	; 252
    1090:	7f 4f       	sbci	r23, 0xFF	; 255
    1092:	ce 01       	movw	r24, r28
    1094:	01 96       	adiw	r24, 0x01	; 1
    1096:	0e 94 be 0f 	call	0x1f7c	; 0x1f7c <xTaskCheckForTimeOut>
    109a:	81 11       	cpse	r24, r1
    109c:	1b c0       	rjmp	.+54     	; 0x10d4 <xQueueGenericSend+0xfc>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    109e:	c8 01       	movw	r24, r16
    10a0:	0e 94 ae 06 	call	0xd5c	; 0xd5c <prvIsQueueFull>
    10a4:	88 23       	and	r24, r24
    10a6:	81 f0       	breq	.+32     	; 0x10c8 <xQueueGenericSend+0xf0>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    10a8:	6c 81       	ldd	r22, Y+4	; 0x04
    10aa:	7d 81       	ldd	r23, Y+5	; 0x05
    10ac:	c8 01       	movw	r24, r16
    10ae:	08 96       	adiw	r24, 0x08	; 8
    10b0:	0e 94 06 0f 	call	0x1e0c	; 0x1e0c <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    10b4:	c8 01       	movw	r24, r16
    10b6:	0e 94 35 07 	call	0xe6a	; 0xe6a <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    10ba:	0e 94 e9 0d 	call	0x1bd2	; 0x1bd2 <xTaskResumeAll>
    10be:	81 11       	cpse	r24, r1
    10c0:	9e cf       	rjmp	.-196    	; 0xffe <xQueueGenericSend+0x26>
				{
					portYIELD_WITHIN_API();
    10c2:	0e 94 a5 05 	call	0xb4a	; 0xb4a <vPortYield>
    10c6:	9b cf       	rjmp	.-202    	; 0xffe <xQueueGenericSend+0x26>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    10c8:	c8 01       	movw	r24, r16
    10ca:	0e 94 35 07 	call	0xe6a	; 0xe6a <prvUnlockQueue>
				( void ) xTaskResumeAll();
    10ce:	0e 94 e9 0d 	call	0x1bd2	; 0x1bd2 <xTaskResumeAll>
    10d2:	95 cf       	rjmp	.-214    	; 0xffe <xQueueGenericSend+0x26>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    10d4:	c8 01       	movw	r24, r16
    10d6:	0e 94 35 07 	call	0xe6a	; 0xe6a <prvUnlockQueue>
			( void ) xTaskResumeAll();
    10da:	0e 94 e9 0d 	call	0x1bd2	; 0x1bd2 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    10de:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    10e0:	0f 90       	pop	r0
    10e2:	0f 90       	pop	r0
    10e4:	0f 90       	pop	r0
    10e6:	0f 90       	pop	r0
    10e8:	0f 90       	pop	r0
    10ea:	df 91       	pop	r29
    10ec:	cf 91       	pop	r28
    10ee:	1f 91       	pop	r17
    10f0:	0f 91       	pop	r16
    10f2:	ff 90       	pop	r15
    10f4:	ef 90       	pop	r14
    10f6:	df 90       	pop	r13
    10f8:	cf 90       	pop	r12
    10fa:	08 95       	ret

000010fc <prvInitialiseMutex>:

#if( configUSE_MUTEXES == 1 )

	static void prvInitialiseMutex( Queue_t *pxNewQueue )
	{
		if( pxNewQueue != NULL )
    10fc:	00 97       	sbiw	r24, 0x00	; 0
    10fe:	69 f0       	breq	.+26     	; 0x111a <__stack+0x1b>
    1100:	fc 01       	movw	r30, r24
		{
			/* The queue create function will set all the queue structure members
			correctly for a generic queue, but this function is creating a
			mutex.  Overwrite those members that need to be set differently -
			in particular the information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    1102:	13 82       	std	Z+3, r1	; 0x03
    1104:	12 82       	std	Z+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    1106:	11 82       	std	Z+1, r1	; 0x01
    1108:	10 82       	st	Z, r1

			/* In case this is a recursive mutex. */
			pxNewQueue->u.uxRecursiveCallCount = 0;
    110a:	16 82       	std	Z+6, r1	; 0x06

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    110c:	20 e0       	ldi	r18, 0x00	; 0
    110e:	40 e0       	ldi	r20, 0x00	; 0
    1110:	50 e0       	ldi	r21, 0x00	; 0
    1112:	60 e0       	ldi	r22, 0x00	; 0
    1114:	70 e0       	ldi	r23, 0x00	; 0
    1116:	0e 94 ec 07 	call	0xfd8	; 0xfd8 <xQueueGenericSend>
    111a:	08 95       	ret

0000111c <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    111c:	cf 93       	push	r28
    111e:	df 93       	push	r29
	Queue_t *pxNewQueue;
	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;

		pxNewQueue = ( Queue_t * ) xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
    1120:	48 2f       	mov	r20, r24
    1122:	60 e0       	ldi	r22, 0x00	; 0
    1124:	81 e0       	ldi	r24, 0x01	; 1
    1126:	0e 94 c2 07 	call	0xf84	; 0xf84 <xQueueGenericCreate>
    112a:	ec 01       	movw	r28, r24
		prvInitialiseMutex( pxNewQueue );
    112c:	0e 94 7e 08 	call	0x10fc	; 0x10fc <prvInitialiseMutex>

		return pxNewQueue;
	}
    1130:	ce 01       	movw	r24, r28
    1132:	df 91       	pop	r29
    1134:	cf 91       	pop	r28
    1136:	08 95       	ret

00001138 <xQueueGenericSendFromISR>:
	}
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    1138:	ef 92       	push	r14
    113a:	ff 92       	push	r15
    113c:	0f 93       	push	r16
    113e:	1f 93       	push	r17
    1140:	cf 93       	push	r28
    1142:	df 93       	push	r29
    1144:	8a 01       	movw	r16, r20
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1146:	fc 01       	movw	r30, r24
    1148:	52 8d       	ldd	r21, Z+26	; 0x1a
    114a:	33 8d       	ldd	r19, Z+27	; 0x1b
    114c:	53 17       	cp	r21, r19
    114e:	10 f0       	brcs	.+4      	; 0x1154 <xQueueGenericSendFromISR+0x1c>
    1150:	22 30       	cpi	r18, 0x02	; 2
    1152:	f1 f4       	brne	.+60     	; 0x1190 <xQueueGenericSendFromISR+0x58>
    1154:	42 2f       	mov	r20, r18
    1156:	78 01       	movw	r14, r16
    1158:	ec 01       	movw	r28, r24
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    115a:	1e 8d       	ldd	r17, Y+30	; 0x1e
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    115c:	0e 94 bc 06 	call	0xd78	; 0xd78 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    1160:	1f 3f       	cpi	r17, 0xFF	; 255
    1162:	81 f4       	brne	.+32     	; 0x1184 <xQueueGenericSendFromISR+0x4c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1164:	89 89       	ldd	r24, Y+17	; 0x11
    1166:	88 23       	and	r24, r24
    1168:	a9 f0       	breq	.+42     	; 0x1194 <xQueueGenericSendFromISR+0x5c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    116a:	ce 01       	movw	r24, r28
    116c:	41 96       	adiw	r24, 0x11	; 17
    116e:	0e 94 31 0f 	call	0x1e62	; 0x1e62 <xTaskRemoveFromEventList>
    1172:	88 23       	and	r24, r24
    1174:	89 f0       	breq	.+34     	; 0x1198 <xQueueGenericSendFromISR+0x60>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1176:	e1 14       	cp	r14, r1
    1178:	f1 04       	cpc	r15, r1
    117a:	81 f0       	breq	.+32     	; 0x119c <xQueueGenericSendFromISR+0x64>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    117c:	81 e0       	ldi	r24, 0x01	; 1
    117e:	f7 01       	movw	r30, r14
    1180:	80 83       	st	Z, r24
    1182:	0d c0       	rjmp	.+26     	; 0x119e <xQueueGenericSendFromISR+0x66>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    1184:	ff 24       	eor	r15, r15
    1186:	f3 94       	inc	r15
    1188:	f1 0e       	add	r15, r17
    118a:	fe 8e       	std	Y+30, r15	; 0x1e
			}

			xReturn = pdPASS;
    118c:	81 e0       	ldi	r24, 0x01	; 1
    118e:	07 c0       	rjmp	.+14     	; 0x119e <xQueueGenericSendFromISR+0x66>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1190:	80 e0       	ldi	r24, 0x00	; 0
    1192:	05 c0       	rjmp	.+10     	; 0x119e <xQueueGenericSendFromISR+0x66>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
			}

			xReturn = pdPASS;
    1194:	81 e0       	ldi	r24, 0x01	; 1
    1196:	03 c0       	rjmp	.+6      	; 0x119e <xQueueGenericSendFromISR+0x66>
    1198:	81 e0       	ldi	r24, 0x01	; 1
    119a:	01 c0       	rjmp	.+2      	; 0x119e <xQueueGenericSendFromISR+0x66>
    119c:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    119e:	df 91       	pop	r29
    11a0:	cf 91       	pop	r28
    11a2:	1f 91       	pop	r17
    11a4:	0f 91       	pop	r16
    11a6:	ff 90       	pop	r15
    11a8:	ef 90       	pop	r14
    11aa:	08 95       	ret

000011ac <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    11ac:	cf 93       	push	r28
    11ae:	df 93       	push	r29
    11b0:	fc 01       	movw	r30, r24
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    11b2:	82 8d       	ldd	r24, Z+26	; 0x1a

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    11b4:	93 8d       	ldd	r25, Z+27	; 0x1b
    11b6:	89 17       	cp	r24, r25
    11b8:	c0 f4       	brcc	.+48     	; 0x11ea <xQueueGiveFromISR+0x3e>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    11ba:	96 8d       	ldd	r25, Z+30	; 0x1e
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
    11bc:	8f 5f       	subi	r24, 0xFF	; 255
    11be:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    11c0:	9f 3f       	cpi	r25, 0xFF	; 255
    11c2:	79 f4       	brne	.+30     	; 0x11e2 <xQueueGiveFromISR+0x36>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    11c4:	81 89       	ldd	r24, Z+17	; 0x11
    11c6:	88 23       	and	r24, r24
    11c8:	91 f0       	breq	.+36     	; 0x11ee <xQueueGiveFromISR+0x42>
    11ca:	eb 01       	movw	r28, r22
    11cc:	cf 01       	movw	r24, r30
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    11ce:	41 96       	adiw	r24, 0x11	; 17
    11d0:	0e 94 31 0f 	call	0x1e62	; 0x1e62 <xTaskRemoveFromEventList>
    11d4:	88 23       	and	r24, r24
    11d6:	69 f0       	breq	.+26     	; 0x11f2 <xQueueGiveFromISR+0x46>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    11d8:	20 97       	sbiw	r28, 0x00	; 0
    11da:	69 f0       	breq	.+26     	; 0x11f6 <xQueueGiveFromISR+0x4a>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    11dc:	81 e0       	ldi	r24, 0x01	; 1
    11de:	88 83       	st	Y, r24
    11e0:	0b c0       	rjmp	.+22     	; 0x11f8 <xQueueGiveFromISR+0x4c>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    11e2:	9f 5f       	subi	r25, 0xFF	; 255
    11e4:	96 8f       	std	Z+30, r25	; 0x1e
			}

			xReturn = pdPASS;
    11e6:	81 e0       	ldi	r24, 0x01	; 1
    11e8:	07 c0       	rjmp	.+14     	; 0x11f8 <xQueueGiveFromISR+0x4c>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    11ea:	80 e0       	ldi	r24, 0x00	; 0
    11ec:	05 c0       	rjmp	.+10     	; 0x11f8 <xQueueGiveFromISR+0x4c>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
			}

			xReturn = pdPASS;
    11ee:	81 e0       	ldi	r24, 0x01	; 1
    11f0:	03 c0       	rjmp	.+6      	; 0x11f8 <xQueueGiveFromISR+0x4c>
    11f2:	81 e0       	ldi	r24, 0x01	; 1
    11f4:	01 c0       	rjmp	.+2      	; 0x11f8 <xQueueGiveFromISR+0x4c>
    11f6:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    11f8:	df 91       	pop	r29
    11fa:	cf 91       	pop	r28
    11fc:	08 95       	ret

000011fe <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    11fe:	8f 92       	push	r8
    1200:	9f 92       	push	r9
    1202:	bf 92       	push	r11
    1204:	cf 92       	push	r12
    1206:	df 92       	push	r13
    1208:	ef 92       	push	r14
    120a:	ff 92       	push	r15
    120c:	0f 93       	push	r16
    120e:	1f 93       	push	r17
    1210:	cf 93       	push	r28
    1212:	df 93       	push	r29
    1214:	00 d0       	rcall	.+0      	; 0x1216 <xQueueGenericReceive+0x18>
    1216:	00 d0       	rcall	.+0      	; 0x1218 <xQueueGenericReceive+0x1a>
    1218:	1f 92       	push	r1
    121a:	cd b7       	in	r28, 0x3d	; 61
    121c:	de b7       	in	r29, 0x3e	; 62
    121e:	8c 01       	movw	r16, r24
    1220:	6b 01       	movw	r12, r22
    1222:	5d 83       	std	Y+5, r21	; 0x05
    1224:	4c 83       	std	Y+4, r20	; 0x04
    1226:	b2 2e       	mov	r11, r18
BaseType_t xEntryTimeSet = pdFALSE;
    1228:	e1 2c       	mov	r14, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    122a:	0f b6       	in	r0, 0x3f	; 63
    122c:	f8 94       	cli
    122e:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1230:	f8 01       	movw	r30, r16
    1232:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1234:	ff 20       	and	r15, r15
    1236:	91 f1       	breq	.+100    	; 0x129c <xQueueGenericReceive+0x9e>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    1238:	86 80       	ldd	r8, Z+6	; 0x06
    123a:	97 80       	ldd	r9, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    123c:	b6 01       	movw	r22, r12
    123e:	c8 01       	movw	r24, r16
    1240:	0e 94 1b 07 	call	0xe36	; 0xe36 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1244:	b1 10       	cpse	r11, r1
    1246:	19 c0       	rjmp	.+50     	; 0x127a <xQueueGenericReceive+0x7c>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
    1248:	fa 94       	dec	r15
    124a:	f8 01       	movw	r30, r16
    124c:	f2 8e       	std	Z+26, r15	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    124e:	80 81       	ld	r24, Z
    1250:	91 81       	ldd	r25, Z+1	; 0x01
    1252:	89 2b       	or	r24, r25
    1254:	29 f4       	brne	.+10     	; 0x1260 <xQueueGenericReceive+0x62>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    1256:	0e 94 b2 10 	call	0x2164	; 0x2164 <pvTaskIncrementMutexHeldCount>
    125a:	f8 01       	movw	r30, r16
    125c:	93 83       	std	Z+3, r25	; 0x03
    125e:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1260:	f8 01       	movw	r30, r16
    1262:	80 85       	ldd	r24, Z+8	; 0x08
    1264:	88 23       	and	r24, r24
    1266:	b1 f0       	breq	.+44     	; 0x1294 <xQueueGenericReceive+0x96>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1268:	c8 01       	movw	r24, r16
    126a:	08 96       	adiw	r24, 0x08	; 8
    126c:	0e 94 31 0f 	call	0x1e62	; 0x1e62 <xTaskRemoveFromEventList>
    1270:	88 23       	and	r24, r24
    1272:	81 f0       	breq	.+32     	; 0x1294 <xQueueGenericReceive+0x96>
						{
							queueYIELD_IF_USING_PREEMPTION();
    1274:	0e 94 a5 05 	call	0xb4a	; 0xb4a <vPortYield>
    1278:	0d c0       	rjmp	.+26     	; 0x1294 <xQueueGenericReceive+0x96>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    127a:	f8 01       	movw	r30, r16
    127c:	97 82       	std	Z+7, r9	; 0x07
    127e:	86 82       	std	Z+6, r8	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1280:	81 89       	ldd	r24, Z+17	; 0x11
    1282:	88 23       	and	r24, r24
    1284:	39 f0       	breq	.+14     	; 0x1294 <xQueueGenericReceive+0x96>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1286:	c8 01       	movw	r24, r16
    1288:	41 96       	adiw	r24, 0x11	; 17
    128a:	0e 94 31 0f 	call	0x1e62	; 0x1e62 <xTaskRemoveFromEventList>
    128e:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    1290:	0e 94 a5 05 	call	0xb4a	; 0xb4a <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    1294:	0f 90       	pop	r0
    1296:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1298:	81 e0       	ldi	r24, 0x01	; 1
    129a:	61 c0       	rjmp	.+194    	; 0x135e <xQueueGenericReceive+0x160>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    129c:	8c 81       	ldd	r24, Y+4	; 0x04
    129e:	9d 81       	ldd	r25, Y+5	; 0x05
    12a0:	89 2b       	or	r24, r25
    12a2:	21 f4       	brne	.+8      	; 0x12ac <xQueueGenericReceive+0xae>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    12a4:	0f 90       	pop	r0
    12a6:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    12a8:	80 e0       	ldi	r24, 0x00	; 0
    12aa:	59 c0       	rjmp	.+178    	; 0x135e <xQueueGenericReceive+0x160>
				}
				else if( xEntryTimeSet == pdFALSE )
    12ac:	e1 10       	cpse	r14, r1
    12ae:	06 c0       	rjmp	.+12     	; 0x12bc <xQueueGenericReceive+0xbe>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    12b0:	ce 01       	movw	r24, r28
    12b2:	01 96       	adiw	r24, 0x01	; 1
    12b4:	0e 94 b3 0f 	call	0x1f66	; 0x1f66 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    12b8:	ee 24       	eor	r14, r14
    12ba:	e3 94       	inc	r14
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    12bc:	0f 90       	pop	r0
    12be:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    12c0:	0e 94 0f 0d 	call	0x1a1e	; 0x1a1e <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    12c4:	0f b6       	in	r0, 0x3f	; 63
    12c6:	f8 94       	cli
    12c8:	0f 92       	push	r0
    12ca:	f8 01       	movw	r30, r16
    12cc:	85 8d       	ldd	r24, Z+29	; 0x1d
    12ce:	8f 3f       	cpi	r24, 0xFF	; 255
    12d0:	09 f4       	brne	.+2      	; 0x12d4 <xQueueGenericReceive+0xd6>
    12d2:	15 8e       	std	Z+29, r1	; 0x1d
    12d4:	f8 01       	movw	r30, r16
    12d6:	86 8d       	ldd	r24, Z+30	; 0x1e
    12d8:	8f 3f       	cpi	r24, 0xFF	; 255
    12da:	09 f4       	brne	.+2      	; 0x12de <xQueueGenericReceive+0xe0>
    12dc:	16 8e       	std	Z+30, r1	; 0x1e
    12de:	0f 90       	pop	r0
    12e0:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    12e2:	be 01       	movw	r22, r28
    12e4:	6c 5f       	subi	r22, 0xFC	; 252
    12e6:	7f 4f       	sbci	r23, 0xFF	; 255
    12e8:	ce 01       	movw	r24, r28
    12ea:	01 96       	adiw	r24, 0x01	; 1
    12ec:	0e 94 be 0f 	call	0x1f7c	; 0x1f7c <xTaskCheckForTimeOut>
    12f0:	81 11       	cpse	r24, r1
    12f2:	29 c0       	rjmp	.+82     	; 0x1346 <xQueueGenericReceive+0x148>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    12f4:	c8 01       	movw	r24, r16
    12f6:	0e 94 a1 06 	call	0xd42	; 0xd42 <prvIsQueueEmpty>
    12fa:	88 23       	and	r24, r24
    12fc:	f1 f0       	breq	.+60     	; 0x133a <xQueueGenericReceive+0x13c>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    12fe:	f8 01       	movw	r30, r16
    1300:	80 81       	ld	r24, Z
    1302:	91 81       	ldd	r25, Z+1	; 0x01
    1304:	89 2b       	or	r24, r25
    1306:	49 f4       	brne	.+18     	; 0x131a <xQueueGenericReceive+0x11c>
					{
						taskENTER_CRITICAL();
    1308:	0f b6       	in	r0, 0x3f	; 63
    130a:	f8 94       	cli
    130c:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    130e:	82 81       	ldd	r24, Z+2	; 0x02
    1310:	93 81       	ldd	r25, Z+3	; 0x03
    1312:	0e 94 f9 0f 	call	0x1ff2	; 0x1ff2 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    1316:	0f 90       	pop	r0
    1318:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    131a:	6c 81       	ldd	r22, Y+4	; 0x04
    131c:	7d 81       	ldd	r23, Y+5	; 0x05
    131e:	c8 01       	movw	r24, r16
    1320:	41 96       	adiw	r24, 0x11	; 17
    1322:	0e 94 06 0f 	call	0x1e0c	; 0x1e0c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1326:	c8 01       	movw	r24, r16
    1328:	0e 94 35 07 	call	0xe6a	; 0xe6a <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    132c:	0e 94 e9 0d 	call	0x1bd2	; 0x1bd2 <xTaskResumeAll>
    1330:	81 11       	cpse	r24, r1
    1332:	7b cf       	rjmp	.-266    	; 0x122a <xQueueGenericReceive+0x2c>
				{
					portYIELD_WITHIN_API();
    1334:	0e 94 a5 05 	call	0xb4a	; 0xb4a <vPortYield>
    1338:	78 cf       	rjmp	.-272    	; 0x122a <xQueueGenericReceive+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    133a:	c8 01       	movw	r24, r16
    133c:	0e 94 35 07 	call	0xe6a	; 0xe6a <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1340:	0e 94 e9 0d 	call	0x1bd2	; 0x1bd2 <xTaskResumeAll>
    1344:	72 cf       	rjmp	.-284    	; 0x122a <xQueueGenericReceive+0x2c>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1346:	c8 01       	movw	r24, r16
    1348:	0e 94 35 07 	call	0xe6a	; 0xe6a <prvUnlockQueue>
			( void ) xTaskResumeAll();
    134c:	0e 94 e9 0d 	call	0x1bd2	; 0x1bd2 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1350:	c8 01       	movw	r24, r16
    1352:	0e 94 a1 06 	call	0xd42	; 0xd42 <prvIsQueueEmpty>
    1356:	88 23       	and	r24, r24
    1358:	09 f4       	brne	.+2      	; 0x135c <xQueueGenericReceive+0x15e>
    135a:	67 cf       	rjmp	.-306    	; 0x122a <xQueueGenericReceive+0x2c>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    135c:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
    135e:	0f 90       	pop	r0
    1360:	0f 90       	pop	r0
    1362:	0f 90       	pop	r0
    1364:	0f 90       	pop	r0
    1366:	0f 90       	pop	r0
    1368:	df 91       	pop	r29
    136a:	cf 91       	pop	r28
    136c:	1f 91       	pop	r17
    136e:	0f 91       	pop	r16
    1370:	ff 90       	pop	r15
    1372:	ef 90       	pop	r14
    1374:	df 90       	pop	r13
    1376:	cf 90       	pop	r12
    1378:	bf 90       	pop	r11
    137a:	9f 90       	pop	r9
    137c:	8f 90       	pop	r8
    137e:	08 95       	ret

00001380 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1380:	ef 92       	push	r14
    1382:	ff 92       	push	r15
    1384:	0f 93       	push	r16
    1386:	1f 93       	push	r17
    1388:	cf 93       	push	r28
    138a:	df 93       	push	r29
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    138c:	fc 01       	movw	r30, r24
    138e:	c2 8d       	ldd	r28, Z+26	; 0x1a

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1390:	cc 23       	and	r28, r28
    1392:	f9 f0       	breq	.+62     	; 0x13d2 <xQueueReceiveFromISR+0x52>
    1394:	7a 01       	movw	r14, r20
    1396:	8c 01       	movw	r16, r24
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    1398:	d5 8d       	ldd	r29, Z+29	; 0x1d

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    139a:	0e 94 1b 07 	call	0xe36	; 0xe36 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
    139e:	c1 50       	subi	r28, 0x01	; 1
    13a0:	f8 01       	movw	r30, r16
    13a2:	c2 8f       	std	Z+26, r28	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    13a4:	df 3f       	cpi	r29, 0xFF	; 255
    13a6:	81 f4       	brne	.+32     	; 0x13c8 <xQueueReceiveFromISR+0x48>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    13a8:	80 85       	ldd	r24, Z+8	; 0x08
    13aa:	88 23       	and	r24, r24
    13ac:	a1 f0       	breq	.+40     	; 0x13d6 <xQueueReceiveFromISR+0x56>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    13ae:	c8 01       	movw	r24, r16
    13b0:	08 96       	adiw	r24, 0x08	; 8
    13b2:	0e 94 31 0f 	call	0x1e62	; 0x1e62 <xTaskRemoveFromEventList>
    13b6:	88 23       	and	r24, r24
    13b8:	81 f0       	breq	.+32     	; 0x13da <xQueueReceiveFromISR+0x5a>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    13ba:	e1 14       	cp	r14, r1
    13bc:	f1 04       	cpc	r15, r1
    13be:	79 f0       	breq	.+30     	; 0x13de <xQueueReceiveFromISR+0x5e>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    13c0:	81 e0       	ldi	r24, 0x01	; 1
    13c2:	f7 01       	movw	r30, r14
    13c4:	80 83       	st	Z, r24
    13c6:	0c c0       	rjmp	.+24     	; 0x13e0 <xQueueReceiveFromISR+0x60>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    13c8:	df 5f       	subi	r29, 0xFF	; 255
    13ca:	f8 01       	movw	r30, r16
    13cc:	d5 8f       	std	Z+29, r29	; 0x1d
			}

			xReturn = pdPASS;
    13ce:	81 e0       	ldi	r24, 0x01	; 1
    13d0:	07 c0       	rjmp	.+14     	; 0x13e0 <xQueueReceiveFromISR+0x60>
		}
		else
		{
			xReturn = pdFAIL;
    13d2:	80 e0       	ldi	r24, 0x00	; 0
    13d4:	05 c0       	rjmp	.+10     	; 0x13e0 <xQueueReceiveFromISR+0x60>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
			}

			xReturn = pdPASS;
    13d6:	81 e0       	ldi	r24, 0x01	; 1
    13d8:	03 c0       	rjmp	.+6      	; 0x13e0 <xQueueReceiveFromISR+0x60>
    13da:	81 e0       	ldi	r24, 0x01	; 1
    13dc:	01 c0       	rjmp	.+2      	; 0x13e0 <xQueueReceiveFromISR+0x60>
    13de:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    13e0:	df 91       	pop	r29
    13e2:	cf 91       	pop	r28
    13e4:	1f 91       	pop	r17
    13e6:	0f 91       	pop	r16
    13e8:	ff 90       	pop	r15
    13ea:	ef 90       	pop	r14
    13ec:	08 95       	ret

000013ee <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    13ee:	0f 93       	push	r16
    13f0:	1f 93       	push	r17
    13f2:	cf 93       	push	r28
    13f4:	df 93       	push	r29
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    13f6:	fc 01       	movw	r30, r24
    13f8:	22 8d       	ldd	r18, Z+26	; 0x1a
    13fa:	22 23       	and	r18, r18
    13fc:	49 f0       	breq	.+18     	; 0x1410 <xQueuePeekFromISR+0x22>
    13fe:	ec 01       	movw	r28, r24
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    1400:	06 81       	ldd	r16, Z+6	; 0x06
    1402:	17 81       	ldd	r17, Z+7	; 0x07
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1404:	0e 94 1b 07 	call	0xe36	; 0xe36 <prvCopyDataFromQueue>
			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    1408:	1f 83       	std	Y+7, r17	; 0x07
    140a:	0e 83       	std	Y+6, r16	; 0x06

			xReturn = pdPASS;
    140c:	81 e0       	ldi	r24, 0x01	; 1
    140e:	01 c0       	rjmp	.+2      	; 0x1412 <xQueuePeekFromISR+0x24>
		}
		else
		{
			xReturn = pdFAIL;
    1410:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1412:	df 91       	pop	r29
    1414:	cf 91       	pop	r28
    1416:	1f 91       	pop	r17
    1418:	0f 91       	pop	r16
    141a:	08 95       	ret

0000141c <uxQueueMessagesWaiting>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    141c:	0f b6       	in	r0, 0x3f	; 63
    141e:	f8 94       	cli
    1420:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    1422:	fc 01       	movw	r30, r24
    1424:	82 8d       	ldd	r24, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    1426:	0f 90       	pop	r0
    1428:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    142a:	08 95       	ret

0000142c <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    142c:	fc 01       	movw	r30, r24
Queue_t *pxQueue;

	pxQueue = ( Queue_t * ) xQueue;
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    142e:	0f b6       	in	r0, 0x3f	; 63
    1430:	f8 94       	cli
    1432:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    1434:	93 8d       	ldd	r25, Z+27	; 0x1b
    1436:	82 8d       	ldd	r24, Z+26	; 0x1a
    1438:	98 1b       	sub	r25, r24
    143a:	89 2f       	mov	r24, r25
	}
	taskEXIT_CRITICAL();
    143c:	0f 90       	pop	r0
    143e:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1440:	08 95       	ret

00001442 <uxQueueMessagesWaitingFromISR>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    1442:	fc 01       	movw	r30, r24
    1444:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1446:	08 95       	ret

00001448 <vQueueDelete>:

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    1448:	0e 94 92 06 	call	0xd24	; 0xd24 <vPortFree>
    144c:	08 95       	ret

0000144e <xQueueIsQueueEmptyFromISR>:
BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
    144e:	fc 01       	movw	r30, r24
    1450:	82 8d       	ldd	r24, Z+26	; 0x1a
    1452:	81 11       	cpse	r24, r1
    1454:	02 c0       	rjmp	.+4      	; 0x145a <xQueueIsQueueEmptyFromISR+0xc>
	{
		xReturn = pdTRUE;
    1456:	81 e0       	ldi	r24, 0x01	; 1
    1458:	08 95       	ret
	}
	else
	{
		xReturn = pdFALSE;
    145a:	80 e0       	ldi	r24, 0x00	; 0
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    145c:	08 95       	ret

0000145e <xQueueIsQueueFullFromISR>:
BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
    145e:	fc 01       	movw	r30, r24
    1460:	22 8d       	ldd	r18, Z+26	; 0x1a
    1462:	83 8d       	ldd	r24, Z+27	; 0x1b
    1464:	28 13       	cpse	r18, r24
    1466:	02 c0       	rjmp	.+4      	; 0x146c <xQueueIsQueueFullFromISR+0xe>
	{
		xReturn = pdTRUE;
    1468:	81 e0       	ldi	r24, 0x01	; 1
    146a:	08 95       	ret
	}
	else
	{
		xReturn = pdFALSE;
    146c:	80 e0       	ldi	r24, 0x00	; 0
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    146e:	08 95       	ret

00001470 <xQueueCRSend>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait )
	{
    1470:	ef 92       	push	r14
    1472:	ff 92       	push	r15
    1474:	0f 93       	push	r16
    1476:	1f 93       	push	r17
    1478:	cf 93       	push	r28
    147a:	df 93       	push	r29
    147c:	ec 01       	movw	r28, r24
    147e:	7b 01       	movw	r14, r22
    1480:	8a 01       	movw	r16, r20
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;

		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    1482:	f8 94       	cli
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1484:	0e 94 ae 06 	call	0xd5c	; 0xd5c <prvIsQueueFull>
    1488:	88 23       	and	r24, r24
    148a:	79 f0       	breq	.+30     	; 0x14aa <xQueueCRSend+0x3a>
			{
				/* The queue is full - do we want to block or just leave without
				posting? */
				if( xTicksToWait > ( TickType_t ) 0 )
    148c:	01 15       	cp	r16, r1
    148e:	11 05       	cpc	r17, r1
    1490:	49 f0       	breq	.+18     	; 0x14a4 <xQueueCRSend+0x34>
				{
					/* As this is called from a coroutine we cannot block directly, but
					return indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    1492:	be 01       	movw	r22, r28
    1494:	68 5f       	subi	r22, 0xF8	; 248
    1496:	7f 4f       	sbci	r23, 0xFF	; 255
    1498:	c8 01       	movw	r24, r16
    149a:	0e 94 1b 02 	call	0x436	; 0x436 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    149e:	78 94       	sei
					return errQUEUE_BLOCKED;
    14a0:	8c ef       	ldi	r24, 0xFC	; 252
    14a2:	1f c0       	rjmp	.+62     	; 0x14e2 <xQueueCRSend+0x72>
				}
				else
				{
					portENABLE_INTERRUPTS();
    14a4:	78 94       	sei
					return errQUEUE_FULL;
    14a6:	80 e0       	ldi	r24, 0x00	; 0
    14a8:	1c c0       	rjmp	.+56     	; 0x14e2 <xQueueCRSend+0x72>
				}
			}
		}
		portENABLE_INTERRUPTS();
    14aa:	78 94       	sei

		portDISABLE_INTERRUPTS();
    14ac:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    14ae:	9a 8d       	ldd	r25, Y+26	; 0x1a
    14b0:	8b 8d       	ldd	r24, Y+27	; 0x1b
    14b2:	98 17       	cp	r25, r24
    14b4:	80 f4       	brcc	.+32     	; 0x14d6 <xQueueCRSend+0x66>
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    14b6:	40 e0       	ldi	r20, 0x00	; 0
    14b8:	b7 01       	movw	r22, r14
    14ba:	ce 01       	movw	r24, r28
    14bc:	0e 94 bc 06 	call	0xd78	; 0xd78 <prvCopyDataToQueue>
				xReturn = pdPASS;

				/* Were any co-routines waiting for data to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    14c0:	89 89       	ldd	r24, Y+17	; 0x11
    14c2:	88 23       	and	r24, r24
    14c4:	51 f0       	breq	.+20     	; 0x14da <xQueueCRSend+0x6a>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    14c6:	ce 01       	movw	r24, r28
    14c8:	41 96       	adiw	r24, 0x11	; 17
    14ca:	0e 94 b6 02 	call	0x56c	; 0x56c <xCoRoutineRemoveFromEventList>
    14ce:	81 11       	cpse	r24, r1
    14d0:	06 c0       	rjmp	.+12     	; 0x14de <xQueueCRSend+0x6e>
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
				xReturn = pdPASS;
    14d2:	81 e0       	ldi	r24, 0x01	; 1
    14d4:	05 c0       	rjmp	.+10     	; 0x14e0 <xQueueCRSend+0x70>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = errQUEUE_FULL;
    14d6:	80 e0       	ldi	r24, 0x00	; 0
    14d8:	03 c0       	rjmp	.+6      	; 0x14e0 <xQueueCRSend+0x70>
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
				xReturn = pdPASS;
    14da:	81 e0       	ldi	r24, 0x01	; 1
    14dc:	01 c0       	rjmp	.+2      	; 0x14e0 <xQueueCRSend+0x70>
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
					{
						/* The co-routine waiting has a higher priority so record
						that a yield might be appropriate. */
						xReturn = errQUEUE_YIELD;
    14de:	8b ef       	ldi	r24, 0xFB	; 251
			else
			{
				xReturn = errQUEUE_FULL;
			}
		}
		portENABLE_INTERRUPTS();
    14e0:	78 94       	sei

		return xReturn;
	}
    14e2:	df 91       	pop	r29
    14e4:	cf 91       	pop	r28
    14e6:	1f 91       	pop	r17
    14e8:	0f 91       	pop	r16
    14ea:	ff 90       	pop	r15
    14ec:	ef 90       	pop	r14
    14ee:	08 95       	ret

000014f0 <xQueueCRReceive>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
	{
    14f0:	cf 93       	push	r28
    14f2:	df 93       	push	r29
    14f4:	ec 01       	movw	r28, r24
    14f6:	9b 01       	movw	r18, r22
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;

		/* If the queue is already empty we may have to block.  A critical section
		is required to prevent an interrupt adding something to the queue
		between the check to see if the queue is empty and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    14f8:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    14fa:	9a 8d       	ldd	r25, Y+26	; 0x1a
    14fc:	91 11       	cpse	r25, r1
    14fe:	0f c0       	rjmp	.+30     	; 0x151e <xQueueCRReceive+0x2e>
			{
				/* There are no messages in the queue, do we want to block or just
				leave with nothing? */
				if( xTicksToWait > ( TickType_t ) 0 )
    1500:	41 15       	cp	r20, r1
    1502:	51 05       	cpc	r21, r1
    1504:	49 f0       	breq	.+18     	; 0x1518 <xQueueCRReceive+0x28>
				{
					/* As this is a co-routine we cannot block directly, but return
					indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    1506:	be 01       	movw	r22, r28
    1508:	6f 5e       	subi	r22, 0xEF	; 239
    150a:	7f 4f       	sbci	r23, 0xFF	; 255
    150c:	ca 01       	movw	r24, r20
    150e:	0e 94 1b 02 	call	0x436	; 0x436 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    1512:	78 94       	sei
					return errQUEUE_BLOCKED;
    1514:	8c ef       	ldi	r24, 0xFC	; 252
    1516:	32 c0       	rjmp	.+100    	; 0x157c <xQueueCRReceive+0x8c>
				}
				else
				{
					portENABLE_INTERRUPTS();
    1518:	78 94       	sei
					return errQUEUE_FULL;
    151a:	80 e0       	ldi	r24, 0x00	; 0
    151c:	2f c0       	rjmp	.+94     	; 0x157c <xQueueCRReceive+0x8c>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portENABLE_INTERRUPTS();
    151e:	78 94       	sei

		portDISABLE_INTERRUPTS();
    1520:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1522:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1524:	88 23       	and	r24, r24
    1526:	21 f1       	breq	.+72     	; 0x1570 <xQueueCRReceive+0x80>
			{
				/* Data is available from the queue. */
				pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    1528:	4c 8d       	ldd	r20, Y+28	; 0x1c
    152a:	50 e0       	ldi	r21, 0x00	; 0
    152c:	8e 81       	ldd	r24, Y+6	; 0x06
    152e:	9f 81       	ldd	r25, Y+7	; 0x07
    1530:	84 0f       	add	r24, r20
    1532:	95 1f       	adc	r25, r21
    1534:	9f 83       	std	Y+7, r25	; 0x07
    1536:	8e 83       	std	Y+6, r24	; 0x06
				if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
    1538:	6a 81       	ldd	r22, Y+2	; 0x02
    153a:	7b 81       	ldd	r23, Y+3	; 0x03
    153c:	86 17       	cp	r24, r22
    153e:	97 07       	cpc	r25, r23
    1540:	20 f0       	brcs	.+8      	; 0x154a <xQueueCRReceive+0x5a>
				{
					pxQueue->u.pcReadFrom = pxQueue->pcHead;
    1542:	88 81       	ld	r24, Y
    1544:	99 81       	ldd	r25, Y+1	; 0x01
    1546:	9f 83       	std	Y+7, r25	; 0x07
    1548:	8e 83       	std	Y+6, r24	; 0x06
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
    154a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    154c:	81 50       	subi	r24, 0x01	; 1
    154e:	8a 8f       	std	Y+26, r24	; 0x1a
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1550:	6e 81       	ldd	r22, Y+6	; 0x06
    1552:	7f 81       	ldd	r23, Y+7	; 0x07
    1554:	c9 01       	movw	r24, r18
    1556:	0e 94 77 15 	call	0x2aee	; 0x2aee <memcpy>

				xReturn = pdPASS;

				/* Were any co-routines waiting for space to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    155a:	88 85       	ldd	r24, Y+8	; 0x08
    155c:	88 23       	and	r24, r24
    155e:	51 f0       	breq	.+20     	; 0x1574 <xQueueCRReceive+0x84>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1560:	ce 01       	movw	r24, r28
    1562:	08 96       	adiw	r24, 0x08	; 8
    1564:	0e 94 b6 02 	call	0x56c	; 0x56c <xCoRoutineRemoveFromEventList>
    1568:	81 11       	cpse	r24, r1
    156a:	06 c0       	rjmp	.+12     	; 0x1578 <xQueueCRReceive+0x88>
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

				xReturn = pdPASS;
    156c:	81 e0       	ldi	r24, 0x01	; 1
    156e:	05 c0       	rjmp	.+10     	; 0x157a <xQueueCRReceive+0x8a>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = pdFAIL;
    1570:	80 e0       	ldi	r24, 0x00	; 0
    1572:	03 c0       	rjmp	.+6      	; 0x157a <xQueueCRReceive+0x8a>
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

				xReturn = pdPASS;
    1574:	81 e0       	ldi	r24, 0x01	; 1
    1576:	01 c0       	rjmp	.+2      	; 0x157a <xQueueCRReceive+0x8a>
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
					{
						xReturn = errQUEUE_YIELD;
    1578:	8b ef       	ldi	r24, 0xFB	; 251
			else
			{
				xReturn = pdFAIL;
			}
		}
		portENABLE_INTERRUPTS();
    157a:	78 94       	sei

		return xReturn;
	}
    157c:	df 91       	pop	r29
    157e:	cf 91       	pop	r28
    1580:	08 95       	ret

00001582 <xQueueCRSendFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken )
	{
    1582:	0f 93       	push	r16
    1584:	1f 93       	push	r17
    1586:	cf 93       	push	r28
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;

		/* Cannot block within an ISR so if there is no space on the queue then
		exit without doing anything. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1588:	fc 01       	movw	r30, r24
    158a:	32 8d       	ldd	r19, Z+26	; 0x1a
    158c:	23 8d       	ldd	r18, Z+27	; 0x1b
    158e:	32 17       	cp	r19, r18
    1590:	98 f4       	brcc	.+38     	; 0x15b8 <xQueueCRSendFromISR+0x36>
    1592:	c4 2f       	mov	r28, r20
    1594:	8c 01       	movw	r16, r24
		{
			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    1596:	40 e0       	ldi	r20, 0x00	; 0
    1598:	0e 94 bc 06 	call	0xd78	; 0xd78 <prvCopyDataToQueue>

			/* We only want to wake one co-routine per ISR, so check that a
			co-routine has not already been woken. */
			if( xCoRoutinePreviouslyWoken == pdFALSE )
    159c:	c1 11       	cpse	r28, r1
    159e:	0e c0       	rjmp	.+28     	; 0x15bc <xQueueCRSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    15a0:	f8 01       	movw	r30, r16
    15a2:	81 89       	ldd	r24, Z+17	; 0x11
    15a4:	88 23       	and	r24, r24
    15a6:	61 f0       	breq	.+24     	; 0x15c0 <xQueueCRSendFromISR+0x3e>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    15a8:	c8 01       	movw	r24, r16
    15aa:	41 96       	adiw	r24, 0x11	; 17
    15ac:	0e 94 b6 02 	call	0x56c	; 0x56c <xCoRoutineRemoveFromEventList>
    15b0:	88 23       	and	r24, r24
    15b2:	41 f0       	breq	.+16     	; 0x15c4 <xQueueCRSendFromISR+0x42>
					{
						return pdTRUE;
    15b4:	81 e0       	ldi	r24, 0x01	; 1
    15b6:	07 c0       	rjmp	.+14     	; 0x15c6 <xQueueCRSendFromISR+0x44>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xCoRoutinePreviouslyWoken;
    15b8:	84 2f       	mov	r24, r20
    15ba:	05 c0       	rjmp	.+10     	; 0x15c6 <xQueueCRSendFromISR+0x44>
    15bc:	8c 2f       	mov	r24, r28
    15be:	03 c0       	rjmp	.+6      	; 0x15c6 <xQueueCRSendFromISR+0x44>
    15c0:	8c 2f       	mov	r24, r28
    15c2:	01 c0       	rjmp	.+2      	; 0x15c6 <xQueueCRSendFromISR+0x44>
    15c4:	8c 2f       	mov	r24, r28
	}
    15c6:	cf 91       	pop	r28
    15c8:	1f 91       	pop	r17
    15ca:	0f 91       	pop	r16
    15cc:	08 95       	ret

000015ce <xQueueCRReceiveFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWoken )
	{
    15ce:	0f 93       	push	r16
    15d0:	1f 93       	push	r17
    15d2:	cf 93       	push	r28
    15d4:	df 93       	push	r29
    15d6:	fc 01       	movw	r30, r24
	BaseType_t xReturn;
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;

		/* We cannot block from an ISR, so check there is data available. If
		not then just leave without doing anything. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    15d8:	82 8d       	ldd	r24, Z+26	; 0x1a
    15da:	88 23       	and	r24, r24
    15dc:	69 f1       	breq	.+90     	; 0x1638 <xQueueCRReceiveFromISR+0x6a>
		{
			/* Copy the data from the queue. */
			pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    15de:	24 8d       	ldd	r18, Z+28	; 0x1c
    15e0:	30 e0       	ldi	r19, 0x00	; 0
    15e2:	a6 81       	ldd	r26, Z+6	; 0x06
    15e4:	b7 81       	ldd	r27, Z+7	; 0x07
    15e6:	a2 0f       	add	r26, r18
    15e8:	b3 1f       	adc	r27, r19
    15ea:	b7 83       	std	Z+7, r27	; 0x07
    15ec:	a6 83       	std	Z+6, r26	; 0x06
			if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
    15ee:	82 81       	ldd	r24, Z+2	; 0x02
    15f0:	93 81       	ldd	r25, Z+3	; 0x03
    15f2:	a8 17       	cp	r26, r24
    15f4:	b9 07       	cpc	r27, r25
    15f6:	20 f0       	brcs	.+8      	; 0x1600 <xQueueCRReceiveFromISR+0x32>
			{
				pxQueue->u.pcReadFrom = pxQueue->pcHead;
    15f8:	80 81       	ld	r24, Z
    15fa:	91 81       	ldd	r25, Z+1	; 0x01
    15fc:	97 83       	std	Z+7, r25	; 0x07
    15fe:	86 83       	std	Z+6, r24	; 0x06
    1600:	8a 01       	movw	r16, r20
    1602:	cb 01       	movw	r24, r22
    1604:	ef 01       	movw	r28, r30
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
			--( pxQueue->uxMessagesWaiting );
    1606:	42 8d       	ldd	r20, Z+26	; 0x1a
    1608:	41 50       	subi	r20, 0x01	; 1
    160a:	42 8f       	std	Z+26, r20	; 0x1a
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    160c:	66 81       	ldd	r22, Z+6	; 0x06
    160e:	77 81       	ldd	r23, Z+7	; 0x07
    1610:	a9 01       	movw	r20, r18
    1612:	0e 94 77 15 	call	0x2aee	; 0x2aee <memcpy>

			if( ( *pxCoRoutineWoken ) == pdFALSE )
    1616:	f8 01       	movw	r30, r16
    1618:	80 81       	ld	r24, Z
    161a:	81 11       	cpse	r24, r1
    161c:	0f c0       	rjmp	.+30     	; 0x163c <xQueueCRReceiveFromISR+0x6e>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    161e:	88 85       	ldd	r24, Y+8	; 0x08
    1620:	88 23       	and	r24, r24
    1622:	71 f0       	breq	.+28     	; 0x1640 <xQueueCRReceiveFromISR+0x72>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1624:	ce 01       	movw	r24, r28
    1626:	08 96       	adiw	r24, 0x08	; 8
    1628:	0e 94 b6 02 	call	0x56c	; 0x56c <xCoRoutineRemoveFromEventList>
    162c:	88 23       	and	r24, r24
    162e:	51 f0       	breq	.+20     	; 0x1644 <xQueueCRReceiveFromISR+0x76>
					{
						*pxCoRoutineWoken = pdTRUE;
    1630:	81 e0       	ldi	r24, 0x01	; 1
    1632:	f8 01       	movw	r30, r16
    1634:	80 83       	st	Z, r24
    1636:	07 c0       	rjmp	.+14     	; 0x1646 <xQueueCRReceiveFromISR+0x78>

			xReturn = pdPASS;
		}
		else
		{
			xReturn = pdFAIL;
    1638:	80 e0       	ldi	r24, 0x00	; 0
    163a:	05 c0       	rjmp	.+10     	; 0x1646 <xQueueCRReceiveFromISR+0x78>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			xReturn = pdPASS;
    163c:	81 e0       	ldi	r24, 0x01	; 1
    163e:	03 c0       	rjmp	.+6      	; 0x1646 <xQueueCRReceiveFromISR+0x78>
    1640:	81 e0       	ldi	r24, 0x01	; 1
    1642:	01 c0       	rjmp	.+2      	; 0x1646 <xQueueCRReceiveFromISR+0x78>
    1644:	81 e0       	ldi	r24, 0x01	; 1
		{
			xReturn = pdFAIL;
		}

		return xReturn;
	}
    1646:	df 91       	pop	r29
    1648:	cf 91       	pop	r28
    164a:	1f 91       	pop	r17
    164c:	0f 91       	pop	r16
    164e:	08 95       	ret

00001650 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    1650:	e0 91 81 0d 	lds	r30, 0x0D81	; 0x800d81 <pxDelayedTaskList>
    1654:	f0 91 82 0d 	lds	r31, 0x0D82	; 0x800d82 <pxDelayedTaskList+0x1>
    1658:	80 81       	ld	r24, Z
    165a:	81 11       	cpse	r24, r1
    165c:	07 c0       	rjmp	.+14     	; 0x166c <prvResetNextTaskUnblockTime+0x1c>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    165e:	8f ef       	ldi	r24, 0xFF	; 255
    1660:	9f ef       	ldi	r25, 0xFF	; 255
    1662:	90 93 6c 0d 	sts	0x0D6C, r25	; 0x800d6c <xNextTaskUnblockTime+0x1>
    1666:	80 93 6b 0d 	sts	0x0D6B, r24	; 0x800d6b <xNextTaskUnblockTime>
    166a:	08 95       	ret
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    166c:	e0 91 81 0d 	lds	r30, 0x0D81	; 0x800d81 <pxDelayedTaskList>
    1670:	f0 91 82 0d 	lds	r31, 0x0D82	; 0x800d82 <pxDelayedTaskList+0x1>
    1674:	05 80       	ldd	r0, Z+5	; 0x05
    1676:	f6 81       	ldd	r31, Z+6	; 0x06
    1678:	e0 2d       	mov	r30, r0
    167a:	06 80       	ldd	r0, Z+6	; 0x06
    167c:	f7 81       	ldd	r31, Z+7	; 0x07
    167e:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    1680:	82 81       	ldd	r24, Z+2	; 0x02
    1682:	93 81       	ldd	r25, Z+3	; 0x03
    1684:	90 93 6c 0d 	sts	0x0D6C, r25	; 0x800d6c <xNextTaskUnblockTime+0x1>
    1688:	80 93 6b 0d 	sts	0x0D6B, r24	; 0x800d6b <xNextTaskUnblockTime>
    168c:	08 95       	ret

0000168e <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    168e:	6f 92       	push	r6
    1690:	7f 92       	push	r7
    1692:	8f 92       	push	r8
    1694:	9f 92       	push	r9
    1696:	af 92       	push	r10
    1698:	bf 92       	push	r11
    169a:	cf 92       	push	r12
    169c:	df 92       	push	r13
    169e:	ef 92       	push	r14
    16a0:	0f 93       	push	r16
    16a2:	1f 93       	push	r17
    16a4:	cf 93       	push	r28
    16a6:	df 93       	push	r29
    16a8:	cd b7       	in	r28, 0x3d	; 61
    16aa:	de b7       	in	r29, 0x3e	; 62
    16ac:	4c 01       	movw	r8, r24
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
    16ae:	f5 01       	movw	r30, r10
    16b0:	87 89       	ldd	r24, Z+23	; 0x17
    16b2:	90 8d       	ldd	r25, Z+24	; 0x18
    16b4:	21 50       	subi	r18, 0x01	; 1
    16b6:	31 09       	sbc	r19, r1
    16b8:	3c 01       	movw	r6, r24
    16ba:	62 0e       	add	r6, r18
    16bc:	73 1e       	adc	r7, r19
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    16be:	20 e0       	ldi	r18, 0x00	; 0
    16c0:	0f c0       	rjmp	.+30     	; 0x16e0 <prvInitialiseNewTask+0x52>
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    16c2:	82 2f       	mov	r24, r18
    16c4:	90 e0       	ldi	r25, 0x00	; 0
    16c6:	fb 01       	movw	r30, r22
    16c8:	e8 0f       	add	r30, r24
    16ca:	f9 1f       	adc	r31, r25
    16cc:	30 81       	ld	r19, Z
    16ce:	d5 01       	movw	r26, r10
    16d0:	a8 0f       	add	r26, r24
    16d2:	b9 1f       	adc	r27, r25
    16d4:	59 96       	adiw	r26, 0x19	; 25
    16d6:	3c 93       	st	X, r19

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    16d8:	80 81       	ld	r24, Z
    16da:	88 23       	and	r24, r24
    16dc:	19 f0       	breq	.+6      	; 0x16e4 <prvInitialiseNewTask+0x56>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    16de:	2f 5f       	subi	r18, 0xFF	; 255
    16e0:	28 30       	cpi	r18, 0x08	; 8
    16e2:	78 f3       	brcs	.-34     	; 0x16c2 <prvInitialiseNewTask+0x34>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    16e4:	f5 01       	movw	r30, r10
    16e6:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    16e8:	f3 e0       	ldi	r31, 0x03	; 3
    16ea:	fe 15       	cp	r31, r14
    16ec:	20 f4       	brcc	.+8      	; 0x16f6 <prvInitialiseNewTask+0x68>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    16ee:	0f 2e       	mov	r0, r31
    16f0:	f3 e0       	ldi	r31, 0x03	; 3
    16f2:	ef 2e       	mov	r14, r31
    16f4:	f0 2d       	mov	r31, r0
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    16f6:	f5 01       	movw	r30, r10
    16f8:	e6 8a       	std	Z+22, r14	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
    16fa:	e1 a2       	std	Z+33, r14	; 0x21
		pxNewTCB->uxMutexesHeld = 0;
    16fc:	12 a2       	std	Z+34, r1	; 0x22
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    16fe:	c5 01       	movw	r24, r10
    1700:	02 96       	adiw	r24, 0x02	; 2
    1702:	0e 94 83 04 	call	0x906	; 0x906 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    1706:	c5 01       	movw	r24, r10
    1708:	0c 96       	adiw	r24, 0x0c	; 12
    170a:	0e 94 83 04 	call	0x906	; 0x906 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    170e:	f5 01       	movw	r30, r10
    1710:	b1 86       	std	Z+9, r11	; 0x09
    1712:	a0 86       	std	Z+8, r10	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1714:	84 e0       	ldi	r24, 0x04	; 4
    1716:	90 e0       	ldi	r25, 0x00	; 0
    1718:	8e 19       	sub	r24, r14
    171a:	91 09       	sbc	r25, r1
    171c:	95 87       	std	Z+13, r25	; 0x0d
    171e:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    1720:	b3 8a       	std	Z+19, r11	; 0x13
    1722:	a2 8a       	std	Z+18, r10	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    1724:	13 a2       	std	Z+35, r1	; 0x23
    1726:	14 a2       	std	Z+36, r1	; 0x24
    1728:	15 a2       	std	Z+37, r1	; 0x25
    172a:	16 a2       	std	Z+38, r1	; 0x26
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    172c:	17 a2       	std	Z+39, r1	; 0x27
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    172e:	a8 01       	movw	r20, r16
    1730:	b4 01       	movw	r22, r8
    1732:	c3 01       	movw	r24, r6
    1734:	0e 94 09 05 	call	0xa12	; 0xa12 <pxPortInitialiseStack>
    1738:	f5 01       	movw	r30, r10
    173a:	91 83       	std	Z+1, r25	; 0x01
    173c:	80 83       	st	Z, r24
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( ( void * ) pxCreatedTask != NULL )
    173e:	c1 14       	cp	r12, r1
    1740:	d1 04       	cpc	r13, r1
    1742:	19 f0       	breq	.+6      	; 0x174a <prvInitialiseNewTask+0xbc>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    1744:	f6 01       	movw	r30, r12
    1746:	b1 82       	std	Z+1, r11	; 0x01
    1748:	a0 82       	st	Z, r10
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    174a:	df 91       	pop	r29
    174c:	cf 91       	pop	r28
    174e:	1f 91       	pop	r17
    1750:	0f 91       	pop	r16
    1752:	ef 90       	pop	r14
    1754:	df 90       	pop	r13
    1756:	cf 90       	pop	r12
    1758:	bf 90       	pop	r11
    175a:	af 90       	pop	r10
    175c:	9f 90       	pop	r9
    175e:	8f 90       	pop	r8
    1760:	7f 90       	pop	r7
    1762:	6f 90       	pop	r6
    1764:	08 95       	ret

00001766 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    1766:	cf 93       	push	r28
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    1768:	c0 e0       	ldi	r28, 0x00	; 0
    176a:	10 c0       	rjmp	.+32     	; 0x178c <prvInitialiseTaskLists+0x26>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    176c:	8c 2f       	mov	r24, r28
    176e:	90 e0       	ldi	r25, 0x00	; 0
    1770:	9c 01       	movw	r18, r24
    1772:	22 0f       	add	r18, r18
    1774:	33 1f       	adc	r19, r19
    1776:	22 0f       	add	r18, r18
    1778:	33 1f       	adc	r19, r19
    177a:	22 0f       	add	r18, r18
    177c:	33 1f       	adc	r19, r19
    177e:	82 0f       	add	r24, r18
    1780:	93 1f       	adc	r25, r19
    1782:	8b 56       	subi	r24, 0x6B	; 107
    1784:	92 4f       	sbci	r25, 0xF2	; 242
    1786:	0e 94 75 04 	call	0x8ea	; 0x8ea <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    178a:	cf 5f       	subi	r28, 0xFF	; 255
    178c:	c4 30       	cpi	r28, 0x04	; 4
    178e:	70 f3       	brcs	.-36     	; 0x176c <prvInitialiseTaskLists+0x6>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    1790:	8c e8       	ldi	r24, 0x8C	; 140
    1792:	9d e0       	ldi	r25, 0x0D	; 13
    1794:	0e 94 75 04 	call	0x8ea	; 0x8ea <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    1798:	83 e8       	ldi	r24, 0x83	; 131
    179a:	9d e0       	ldi	r25, 0x0D	; 13
    179c:	0e 94 75 04 	call	0x8ea	; 0x8ea <vListInitialise>
	vListInitialise( &xPendingReadyList );
    17a0:	86 e7       	ldi	r24, 0x76	; 118
    17a2:	9d e0       	ldi	r25, 0x0D	; 13
    17a4:	0e 94 75 04 	call	0x8ea	; 0x8ea <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    17a8:	8c e8       	ldi	r24, 0x8C	; 140
    17aa:	9d e0       	ldi	r25, 0x0D	; 13
    17ac:	90 93 82 0d 	sts	0x0D82, r25	; 0x800d82 <pxDelayedTaskList+0x1>
    17b0:	80 93 81 0d 	sts	0x0D81, r24	; 0x800d81 <pxDelayedTaskList>
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    17b4:	83 e8       	ldi	r24, 0x83	; 131
    17b6:	9d e0       	ldi	r25, 0x0D	; 13
    17b8:	90 93 80 0d 	sts	0x0D80, r25	; 0x800d80 <pxOverflowDelayedTaskList+0x1>
    17bc:	80 93 7f 0d 	sts	0x0D7F, r24	; 0x800d7f <pxOverflowDelayedTaskList>
}
    17c0:	cf 91       	pop	r28
    17c2:	08 95       	ret

000017c4 <prvAddNewTaskToReadyList>:
	}
}
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
    17c4:	cf 93       	push	r28
    17c6:	df 93       	push	r29
    17c8:	ec 01       	movw	r28, r24
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    17ca:	0f b6       	in	r0, 0x3f	; 63
    17cc:	f8 94       	cli
    17ce:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    17d0:	80 91 75 0d 	lds	r24, 0x0D75	; 0x800d75 <uxCurrentNumberOfTasks>
    17d4:	8f 5f       	subi	r24, 0xFF	; 255
    17d6:	80 93 75 0d 	sts	0x0D75, r24	; 0x800d75 <uxCurrentNumberOfTasks>
		if( pxCurrentTCB == NULL )
    17da:	80 91 b9 0d 	lds	r24, 0x0DB9	; 0x800db9 <pxCurrentTCB>
    17de:	90 91 ba 0d 	lds	r25, 0x0DBA	; 0x800dba <pxCurrentTCB+0x1>
    17e2:	89 2b       	or	r24, r25
    17e4:	59 f4       	brne	.+22     	; 0x17fc <prvAddNewTaskToReadyList+0x38>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    17e6:	d0 93 ba 0d 	sts	0x0DBA, r29	; 0x800dba <pxCurrentTCB+0x1>
    17ea:	c0 93 b9 0d 	sts	0x0DB9, r28	; 0x800db9 <pxCurrentTCB>

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    17ee:	80 91 75 0d 	lds	r24, 0x0D75	; 0x800d75 <uxCurrentNumberOfTasks>
    17f2:	81 30       	cpi	r24, 0x01	; 1
    17f4:	99 f4       	brne	.+38     	; 0x181c <prvAddNewTaskToReadyList+0x58>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
    17f6:	0e 94 b3 0b 	call	0x1766	; 0x1766 <prvInitialiseTaskLists>
    17fa:	10 c0       	rjmp	.+32     	; 0x181c <prvAddNewTaskToReadyList+0x58>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    17fc:	80 91 71 0d 	lds	r24, 0x0D71	; 0x800d71 <xSchedulerRunning>
    1800:	81 11       	cpse	r24, r1
    1802:	0c c0       	rjmp	.+24     	; 0x181c <prvAddNewTaskToReadyList+0x58>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    1804:	e0 91 b9 0d 	lds	r30, 0x0DB9	; 0x800db9 <pxCurrentTCB>
    1808:	f0 91 ba 0d 	lds	r31, 0x0DBA	; 0x800dba <pxCurrentTCB+0x1>
    180c:	96 89       	ldd	r25, Z+22	; 0x16
    180e:	8e 89       	ldd	r24, Y+22	; 0x16
    1810:	89 17       	cp	r24, r25
    1812:	20 f0       	brcs	.+8      	; 0x181c <prvAddNewTaskToReadyList+0x58>
				{
					pxCurrentTCB = pxNewTCB;
    1814:	d0 93 ba 0d 	sts	0x0DBA, r29	; 0x800dba <pxCurrentTCB+0x1>
    1818:	c0 93 b9 0d 	sts	0x0DB9, r28	; 0x800db9 <pxCurrentTCB>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    181c:	80 91 6d 0d 	lds	r24, 0x0D6D	; 0x800d6d <uxTaskNumber>
    1820:	8f 5f       	subi	r24, 0xFF	; 255
    1822:	80 93 6d 0d 	sts	0x0D6D, r24	; 0x800d6d <uxTaskNumber>
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    1826:	8e 89       	ldd	r24, Y+22	; 0x16
    1828:	90 91 72 0d 	lds	r25, 0x0D72	; 0x800d72 <uxTopReadyPriority>
    182c:	98 17       	cp	r25, r24
    182e:	10 f4       	brcc	.+4      	; 0x1834 <prvAddNewTaskToReadyList+0x70>
    1830:	80 93 72 0d 	sts	0x0D72, r24	; 0x800d72 <uxTopReadyPriority>
    1834:	90 e0       	ldi	r25, 0x00	; 0
    1836:	9c 01       	movw	r18, r24
    1838:	22 0f       	add	r18, r18
    183a:	33 1f       	adc	r19, r19
    183c:	22 0f       	add	r18, r18
    183e:	33 1f       	adc	r19, r19
    1840:	22 0f       	add	r18, r18
    1842:	33 1f       	adc	r19, r19
    1844:	82 0f       	add	r24, r18
    1846:	93 1f       	adc	r25, r19
    1848:	be 01       	movw	r22, r28
    184a:	6e 5f       	subi	r22, 0xFE	; 254
    184c:	7f 4f       	sbci	r23, 0xFF	; 255
    184e:	8b 56       	subi	r24, 0x6B	; 107
    1850:	92 4f       	sbci	r25, 0xF2	; 242
    1852:	0e 94 87 04 	call	0x90e	; 0x90e <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    1856:	0f 90       	pop	r0
    1858:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    185a:	80 91 71 0d 	lds	r24, 0x0D71	; 0x800d71 <xSchedulerRunning>
    185e:	88 23       	and	r24, r24
    1860:	51 f0       	breq	.+20     	; 0x1876 <prvAddNewTaskToReadyList+0xb2>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    1862:	e0 91 b9 0d 	lds	r30, 0x0DB9	; 0x800db9 <pxCurrentTCB>
    1866:	f0 91 ba 0d 	lds	r31, 0x0DBA	; 0x800dba <pxCurrentTCB+0x1>
    186a:	96 89       	ldd	r25, Z+22	; 0x16
    186c:	8e 89       	ldd	r24, Y+22	; 0x16
    186e:	98 17       	cp	r25, r24
    1870:	10 f4       	brcc	.+4      	; 0x1876 <prvAddNewTaskToReadyList+0xb2>
		{
			taskYIELD_IF_USING_PREEMPTION();
    1872:	0e 94 a5 05 	call	0xb4a	; 0xb4a <vPortYield>
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    1876:	df 91       	pop	r29
    1878:	cf 91       	pop	r28
    187a:	08 95       	ret

0000187c <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    187c:	0f 93       	push	r16
    187e:	1f 93       	push	r17
    1880:	cf 93       	push	r28
    1882:	df 93       	push	r29
    1884:	ec 01       	movw	r28, r24
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    1886:	00 91 73 0d 	lds	r16, 0x0D73	; 0x800d73 <xTickCount>
    188a:	10 91 74 0d 	lds	r17, 0x0D74	; 0x800d74 <xTickCount+0x1>
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    188e:	80 91 b9 0d 	lds	r24, 0x0DB9	; 0x800db9 <pxCurrentTCB>
    1892:	90 91 ba 0d 	lds	r25, 0x0DBA	; 0x800dba <pxCurrentTCB+0x1>
    1896:	02 96       	adiw	r24, 0x02	; 2
    1898:	0e 94 d9 04 	call	0x9b2	; 0x9b2 <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
		/* Calculate the time at which the task should be woken if the event
		does not occur.  This may overflow but this doesn't matter, the kernel
		will manage it correctly. */
		xTimeToWake = xConstTickCount + xTicksToWait;
    189c:	c0 0f       	add	r28, r16
    189e:	d1 1f       	adc	r29, r17

		/* The list item will be inserted in wake time order. */
		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    18a0:	e0 91 b9 0d 	lds	r30, 0x0DB9	; 0x800db9 <pxCurrentTCB>
    18a4:	f0 91 ba 0d 	lds	r31, 0x0DBA	; 0x800dba <pxCurrentTCB+0x1>
    18a8:	d3 83       	std	Z+3, r29	; 0x03
    18aa:	c2 83       	std	Z+2, r28	; 0x02

		if( xTimeToWake < xConstTickCount )
    18ac:	c0 17       	cp	r28, r16
    18ae:	d1 07       	cpc	r29, r17
    18b0:	68 f4       	brcc	.+26     	; 0x18cc <prvAddCurrentTaskToDelayedList+0x50>
		{
			/* Wake time has overflowed.  Place this item in the overflow list. */
			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    18b2:	60 91 b9 0d 	lds	r22, 0x0DB9	; 0x800db9 <pxCurrentTCB>
    18b6:	70 91 ba 0d 	lds	r23, 0x0DBA	; 0x800dba <pxCurrentTCB+0x1>
    18ba:	80 91 7f 0d 	lds	r24, 0x0D7F	; 0x800d7f <pxOverflowDelayedTaskList>
    18be:	90 91 80 0d 	lds	r25, 0x0D80	; 0x800d80 <pxOverflowDelayedTaskList+0x1>
    18c2:	6e 5f       	subi	r22, 0xFE	; 254
    18c4:	7f 4f       	sbci	r23, 0xFF	; 255
    18c6:	0e 94 a8 04 	call	0x950	; 0x950 <vListInsert>
    18ca:	17 c0       	rjmp	.+46     	; 0x18fa <prvAddCurrentTaskToDelayedList+0x7e>
		}
		else
		{
			/* The wake time has not overflowed, so the current block list is used. */
			vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    18cc:	60 91 b9 0d 	lds	r22, 0x0DB9	; 0x800db9 <pxCurrentTCB>
    18d0:	70 91 ba 0d 	lds	r23, 0x0DBA	; 0x800dba <pxCurrentTCB+0x1>
    18d4:	80 91 81 0d 	lds	r24, 0x0D81	; 0x800d81 <pxDelayedTaskList>
    18d8:	90 91 82 0d 	lds	r25, 0x0D82	; 0x800d82 <pxDelayedTaskList+0x1>
    18dc:	6e 5f       	subi	r22, 0xFE	; 254
    18de:	7f 4f       	sbci	r23, 0xFF	; 255
    18e0:	0e 94 a8 04 	call	0x950	; 0x950 <vListInsert>

			/* If the task entering the blocked state was placed at the head of the
			list of blocked tasks then xNextTaskUnblockTime needs to be updated
			too. */
			if( xTimeToWake < xNextTaskUnblockTime )
    18e4:	80 91 6b 0d 	lds	r24, 0x0D6B	; 0x800d6b <xNextTaskUnblockTime>
    18e8:	90 91 6c 0d 	lds	r25, 0x0D6C	; 0x800d6c <xNextTaskUnblockTime+0x1>
    18ec:	c8 17       	cp	r28, r24
    18ee:	d9 07       	cpc	r29, r25
    18f0:	20 f4       	brcc	.+8      	; 0x18fa <prvAddCurrentTaskToDelayedList+0x7e>
			{
				xNextTaskUnblockTime = xTimeToWake;
    18f2:	d0 93 6c 0d 	sts	0x0D6C, r29	; 0x800d6c <xNextTaskUnblockTime+0x1>
    18f6:	c0 93 6b 0d 	sts	0x0D6B, r28	; 0x800d6b <xNextTaskUnblockTime>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    18fa:	df 91       	pop	r29
    18fc:	cf 91       	pop	r28
    18fe:	1f 91       	pop	r17
    1900:	0f 91       	pop	r16
    1902:	08 95       	ret

00001904 <prvIdleTask>:

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    1904:	80 91 95 0d 	lds	r24, 0x0D95	; 0x800d95 <pxReadyTasksLists>
    1908:	82 30       	cpi	r24, 0x02	; 2
    190a:	10 f0       	brcs	.+4      	; 0x1910 <prvIdleTask+0xc>
			{
				taskYIELD();
    190c:	0e 94 a5 05 	call	0xb4a	; 0xb4a <vPortYield>
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
    1910:	0e 94 16 15 	call	0x2a2c	; 0x2a2c <vApplicationIdleHook>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
    1914:	f7 cf       	rjmp	.-18     	; 0x1904 <prvIdleTask>

00001916 <xTaskCreate>:
							const char * const pcName,
							const uint16_t usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
    1916:	2f 92       	push	r2
    1918:	3f 92       	push	r3
    191a:	4f 92       	push	r4
    191c:	5f 92       	push	r5
    191e:	6f 92       	push	r6
    1920:	7f 92       	push	r7
    1922:	8f 92       	push	r8
    1924:	9f 92       	push	r9
    1926:	af 92       	push	r10
    1928:	bf 92       	push	r11
    192a:	cf 92       	push	r12
    192c:	df 92       	push	r13
    192e:	ef 92       	push	r14
    1930:	ff 92       	push	r15
    1932:	0f 93       	push	r16
    1934:	1f 93       	push	r17
    1936:	cf 93       	push	r28
    1938:	df 93       	push	r29
    193a:	3c 01       	movw	r6, r24
    193c:	1b 01       	movw	r2, r22
    193e:	5a 01       	movw	r10, r20
    1940:	29 01       	movw	r4, r18
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1942:	ca 01       	movw	r24, r20
    1944:	0e 94 5d 06 	call	0xcba	; 0xcba <pvPortMalloc>
    1948:	6c 01       	movw	r12, r24

			if( pxStack != NULL )
    194a:	89 2b       	or	r24, r25
    194c:	71 f0       	breq	.+28     	; 0x196a <xTaskCreate+0x54>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
    194e:	88 e2       	ldi	r24, 0x28	; 40
    1950:	90 e0       	ldi	r25, 0x00	; 0
    1952:	0e 94 5d 06 	call	0xcba	; 0xcba <pvPortMalloc>
    1956:	ec 01       	movw	r28, r24

				if( pxNewTCB != NULL )
    1958:	89 2b       	or	r24, r25
    195a:	19 f0       	breq	.+6      	; 0x1962 <xTaskCreate+0x4c>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    195c:	d8 8e       	std	Y+24, r13	; 0x18
    195e:	cf 8a       	std	Y+23, r12	; 0x17
    1960:	06 c0       	rjmp	.+12     	; 0x196e <xTaskCreate+0x58>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    1962:	c6 01       	movw	r24, r12
    1964:	0e 94 92 06 	call	0xd24	; 0xd24 <vPortFree>
    1968:	02 c0       	rjmp	.+4      	; 0x196e <xTaskCreate+0x58>
				}
			}
			else
			{
				pxNewTCB = NULL;
    196a:	c0 e0       	ldi	r28, 0x00	; 0
    196c:	d0 e0       	ldi	r29, 0x00	; 0
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
    196e:	20 97       	sbiw	r28, 0x00	; 0
    1970:	91 f0       	breq	.+36     	; 0x1996 <xTaskCreate+0x80>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    1972:	95 01       	movw	r18, r10
    1974:	40 e0       	ldi	r20, 0x00	; 0
    1976:	50 e0       	ldi	r21, 0x00	; 0
    1978:	81 2c       	mov	r8, r1
    197a:	91 2c       	mov	r9, r1
    197c:	5e 01       	movw	r10, r28
    197e:	67 01       	movw	r12, r14
    1980:	e0 2e       	mov	r14, r16
    1982:	82 01       	movw	r16, r4
    1984:	b1 01       	movw	r22, r2
    1986:	c3 01       	movw	r24, r6
    1988:	0e 94 47 0b 	call	0x168e	; 0x168e <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
    198c:	ce 01       	movw	r24, r28
    198e:	0e 94 e2 0b 	call	0x17c4	; 0x17c4 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
    1992:	81 e0       	ldi	r24, 0x01	; 1
    1994:	01 c0       	rjmp	.+2      	; 0x1998 <xTaskCreate+0x82>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1996:	8f ef       	ldi	r24, 0xFF	; 255
		}

		return xReturn;
	}
    1998:	df 91       	pop	r29
    199a:	cf 91       	pop	r28
    199c:	1f 91       	pop	r17
    199e:	0f 91       	pop	r16
    19a0:	ff 90       	pop	r15
    19a2:	ef 90       	pop	r14
    19a4:	df 90       	pop	r13
    19a6:	cf 90       	pop	r12
    19a8:	bf 90       	pop	r11
    19aa:	af 90       	pop	r10
    19ac:	9f 90       	pop	r9
    19ae:	8f 90       	pop	r8
    19b0:	7f 90       	pop	r7
    19b2:	6f 90       	pop	r6
    19b4:	5f 90       	pop	r5
    19b6:	4f 90       	pop	r4
    19b8:	3f 90       	pop	r3
    19ba:	2f 90       	pop	r2
    19bc:	08 95       	ret

000019be <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    19be:	ef 92       	push	r14
    19c0:	ff 92       	push	r15
    19c2:	0f 93       	push	r16
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    19c4:	0f 2e       	mov	r0, r31
    19c6:	f9 e6       	ldi	r31, 0x69	; 105
    19c8:	ef 2e       	mov	r14, r31
    19ca:	fd e0       	ldi	r31, 0x0D	; 13
    19cc:	ff 2e       	mov	r15, r31
    19ce:	f0 2d       	mov	r31, r0
    19d0:	00 e0       	ldi	r16, 0x00	; 0
    19d2:	20 e0       	ldi	r18, 0x00	; 0
    19d4:	30 e0       	ldi	r19, 0x00	; 0
    19d6:	45 e5       	ldi	r20, 0x55	; 85
    19d8:	50 e0       	ldi	r21, 0x00	; 0
    19da:	60 e0       	ldi	r22, 0x00	; 0
    19dc:	71 e0       	ldi	r23, 0x01	; 1
    19de:	82 e8       	ldi	r24, 0x82	; 130
    19e0:	9c e0       	ldi	r25, 0x0C	; 12
    19e2:	0e 94 8b 0c 	call	0x1916	; 0x1916 <xTaskCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    19e6:	81 30       	cpi	r24, 0x01	; 1
    19e8:	81 f4       	brne	.+32     	; 0x1a0a <vTaskStartScheduler+0x4c>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    19ea:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    19ec:	8f ef       	ldi	r24, 0xFF	; 255
    19ee:	9f ef       	ldi	r25, 0xFF	; 255
    19f0:	90 93 6c 0d 	sts	0x0D6C, r25	; 0x800d6c <xNextTaskUnblockTime+0x1>
    19f4:	80 93 6b 0d 	sts	0x0D6B, r24	; 0x800d6b <xNextTaskUnblockTime>
		xSchedulerRunning = pdTRUE;
    19f8:	81 e0       	ldi	r24, 0x01	; 1
    19fa:	80 93 71 0d 	sts	0x0D71, r24	; 0x800d71 <xSchedulerRunning>
		xTickCount = ( TickType_t ) 0U;
    19fe:	10 92 74 0d 	sts	0x0D74, r1	; 0x800d74 <xTickCount+0x1>
    1a02:	10 92 73 0d 	sts	0x0D73, r1	; 0x800d73 <xTickCount>
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    1a06:	0e 94 75 05 	call	0xaea	; 0xaea <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    1a0a:	0f 91       	pop	r16
    1a0c:	ff 90       	pop	r15
    1a0e:	ef 90       	pop	r14
    1a10:	08 95       	ret

00001a12 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    1a12:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    1a14:	10 92 71 0d 	sts	0x0D71, r1	; 0x800d71 <xSchedulerRunning>
	vPortEndScheduler();
    1a18:	0e 94 a4 05 	call	0xb48	; 0xb48 <vPortEndScheduler>
    1a1c:	08 95       	ret

00001a1e <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    1a1e:	80 91 68 0d 	lds	r24, 0x0D68	; 0x800d68 <uxSchedulerSuspended>
    1a22:	8f 5f       	subi	r24, 0xFF	; 255
    1a24:	80 93 68 0d 	sts	0x0D68, r24	; 0x800d68 <uxSchedulerSuspended>
    1a28:	08 95       	ret

00001a2a <xTaskGetTickCount>:
TickType_t xTaskGetTickCount( void )
{
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    1a2a:	0f b6       	in	r0, 0x3f	; 63
    1a2c:	f8 94       	cli
    1a2e:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    1a30:	80 91 73 0d 	lds	r24, 0x0D73	; 0x800d73 <xTickCount>
    1a34:	90 91 74 0d 	lds	r25, 0x0D74	; 0x800d74 <xTickCount+0x1>
	}
	portTICK_TYPE_EXIT_CRITICAL();
    1a38:	0f 90       	pop	r0
    1a3a:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    1a3c:	08 95       	ret

00001a3e <xTaskGetTickCountFromISR>:
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
	{
		xReturn = xTickCount;
    1a3e:	80 91 73 0d 	lds	r24, 0x0D73	; 0x800d73 <xTickCount>
    1a42:	90 91 74 0d 	lds	r25, 0x0D74	; 0x800d74 <xTickCount+0x1>
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1a46:	08 95       	ret

00001a48 <uxTaskGetNumberOfTasks>:

UBaseType_t uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    1a48:	80 91 75 0d 	lds	r24, 0x0D75	; 0x800d75 <uxCurrentNumberOfTasks>
}
    1a4c:	08 95       	ret

00001a4e <pcTaskGetName>:
{
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    1a4e:	00 97       	sbiw	r24, 0x00	; 0
    1a50:	21 f4       	brne	.+8      	; 0x1a5a <pcTaskGetName+0xc>
    1a52:	80 91 b9 0d 	lds	r24, 0x0DB9	; 0x800db9 <pxCurrentTCB>
    1a56:	90 91 ba 0d 	lds	r25, 0x0DBA	; 0x800dba <pxCurrentTCB+0x1>
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
}
    1a5a:	49 96       	adiw	r24, 0x19	; 25
    1a5c:	08 95       	ret

00001a5e <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    1a5e:	df 92       	push	r13
    1a60:	ef 92       	push	r14
    1a62:	ff 92       	push	r15
    1a64:	0f 93       	push	r16
    1a66:	1f 93       	push	r17
    1a68:	cf 93       	push	r28
    1a6a:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1a6c:	80 91 68 0d 	lds	r24, 0x0D68	; 0x800d68 <uxSchedulerSuspended>
    1a70:	81 11       	cpse	r24, r1
    1a72:	97 c0       	rjmp	.+302    	; 0x1ba2 <xTaskIncrementTick+0x144>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + 1;
    1a74:	e0 90 73 0d 	lds	r14, 0x0D73	; 0x800d73 <xTickCount>
    1a78:	f0 90 74 0d 	lds	r15, 0x0D74	; 0x800d74 <xTickCount+0x1>
    1a7c:	8f ef       	ldi	r24, 0xFF	; 255
    1a7e:	e8 1a       	sub	r14, r24
    1a80:	f8 0a       	sbc	r15, r24

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    1a82:	f0 92 74 0d 	sts	0x0D74, r15	; 0x800d74 <xTickCount+0x1>
    1a86:	e0 92 73 0d 	sts	0x0D73, r14	; 0x800d73 <xTickCount>

		if( xConstTickCount == ( TickType_t ) 0U )
    1a8a:	e1 14       	cp	r14, r1
    1a8c:	f1 04       	cpc	r15, r1
    1a8e:	b9 f4       	brne	.+46     	; 0x1abe <xTaskIncrementTick+0x60>
		{
			taskSWITCH_DELAYED_LISTS();
    1a90:	80 91 81 0d 	lds	r24, 0x0D81	; 0x800d81 <pxDelayedTaskList>
    1a94:	90 91 82 0d 	lds	r25, 0x0D82	; 0x800d82 <pxDelayedTaskList+0x1>
    1a98:	20 91 7f 0d 	lds	r18, 0x0D7F	; 0x800d7f <pxOverflowDelayedTaskList>
    1a9c:	30 91 80 0d 	lds	r19, 0x0D80	; 0x800d80 <pxOverflowDelayedTaskList+0x1>
    1aa0:	30 93 82 0d 	sts	0x0D82, r19	; 0x800d82 <pxDelayedTaskList+0x1>
    1aa4:	20 93 81 0d 	sts	0x0D81, r18	; 0x800d81 <pxDelayedTaskList>
    1aa8:	90 93 80 0d 	sts	0x0D80, r25	; 0x800d80 <pxOverflowDelayedTaskList+0x1>
    1aac:	80 93 7f 0d 	sts	0x0D7F, r24	; 0x800d7f <pxOverflowDelayedTaskList>
    1ab0:	80 91 6e 0d 	lds	r24, 0x0D6E	; 0x800d6e <xNumOfOverflows>
    1ab4:	8f 5f       	subi	r24, 0xFF	; 255
    1ab6:	80 93 6e 0d 	sts	0x0D6E, r24	; 0x800d6e <xNumOfOverflows>
    1aba:	0e 94 28 0b 	call	0x1650	; 0x1650 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    1abe:	80 91 6b 0d 	lds	r24, 0x0D6B	; 0x800d6b <xNextTaskUnblockTime>
    1ac2:	90 91 6c 0d 	lds	r25, 0x0D6C	; 0x800d6c <xNextTaskUnblockTime+0x1>
    1ac6:	e8 16       	cp	r14, r24
    1ac8:	f9 06       	cpc	r15, r25
    1aca:	28 f4       	brcc	.+10     	; 0x1ad6 <xTaskIncrementTick+0x78>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    1acc:	d1 2c       	mov	r13, r1
    1ace:	53 c0       	rjmp	.+166    	; 0x1b76 <xTaskIncrementTick+0x118>
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
						{
							xSwitchRequired = pdTRUE;
    1ad0:	dd 24       	eor	r13, r13
    1ad2:	d3 94       	inc	r13
    1ad4:	01 c0       	rjmp	.+2      	; 0x1ad8 <xTaskIncrementTick+0x7a>
    1ad6:	d1 2c       	mov	r13, r1
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    1ad8:	e0 91 81 0d 	lds	r30, 0x0D81	; 0x800d81 <pxDelayedTaskList>
    1adc:	f0 91 82 0d 	lds	r31, 0x0D82	; 0x800d82 <pxDelayedTaskList+0x1>
    1ae0:	80 81       	ld	r24, Z
    1ae2:	81 11       	cpse	r24, r1
    1ae4:	07 c0       	rjmp	.+14     	; 0x1af4 <xTaskIncrementTick+0x96>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1ae6:	8f ef       	ldi	r24, 0xFF	; 255
    1ae8:	9f ef       	ldi	r25, 0xFF	; 255
    1aea:	90 93 6c 0d 	sts	0x0D6C, r25	; 0x800d6c <xNextTaskUnblockTime+0x1>
    1aee:	80 93 6b 0d 	sts	0x0D6B, r24	; 0x800d6b <xNextTaskUnblockTime>
					break;
    1af2:	41 c0       	rjmp	.+130    	; 0x1b76 <xTaskIncrementTick+0x118>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    1af4:	e0 91 81 0d 	lds	r30, 0x0D81	; 0x800d81 <pxDelayedTaskList>
    1af8:	f0 91 82 0d 	lds	r31, 0x0D82	; 0x800d82 <pxDelayedTaskList+0x1>
    1afc:	05 80       	ldd	r0, Z+5	; 0x05
    1afe:	f6 81       	ldd	r31, Z+6	; 0x06
    1b00:	e0 2d       	mov	r30, r0
    1b02:	c6 81       	ldd	r28, Z+6	; 0x06
    1b04:	d7 81       	ldd	r29, Z+7	; 0x07
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    1b06:	8a 81       	ldd	r24, Y+2	; 0x02
    1b08:	9b 81       	ldd	r25, Y+3	; 0x03

					if( xConstTickCount < xItemValue )
    1b0a:	e8 16       	cp	r14, r24
    1b0c:	f9 06       	cpc	r15, r25
    1b0e:	28 f4       	brcc	.+10     	; 0x1b1a <xTaskIncrementTick+0xbc>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    1b10:	90 93 6c 0d 	sts	0x0D6C, r25	; 0x800d6c <xNextTaskUnblockTime+0x1>
    1b14:	80 93 6b 0d 	sts	0x0D6B, r24	; 0x800d6b <xNextTaskUnblockTime>
						break;
    1b18:	2e c0       	rjmp	.+92     	; 0x1b76 <xTaskIncrementTick+0x118>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1b1a:	8e 01       	movw	r16, r28
    1b1c:	0e 5f       	subi	r16, 0xFE	; 254
    1b1e:	1f 4f       	sbci	r17, 0xFF	; 255
    1b20:	c8 01       	movw	r24, r16
    1b22:	0e 94 d9 04 	call	0x9b2	; 0x9b2 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    1b26:	8c 89       	ldd	r24, Y+20	; 0x14
    1b28:	9d 89       	ldd	r25, Y+21	; 0x15
    1b2a:	89 2b       	or	r24, r25
    1b2c:	21 f0       	breq	.+8      	; 0x1b36 <xTaskIncrementTick+0xd8>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    1b2e:	ce 01       	movw	r24, r28
    1b30:	0c 96       	adiw	r24, 0x0c	; 12
    1b32:	0e 94 d9 04 	call	0x9b2	; 0x9b2 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    1b36:	8e 89       	ldd	r24, Y+22	; 0x16
    1b38:	90 91 72 0d 	lds	r25, 0x0D72	; 0x800d72 <uxTopReadyPriority>
    1b3c:	98 17       	cp	r25, r24
    1b3e:	10 f4       	brcc	.+4      	; 0x1b44 <xTaskIncrementTick+0xe6>
    1b40:	80 93 72 0d 	sts	0x0D72, r24	; 0x800d72 <uxTopReadyPriority>
    1b44:	90 e0       	ldi	r25, 0x00	; 0
    1b46:	9c 01       	movw	r18, r24
    1b48:	22 0f       	add	r18, r18
    1b4a:	33 1f       	adc	r19, r19
    1b4c:	22 0f       	add	r18, r18
    1b4e:	33 1f       	adc	r19, r19
    1b50:	22 0f       	add	r18, r18
    1b52:	33 1f       	adc	r19, r19
    1b54:	82 0f       	add	r24, r18
    1b56:	93 1f       	adc	r25, r19
    1b58:	b8 01       	movw	r22, r16
    1b5a:	8b 56       	subi	r24, 0x6B	; 107
    1b5c:	92 4f       	sbci	r25, 0xF2	; 242
    1b5e:	0e 94 87 04 	call	0x90e	; 0x90e <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1b62:	9e 89       	ldd	r25, Y+22	; 0x16
    1b64:	e0 91 b9 0d 	lds	r30, 0x0DB9	; 0x800db9 <pxCurrentTCB>
    1b68:	f0 91 ba 0d 	lds	r31, 0x0DBA	; 0x800dba <pxCurrentTCB+0x1>
    1b6c:	86 89       	ldd	r24, Z+22	; 0x16
    1b6e:	98 17       	cp	r25, r24
    1b70:	08 f0       	brcs	.+2      	; 0x1b74 <xTaskIncrementTick+0x116>
    1b72:	ae cf       	rjmp	.-164    	; 0x1ad0 <xTaskIncrementTick+0x72>
    1b74:	b1 cf       	rjmp	.-158    	; 0x1ad8 <xTaskIncrementTick+0x7a>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    1b76:	e0 91 b9 0d 	lds	r30, 0x0DB9	; 0x800db9 <pxCurrentTCB>
    1b7a:	f0 91 ba 0d 	lds	r31, 0x0DBA	; 0x800dba <pxCurrentTCB+0x1>
    1b7e:	86 89       	ldd	r24, Z+22	; 0x16
    1b80:	90 e0       	ldi	r25, 0x00	; 0
    1b82:	fc 01       	movw	r30, r24
    1b84:	ee 0f       	add	r30, r30
    1b86:	ff 1f       	adc	r31, r31
    1b88:	ee 0f       	add	r30, r30
    1b8a:	ff 1f       	adc	r31, r31
    1b8c:	ee 0f       	add	r30, r30
    1b8e:	ff 1f       	adc	r31, r31
    1b90:	8e 0f       	add	r24, r30
    1b92:	9f 1f       	adc	r25, r31
    1b94:	fc 01       	movw	r30, r24
    1b96:	eb 56       	subi	r30, 0x6B	; 107
    1b98:	f2 4f       	sbci	r31, 0xF2	; 242
    1b9a:	80 81       	ld	r24, Z
    1b9c:	82 30       	cpi	r24, 0x02	; 2
    1b9e:	40 f4       	brcc	.+16     	; 0x1bb0 <xTaskIncrementTick+0x152>
    1ba0:	09 c0       	rjmp	.+18     	; 0x1bb4 <xTaskIncrementTick+0x156>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    1ba2:	80 91 70 0d 	lds	r24, 0x0D70	; 0x800d70 <uxPendedTicks>
    1ba6:	8f 5f       	subi	r24, 0xFF	; 255
    1ba8:	80 93 70 0d 	sts	0x0D70, r24	; 0x800d70 <uxPendedTicks>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    1bac:	d1 2c       	mov	r13, r1
    1bae:	02 c0       	rjmp	.+4      	; 0x1bb4 <xTaskIncrementTick+0x156>
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
			{
				xSwitchRequired = pdTRUE;
    1bb0:	dd 24       	eor	r13, r13
    1bb2:	d3 94       	inc	r13
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    1bb4:	80 91 6f 0d 	lds	r24, 0x0D6F	; 0x800d6f <xYieldPending>
    1bb8:	88 23       	and	r24, r24
    1bba:	11 f0       	breq	.+4      	; 0x1bc0 <xTaskIncrementTick+0x162>
		{
			xSwitchRequired = pdTRUE;
    1bbc:	dd 24       	eor	r13, r13
    1bbe:	d3 94       	inc	r13
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
    1bc0:	8d 2d       	mov	r24, r13
    1bc2:	df 91       	pop	r29
    1bc4:	cf 91       	pop	r28
    1bc6:	1f 91       	pop	r17
    1bc8:	0f 91       	pop	r16
    1bca:	ff 90       	pop	r15
    1bcc:	ef 90       	pop	r14
    1bce:	df 90       	pop	r13
    1bd0:	08 95       	ret

00001bd2 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    1bd2:	0f 93       	push	r16
    1bd4:	1f 93       	push	r17
    1bd6:	cf 93       	push	r28
    1bd8:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    1bda:	0f b6       	in	r0, 0x3f	; 63
    1bdc:	f8 94       	cli
    1bde:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    1be0:	80 91 68 0d 	lds	r24, 0x0D68	; 0x800d68 <uxSchedulerSuspended>
    1be4:	81 50       	subi	r24, 0x01	; 1
    1be6:	80 93 68 0d 	sts	0x0D68, r24	; 0x800d68 <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1bea:	80 91 68 0d 	lds	r24, 0x0D68	; 0x800d68 <uxSchedulerSuspended>
    1bee:	81 11       	cpse	r24, r1
    1bf0:	58 c0       	rjmp	.+176    	; 0x1ca2 <xTaskResumeAll+0xd0>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    1bf2:	80 91 75 0d 	lds	r24, 0x0D75	; 0x800d75 <uxCurrentNumberOfTasks>
    1bf6:	81 11       	cpse	r24, r1
    1bf8:	33 c0       	rjmp	.+102    	; 0x1c60 <xTaskResumeAll+0x8e>
    1bfa:	56 c0       	rjmp	.+172    	; 0x1ca8 <xTaskResumeAll+0xd6>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    1bfc:	e0 91 7b 0d 	lds	r30, 0x0D7B	; 0x800d7b <xPendingReadyList+0x5>
    1c00:	f0 91 7c 0d 	lds	r31, 0x0D7C	; 0x800d7c <xPendingReadyList+0x6>
    1c04:	c6 81       	ldd	r28, Z+6	; 0x06
    1c06:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    1c08:	ce 01       	movw	r24, r28
    1c0a:	0c 96       	adiw	r24, 0x0c	; 12
    1c0c:	0e 94 d9 04 	call	0x9b2	; 0x9b2 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1c10:	8e 01       	movw	r16, r28
    1c12:	0e 5f       	subi	r16, 0xFE	; 254
    1c14:	1f 4f       	sbci	r17, 0xFF	; 255
    1c16:	c8 01       	movw	r24, r16
    1c18:	0e 94 d9 04 	call	0x9b2	; 0x9b2 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    1c1c:	8e 89       	ldd	r24, Y+22	; 0x16
    1c1e:	90 91 72 0d 	lds	r25, 0x0D72	; 0x800d72 <uxTopReadyPriority>
    1c22:	98 17       	cp	r25, r24
    1c24:	10 f4       	brcc	.+4      	; 0x1c2a <xTaskResumeAll+0x58>
    1c26:	80 93 72 0d 	sts	0x0D72, r24	; 0x800d72 <uxTopReadyPriority>
    1c2a:	90 e0       	ldi	r25, 0x00	; 0
    1c2c:	9c 01       	movw	r18, r24
    1c2e:	22 0f       	add	r18, r18
    1c30:	33 1f       	adc	r19, r19
    1c32:	22 0f       	add	r18, r18
    1c34:	33 1f       	adc	r19, r19
    1c36:	22 0f       	add	r18, r18
    1c38:	33 1f       	adc	r19, r19
    1c3a:	82 0f       	add	r24, r18
    1c3c:	93 1f       	adc	r25, r19
    1c3e:	b8 01       	movw	r22, r16
    1c40:	8b 56       	subi	r24, 0x6B	; 107
    1c42:	92 4f       	sbci	r25, 0xF2	; 242
    1c44:	0e 94 87 04 	call	0x90e	; 0x90e <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1c48:	9e 89       	ldd	r25, Y+22	; 0x16
    1c4a:	e0 91 b9 0d 	lds	r30, 0x0DB9	; 0x800db9 <pxCurrentTCB>
    1c4e:	f0 91 ba 0d 	lds	r31, 0x0DBA	; 0x800dba <pxCurrentTCB+0x1>
    1c52:	86 89       	ldd	r24, Z+22	; 0x16
    1c54:	98 17       	cp	r25, r24
    1c56:	30 f0       	brcs	.+12     	; 0x1c64 <xTaskResumeAll+0x92>
					{
						xYieldPending = pdTRUE;
    1c58:	81 e0       	ldi	r24, 0x01	; 1
    1c5a:	80 93 6f 0d 	sts	0x0D6F, r24	; 0x800d6f <xYieldPending>
    1c5e:	02 c0       	rjmp	.+4      	; 0x1c64 <xTaskResumeAll+0x92>
    1c60:	c0 e0       	ldi	r28, 0x00	; 0
    1c62:	d0 e0       	ldi	r29, 0x00	; 0
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    1c64:	80 91 76 0d 	lds	r24, 0x0D76	; 0x800d76 <xPendingReadyList>
    1c68:	81 11       	cpse	r24, r1
    1c6a:	c8 cf       	rjmp	.-112    	; 0x1bfc <xTaskResumeAll+0x2a>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    1c6c:	cd 2b       	or	r28, r29
    1c6e:	11 f0       	breq	.+4      	; 0x1c74 <xTaskResumeAll+0xa2>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    1c70:	0e 94 28 0b 	call	0x1650	; 0x1650 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    1c74:	c0 91 70 0d 	lds	r28, 0x0D70	; 0x800d70 <uxPendedTicks>

					if( uxPendedCounts > ( UBaseType_t ) 0U )
    1c78:	cc 23       	and	r28, r28
    1c7a:	59 f0       	breq	.+22     	; 0x1c92 <xTaskResumeAll+0xc0>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    1c7c:	0e 94 2f 0d 	call	0x1a5e	; 0x1a5e <xTaskIncrementTick>
    1c80:	88 23       	and	r24, r24
    1c82:	19 f0       	breq	.+6      	; 0x1c8a <xTaskResumeAll+0xb8>
							{
								xYieldPending = pdTRUE;
    1c84:	81 e0       	ldi	r24, 0x01	; 1
    1c86:	80 93 6f 0d 	sts	0x0D6F, r24	; 0x800d6f <xYieldPending>
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
    1c8a:	c1 50       	subi	r28, 0x01	; 1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    1c8c:	b9 f7       	brne	.-18     	; 0x1c7c <xTaskResumeAll+0xaa>

						uxPendedTicks = 0;
    1c8e:	10 92 70 0d 	sts	0x0D70, r1	; 0x800d70 <uxPendedTicks>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    1c92:	80 91 6f 0d 	lds	r24, 0x0D6F	; 0x800d6f <xYieldPending>
    1c96:	88 23       	and	r24, r24
    1c98:	31 f0       	breq	.+12     	; 0x1ca6 <xTaskResumeAll+0xd4>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    1c9a:	0e 94 a5 05 	call	0xb4a	; 0xb4a <vPortYield>

				if( xYieldPending != pdFALSE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    1c9e:	81 e0       	ldi	r24, 0x01	; 1
    1ca0:	03 c0       	rjmp	.+6      	; 0x1ca8 <xTaskResumeAll+0xd6>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB = NULL;
BaseType_t xAlreadyYielded = pdFALSE;
    1ca2:	80 e0       	ldi	r24, 0x00	; 0
    1ca4:	01 c0       	rjmp	.+2      	; 0x1ca8 <xTaskResumeAll+0xd6>
    1ca6:	80 e0       	ldi	r24, 0x00	; 0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    1ca8:	0f 90       	pop	r0
    1caa:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    1cac:	df 91       	pop	r29
    1cae:	cf 91       	pop	r28
    1cb0:	1f 91       	pop	r17
    1cb2:	0f 91       	pop	r16
    1cb4:	08 95       	ret

00001cb6 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    1cb6:	0f 93       	push	r16
    1cb8:	1f 93       	push	r17
    1cba:	cf 93       	push	r28
    1cbc:	df 93       	push	r29
    1cbe:	8c 01       	movw	r16, r24
    1cc0:	eb 01       	movw	r28, r22

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    1cc2:	0e 94 0f 0d 	call	0x1a1e	; 0x1a1e <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    1cc6:	40 91 73 0d 	lds	r20, 0x0D73	; 0x800d73 <xTickCount>
    1cca:	50 91 74 0d 	lds	r21, 0x0D74	; 0x800d74 <xTickCount+0x1>

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    1cce:	f8 01       	movw	r30, r16
    1cd0:	20 81       	ld	r18, Z
    1cd2:	31 81       	ldd	r19, Z+1	; 0x01
    1cd4:	c9 01       	movw	r24, r18
    1cd6:	8c 0f       	add	r24, r28
    1cd8:	9d 1f       	adc	r25, r29

			if( xConstTickCount < *pxPreviousWakeTime )
    1cda:	42 17       	cp	r20, r18
    1cdc:	53 07       	cpc	r21, r19
    1cde:	40 f4       	brcc	.+16     	; 0x1cf0 <vTaskDelayUntil+0x3a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    1ce0:	82 17       	cp	r24, r18
    1ce2:	93 07       	cpc	r25, r19
    1ce4:	68 f4       	brcc	.+26     	; 0x1d00 <vTaskDelayUntil+0x4a>
    1ce6:	48 17       	cp	r20, r24
    1ce8:	59 07       	cpc	r21, r25
    1cea:	60 f0       	brcs	.+24     	; 0x1d04 <vTaskDelayUntil+0x4e>
#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    1cec:	20 e0       	ldi	r18, 0x00	; 0
    1cee:	0f c0       	rjmp	.+30     	; 0x1d0e <vTaskDelayUntil+0x58>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    1cf0:	82 17       	cp	r24, r18
    1cf2:	93 07       	cpc	r25, r19
    1cf4:	48 f0       	brcs	.+18     	; 0x1d08 <vTaskDelayUntil+0x52>
    1cf6:	48 17       	cp	r20, r24
    1cf8:	59 07       	cpc	r21, r25
    1cfa:	40 f0       	brcs	.+16     	; 0x1d0c <vTaskDelayUntil+0x56>
#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    1cfc:	20 e0       	ldi	r18, 0x00	; 0
    1cfe:	07 c0       	rjmp	.+14     	; 0x1d0e <vTaskDelayUntil+0x58>
    1d00:	20 e0       	ldi	r18, 0x00	; 0
    1d02:	05 c0       	rjmp	.+10     	; 0x1d0e <vTaskDelayUntil+0x58>
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
				{
					xShouldDelay = pdTRUE;
    1d04:	21 e0       	ldi	r18, 0x01	; 1
    1d06:	03 c0       	rjmp	.+6      	; 0x1d0e <vTaskDelayUntil+0x58>
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
				{
					xShouldDelay = pdTRUE;
    1d08:	21 e0       	ldi	r18, 0x01	; 1
    1d0a:	01 c0       	rjmp	.+2      	; 0x1d0e <vTaskDelayUntil+0x58>
    1d0c:	21 e0       	ldi	r18, 0x01	; 1
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    1d0e:	f8 01       	movw	r30, r16
    1d10:	91 83       	std	Z+1, r25	; 0x01
    1d12:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    1d14:	22 23       	and	r18, r18
    1d16:	29 f0       	breq	.+10     	; 0x1d22 <vTaskDelayUntil+0x6c>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    1d18:	60 e0       	ldi	r22, 0x00	; 0
    1d1a:	84 1b       	sub	r24, r20
    1d1c:	95 0b       	sbc	r25, r21
    1d1e:	0e 94 3e 0c 	call	0x187c	; 0x187c <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    1d22:	0e 94 e9 0d 	call	0x1bd2	; 0x1bd2 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1d26:	81 11       	cpse	r24, r1
    1d28:	02 c0       	rjmp	.+4      	; 0x1d2e <vTaskDelayUntil+0x78>
		{
			portYIELD_WITHIN_API();
    1d2a:	0e 94 a5 05 	call	0xb4a	; 0xb4a <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    1d2e:	df 91       	pop	r29
    1d30:	cf 91       	pop	r28
    1d32:	1f 91       	pop	r17
    1d34:	0f 91       	pop	r16
    1d36:	08 95       	ret

00001d38 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    1d38:	cf 93       	push	r28
    1d3a:	df 93       	push	r29
    1d3c:	ec 01       	movw	r28, r24
	BaseType_t xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    1d3e:	89 2b       	or	r24, r25
    1d40:	49 f0       	breq	.+18     	; 0x1d54 <vTaskDelay+0x1c>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    1d42:	0e 94 0f 0d 	call	0x1a1e	; 0x1a1e <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    1d46:	60 e0       	ldi	r22, 0x00	; 0
    1d48:	ce 01       	movw	r24, r28
    1d4a:	0e 94 3e 0c 	call	0x187c	; 0x187c <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    1d4e:	0e 94 e9 0d 	call	0x1bd2	; 0x1bd2 <xTaskResumeAll>
    1d52:	01 c0       	rjmp	.+2      	; 0x1d56 <vTaskDelay+0x1e>

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
	BaseType_t xAlreadyYielded = pdFALSE;
    1d54:	80 e0       	ldi	r24, 0x00	; 0
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1d56:	81 11       	cpse	r24, r1
    1d58:	02 c0       	rjmp	.+4      	; 0x1d5e <vTaskDelay+0x26>
		{
			portYIELD_WITHIN_API();
    1d5a:	0e 94 a5 05 	call	0xb4a	; 0xb4a <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    1d5e:	df 91       	pop	r29
    1d60:	cf 91       	pop	r28
    1d62:	08 95       	ret

00001d64 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    1d64:	80 91 68 0d 	lds	r24, 0x0D68	; 0x800d68 <uxSchedulerSuspended>
    1d68:	88 23       	and	r24, r24
    1d6a:	21 f0       	breq	.+8      	; 0x1d74 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    1d6c:	81 e0       	ldi	r24, 0x01	; 1
    1d6e:	80 93 6f 0d 	sts	0x0D6F, r24	; 0x800d6f <xYieldPending>
    1d72:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
    1d74:	10 92 6f 0d 	sts	0x0D6F, r1	; 0x800d6f <xYieldPending>
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    1d78:	20 91 72 0d 	lds	r18, 0x0D72	; 0x800d72 <uxTopReadyPriority>
    1d7c:	01 c0       	rjmp	.+2      	; 0x1d80 <vTaskSwitchContext+0x1c>
    1d7e:	21 50       	subi	r18, 0x01	; 1
    1d80:	82 2f       	mov	r24, r18
    1d82:	90 e0       	ldi	r25, 0x00	; 0
    1d84:	fc 01       	movw	r30, r24
    1d86:	ee 0f       	add	r30, r30
    1d88:	ff 1f       	adc	r31, r31
    1d8a:	ee 0f       	add	r30, r30
    1d8c:	ff 1f       	adc	r31, r31
    1d8e:	ee 0f       	add	r30, r30
    1d90:	ff 1f       	adc	r31, r31
    1d92:	e8 0f       	add	r30, r24
    1d94:	f9 1f       	adc	r31, r25
    1d96:	eb 56       	subi	r30, 0x6B	; 107
    1d98:	f2 4f       	sbci	r31, 0xF2	; 242
    1d9a:	30 81       	ld	r19, Z
    1d9c:	33 23       	and	r19, r19
    1d9e:	79 f3       	breq	.-34     	; 0x1d7e <vTaskSwitchContext+0x1a>
    1da0:	ac 01       	movw	r20, r24
    1da2:	44 0f       	add	r20, r20
    1da4:	55 1f       	adc	r21, r21
    1da6:	44 0f       	add	r20, r20
    1da8:	55 1f       	adc	r21, r21
    1daa:	44 0f       	add	r20, r20
    1dac:	55 1f       	adc	r21, r21
    1dae:	48 0f       	add	r20, r24
    1db0:	59 1f       	adc	r21, r25
    1db2:	df 01       	movw	r26, r30
    1db4:	01 80       	ldd	r0, Z+1	; 0x01
    1db6:	f2 81       	ldd	r31, Z+2	; 0x02
    1db8:	e0 2d       	mov	r30, r0
    1dba:	02 80       	ldd	r0, Z+2	; 0x02
    1dbc:	f3 81       	ldd	r31, Z+3	; 0x03
    1dbe:	e0 2d       	mov	r30, r0
    1dc0:	12 96       	adiw	r26, 0x02	; 2
    1dc2:	fc 93       	st	X, r31
    1dc4:	ee 93       	st	-X, r30
    1dc6:	11 97       	sbiw	r26, 0x01	; 1
    1dc8:	48 56       	subi	r20, 0x68	; 104
    1dca:	52 4f       	sbci	r21, 0xF2	; 242
    1dcc:	e4 17       	cp	r30, r20
    1dce:	f5 07       	cpc	r31, r21
    1dd0:	29 f4       	brne	.+10     	; 0x1ddc <vTaskSwitchContext+0x78>
    1dd2:	42 81       	ldd	r20, Z+2	; 0x02
    1dd4:	53 81       	ldd	r21, Z+3	; 0x03
    1dd6:	fd 01       	movw	r30, r26
    1dd8:	52 83       	std	Z+2, r21	; 0x02
    1dda:	41 83       	std	Z+1, r20	; 0x01
    1ddc:	fc 01       	movw	r30, r24
    1dde:	ee 0f       	add	r30, r30
    1de0:	ff 1f       	adc	r31, r31
    1de2:	ee 0f       	add	r30, r30
    1de4:	ff 1f       	adc	r31, r31
    1de6:	ee 0f       	add	r30, r30
    1de8:	ff 1f       	adc	r31, r31
    1dea:	8e 0f       	add	r24, r30
    1dec:	9f 1f       	adc	r25, r31
    1dee:	fc 01       	movw	r30, r24
    1df0:	eb 56       	subi	r30, 0x6B	; 107
    1df2:	f2 4f       	sbci	r31, 0xF2	; 242
    1df4:	01 80       	ldd	r0, Z+1	; 0x01
    1df6:	f2 81       	ldd	r31, Z+2	; 0x02
    1df8:	e0 2d       	mov	r30, r0
    1dfa:	86 81       	ldd	r24, Z+6	; 0x06
    1dfc:	97 81       	ldd	r25, Z+7	; 0x07
    1dfe:	90 93 ba 0d 	sts	0x0DBA, r25	; 0x800dba <pxCurrentTCB+0x1>
    1e02:	80 93 b9 0d 	sts	0x0DB9, r24	; 0x800db9 <pxCurrentTCB>
    1e06:	20 93 72 0d 	sts	0x0D72, r18	; 0x800d72 <uxTopReadyPriority>
    1e0a:	08 95       	ret

00001e0c <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    1e0c:	cf 93       	push	r28
    1e0e:	df 93       	push	r29
    1e10:	eb 01       	movw	r28, r22

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    1e12:	60 91 b9 0d 	lds	r22, 0x0DB9	; 0x800db9 <pxCurrentTCB>
    1e16:	70 91 ba 0d 	lds	r23, 0x0DBA	; 0x800dba <pxCurrentTCB+0x1>
    1e1a:	64 5f       	subi	r22, 0xF4	; 244
    1e1c:	7f 4f       	sbci	r23, 0xFF	; 255
    1e1e:	0e 94 a8 04 	call	0x950	; 0x950 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    1e22:	61 e0       	ldi	r22, 0x01	; 1
    1e24:	ce 01       	movw	r24, r28
    1e26:	0e 94 3e 0c 	call	0x187c	; 0x187c <prvAddCurrentTaskToDelayedList>
}
    1e2a:	df 91       	pop	r29
    1e2c:	cf 91       	pop	r28
    1e2e:	08 95       	ret

00001e30 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    1e30:	cf 93       	push	r28
    1e32:	df 93       	push	r29
    1e34:	ea 01       	movw	r28, r20
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    1e36:	e0 91 b9 0d 	lds	r30, 0x0DB9	; 0x800db9 <pxCurrentTCB>
    1e3a:	f0 91 ba 0d 	lds	r31, 0x0DBA	; 0x800dba <pxCurrentTCB+0x1>
    1e3e:	70 68       	ori	r23, 0x80	; 128
    1e40:	75 87       	std	Z+13, r23	; 0x0d
    1e42:	64 87       	std	Z+12, r22	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    1e44:	60 91 b9 0d 	lds	r22, 0x0DB9	; 0x800db9 <pxCurrentTCB>
    1e48:	70 91 ba 0d 	lds	r23, 0x0DBA	; 0x800dba <pxCurrentTCB+0x1>
    1e4c:	64 5f       	subi	r22, 0xF4	; 244
    1e4e:	7f 4f       	sbci	r23, 0xFF	; 255
    1e50:	0e 94 87 04 	call	0x90e	; 0x90e <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    1e54:	61 e0       	ldi	r22, 0x01	; 1
    1e56:	ce 01       	movw	r24, r28
    1e58:	0e 94 3e 0c 	call	0x187c	; 0x187c <prvAddCurrentTaskToDelayedList>
}
    1e5c:	df 91       	pop	r29
    1e5e:	cf 91       	pop	r28
    1e60:	08 95       	ret

00001e62 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    1e62:	0f 93       	push	r16
    1e64:	1f 93       	push	r17
    1e66:	cf 93       	push	r28
    1e68:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1e6a:	dc 01       	movw	r26, r24
    1e6c:	15 96       	adiw	r26, 0x05	; 5
    1e6e:	ed 91       	ld	r30, X+
    1e70:	fc 91       	ld	r31, X
    1e72:	16 97       	sbiw	r26, 0x06	; 6
    1e74:	c6 81       	ldd	r28, Z+6	; 0x06
    1e76:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    1e78:	8e 01       	movw	r16, r28
    1e7a:	04 5f       	subi	r16, 0xF4	; 244
    1e7c:	1f 4f       	sbci	r17, 0xFF	; 255
    1e7e:	c8 01       	movw	r24, r16
    1e80:	0e 94 d9 04 	call	0x9b2	; 0x9b2 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1e84:	80 91 68 0d 	lds	r24, 0x0D68	; 0x800d68 <uxSchedulerSuspended>
    1e88:	81 11       	cpse	r24, r1
    1e8a:	1c c0       	rjmp	.+56     	; 0x1ec4 <xTaskRemoveFromEventList+0x62>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    1e8c:	0a 50       	subi	r16, 0x0A	; 10
    1e8e:	11 09       	sbc	r17, r1
    1e90:	c8 01       	movw	r24, r16
    1e92:	0e 94 d9 04 	call	0x9b2	; 0x9b2 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    1e96:	8e 89       	ldd	r24, Y+22	; 0x16
    1e98:	90 91 72 0d 	lds	r25, 0x0D72	; 0x800d72 <uxTopReadyPriority>
    1e9c:	98 17       	cp	r25, r24
    1e9e:	10 f4       	brcc	.+4      	; 0x1ea4 <xTaskRemoveFromEventList+0x42>
    1ea0:	80 93 72 0d 	sts	0x0D72, r24	; 0x800d72 <uxTopReadyPriority>
    1ea4:	90 e0       	ldi	r25, 0x00	; 0
    1ea6:	9c 01       	movw	r18, r24
    1ea8:	22 0f       	add	r18, r18
    1eaa:	33 1f       	adc	r19, r19
    1eac:	22 0f       	add	r18, r18
    1eae:	33 1f       	adc	r19, r19
    1eb0:	22 0f       	add	r18, r18
    1eb2:	33 1f       	adc	r19, r19
    1eb4:	82 0f       	add	r24, r18
    1eb6:	93 1f       	adc	r25, r19
    1eb8:	b8 01       	movw	r22, r16
    1eba:	8b 56       	subi	r24, 0x6B	; 107
    1ebc:	92 4f       	sbci	r25, 0xF2	; 242
    1ebe:	0e 94 87 04 	call	0x90e	; 0x90e <vListInsertEnd>
    1ec2:	05 c0       	rjmp	.+10     	; 0x1ece <xTaskRemoveFromEventList+0x6c>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    1ec4:	b8 01       	movw	r22, r16
    1ec6:	86 e7       	ldi	r24, 0x76	; 118
    1ec8:	9d e0       	ldi	r25, 0x0D	; 13
    1eca:	0e 94 87 04 	call	0x90e	; 0x90e <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    1ece:	9e 89       	ldd	r25, Y+22	; 0x16
    1ed0:	e0 91 b9 0d 	lds	r30, 0x0DB9	; 0x800db9 <pxCurrentTCB>
    1ed4:	f0 91 ba 0d 	lds	r31, 0x0DBA	; 0x800dba <pxCurrentTCB+0x1>
    1ed8:	86 89       	ldd	r24, Z+22	; 0x16
    1eda:	89 17       	cp	r24, r25
    1edc:	20 f4       	brcc	.+8      	; 0x1ee6 <xTaskRemoveFromEventList+0x84>
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    1ede:	81 e0       	ldi	r24, 0x01	; 1
    1ee0:	80 93 6f 0d 	sts	0x0D6F, r24	; 0x800d6f <xYieldPending>
    1ee4:	01 c0       	rjmp	.+2      	; 0x1ee8 <xTaskRemoveFromEventList+0x86>
	}
	else
	{
		xReturn = pdFALSE;
    1ee6:	80 e0       	ldi	r24, 0x00	; 0
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
}
    1ee8:	df 91       	pop	r29
    1eea:	cf 91       	pop	r28
    1eec:	1f 91       	pop	r17
    1eee:	0f 91       	pop	r16
    1ef0:	08 95       	ret

00001ef2 <xTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    1ef2:	0f 93       	push	r16
    1ef4:	1f 93       	push	r17
    1ef6:	cf 93       	push	r28
    1ef8:	df 93       	push	r29
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    1efa:	70 68       	ori	r23, 0x80	; 128
    1efc:	fc 01       	movw	r30, r24
    1efe:	71 83       	std	Z+1, r23	; 0x01
    1f00:	60 83       	st	Z, r22

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
    1f02:	c6 81       	ldd	r28, Z+6	; 0x06
    1f04:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    1f06:	0e 94 d9 04 	call	0x9b2	; 0x9b2 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    1f0a:	8e 01       	movw	r16, r28
    1f0c:	0e 5f       	subi	r16, 0xFE	; 254
    1f0e:	1f 4f       	sbci	r17, 0xFF	; 255
    1f10:	c8 01       	movw	r24, r16
    1f12:	0e 94 d9 04 	call	0x9b2	; 0x9b2 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    1f16:	8e 89       	ldd	r24, Y+22	; 0x16
    1f18:	90 91 72 0d 	lds	r25, 0x0D72	; 0x800d72 <uxTopReadyPriority>
    1f1c:	98 17       	cp	r25, r24
    1f1e:	10 f4       	brcc	.+4      	; 0x1f24 <xTaskRemoveFromUnorderedEventList+0x32>
    1f20:	80 93 72 0d 	sts	0x0D72, r24	; 0x800d72 <uxTopReadyPriority>
    1f24:	90 e0       	ldi	r25, 0x00	; 0
    1f26:	9c 01       	movw	r18, r24
    1f28:	22 0f       	add	r18, r18
    1f2a:	33 1f       	adc	r19, r19
    1f2c:	22 0f       	add	r18, r18
    1f2e:	33 1f       	adc	r19, r19
    1f30:	22 0f       	add	r18, r18
    1f32:	33 1f       	adc	r19, r19
    1f34:	82 0f       	add	r24, r18
    1f36:	93 1f       	adc	r25, r19
    1f38:	b8 01       	movw	r22, r16
    1f3a:	8b 56       	subi	r24, 0x6B	; 107
    1f3c:	92 4f       	sbci	r25, 0xF2	; 242
    1f3e:	0e 94 87 04 	call	0x90e	; 0x90e <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    1f42:	9e 89       	ldd	r25, Y+22	; 0x16
    1f44:	e0 91 b9 0d 	lds	r30, 0x0DB9	; 0x800db9 <pxCurrentTCB>
    1f48:	f0 91 ba 0d 	lds	r31, 0x0DBA	; 0x800dba <pxCurrentTCB+0x1>
    1f4c:	86 89       	ldd	r24, Z+22	; 0x16
    1f4e:	89 17       	cp	r24, r25
    1f50:	20 f4       	brcc	.+8      	; 0x1f5a <xTaskRemoveFromUnorderedEventList+0x68>
		switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    1f52:	81 e0       	ldi	r24, 0x01	; 1
    1f54:	80 93 6f 0d 	sts	0x0D6F, r24	; 0x800d6f <xYieldPending>
    1f58:	01 c0       	rjmp	.+2      	; 0x1f5c <xTaskRemoveFromUnorderedEventList+0x6a>
	}
	else
	{
		xReturn = pdFALSE;
    1f5a:	80 e0       	ldi	r24, 0x00	; 0
	}

	return xReturn;
}
    1f5c:	df 91       	pop	r29
    1f5e:	cf 91       	pop	r28
    1f60:	1f 91       	pop	r17
    1f62:	0f 91       	pop	r16
    1f64:	08 95       	ret

00001f66 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    1f66:	20 91 6e 0d 	lds	r18, 0x0D6E	; 0x800d6e <xNumOfOverflows>
    1f6a:	fc 01       	movw	r30, r24
    1f6c:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    1f6e:	20 91 73 0d 	lds	r18, 0x0D73	; 0x800d73 <xTickCount>
    1f72:	30 91 74 0d 	lds	r19, 0x0D74	; 0x800d74 <xTickCount+0x1>
    1f76:	32 83       	std	Z+2, r19	; 0x02
    1f78:	21 83       	std	Z+1, r18	; 0x01
    1f7a:	08 95       	ret

00001f7c <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    1f7c:	cf 93       	push	r28
    1f7e:	df 93       	push	r29
    1f80:	fc 01       	movw	r30, r24
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    1f82:	0f b6       	in	r0, 0x3f	; 63
    1f84:	f8 94       	cli
    1f86:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    1f88:	40 91 73 0d 	lds	r20, 0x0D73	; 0x800d73 <xTickCount>
    1f8c:	50 91 74 0d 	lds	r21, 0x0D74	; 0x800d74 <xTickCount+0x1>
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    1f90:	90 81       	ld	r25, Z
    1f92:	80 91 6e 0d 	lds	r24, 0x0D6E	; 0x800d6e <xNumOfOverflows>
    1f96:	98 17       	cp	r25, r24
    1f98:	29 f0       	breq	.+10     	; 0x1fa4 <xTaskCheckForTimeOut+0x28>
    1f9a:	81 81       	ldd	r24, Z+1	; 0x01
    1f9c:	92 81       	ldd	r25, Z+2	; 0x02
    1f9e:	48 17       	cp	r20, r24
    1fa0:	59 07       	cpc	r21, r25
    1fa2:	b0 f4       	brcc	.+44     	; 0x1fd0 <xTaskCheckForTimeOut+0x54>
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    1fa4:	21 81       	ldd	r18, Z+1	; 0x01
    1fa6:	32 81       	ldd	r19, Z+2	; 0x02
    1fa8:	ca 01       	movw	r24, r20
    1faa:	82 1b       	sub	r24, r18
    1fac:	93 0b       	sbc	r25, r19
    1fae:	eb 01       	movw	r28, r22
    1fb0:	a8 81       	ld	r26, Y
    1fb2:	b9 81       	ldd	r27, Y+1	; 0x01
    1fb4:	8a 17       	cp	r24, r26
    1fb6:	9b 07       	cpc	r25, r27
    1fb8:	68 f4       	brcc	.+26     	; 0x1fd4 <xTaskCheckForTimeOut+0x58>
    1fba:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
    1fbc:	24 1b       	sub	r18, r20
    1fbe:	35 0b       	sbc	r19, r21
    1fc0:	2a 0f       	add	r18, r26
    1fc2:	3b 1f       	adc	r19, r27
    1fc4:	39 83       	std	Y+1, r19	; 0x01
    1fc6:	28 83       	st	Y, r18
			vTaskSetTimeOutState( pxTimeOut );
    1fc8:	0e 94 b3 0f 	call	0x1f66	; 0x1f66 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    1fcc:	80 e0       	ldi	r24, 0x00	; 0
    1fce:	03 c0       	rjmp	.+6      	; 0x1fd6 <xTaskCheckForTimeOut+0x5a>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    1fd0:	81 e0       	ldi	r24, 0x01	; 1
    1fd2:	01 c0       	rjmp	.+2      	; 0x1fd6 <xTaskCheckForTimeOut+0x5a>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    1fd4:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    1fd6:	0f 90       	pop	r0
    1fd8:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    1fda:	df 91       	pop	r29
    1fdc:	cf 91       	pop	r28
    1fde:	08 95       	ret

00001fe0 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    1fe0:	81 e0       	ldi	r24, 0x01	; 1
    1fe2:	80 93 6f 0d 	sts	0x0D6F, r24	; 0x800d6f <xYieldPending>
    1fe6:	08 95       	ret

00001fe8 <xTaskGetCurrentTaskHandle>:
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    1fe8:	80 91 b9 0d 	lds	r24, 0x0DB9	; 0x800db9 <pxCurrentTCB>
    1fec:	90 91 ba 0d 	lds	r25, 0x0DBA	; 0x800dba <pxCurrentTCB+0x1>

		return xReturn;
	}
    1ff0:	08 95       	ret

00001ff2 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
    1ff2:	0f 93       	push	r16
    1ff4:	1f 93       	push	r17
    1ff6:	cf 93       	push	r28
    1ff8:	df 93       	push	r29
    1ffa:	fc 01       	movw	r30, r24
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
    1ffc:	89 2b       	or	r24, r25
    1ffe:	09 f4       	brne	.+2      	; 0x2002 <vTaskPriorityInherit+0x10>
    2000:	55 c0       	rjmp	.+170    	; 0x20ac <vTaskPriorityInherit+0xba>
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    2002:	26 89       	ldd	r18, Z+22	; 0x16
    2004:	a0 91 b9 0d 	lds	r26, 0x0DB9	; 0x800db9 <pxCurrentTCB>
    2008:	b0 91 ba 0d 	lds	r27, 0x0DBA	; 0x800dba <pxCurrentTCB+0x1>
    200c:	56 96       	adiw	r26, 0x16	; 22
    200e:	8c 91       	ld	r24, X
    2010:	28 17       	cp	r18, r24
    2012:	08 f0       	brcs	.+2      	; 0x2016 <vTaskPriorityInherit+0x24>
    2014:	4b c0       	rjmp	.+150    	; 0x20ac <vTaskPriorityInherit+0xba>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not	being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    2016:	84 85       	ldd	r24, Z+12	; 0x0c
    2018:	95 85       	ldd	r25, Z+13	; 0x0d
    201a:	99 23       	and	r25, r25
    201c:	64 f0       	brlt	.+24     	; 0x2036 <vTaskPriorityInherit+0x44>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    201e:	a0 91 b9 0d 	lds	r26, 0x0DB9	; 0x800db9 <pxCurrentTCB>
    2022:	b0 91 ba 0d 	lds	r27, 0x0DBA	; 0x800dba <pxCurrentTCB+0x1>
    2026:	56 96       	adiw	r26, 0x16	; 22
    2028:	3c 91       	ld	r19, X
    202a:	84 e0       	ldi	r24, 0x04	; 4
    202c:	90 e0       	ldi	r25, 0x00	; 0
    202e:	83 1b       	sub	r24, r19
    2030:	91 09       	sbc	r25, r1
    2032:	95 87       	std	Z+13, r25	; 0x0d
    2034:	84 87       	std	Z+12, r24	; 0x0c
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
    2036:	82 85       	ldd	r24, Z+10	; 0x0a
    2038:	93 85       	ldd	r25, Z+11	; 0x0b
    203a:	30 e0       	ldi	r19, 0x00	; 0
    203c:	a9 01       	movw	r20, r18
    203e:	44 0f       	add	r20, r20
    2040:	55 1f       	adc	r21, r21
    2042:	44 0f       	add	r20, r20
    2044:	55 1f       	adc	r21, r21
    2046:	44 0f       	add	r20, r20
    2048:	55 1f       	adc	r21, r21
    204a:	24 0f       	add	r18, r20
    204c:	35 1f       	adc	r19, r21
    204e:	2b 56       	subi	r18, 0x6B	; 107
    2050:	32 4f       	sbci	r19, 0xF2	; 242
    2052:	82 17       	cp	r24, r18
    2054:	93 07       	cpc	r25, r19
    2056:	19 f5       	brne	.+70     	; 0x209e <vTaskPriorityInherit+0xac>
    2058:	8f 01       	movw	r16, r30
				{
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    205a:	ef 01       	movw	r28, r30
    205c:	22 96       	adiw	r28, 0x02	; 2
    205e:	ce 01       	movw	r24, r28
    2060:	0e 94 d9 04 	call	0x9b2	; 0x9b2 <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2064:	e0 91 b9 0d 	lds	r30, 0x0DB9	; 0x800db9 <pxCurrentTCB>
    2068:	f0 91 ba 0d 	lds	r31, 0x0DBA	; 0x800dba <pxCurrentTCB+0x1>
    206c:	86 89       	ldd	r24, Z+22	; 0x16
    206e:	f8 01       	movw	r30, r16
    2070:	86 8b       	std	Z+22, r24	; 0x16
					prvAddTaskToReadyList( pxTCB );
    2072:	90 91 72 0d 	lds	r25, 0x0D72	; 0x800d72 <uxTopReadyPriority>
    2076:	98 17       	cp	r25, r24
    2078:	10 f4       	brcc	.+4      	; 0x207e <vTaskPriorityInherit+0x8c>
    207a:	80 93 72 0d 	sts	0x0D72, r24	; 0x800d72 <uxTopReadyPriority>
    207e:	90 e0       	ldi	r25, 0x00	; 0
    2080:	9c 01       	movw	r18, r24
    2082:	22 0f       	add	r18, r18
    2084:	33 1f       	adc	r19, r19
    2086:	22 0f       	add	r18, r18
    2088:	33 1f       	adc	r19, r19
    208a:	22 0f       	add	r18, r18
    208c:	33 1f       	adc	r19, r19
    208e:	82 0f       	add	r24, r18
    2090:	93 1f       	adc	r25, r19
    2092:	be 01       	movw	r22, r28
    2094:	8b 56       	subi	r24, 0x6B	; 107
    2096:	92 4f       	sbci	r25, 0xF2	; 242
    2098:	0e 94 87 04 	call	0x90e	; 0x90e <vListInsertEnd>
    209c:	07 c0       	rjmp	.+14     	; 0x20ac <vTaskPriorityInherit+0xba>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    209e:	a0 91 b9 0d 	lds	r26, 0x0DB9	; 0x800db9 <pxCurrentTCB>
    20a2:	b0 91 ba 0d 	lds	r27, 0x0DBA	; 0x800dba <pxCurrentTCB+0x1>
    20a6:	56 96       	adiw	r26, 0x16	; 22
    20a8:	8c 91       	ld	r24, X
    20aa:	86 8b       	std	Z+22, r24	; 0x16
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    20ac:	df 91       	pop	r29
    20ae:	cf 91       	pop	r28
    20b0:	1f 91       	pop	r17
    20b2:	0f 91       	pop	r16
    20b4:	08 95       	ret

000020b6 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    20b6:	0f 93       	push	r16
    20b8:	1f 93       	push	r17
    20ba:	cf 93       	push	r28
    20bc:	df 93       	push	r29
    20be:	fc 01       	movw	r30, r24
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;

		if( pxMutexHolder != NULL )
    20c0:	89 2b       	or	r24, r25
    20c2:	79 f1       	breq	.+94     	; 0x2122 <xTaskPriorityDisinherit+0x6c>
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );

			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
    20c4:	82 a1       	ldd	r24, Z+34	; 0x22
    20c6:	81 50       	subi	r24, 0x01	; 1
    20c8:	82 a3       	std	Z+34, r24	; 0x22

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    20ca:	26 89       	ldd	r18, Z+22	; 0x16
    20cc:	91 a1       	ldd	r25, Z+33	; 0x21
    20ce:	29 17       	cp	r18, r25
    20d0:	51 f1       	breq	.+84     	; 0x2126 <xTaskPriorityDisinherit+0x70>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    20d2:	81 11       	cpse	r24, r1
    20d4:	2a c0       	rjmp	.+84     	; 0x212a <xTaskPriorityDisinherit+0x74>
    20d6:	ef 01       	movw	r28, r30
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding	task then it must be the running state task.  Remove
					the	holding task from the ready	list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    20d8:	8f 01       	movw	r16, r30
    20da:	0e 5f       	subi	r16, 0xFE	; 254
    20dc:	1f 4f       	sbci	r17, 0xFF	; 255
    20de:	c8 01       	movw	r24, r16
    20e0:	0e 94 d9 04 	call	0x9b2	; 0x9b2 <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    20e4:	89 a1       	ldd	r24, Y+33	; 0x21
    20e6:	8e 8b       	std	Y+22, r24	; 0x16

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    20e8:	24 e0       	ldi	r18, 0x04	; 4
    20ea:	30 e0       	ldi	r19, 0x00	; 0
    20ec:	28 1b       	sub	r18, r24
    20ee:	31 09       	sbc	r19, r1
    20f0:	3d 87       	std	Y+13, r19	; 0x0d
    20f2:	2c 87       	std	Y+12, r18	; 0x0c
					prvAddTaskToReadyList( pxTCB );
    20f4:	90 91 72 0d 	lds	r25, 0x0D72	; 0x800d72 <uxTopReadyPriority>
    20f8:	98 17       	cp	r25, r24
    20fa:	10 f4       	brcc	.+4      	; 0x2100 <xTaskPriorityDisinherit+0x4a>
    20fc:	80 93 72 0d 	sts	0x0D72, r24	; 0x800d72 <uxTopReadyPriority>
    2100:	90 e0       	ldi	r25, 0x00	; 0
    2102:	9c 01       	movw	r18, r24
    2104:	22 0f       	add	r18, r18
    2106:	33 1f       	adc	r19, r19
    2108:	22 0f       	add	r18, r18
    210a:	33 1f       	adc	r19, r19
    210c:	22 0f       	add	r18, r18
    210e:	33 1f       	adc	r19, r19
    2110:	82 0f       	add	r24, r18
    2112:	93 1f       	adc	r25, r19
    2114:	b8 01       	movw	r22, r16
    2116:	8b 56       	subi	r24, 0x6B	; 107
    2118:	92 4f       	sbci	r25, 0xF2	; 242
    211a:	0e 94 87 04 	call	0x90e	; 0x90e <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
    211e:	81 e0       	ldi	r24, 0x01	; 1
    2120:	05 c0       	rjmp	.+10     	; 0x212c <xTaskPriorityDisinherit+0x76>
#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;
    2122:	80 e0       	ldi	r24, 0x00	; 0
    2124:	03 c0       	rjmp	.+6      	; 0x212c <xTaskPriorityDisinherit+0x76>
    2126:	80 e0       	ldi	r24, 0x00	; 0
    2128:	01 c0       	rjmp	.+2      	; 0x212c <xTaskPriorityDisinherit+0x76>
    212a:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
    212c:	df 91       	pop	r29
    212e:	cf 91       	pop	r28
    2130:	1f 91       	pop	r17
    2132:	0f 91       	pop	r16
    2134:	08 95       	ret

00002136 <uxTaskResetEventItemValue>:

TickType_t uxTaskResetEventItemValue( void )
{
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    2136:	e0 91 b9 0d 	lds	r30, 0x0DB9	; 0x800db9 <pxCurrentTCB>
    213a:	f0 91 ba 0d 	lds	r31, 0x0DBA	; 0x800dba <pxCurrentTCB+0x1>
    213e:	84 85       	ldd	r24, Z+12	; 0x0c
    2140:	95 85       	ldd	r25, Z+13	; 0x0d

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2142:	e0 91 b9 0d 	lds	r30, 0x0DB9	; 0x800db9 <pxCurrentTCB>
    2146:	f0 91 ba 0d 	lds	r31, 0x0DBA	; 0x800dba <pxCurrentTCB+0x1>
    214a:	a0 91 b9 0d 	lds	r26, 0x0DB9	; 0x800db9 <pxCurrentTCB>
    214e:	b0 91 ba 0d 	lds	r27, 0x0DBA	; 0x800dba <pxCurrentTCB+0x1>
    2152:	56 96       	adiw	r26, 0x16	; 22
    2154:	4c 91       	ld	r20, X
    2156:	24 e0       	ldi	r18, 0x04	; 4
    2158:	30 e0       	ldi	r19, 0x00	; 0
    215a:	24 1b       	sub	r18, r20
    215c:	31 09       	sbc	r19, r1
    215e:	35 87       	std	Z+13, r19	; 0x0d
    2160:	24 87       	std	Z+12, r18	; 0x0c

	return uxReturn;
}
    2162:	08 95       	ret

00002164 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    2164:	80 91 b9 0d 	lds	r24, 0x0DB9	; 0x800db9 <pxCurrentTCB>
    2168:	90 91 ba 0d 	lds	r25, 0x0DBA	; 0x800dba <pxCurrentTCB+0x1>
    216c:	89 2b       	or	r24, r25
    216e:	39 f0       	breq	.+14     	; 0x217e <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    2170:	e0 91 b9 0d 	lds	r30, 0x0DB9	; 0x800db9 <pxCurrentTCB>
    2174:	f0 91 ba 0d 	lds	r31, 0x0DBA	; 0x800dba <pxCurrentTCB+0x1>
    2178:	82 a1       	ldd	r24, Z+34	; 0x22
    217a:	8f 5f       	subi	r24, 0xFF	; 255
    217c:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    217e:	80 91 b9 0d 	lds	r24, 0x0DB9	; 0x800db9 <pxCurrentTCB>
    2182:	90 91 ba 0d 	lds	r25, 0x0DBA	; 0x800dba <pxCurrentTCB+0x1>
	}
    2186:	08 95       	ret

00002188 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    2188:	0f 93       	push	r16
    218a:	1f 93       	push	r17
    218c:	cf 93       	push	r28
    218e:	c8 2f       	mov	r28, r24
    2190:	cb 01       	movw	r24, r22
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    2192:	0f b6       	in	r0, 0x3f	; 63
    2194:	f8 94       	cli
    2196:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    2198:	e0 91 b9 0d 	lds	r30, 0x0DB9	; 0x800db9 <pxCurrentTCB>
    219c:	f0 91 ba 0d 	lds	r31, 0x0DBA	; 0x800dba <pxCurrentTCB+0x1>
    21a0:	43 a1       	ldd	r20, Z+35	; 0x23
    21a2:	54 a1       	ldd	r21, Z+36	; 0x24
    21a4:	65 a1       	ldd	r22, Z+37	; 0x25
    21a6:	76 a1       	ldd	r23, Z+38	; 0x26
    21a8:	45 2b       	or	r20, r21
    21aa:	46 2b       	or	r20, r22
    21ac:	47 2b       	or	r20, r23
    21ae:	69 f4       	brne	.+26     	; 0x21ca <ulTaskNotifyTake+0x42>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    21b0:	e0 91 b9 0d 	lds	r30, 0x0DB9	; 0x800db9 <pxCurrentTCB>
    21b4:	f0 91 ba 0d 	lds	r31, 0x0DBA	; 0x800dba <pxCurrentTCB+0x1>
    21b8:	21 e0       	ldi	r18, 0x01	; 1
    21ba:	27 a3       	std	Z+39, r18	; 0x27

				if( xTicksToWait > ( TickType_t ) 0 )
    21bc:	00 97       	sbiw	r24, 0x00	; 0
    21be:	29 f0       	breq	.+10     	; 0x21ca <ulTaskNotifyTake+0x42>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    21c0:	61 e0       	ldi	r22, 0x01	; 1
    21c2:	0e 94 3e 0c 	call	0x187c	; 0x187c <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    21c6:	0e 94 a5 05 	call	0xb4a	; 0xb4a <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    21ca:	0f 90       	pop	r0
    21cc:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    21ce:	0f b6       	in	r0, 0x3f	; 63
    21d0:	f8 94       	cli
    21d2:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    21d4:	e0 91 b9 0d 	lds	r30, 0x0DB9	; 0x800db9 <pxCurrentTCB>
    21d8:	f0 91 ba 0d 	lds	r31, 0x0DBA	; 0x800dba <pxCurrentTCB+0x1>
    21dc:	63 a1       	ldd	r22, Z+35	; 0x23
    21de:	74 a1       	ldd	r23, Z+36	; 0x24
    21e0:	85 a1       	ldd	r24, Z+37	; 0x25
    21e2:	96 a1       	ldd	r25, Z+38	; 0x26

			if( ulReturn != 0UL )
    21e4:	61 15       	cp	r22, r1
    21e6:	71 05       	cpc	r23, r1
    21e8:	81 05       	cpc	r24, r1
    21ea:	91 05       	cpc	r25, r1
    21ec:	c9 f0       	breq	.+50     	; 0x2220 <ulTaskNotifyTake+0x98>
			{
				if( xClearCountOnExit != pdFALSE )
    21ee:	cc 23       	and	r28, r28
    21f0:	49 f0       	breq	.+18     	; 0x2204 <ulTaskNotifyTake+0x7c>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    21f2:	e0 91 b9 0d 	lds	r30, 0x0DB9	; 0x800db9 <pxCurrentTCB>
    21f6:	f0 91 ba 0d 	lds	r31, 0x0DBA	; 0x800dba <pxCurrentTCB+0x1>
    21fa:	13 a2       	std	Z+35, r1	; 0x23
    21fc:	14 a2       	std	Z+36, r1	; 0x24
    21fe:	15 a2       	std	Z+37, r1	; 0x25
    2200:	16 a2       	std	Z+38, r1	; 0x26
    2202:	0e c0       	rjmp	.+28     	; 0x2220 <ulTaskNotifyTake+0x98>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - 1;
    2204:	e0 91 b9 0d 	lds	r30, 0x0DB9	; 0x800db9 <pxCurrentTCB>
    2208:	f0 91 ba 0d 	lds	r31, 0x0DBA	; 0x800dba <pxCurrentTCB+0x1>
    220c:	8b 01       	movw	r16, r22
    220e:	9c 01       	movw	r18, r24
    2210:	01 50       	subi	r16, 0x01	; 1
    2212:	11 09       	sbc	r17, r1
    2214:	21 09       	sbc	r18, r1
    2216:	31 09       	sbc	r19, r1
    2218:	03 a3       	std	Z+35, r16	; 0x23
    221a:	14 a3       	std	Z+36, r17	; 0x24
    221c:	25 a3       	std	Z+37, r18	; 0x25
    221e:	36 a3       	std	Z+38, r19	; 0x26
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    2220:	e0 91 b9 0d 	lds	r30, 0x0DB9	; 0x800db9 <pxCurrentTCB>
    2224:	f0 91 ba 0d 	lds	r31, 0x0DBA	; 0x800dba <pxCurrentTCB+0x1>
    2228:	17 a2       	std	Z+39, r1	; 0x27
		}
		taskEXIT_CRITICAL();
    222a:	0f 90       	pop	r0
    222c:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
	}
    222e:	cf 91       	pop	r28
    2230:	1f 91       	pop	r17
    2232:	0f 91       	pop	r16
    2234:	08 95       	ret

00002236 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    2236:	4f 92       	push	r4
    2238:	5f 92       	push	r5
    223a:	6f 92       	push	r6
    223c:	7f 92       	push	r7
    223e:	8f 92       	push	r8
    2240:	9f 92       	push	r9
    2242:	af 92       	push	r10
    2244:	bf 92       	push	r11
    2246:	ef 92       	push	r14
    2248:	ff 92       	push	r15
    224a:	0f 93       	push	r16
    224c:	1f 93       	push	r17
    224e:	49 01       	movw	r8, r18
    2250:	5a 01       	movw	r10, r20
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    2252:	0f b6       	in	r0, 0x3f	; 63
    2254:	f8 94       	cli
    2256:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    2258:	e0 91 b9 0d 	lds	r30, 0x0DB9	; 0x800db9 <pxCurrentTCB>
    225c:	f0 91 ba 0d 	lds	r31, 0x0DBA	; 0x800dba <pxCurrentTCB+0x1>
    2260:	27 a1       	ldd	r18, Z+39	; 0x27
    2262:	22 30       	cpi	r18, 0x02	; 2
    2264:	29 f1       	breq	.+74     	; 0x22b0 <xTaskNotifyWait+0x7a>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    2266:	e0 91 b9 0d 	lds	r30, 0x0DB9	; 0x800db9 <pxCurrentTCB>
    226a:	f0 91 ba 0d 	lds	r31, 0x0DBA	; 0x800dba <pxCurrentTCB+0x1>
    226e:	43 a0       	ldd	r4, Z+35	; 0x23
    2270:	54 a0       	ldd	r5, Z+36	; 0x24
    2272:	65 a0       	ldd	r6, Z+37	; 0x25
    2274:	76 a0       	ldd	r7, Z+38	; 0x26
    2276:	dc 01       	movw	r26, r24
    2278:	cb 01       	movw	r24, r22
    227a:	80 95       	com	r24
    227c:	90 95       	com	r25
    227e:	a0 95       	com	r26
    2280:	b0 95       	com	r27
    2282:	84 21       	and	r24, r4
    2284:	95 21       	and	r25, r5
    2286:	a6 21       	and	r26, r6
    2288:	b7 21       	and	r27, r7
    228a:	83 a3       	std	Z+35, r24	; 0x23
    228c:	94 a3       	std	Z+36, r25	; 0x24
    228e:	a5 a3       	std	Z+37, r26	; 0x25
    2290:	b6 a3       	std	Z+38, r27	; 0x26

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    2292:	e0 91 b9 0d 	lds	r30, 0x0DB9	; 0x800db9 <pxCurrentTCB>
    2296:	f0 91 ba 0d 	lds	r31, 0x0DBA	; 0x800dba <pxCurrentTCB+0x1>
    229a:	81 e0       	ldi	r24, 0x01	; 1
    229c:	87 a3       	std	Z+39, r24	; 0x27

				if( xTicksToWait > ( TickType_t ) 0 )
    229e:	e1 14       	cp	r14, r1
    22a0:	f1 04       	cpc	r15, r1
    22a2:	31 f0       	breq	.+12     	; 0x22b0 <xTaskNotifyWait+0x7a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    22a4:	61 e0       	ldi	r22, 0x01	; 1
    22a6:	c7 01       	movw	r24, r14
    22a8:	0e 94 3e 0c 	call	0x187c	; 0x187c <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    22ac:	0e 94 a5 05 	call	0xb4a	; 0xb4a <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    22b0:	0f 90       	pop	r0
    22b2:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    22b4:	0f b6       	in	r0, 0x3f	; 63
    22b6:	f8 94       	cli
    22b8:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    22ba:	01 15       	cp	r16, r1
    22bc:	11 05       	cpc	r17, r1
    22be:	69 f0       	breq	.+26     	; 0x22da <xTaskNotifyWait+0xa4>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    22c0:	e0 91 b9 0d 	lds	r30, 0x0DB9	; 0x800db9 <pxCurrentTCB>
    22c4:	f0 91 ba 0d 	lds	r31, 0x0DBA	; 0x800dba <pxCurrentTCB+0x1>
    22c8:	83 a1       	ldd	r24, Z+35	; 0x23
    22ca:	94 a1       	ldd	r25, Z+36	; 0x24
    22cc:	a5 a1       	ldd	r26, Z+37	; 0x25
    22ce:	b6 a1       	ldd	r27, Z+38	; 0x26
    22d0:	f8 01       	movw	r30, r16
    22d2:	80 83       	st	Z, r24
    22d4:	91 83       	std	Z+1, r25	; 0x01
    22d6:	a2 83       	std	Z+2, r26	; 0x02
    22d8:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState == taskWAITING_NOTIFICATION )
    22da:	e0 91 b9 0d 	lds	r30, 0x0DB9	; 0x800db9 <pxCurrentTCB>
    22de:	f0 91 ba 0d 	lds	r31, 0x0DBA	; 0x800dba <pxCurrentTCB+0x1>
    22e2:	87 a1       	ldd	r24, Z+39	; 0x27
    22e4:	81 30       	cpi	r24, 0x01	; 1
    22e6:	b1 f0       	breq	.+44     	; 0x2314 <xTaskNotifyWait+0xde>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    22e8:	e0 91 b9 0d 	lds	r30, 0x0DB9	; 0x800db9 <pxCurrentTCB>
    22ec:	f0 91 ba 0d 	lds	r31, 0x0DBA	; 0x800dba <pxCurrentTCB+0x1>
    22f0:	83 a1       	ldd	r24, Z+35	; 0x23
    22f2:	94 a1       	ldd	r25, Z+36	; 0x24
    22f4:	a5 a1       	ldd	r26, Z+37	; 0x25
    22f6:	b6 a1       	ldd	r27, Z+38	; 0x26
    22f8:	80 94       	com	r8
    22fa:	90 94       	com	r9
    22fc:	a0 94       	com	r10
    22fe:	b0 94       	com	r11
    2300:	88 22       	and	r8, r24
    2302:	99 22       	and	r9, r25
    2304:	aa 22       	and	r10, r26
    2306:	bb 22       	and	r11, r27
    2308:	83 a2       	std	Z+35, r8	; 0x23
    230a:	94 a2       	std	Z+36, r9	; 0x24
    230c:	a5 a2       	std	Z+37, r10	; 0x25
    230e:	b6 a2       	std	Z+38, r11	; 0x26
				xReturn = pdTRUE;
    2310:	81 e0       	ldi	r24, 0x01	; 1
    2312:	01 c0       	rjmp	.+2      	; 0x2316 <xTaskNotifyWait+0xe0>
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState == taskWAITING_NOTIFICATION )
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    2314:	80 e0       	ldi	r24, 0x00	; 0
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
				xReturn = pdTRUE;
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    2316:	e0 91 b9 0d 	lds	r30, 0x0DB9	; 0x800db9 <pxCurrentTCB>
    231a:	f0 91 ba 0d 	lds	r31, 0x0DBA	; 0x800dba <pxCurrentTCB+0x1>
    231e:	17 a2       	std	Z+39, r1	; 0x27
		}
		taskEXIT_CRITICAL();
    2320:	0f 90       	pop	r0
    2322:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    2324:	1f 91       	pop	r17
    2326:	0f 91       	pop	r16
    2328:	ff 90       	pop	r15
    232a:	ef 90       	pop	r14
    232c:	bf 90       	pop	r11
    232e:	af 90       	pop	r10
    2330:	9f 90       	pop	r9
    2332:	8f 90       	pop	r8
    2334:	7f 90       	pop	r7
    2336:	6f 90       	pop	r6
    2338:	5f 90       	pop	r5
    233a:	4f 90       	pop	r4
    233c:	08 95       	ret

0000233e <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    233e:	ef 92       	push	r14
    2340:	ff 92       	push	r15
    2342:	0f 93       	push	r16
    2344:	1f 93       	push	r17
    2346:	cf 93       	push	r28
    2348:	df 93       	push	r29
    234a:	fc 01       	movw	r30, r24
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = ( TCB_t * ) xTaskToNotify;

		taskENTER_CRITICAL();
    234c:	0f b6       	in	r0, 0x3f	; 63
    234e:	f8 94       	cli
    2350:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    2352:	01 15       	cp	r16, r1
    2354:	11 05       	cpc	r17, r1
    2356:	49 f0       	breq	.+18     	; 0x236a <xTaskGenericNotify+0x2c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    2358:	83 a1       	ldd	r24, Z+35	; 0x23
    235a:	94 a1       	ldd	r25, Z+36	; 0x24
    235c:	a5 a1       	ldd	r26, Z+37	; 0x25
    235e:	b6 a1       	ldd	r27, Z+38	; 0x26
    2360:	e8 01       	movw	r28, r16
    2362:	88 83       	st	Y, r24
    2364:	99 83       	std	Y+1, r25	; 0x01
    2366:	aa 83       	std	Y+2, r26	; 0x02
    2368:	bb 83       	std	Y+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    236a:	87 a1       	ldd	r24, Z+39	; 0x27

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    236c:	92 e0       	ldi	r25, 0x02	; 2
    236e:	97 a3       	std	Z+39, r25	; 0x27

			switch( eAction )
    2370:	22 30       	cpi	r18, 0x02	; 2
    2372:	b9 f0       	breq	.+46     	; 0x23a2 <xTaskGenericNotify+0x64>
    2374:	18 f4       	brcc	.+6      	; 0x237c <xTaskGenericNotify+0x3e>
    2376:	21 30       	cpi	r18, 0x01	; 1
    2378:	31 f0       	breq	.+12     	; 0x2386 <xTaskGenericNotify+0x48>
    237a:	2f c0       	rjmp	.+94     	; 0x23da <xTaskGenericNotify+0x9c>
    237c:	23 30       	cpi	r18, 0x03	; 3
    237e:	f9 f0       	breq	.+62     	; 0x23be <xTaskGenericNotify+0x80>
    2380:	24 30       	cpi	r18, 0x04	; 4
    2382:	19 f1       	breq	.+70     	; 0x23ca <xTaskGenericNotify+0x8c>
    2384:	2a c0       	rjmp	.+84     	; 0x23da <xTaskGenericNotify+0x9c>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    2386:	03 a1       	ldd	r16, Z+35	; 0x23
    2388:	14 a1       	ldd	r17, Z+36	; 0x24
    238a:	25 a1       	ldd	r18, Z+37	; 0x25
    238c:	36 a1       	ldd	r19, Z+38	; 0x26
    238e:	40 2b       	or	r20, r16
    2390:	51 2b       	or	r21, r17
    2392:	62 2b       	or	r22, r18
    2394:	73 2b       	or	r23, r19
    2396:	43 a3       	std	Z+35, r20	; 0x23
    2398:	54 a3       	std	Z+36, r21	; 0x24
    239a:	65 a3       	std	Z+37, r22	; 0x25
    239c:	76 a3       	std	Z+38, r23	; 0x26
#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    239e:	11 e0       	ldi	r17, 0x01	; 1

			switch( eAction )
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
					break;
    23a0:	1f c0       	rjmp	.+62     	; 0x23e0 <xTaskGenericNotify+0xa2>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    23a2:	43 a1       	ldd	r20, Z+35	; 0x23
    23a4:	54 a1       	ldd	r21, Z+36	; 0x24
    23a6:	65 a1       	ldd	r22, Z+37	; 0x25
    23a8:	76 a1       	ldd	r23, Z+38	; 0x26
    23aa:	4f 5f       	subi	r20, 0xFF	; 255
    23ac:	5f 4f       	sbci	r21, 0xFF	; 255
    23ae:	6f 4f       	sbci	r22, 0xFF	; 255
    23b0:	7f 4f       	sbci	r23, 0xFF	; 255
    23b2:	43 a3       	std	Z+35, r20	; 0x23
    23b4:	54 a3       	std	Z+36, r21	; 0x24
    23b6:	65 a3       	std	Z+37, r22	; 0x25
    23b8:	76 a3       	std	Z+38, r23	; 0x26
#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    23ba:	11 e0       	ldi	r17, 0x01	; 1
					pxTCB->ulNotifiedValue |= ulValue;
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
					break;
    23bc:	11 c0       	rjmp	.+34     	; 0x23e0 <xTaskGenericNotify+0xa2>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    23be:	43 a3       	std	Z+35, r20	; 0x23
    23c0:	54 a3       	std	Z+36, r21	; 0x24
    23c2:	65 a3       	std	Z+37, r22	; 0x25
    23c4:	76 a3       	std	Z+38, r23	; 0x26
#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    23c6:	11 e0       	ldi	r17, 0x01	; 1
					( pxTCB->ulNotifiedValue )++;
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
					break;
    23c8:	0b c0       	rjmp	.+22     	; 0x23e0 <xTaskGenericNotify+0xa2>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    23ca:	82 30       	cpi	r24, 0x02	; 2
    23cc:	41 f0       	breq	.+16     	; 0x23de <xTaskGenericNotify+0xa0>
					{
						pxTCB->ulNotifiedValue = ulValue;
    23ce:	43 a3       	std	Z+35, r20	; 0x23
    23d0:	54 a3       	std	Z+36, r21	; 0x24
    23d2:	65 a3       	std	Z+37, r22	; 0x25
    23d4:	76 a3       	std	Z+38, r23	; 0x26
#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    23d6:	11 e0       	ldi	r17, 0x01	; 1
    23d8:	03 c0       	rjmp	.+6      	; 0x23e0 <xTaskGenericNotify+0xa2>
    23da:	11 e0       	ldi	r17, 0x01	; 1
    23dc:	01 c0       	rjmp	.+2      	; 0x23e0 <xTaskGenericNotify+0xa2>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    23de:	10 e0       	ldi	r17, 0x00	; 0

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    23e0:	81 30       	cpi	r24, 0x01	; 1
    23e2:	41 f5       	brne	.+80     	; 0x2434 <xTaskGenericNotify+0xf6>
    23e4:	ef 01       	movw	r28, r30
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    23e6:	7f 01       	movw	r14, r30
    23e8:	82 e0       	ldi	r24, 0x02	; 2
    23ea:	e8 0e       	add	r14, r24
    23ec:	f1 1c       	adc	r15, r1
    23ee:	c7 01       	movw	r24, r14
    23f0:	0e 94 d9 04 	call	0x9b2	; 0x9b2 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    23f4:	8e 89       	ldd	r24, Y+22	; 0x16
    23f6:	90 91 72 0d 	lds	r25, 0x0D72	; 0x800d72 <uxTopReadyPriority>
    23fa:	98 17       	cp	r25, r24
    23fc:	10 f4       	brcc	.+4      	; 0x2402 <xTaskGenericNotify+0xc4>
    23fe:	80 93 72 0d 	sts	0x0D72, r24	; 0x800d72 <uxTopReadyPriority>
    2402:	90 e0       	ldi	r25, 0x00	; 0
    2404:	9c 01       	movw	r18, r24
    2406:	22 0f       	add	r18, r18
    2408:	33 1f       	adc	r19, r19
    240a:	22 0f       	add	r18, r18
    240c:	33 1f       	adc	r19, r19
    240e:	22 0f       	add	r18, r18
    2410:	33 1f       	adc	r19, r19
    2412:	82 0f       	add	r24, r18
    2414:	93 1f       	adc	r25, r19
    2416:	b7 01       	movw	r22, r14
    2418:	8b 56       	subi	r24, 0x6B	; 107
    241a:	92 4f       	sbci	r25, 0xF2	; 242
    241c:	0e 94 87 04 	call	0x90e	; 0x90e <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    2420:	9e 89       	ldd	r25, Y+22	; 0x16
    2422:	e0 91 b9 0d 	lds	r30, 0x0DB9	; 0x800db9 <pxCurrentTCB>
    2426:	f0 91 ba 0d 	lds	r31, 0x0DBA	; 0x800dba <pxCurrentTCB+0x1>
    242a:	86 89       	ldd	r24, Z+22	; 0x16
    242c:	89 17       	cp	r24, r25
    242e:	10 f4       	brcc	.+4      	; 0x2434 <xTaskGenericNotify+0xf6>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    2430:	0e 94 a5 05 	call	0xb4a	; 0xb4a <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    2434:	0f 90       	pop	r0
    2436:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    2438:	81 2f       	mov	r24, r17
    243a:	df 91       	pop	r29
    243c:	cf 91       	pop	r28
    243e:	1f 91       	pop	r17
    2440:	0f 91       	pop	r16
    2442:	ff 90       	pop	r15
    2444:	ef 90       	pop	r14
    2446:	08 95       	ret

00002448 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    2448:	cf 92       	push	r12
    244a:	df 92       	push	r13
    244c:	ef 92       	push	r14
    244e:	ff 92       	push	r15
    2450:	0f 93       	push	r16
    2452:	1f 93       	push	r17
    2454:	cf 93       	push	r28
    2456:	df 93       	push	r29
    2458:	fc 01       	movw	r30, r24

		pxTCB = ( TCB_t * ) xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			if( pulPreviousNotificationValue != NULL )
    245a:	01 15       	cp	r16, r1
    245c:	11 05       	cpc	r17, r1
    245e:	49 f0       	breq	.+18     	; 0x2472 <xTaskGenericNotifyFromISR+0x2a>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    2460:	83 a1       	ldd	r24, Z+35	; 0x23
    2462:	94 a1       	ldd	r25, Z+36	; 0x24
    2464:	a5 a1       	ldd	r26, Z+37	; 0x25
    2466:	b6 a1       	ldd	r27, Z+38	; 0x26
    2468:	e8 01       	movw	r28, r16
    246a:	88 83       	st	Y, r24
    246c:	99 83       	std	Y+1, r25	; 0x01
    246e:	aa 83       	std	Y+2, r26	; 0x02
    2470:	bb 83       	std	Y+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    2472:	87 a1       	ldd	r24, Z+39	; 0x27
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    2474:	92 e0       	ldi	r25, 0x02	; 2
    2476:	97 a3       	std	Z+39, r25	; 0x27

			switch( eAction )
    2478:	22 30       	cpi	r18, 0x02	; 2
    247a:	b9 f0       	breq	.+46     	; 0x24aa <xTaskGenericNotifyFromISR+0x62>
    247c:	18 f4       	brcc	.+6      	; 0x2484 <xTaskGenericNotifyFromISR+0x3c>
    247e:	21 30       	cpi	r18, 0x01	; 1
    2480:	31 f0       	breq	.+12     	; 0x248e <xTaskGenericNotifyFromISR+0x46>
    2482:	2f c0       	rjmp	.+94     	; 0x24e2 <xTaskGenericNotifyFromISR+0x9a>
    2484:	23 30       	cpi	r18, 0x03	; 3
    2486:	f9 f0       	breq	.+62     	; 0x24c6 <xTaskGenericNotifyFromISR+0x7e>
    2488:	24 30       	cpi	r18, 0x04	; 4
    248a:	19 f1       	breq	.+70     	; 0x24d2 <xTaskGenericNotifyFromISR+0x8a>
    248c:	2a c0       	rjmp	.+84     	; 0x24e2 <xTaskGenericNotifyFromISR+0x9a>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    248e:	03 a1       	ldd	r16, Z+35	; 0x23
    2490:	14 a1       	ldd	r17, Z+36	; 0x24
    2492:	25 a1       	ldd	r18, Z+37	; 0x25
    2494:	36 a1       	ldd	r19, Z+38	; 0x26
    2496:	40 2b       	or	r20, r16
    2498:	51 2b       	or	r21, r17
    249a:	62 2b       	or	r22, r18
    249c:	73 2b       	or	r23, r19
    249e:	43 a3       	std	Z+35, r20	; 0x23
    24a0:	54 a3       	std	Z+36, r21	; 0x24
    24a2:	65 a3       	std	Z+37, r22	; 0x25
    24a4:	76 a3       	std	Z+38, r23	; 0x26

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    24a6:	11 e0       	ldi	r17, 0x01	; 1

			switch( eAction )
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
					break;
    24a8:	1f c0       	rjmp	.+62     	; 0x24e8 <xTaskGenericNotifyFromISR+0xa0>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    24aa:	43 a1       	ldd	r20, Z+35	; 0x23
    24ac:	54 a1       	ldd	r21, Z+36	; 0x24
    24ae:	65 a1       	ldd	r22, Z+37	; 0x25
    24b0:	76 a1       	ldd	r23, Z+38	; 0x26
    24b2:	4f 5f       	subi	r20, 0xFF	; 255
    24b4:	5f 4f       	sbci	r21, 0xFF	; 255
    24b6:	6f 4f       	sbci	r22, 0xFF	; 255
    24b8:	7f 4f       	sbci	r23, 0xFF	; 255
    24ba:	43 a3       	std	Z+35, r20	; 0x23
    24bc:	54 a3       	std	Z+36, r21	; 0x24
    24be:	65 a3       	std	Z+37, r22	; 0x25
    24c0:	76 a3       	std	Z+38, r23	; 0x26

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    24c2:	11 e0       	ldi	r17, 0x01	; 1
					pxTCB->ulNotifiedValue |= ulValue;
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
					break;
    24c4:	11 c0       	rjmp	.+34     	; 0x24e8 <xTaskGenericNotifyFromISR+0xa0>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    24c6:	43 a3       	std	Z+35, r20	; 0x23
    24c8:	54 a3       	std	Z+36, r21	; 0x24
    24ca:	65 a3       	std	Z+37, r22	; 0x25
    24cc:	76 a3       	std	Z+38, r23	; 0x26

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    24ce:	11 e0       	ldi	r17, 0x01	; 1
					( pxTCB->ulNotifiedValue )++;
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
					break;
    24d0:	0b c0       	rjmp	.+22     	; 0x24e8 <xTaskGenericNotifyFromISR+0xa0>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    24d2:	82 30       	cpi	r24, 0x02	; 2
    24d4:	41 f0       	breq	.+16     	; 0x24e6 <xTaskGenericNotifyFromISR+0x9e>
					{
						pxTCB->ulNotifiedValue = ulValue;
    24d6:	43 a3       	std	Z+35, r20	; 0x23
    24d8:	54 a3       	std	Z+36, r21	; 0x24
    24da:	65 a3       	std	Z+37, r22	; 0x25
    24dc:	76 a3       	std	Z+38, r23	; 0x26

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    24de:	11 e0       	ldi	r17, 0x01	; 1
    24e0:	03 c0       	rjmp	.+6      	; 0x24e8 <xTaskGenericNotifyFromISR+0xa0>
    24e2:	11 e0       	ldi	r17, 0x01	; 1
    24e4:	01 c0       	rjmp	.+2      	; 0x24e8 <xTaskGenericNotifyFromISR+0xa0>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    24e6:	10 e0       	ldi	r17, 0x00	; 0

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    24e8:	81 30       	cpi	r24, 0x01	; 1
    24ea:	e1 f5       	brne	.+120    	; 0x2564 <xTaskGenericNotifyFromISR+0x11c>
    24ec:	ef 01       	movw	r28, r30
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    24ee:	80 91 68 0d 	lds	r24, 0x0D68	; 0x800d68 <uxSchedulerSuspended>
    24f2:	81 11       	cpse	r24, r1
    24f4:	1e c0       	rjmp	.+60     	; 0x2532 <xTaskGenericNotifyFromISR+0xea>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    24f6:	6f 01       	movw	r12, r30
    24f8:	e2 e0       	ldi	r30, 0x02	; 2
    24fa:	ce 0e       	add	r12, r30
    24fc:	d1 1c       	adc	r13, r1
    24fe:	c6 01       	movw	r24, r12
    2500:	0e 94 d9 04 	call	0x9b2	; 0x9b2 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    2504:	8e 89       	ldd	r24, Y+22	; 0x16
    2506:	90 91 72 0d 	lds	r25, 0x0D72	; 0x800d72 <uxTopReadyPriority>
    250a:	98 17       	cp	r25, r24
    250c:	10 f4       	brcc	.+4      	; 0x2512 <xTaskGenericNotifyFromISR+0xca>
    250e:	80 93 72 0d 	sts	0x0D72, r24	; 0x800d72 <uxTopReadyPriority>
    2512:	90 e0       	ldi	r25, 0x00	; 0
    2514:	9c 01       	movw	r18, r24
    2516:	22 0f       	add	r18, r18
    2518:	33 1f       	adc	r19, r19
    251a:	22 0f       	add	r18, r18
    251c:	33 1f       	adc	r19, r19
    251e:	22 0f       	add	r18, r18
    2520:	33 1f       	adc	r19, r19
    2522:	82 0f       	add	r24, r18
    2524:	93 1f       	adc	r25, r19
    2526:	b6 01       	movw	r22, r12
    2528:	8b 56       	subi	r24, 0x6B	; 107
    252a:	92 4f       	sbci	r25, 0xF2	; 242
    252c:	0e 94 87 04 	call	0x90e	; 0x90e <vListInsertEnd>
    2530:	07 c0       	rjmp	.+14     	; 0x2540 <xTaskGenericNotifyFromISR+0xf8>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    2532:	bf 01       	movw	r22, r30
    2534:	64 5f       	subi	r22, 0xF4	; 244
    2536:	7f 4f       	sbci	r23, 0xFF	; 255
    2538:	86 e7       	ldi	r24, 0x76	; 118
    253a:	9d e0       	ldi	r25, 0x0D	; 13
    253c:	0e 94 87 04 	call	0x90e	; 0x90e <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    2540:	9e 89       	ldd	r25, Y+22	; 0x16
    2542:	e0 91 b9 0d 	lds	r30, 0x0DB9	; 0x800db9 <pxCurrentTCB>
    2546:	f0 91 ba 0d 	lds	r31, 0x0DBA	; 0x800dba <pxCurrentTCB+0x1>
    254a:	86 89       	ldd	r24, Z+22	; 0x16
    254c:	89 17       	cp	r24, r25
    254e:	50 f4       	brcc	.+20     	; 0x2564 <xTaskGenericNotifyFromISR+0x11c>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    2550:	e1 14       	cp	r14, r1
    2552:	f1 04       	cpc	r15, r1
    2554:	21 f0       	breq	.+8      	; 0x255e <xTaskGenericNotifyFromISR+0x116>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    2556:	81 e0       	ldi	r24, 0x01	; 1
    2558:	e7 01       	movw	r28, r14
    255a:	88 83       	st	Y, r24
    255c:	03 c0       	rjmp	.+6      	; 0x2564 <xTaskGenericNotifyFromISR+0x11c>
					else
					{
						/* Mark that a yield is pending in case the user is not
						using the "xHigherPriorityTaskWoken" parameter to an ISR
						safe FreeRTOS function. */
						xYieldPending = pdTRUE;
    255e:	81 e0       	ldi	r24, 0x01	; 1
    2560:	80 93 6f 0d 	sts	0x0D6F, r24	; 0x800d6f <xYieldPending>
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
	}
    2564:	81 2f       	mov	r24, r17
    2566:	df 91       	pop	r29
    2568:	cf 91       	pop	r28
    256a:	1f 91       	pop	r17
    256c:	0f 91       	pop	r16
    256e:	ff 90       	pop	r15
    2570:	ef 90       	pop	r14
    2572:	df 90       	pop	r13
    2574:	cf 90       	pop	r12
    2576:	08 95       	ret

00002578 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    2578:	ef 92       	push	r14
    257a:	ff 92       	push	r15
    257c:	0f 93       	push	r16
    257e:	1f 93       	push	r17
    2580:	cf 93       	push	r28
    2582:	df 93       	push	r29
    2584:	fc 01       	movw	r30, r24

		pxTCB = ( TCB_t * ) xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    2586:	27 a1       	ldd	r18, Z+39	; 0x27
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    2588:	82 e0       	ldi	r24, 0x02	; 2
    258a:	87 a3       	std	Z+39, r24	; 0x27

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    258c:	83 a1       	ldd	r24, Z+35	; 0x23
    258e:	94 a1       	ldd	r25, Z+36	; 0x24
    2590:	a5 a1       	ldd	r26, Z+37	; 0x25
    2592:	b6 a1       	ldd	r27, Z+38	; 0x26
    2594:	01 96       	adiw	r24, 0x01	; 1
    2596:	a1 1d       	adc	r26, r1
    2598:	b1 1d       	adc	r27, r1
    259a:	83 a3       	std	Z+35, r24	; 0x23
    259c:	94 a3       	std	Z+36, r25	; 0x24
    259e:	a5 a3       	std	Z+37, r26	; 0x25
    25a0:	b6 a3       	std	Z+38, r27	; 0x26

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    25a2:	21 30       	cpi	r18, 0x01	; 1
    25a4:	e9 f5       	brne	.+122    	; 0x2620 <vTaskNotifyGiveFromISR+0xa8>
    25a6:	8b 01       	movw	r16, r22
    25a8:	ef 01       	movw	r28, r30
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    25aa:	80 91 68 0d 	lds	r24, 0x0D68	; 0x800d68 <uxSchedulerSuspended>
    25ae:	81 11       	cpse	r24, r1
    25b0:	1e c0       	rjmp	.+60     	; 0x25ee <vTaskNotifyGiveFromISR+0x76>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    25b2:	7f 01       	movw	r14, r30
    25b4:	82 e0       	ldi	r24, 0x02	; 2
    25b6:	e8 0e       	add	r14, r24
    25b8:	f1 1c       	adc	r15, r1
    25ba:	c7 01       	movw	r24, r14
    25bc:	0e 94 d9 04 	call	0x9b2	; 0x9b2 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    25c0:	8e 89       	ldd	r24, Y+22	; 0x16
    25c2:	90 91 72 0d 	lds	r25, 0x0D72	; 0x800d72 <uxTopReadyPriority>
    25c6:	98 17       	cp	r25, r24
    25c8:	10 f4       	brcc	.+4      	; 0x25ce <vTaskNotifyGiveFromISR+0x56>
    25ca:	80 93 72 0d 	sts	0x0D72, r24	; 0x800d72 <uxTopReadyPriority>
    25ce:	90 e0       	ldi	r25, 0x00	; 0
    25d0:	9c 01       	movw	r18, r24
    25d2:	22 0f       	add	r18, r18
    25d4:	33 1f       	adc	r19, r19
    25d6:	22 0f       	add	r18, r18
    25d8:	33 1f       	adc	r19, r19
    25da:	22 0f       	add	r18, r18
    25dc:	33 1f       	adc	r19, r19
    25de:	82 0f       	add	r24, r18
    25e0:	93 1f       	adc	r25, r19
    25e2:	b7 01       	movw	r22, r14
    25e4:	8b 56       	subi	r24, 0x6B	; 107
    25e6:	92 4f       	sbci	r25, 0xF2	; 242
    25e8:	0e 94 87 04 	call	0x90e	; 0x90e <vListInsertEnd>
    25ec:	07 c0       	rjmp	.+14     	; 0x25fc <vTaskNotifyGiveFromISR+0x84>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    25ee:	bf 01       	movw	r22, r30
    25f0:	64 5f       	subi	r22, 0xF4	; 244
    25f2:	7f 4f       	sbci	r23, 0xFF	; 255
    25f4:	86 e7       	ldi	r24, 0x76	; 118
    25f6:	9d e0       	ldi	r25, 0x0D	; 13
    25f8:	0e 94 87 04 	call	0x90e	; 0x90e <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    25fc:	9e 89       	ldd	r25, Y+22	; 0x16
    25fe:	e0 91 b9 0d 	lds	r30, 0x0DB9	; 0x800db9 <pxCurrentTCB>
    2602:	f0 91 ba 0d 	lds	r31, 0x0DBA	; 0x800dba <pxCurrentTCB+0x1>
    2606:	86 89       	ldd	r24, Z+22	; 0x16
    2608:	89 17       	cp	r24, r25
    260a:	50 f4       	brcc	.+20     	; 0x2620 <vTaskNotifyGiveFromISR+0xa8>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    260c:	01 15       	cp	r16, r1
    260e:	11 05       	cpc	r17, r1
    2610:	21 f0       	breq	.+8      	; 0x261a <vTaskNotifyGiveFromISR+0xa2>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    2612:	81 e0       	ldi	r24, 0x01	; 1
    2614:	f8 01       	movw	r30, r16
    2616:	80 83       	st	Z, r24
    2618:	03 c0       	rjmp	.+6      	; 0x2620 <vTaskNotifyGiveFromISR+0xa8>
					else
					{
						/* Mark that a yield is pending in case the user is not
						using the "xHigherPriorityTaskWoken" parameter in an ISR
						safe FreeRTOS function. */
						xYieldPending = pdTRUE;
    261a:	81 e0       	ldi	r24, 0x01	; 1
    261c:	80 93 6f 0d 	sts	0x0D6F, r24	; 0x800d6f <xYieldPending>
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    2620:	df 91       	pop	r29
    2622:	cf 91       	pop	r28
    2624:	1f 91       	pop	r17
    2626:	0f 91       	pop	r16
    2628:	ff 90       	pop	r15
    262a:	ef 90       	pop	r14
    262c:	08 95       	ret

0000262e <xTaskNotifyStateClear>:
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    262e:	00 97       	sbiw	r24, 0x00	; 0
    2630:	21 f4       	brne	.+8      	; 0x263a <xTaskNotifyStateClear+0xc>
    2632:	80 91 b9 0d 	lds	r24, 0x0DB9	; 0x800db9 <pxCurrentTCB>
    2636:	90 91 ba 0d 	lds	r25, 0x0DBA	; 0x800dba <pxCurrentTCB+0x1>

		taskENTER_CRITICAL();
    263a:	0f b6       	in	r0, 0x3f	; 63
    263c:	f8 94       	cli
    263e:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    2640:	fc 01       	movw	r30, r24
    2642:	27 a1       	ldd	r18, Z+39	; 0x27
    2644:	22 30       	cpi	r18, 0x02	; 2
    2646:	19 f4       	brne	.+6      	; 0x264e <xTaskNotifyStateClear+0x20>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    2648:	17 a2       	std	Z+39, r1	; 0x27
				xReturn = pdPASS;
    264a:	81 e0       	ldi	r24, 0x01	; 1
    264c:	01 c0       	rjmp	.+2      	; 0x2650 <xTaskNotifyStateClear+0x22>
			}
			else
			{
				xReturn = pdFAIL;
    264e:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		taskEXIT_CRITICAL();
    2650:	0f 90       	pop	r0
    2652:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    2654:	08 95       	ret

00002656 <vErrorHandler>:
		}
	}
}


static void vErrorHandler( void *pvParameters ) {
    2656:	ff cf       	rjmp	.-2      	; 0x2656 <vErrorHandler>

00002658 <vBluetoothTransmitServiceUART1>:
	( void ) pvParameters;
	
	for( ;; ) {
		/* Waits for bufferSendUART1 to fill, then pops first byte of data and
		   copies it to UART1 data register UDR1 effectively transmitting it. */ 
		xQueueReceive( bufferBluetoothSendUART1, &UDR1, portMAX_DELAY );
    2658:	20 e0       	ldi	r18, 0x00	; 0
    265a:	4f ef       	ldi	r20, 0xFF	; 255
    265c:	5f ef       	ldi	r21, 0xFF	; 255
    265e:	6c e9       	ldi	r22, 0x9C	; 156
    2660:	70 e0       	ldi	r23, 0x00	; 0
    2662:	80 91 bd 0d 	lds	r24, 0x0DBD	; 0x800dbd <bufferBluetoothSendUART1>
    2666:	90 91 be 0d 	lds	r25, 0x0DBE	; 0x800dbe <bufferBluetoothSendUART1+0x1>
    266a:	0e 94 ff 08 	call	0x11fe	; 0x11fe <xQueueGenericReceive>
		while( ! ( UCSR1A & ( 1 << UDRE1 ) ) );		// Wait for transmit to finish
    266e:	80 91 9b 00 	lds	r24, 0x009B	; 0x80009b <__TEXT_REGION_LENGTH__+0x7e009b>
    2672:	85 ff       	sbrs	r24, 5
    2674:	fc cf       	rjmp	.-8      	; 0x266e <vBluetoothTransmitServiceUART1+0x16>
    2676:	f0 cf       	rjmp	.-32     	; 0x2658 <vBluetoothTransmitServiceUART1>

00002678 <vRoombaTransmitServiceUART0>:
	( void ) pvParameters;
	
	for( ;; ) {
		/* Waits for bufferSendUART0 to fill, then pops first byte of data and
		   copies it to UART0 data register UDR0 effectively transmitting it. */ 
		xQueueReceive( bufferRoombaSendUART0, &UDR0, portMAX_DELAY );
    2678:	20 e0       	ldi	r18, 0x00	; 0
    267a:	4f ef       	ldi	r20, 0xFF	; 255
    267c:	5f ef       	ldi	r21, 0xFF	; 255
    267e:	6c e2       	ldi	r22, 0x2C	; 44
    2680:	70 e0       	ldi	r23, 0x00	; 0
    2682:	80 91 bb 0d 	lds	r24, 0x0DBB	; 0x800dbb <bufferRoombaSendUART0>
    2686:	90 91 bc 0d 	lds	r25, 0x0DBC	; 0x800dbc <bufferRoombaSendUART0+0x1>
    268a:	0e 94 ff 08 	call	0x11fe	; 0x11fe <xQueueGenericReceive>
		while( ! ( UCSR0A & ( 1 << UDRE0 ) ) );		// Wait for transmit to finish
    268e:	5d 9b       	sbis	0x0b, 5	; 11
    2690:	fe cf       	rjmp	.-4      	; 0x268e <vRoombaTransmitServiceUART0+0x16>
    2692:	f2 cf       	rjmp	.-28     	; 0x2678 <vRoombaTransmitServiceUART0>

00002694 <error>:
		error( ERROR_BT_RECEIVE );
	}
	return byte;
}

static void error( uint8_t byte ) {
    2694:	cf 93       	push	r28
    2696:	df 93       	push	r29
    2698:	1f 92       	push	r1
    269a:	cd b7       	in	r28, 0x3d	; 61
    269c:	de b7       	in	r29, 0x3e	; 62
    269e:	89 83       	std	Y+1, r24	; 0x01
	/* Receives an error and pushes it on globalError queue. */
	xQueueSendToBack( globalError, &byte, 0 );
    26a0:	20 e0       	ldi	r18, 0x00	; 0
    26a2:	40 e0       	ldi	r20, 0x00	; 0
    26a4:	50 e0       	ldi	r21, 0x00	; 0
    26a6:	be 01       	movw	r22, r28
    26a8:	6f 5f       	subi	r22, 0xFF	; 255
    26aa:	7f 4f       	sbci	r23, 0xFF	; 255
    26ac:	80 91 bf 0d 	lds	r24, 0x0DBF	; 0x800dbf <globalError>
    26b0:	90 91 c0 0d 	lds	r25, 0x0DC0	; 0x800dc0 <globalError+0x1>
    26b4:	0e 94 ec 07 	call	0xfd8	; 0xfd8 <xQueueGenericSend>
}
    26b8:	0f 90       	pop	r0
    26ba:	df 91       	pop	r29
    26bc:	cf 91       	pop	r28
    26be:	08 95       	ret

000026c0 <getByteFromBT>:
	if( errQUEUE_FULL == xQueueSendToBack( bufferBluetoothSendUART1, &byte, pdMS_TO_TICKS( 30 ) ) ) {
		error( ERROR_BT_SEND );
	}
}

static uint8_t getByteFromBT( void ) {
    26c0:	cf 93       	push	r28
    26c2:	df 93       	push	r29
    26c4:	1f 92       	push	r1
    26c6:	cd b7       	in	r28, 0x3d	; 61
    26c8:	de b7       	in	r29, 0x3e	; 62
	/* Gets byte from UART1 receive queue. */
	uint8_t byte;
	if( errQUEUE_EMPTY == xQueueReceive( bufferBluetoothReceiveUART1, &byte, pdMS_TO_TICKS( 30 ) ) ) {
    26ca:	20 e0       	ldi	r18, 0x00	; 0
    26cc:	43 e0       	ldi	r20, 0x03	; 3
    26ce:	50 e0       	ldi	r21, 0x00	; 0
    26d0:	be 01       	movw	r22, r28
    26d2:	6f 5f       	subi	r22, 0xFF	; 255
    26d4:	7f 4f       	sbci	r23, 0xFF	; 255
    26d6:	80 91 c1 0d 	lds	r24, 0x0DC1	; 0x800dc1 <bufferBluetoothReceiveUART1>
    26da:	90 91 c2 0d 	lds	r25, 0x0DC2	; 0x800dc2 <bufferBluetoothReceiveUART1+0x1>
    26de:	0e 94 ff 08 	call	0x11fe	; 0x11fe <xQueueGenericReceive>
    26e2:	81 11       	cpse	r24, r1
    26e4:	03 c0       	rjmp	.+6      	; 0x26ec <getByteFromBT+0x2c>
		error( ERROR_BT_RECEIVE );
    26e6:	86 e0       	ldi	r24, 0x06	; 6
    26e8:	0e 94 4a 13 	call	0x2694	; 0x2694 <error>
	}
	return byte;
}
    26ec:	89 81       	ldd	r24, Y+1	; 0x01
    26ee:	0f 90       	pop	r0
    26f0:	df 91       	pop	r29
    26f2:	cf 91       	pop	r28
    26f4:	08 95       	ret

000026f6 <getByteFromRoomba>:
	if( errQUEUE_FULL == xQueueSendToBack( bufferRoombaSendUART0, &byte, pdMS_TO_TICKS( 30 ) ) ) {
		error( ERROR_ROOMBA_SEND );
	}
}

static uint8_t getByteFromRoomba( void ) {
    26f6:	cf 93       	push	r28
    26f8:	df 93       	push	r29
    26fa:	1f 92       	push	r1
    26fc:	cd b7       	in	r28, 0x3d	; 61
    26fe:	de b7       	in	r29, 0x3e	; 62
	/* Gets byte from UART0 receive queue. */
	uint8_t byte;
	if( errQUEUE_EMPTY == xQueueReceive( bufferRoombaReceiveUART0, &byte, pdMS_TO_TICKS( 30 ) ) ) {
    2700:	20 e0       	ldi	r18, 0x00	; 0
    2702:	43 e0       	ldi	r20, 0x03	; 3
    2704:	50 e0       	ldi	r21, 0x00	; 0
    2706:	be 01       	movw	r22, r28
    2708:	6f 5f       	subi	r22, 0xFF	; 255
    270a:	7f 4f       	sbci	r23, 0xFF	; 255
    270c:	80 91 e5 0d 	lds	r24, 0x0DE5	; 0x800de5 <bufferRoombaReceiveUART0>
    2710:	90 91 e6 0d 	lds	r25, 0x0DE6	; 0x800de6 <bufferRoombaReceiveUART0+0x1>
    2714:	0e 94 ff 08 	call	0x11fe	; 0x11fe <xQueueGenericReceive>
    2718:	81 11       	cpse	r24, r1
    271a:	03 c0       	rjmp	.+6      	; 0x2722 <getByteFromRoomba+0x2c>
		error( ERROR_BT_RECEIVE );
    271c:	86 e0       	ldi	r24, 0x06	; 6
    271e:	0e 94 4a 13 	call	0x2694	; 0x2694 <error>
	}
	return byte;
}
    2722:	89 81       	ldd	r24, Y+1	; 0x01
    2724:	0f 90       	pop	r0
    2726:	df 91       	pop	r29
    2728:	cf 91       	pop	r28
    272a:	08 95       	ret

0000272c <sendByteToRoomba>:
	for( uint8_t i = 0; message[ i ] != '\0'; ++i ) {
		xQueueSendToBack( queue, message+i, pdMS_TO_TICKS( 30 ) );
	}
}

static void sendByteToRoomba( uint8_t byte ) {
    272c:	cf 93       	push	r28
    272e:	df 93       	push	r29
    2730:	1f 92       	push	r1
    2732:	cd b7       	in	r28, 0x3d	; 61
    2734:	de b7       	in	r29, 0x3e	; 62
    2736:	89 83       	std	Y+1, r24	; 0x01
	/* Pushes byte on UART0 send queue. */
	if( errQUEUE_FULL == xQueueSendToBack( bufferRoombaSendUART0, &byte, pdMS_TO_TICKS( 30 ) ) ) {
    2738:	20 e0       	ldi	r18, 0x00	; 0
    273a:	43 e0       	ldi	r20, 0x03	; 3
    273c:	50 e0       	ldi	r21, 0x00	; 0
    273e:	be 01       	movw	r22, r28
    2740:	6f 5f       	subi	r22, 0xFF	; 255
    2742:	7f 4f       	sbci	r23, 0xFF	; 255
    2744:	80 91 bb 0d 	lds	r24, 0x0DBB	; 0x800dbb <bufferRoombaSendUART0>
    2748:	90 91 bc 0d 	lds	r25, 0x0DBC	; 0x800dbc <bufferRoombaSendUART0+0x1>
    274c:	0e 94 ec 07 	call	0xfd8	; 0xfd8 <xQueueGenericSend>
    2750:	81 11       	cpse	r24, r1
    2752:	03 c0       	rjmp	.+6      	; 0x275a <sendByteToRoomba+0x2e>
		error( ERROR_ROOMBA_SEND );
    2754:	83 e0       	ldi	r24, 0x03	; 3
    2756:	0e 94 4a 13 	call	0x2694	; 0x2694 <error>
	}
}
    275a:	0f 90       	pop	r0
    275c:	df 91       	pop	r29
    275e:	cf 91       	pop	r28
    2760:	08 95       	ret

00002762 <handlerRoombaSCIStandard>:
	for( uint8_t i = uxQueueMessagesWaiting( queue ); i > 0; ++i ) {
		xQueueReceive( queue, NULL, 0 );
	}
}

static void handlerRoombaSCIStandard( uint8_t opcode, uint8_t numberOfDataBytes ) {
    2762:	cf 93       	push	r28
    2764:	df 93       	push	r29
    2766:	c6 2f       	mov	r28, r22

	/* Send opcode byte to Roomba. */
	sendByteToRoomba( opcode );
    2768:	0e 94 96 13 	call	0x272c	; 0x272c <sendByteToRoomba>

	/* Send data bytes from BT to Roomba. */
	while( numberOfDataBytes-- ) {
    276c:	05 c0       	rjmp	.+10     	; 0x2778 <handlerRoombaSCIStandard+0x16>
		sendByteToRoomba( getByteFromBT( ) );
    276e:	0e 94 60 13 	call	0x26c0	; 0x26c0 <getByteFromBT>
    2772:	0e 94 96 13 	call	0x272c	; 0x272c <sendByteToRoomba>

	/* Send opcode byte to Roomba. */
	sendByteToRoomba( opcode );

	/* Send data bytes from BT to Roomba. */
	while( numberOfDataBytes-- ) {
    2776:	cd 2f       	mov	r28, r29
    2778:	df ef       	ldi	r29, 0xFF	; 255
    277a:	dc 0f       	add	r29, r28
    277c:	c1 11       	cpse	r28, r1
    277e:	f7 cf       	rjmp	.-18     	; 0x276e <handlerRoombaSCIStandard+0xc>
		sendByteToRoomba( getByteFromBT( ) );
	}
}
    2780:	df 91       	pop	r29
    2782:	cf 91       	pop	r28
    2784:	08 95       	ret

00002786 <handlerRoombaSCISong>:
		sensorDataRoomba[ i ] = getByteFromRoomba( );
		sendByteToBT( sensorDataRoomba[ i ] );
	}
}

static void handlerRoombaSCISong( uint8_t opcode ) {
    2786:	cf 93       	push	r28
    2788:	df 93       	push	r29

	uint8_t notes, length;

	/* Send opcode byte to Roomba. */
	sendByteToRoomba( opcode );
    278a:	0e 94 96 13 	call	0x272c	; 0x272c <sendByteToRoomba>

	/* Receive SCI song number byte from Bluetooth and send it to Roomba. */
	sendByteToRoomba( getByteFromBT( ) );
    278e:	0e 94 60 13 	call	0x26c0	; 0x26c0 <getByteFromBT>
    2792:	0e 94 96 13 	call	0x272c	; 0x272c <sendByteToRoomba>

	/* Receive SCI song number of notes byte from Bluetooth and send it to Roomba. */
	notes = getByteFromBT( );
    2796:	0e 94 60 13 	call	0x26c0	; 0x26c0 <getByteFromBT>
    279a:	d8 2f       	mov	r29, r24
	sendByteToRoomba( notes );
    279c:	0e 94 96 13 	call	0x272c	; 0x272c <sendByteToRoomba>

	/* Song length is specified in notes. Each note consists of 2 bytes (note number and note duration). */
	length = 2 * notes;
    27a0:	dd 0f       	add	r29, r29

	/* Send notes to Roomba. */
	for( uint8_t i = 0; i < length; ++i ) {
    27a2:	c0 e0       	ldi	r28, 0x00	; 0
    27a4:	05 c0       	rjmp	.+10     	; 0x27b0 <handlerRoombaSCISong+0x2a>
		sendByteToRoomba( getByteFromBT( ) );
    27a6:	0e 94 60 13 	call	0x26c0	; 0x26c0 <getByteFromBT>
    27aa:	0e 94 96 13 	call	0x272c	; 0x272c <sendByteToRoomba>

	/* Song length is specified in notes. Each note consists of 2 bytes (note number and note duration). */
	length = 2 * notes;

	/* Send notes to Roomba. */
	for( uint8_t i = 0; i < length; ++i ) {
    27ae:	cf 5f       	subi	r28, 0xFF	; 255
    27b0:	cd 17       	cp	r28, r29
    27b2:	c8 f3       	brcs	.-14     	; 0x27a6 <handlerRoombaSCISong+0x20>
		sendByteToRoomba( getByteFromBT( ) );
	}
}
    27b4:	df 91       	pop	r29
    27b6:	cf 91       	pop	r28
    27b8:	08 95       	ret

000027ba <sendByteToBT>:
		error( ERROR_BT_RECEIVE );
	}
	return byte;
}

static void sendByteToBT( uint8_t byte ) {
    27ba:	cf 93       	push	r28
    27bc:	df 93       	push	r29
    27be:	1f 92       	push	r1
    27c0:	cd b7       	in	r28, 0x3d	; 61
    27c2:	de b7       	in	r29, 0x3e	; 62
    27c4:	89 83       	std	Y+1, r24	; 0x01
	/* Pushes byte on UART1 send queue. */
	if( errQUEUE_FULL == xQueueSendToBack( bufferBluetoothSendUART1, &byte, pdMS_TO_TICKS( 30 ) ) ) {
    27c6:	20 e0       	ldi	r18, 0x00	; 0
    27c8:	43 e0       	ldi	r20, 0x03	; 3
    27ca:	50 e0       	ldi	r21, 0x00	; 0
    27cc:	be 01       	movw	r22, r28
    27ce:	6f 5f       	subi	r22, 0xFF	; 255
    27d0:	7f 4f       	sbci	r23, 0xFF	; 255
    27d2:	80 91 bd 0d 	lds	r24, 0x0DBD	; 0x800dbd <bufferBluetoothSendUART1>
    27d6:	90 91 be 0d 	lds	r25, 0x0DBE	; 0x800dbe <bufferBluetoothSendUART1+0x1>
    27da:	0e 94 ec 07 	call	0xfd8	; 0xfd8 <xQueueGenericSend>
    27de:	81 11       	cpse	r24, r1
    27e0:	03 c0       	rjmp	.+6      	; 0x27e8 <sendByteToBT+0x2e>
		error( ERROR_BT_SEND );
    27e2:	84 e0       	ldi	r24, 0x04	; 4
    27e4:	0e 94 4a 13 	call	0x2694	; 0x2694 <error>
	}
}
    27e8:	0f 90       	pop	r0
    27ea:	df 91       	pop	r29
    27ec:	cf 91       	pop	r28
    27ee:	08 95       	ret

000027f0 <handlerRoombaSCISensors>:
	while( numberOfDataBytes-- ) {
		sendByteToRoomba( getByteFromBT( ) );
	}
}

static void handlerRoombaSCISensors( uint8_t opcode ) {
    27f0:	0f 93       	push	r16
    27f2:	1f 93       	push	r17
    27f4:	cf 93       	push	r28
    27f6:	df 93       	push	r29

	uint8_t packet, lengthOfSensorData;

	/* Send opcode byte to Roomba. */
	sendByteToRoomba( opcode );
    27f8:	0e 94 96 13 	call	0x272c	; 0x272c <sendByteToRoomba>

	/* Receive SCI sensors data packet byte from Bluetooth and send it to Roomba. */
	packet = getByteFromBT( );
    27fc:	0e 94 60 13 	call	0x26c0	; 0x26c0 <getByteFromBT>
    2800:	c8 2f       	mov	r28, r24
	sendByteToRoomba( packet );
    2802:	0e 94 96 13 	call	0x272c	; 0x272c <sendByteToRoomba>

	/* Set number of expected data bytes to receive from Roomba according to SCI sensors data byte. */
	switch (packet) {
    2806:	c1 30       	cpi	r28, 0x01	; 1
    2808:	71 f0       	breq	.+28     	; 0x2826 <handlerRoombaSCISensors+0x36>
    280a:	58 f0       	brcs	.+22     	; 0x2822 <handlerRoombaSCISensors+0x32>
    280c:	c2 30       	cpi	r28, 0x02	; 2
    280e:	19 f0       	breq	.+6      	; 0x2816 <handlerRoombaSCISensors+0x26>
    2810:	c3 30       	cpi	r28, 0x03	; 3
    2812:	49 f0       	breq	.+18     	; 0x2826 <handlerRoombaSCISensors+0x36>
    2814:	02 c0       	rjmp	.+4      	; 0x281a <handlerRoombaSCISensors+0x2a>
		break;
		case SCI_SENSORS_PACKET1:
		lengthOfSensorData = SCI_SENSORS_PACKET1_BYTES;
		break;
		case SCI_SENSORS_PACKET2:
		lengthOfSensorData = SCI_SENSORS_PACKET2_BYTES;
    2816:	06 e0       	ldi	r16, 0x06	; 6
		break;
    2818:	07 c0       	rjmp	.+14     	; 0x2828 <handlerRoombaSCISensors+0x38>
		case SCI_SENSORS_PACKET3:
		lengthOfSensorData = SCI_SENSORS_PACKET3_BYTES;
		break;
		default:
		error( ERROR_DATA );
    281a:	87 e0       	ldi	r24, 0x07	; 7
    281c:	0e 94 4a 13 	call	0x2694	; 0x2694 <error>
		return;
    2820:	13 c0       	rjmp	.+38     	; 0x2848 <handlerRoombaSCISensors+0x58>
	sendByteToRoomba( packet );

	/* Set number of expected data bytes to receive from Roomba according to SCI sensors data byte. */
	switch (packet) {
		case SCI_SENSORS_PACKET0:
		lengthOfSensorData = SCI_SENSORS_PACKET0_BYTES;
    2822:	0a e1       	ldi	r16, 0x1A	; 26
    2824:	01 c0       	rjmp	.+2      	; 0x2828 <handlerRoombaSCISensors+0x38>
		break;
		case SCI_SENSORS_PACKET1:
		lengthOfSensorData = SCI_SENSORS_PACKET1_BYTES;
    2826:	0a e0       	ldi	r16, 0x0A	; 10
		return;
	}

	/* Receive and store sensor data bytes from Roomba into 
	   sensorData[] (as first n bytes) and send it to Bluetooth. */
	for( uint8_t i = 0; i < lengthOfSensorData; ++i ) {
    2828:	10 e0       	ldi	r17, 0x00	; 0
    282a:	0c c0       	rjmp	.+24     	; 0x2844 <handlerRoombaSCISensors+0x54>
		sensorDataRoomba[ i ] = getByteFromRoomba( );
    282c:	c1 2f       	mov	r28, r17
    282e:	d0 e0       	ldi	r29, 0x00	; 0
    2830:	0e 94 7b 13 	call	0x26f6	; 0x26f6 <getByteFromRoomba>
    2834:	fe 01       	movw	r30, r28
    2836:	e5 53       	subi	r30, 0x35	; 53
    2838:	f2 4f       	sbci	r31, 0xF2	; 242
    283a:	80 83       	st	Z, r24
		sendByteToBT( sensorDataRoomba[ i ] );
    283c:	80 81       	ld	r24, Z
    283e:	0e 94 dd 13 	call	0x27ba	; 0x27ba <sendByteToBT>
		return;
	}

	/* Receive and store sensor data bytes from Roomba into 
	   sensorData[] (as first n bytes) and send it to Bluetooth. */
	for( uint8_t i = 0; i < lengthOfSensorData; ++i ) {
    2842:	1f 5f       	subi	r17, 0xFF	; 255
    2844:	10 17       	cp	r17, r16
    2846:	90 f3       	brcs	.-28     	; 0x282c <handlerRoombaSCISensors+0x3c>
		sensorDataRoomba[ i ] = getByteFromRoomba( );
		sendByteToBT( sensorDataRoomba[ i ] );
	}
}
    2848:	df 91       	pop	r29
    284a:	cf 91       	pop	r28
    284c:	1f 91       	pop	r17
    284e:	0f 91       	pop	r16
    2850:	08 95       	ret

00002852 <handlerGetMCUData>:
	for( uint8_t i = 0; i < length; ++i ) {
		sendByteToRoomba( getByteFromBT( ) );
	}
}

static void handlerGetMCUData( void ) {
    2852:	cf 93       	push	r28

	/* Send data bytes from MCU to BT. */
	for( uint8_t i = 0; i < MCU_DATA_BYTES; ++i ) {
    2854:	c0 e0       	ldi	r28, 0x00	; 0
    2856:	08 c0       	rjmp	.+16     	; 0x2868 <handlerGetMCUData+0x16>
		sendByteToBT( sensorDataMCU[ i ] );
    2858:	ec 2f       	mov	r30, r28
    285a:	f0 e0       	ldi	r31, 0x00	; 0
    285c:	ed 53       	subi	r30, 0x3D	; 61
    285e:	f2 4f       	sbci	r31, 0xF2	; 242
    2860:	80 81       	ld	r24, Z
    2862:	0e 94 dd 13 	call	0x27ba	; 0x27ba <sendByteToBT>
}

static void handlerGetMCUData( void ) {

	/* Send data bytes from MCU to BT. */
	for( uint8_t i = 0; i < MCU_DATA_BYTES; ++i ) {
    2866:	cf 5f       	subi	r28, 0xFF	; 255
    2868:	c8 30       	cpi	r28, 0x08	; 8
    286a:	b0 f3       	brcs	.-20     	; 0x2858 <handlerGetMCUData+0x6>
		sendByteToBT( sensorDataMCU[ i ] );
	}
    286c:	cf 91       	pop	r28
    286e:	08 95       	ret

00002870 <vBluetoothReceiveCommandUART1>:
		while( ! ( UCSR1A & ( 1 << UDRE1 ) ) );		// Wait for transmit to finish
	}
}


static void vBluetoothReceiveCommandUART1( void *pvParameters ) {
    2870:	cf 93       	push	r28
    2872:	df 93       	push	r29
    2874:	1f 92       	push	r1
    2876:	cd b7       	in	r28, 0x3d	; 61
    2878:	de b7       	in	r29, 0x3e	; 62
	( void ) pvParameters;
	
	for( ;; ) {

		/* Wait until opcode is received from Bluetooth. */
		xQueueReceive( bufferBluetoothReceiveUART1, &opcode, portMAX_DELAY );
    287a:	20 e0       	ldi	r18, 0x00	; 0
    287c:	4f ef       	ldi	r20, 0xFF	; 255
    287e:	5f ef       	ldi	r21, 0xFF	; 255
    2880:	be 01       	movw	r22, r28
    2882:	6f 5f       	subi	r22, 0xFF	; 255
    2884:	7f 4f       	sbci	r23, 0xFF	; 255
    2886:	80 91 c1 0d 	lds	r24, 0x0DC1	; 0x800dc1 <bufferBluetoothReceiveUART1>
    288a:	90 91 c2 0d 	lds	r25, 0x0DC2	; 0x800dc2 <bufferBluetoothReceiveUART1+0x1>
    288e:	0e 94 ff 08 	call	0x11fe	; 0x11fe <xQueueGenericReceive>

		/* Set number of accompanying data bytes according to Roomba SCI specification. */
		switch( opcode ) {
    2892:	89 81       	ldd	r24, Y+1	; 0x01
    2894:	48 2f       	mov	r20, r24
    2896:	50 e0       	ldi	r21, 0x00	; 0
    2898:	fa 01       	movw	r30, r20
    289a:	e0 58       	subi	r30, 0x80	; 128
    289c:	f1 09       	sbc	r31, r1
    289e:	e1 37       	cpi	r30, 0x71	; 113
    28a0:	f1 05       	cpc	r31, r1
    28a2:	58 f7       	brcc	.-42     	; 0x287a <vBluetoothReceiveCommandUART1+0xa>
    28a4:	ea 5b       	subi	r30, 0xBA	; 186
    28a6:	ff 4f       	sbci	r31, 0xFF	; 255
    28a8:	0c 94 71 15 	jmp	0x2ae2	; 0x2ae2 <__tablejump2__>
			case SCI_POWER_OPCODE:
			case SCI_SPOT_OPCODE:
			case SCI_CLEAN_OPCODE:
			case SCI_MAX_OPCODE:
			case SCI_FORCE_SEEKING_DOCK_OPCODE:
				handlerRoombaSCIStandard( opcode, 0 );
    28ac:	60 e0       	ldi	r22, 0x00	; 0
    28ae:	0e 94 b1 13 	call	0x2762	; 0x2762 <handlerRoombaSCIStandard>
				break;
    28b2:	e3 cf       	rjmp	.-58     	; 0x287a <vBluetoothReceiveCommandUART1+0xa>

			/* Opcode followed by 1 data bytes. */
			case SCI_BAUD_OPCODE:
			case SCI_MOTORS_OPCODE:
			case SCI_PLAY_OPCODE:
				handlerRoombaSCIStandard( opcode, 1 );
    28b4:	61 e0       	ldi	r22, 0x01	; 1
    28b6:	0e 94 b1 13 	call	0x2762	; 0x2762 <handlerRoombaSCIStandard>
				break;
    28ba:	df cf       	rjmp	.-66     	; 0x287a <vBluetoothReceiveCommandUART1+0xa>

			/* Opcode followed by 3 data bytes. */
			case SCI_LEDS_OPCODE:
				handlerRoombaSCIStandard( opcode, 3 );
    28bc:	63 e0       	ldi	r22, 0x03	; 3
    28be:	0e 94 b1 13 	call	0x2762	; 0x2762 <handlerRoombaSCIStandard>
				break;
    28c2:	db cf       	rjmp	.-74     	; 0x287a <vBluetoothReceiveCommandUART1+0xa>
			
			/* Opcode followed by 4 data bytes. */
			case SCI_DRIVE_OPCODE:
				handlerRoombaSCIStandard( opcode, 4 );
    28c4:	64 e0       	ldi	r22, 0x04	; 4
    28c6:	0e 94 b1 13 	call	0x2762	; 0x2762 <handlerRoombaSCIStandard>
				break;
    28ca:	d7 cf       	rjmp	.-82     	; 0x287a <vBluetoothReceiveCommandUART1+0xa>

			/* Opcode followed by 1 data bytes. Roomba returns data. */
			case SCI_SENSORS_OPCODE:
				handlerRoombaSCISensors( opcode );
    28cc:	0e 94 f8 13 	call	0x27f0	; 0x27f0 <handlerRoombaSCISensors>
				break;
    28d0:	d4 cf       	rjmp	.-88     	; 0x287a <vBluetoothReceiveCommandUART1+0xa>

			/* Opcode followed by n data bytes. Serial sequence: 
			  [Opcode] [Song Number] [Song Length] [Note Number 1] [Note Duration 1] [Note Number 2] [Note Duration 2] etc. */
			case SCI_SONG_OPCODE:
				handlerRoombaSCISong( opcode );
    28d2:	0e 94 c3 13 	call	0x2786	; 0x2786 <handlerRoombaSCISong>
				break;
    28d6:	d1 cf       	rjmp	.-94     	; 0x287a <vBluetoothReceiveCommandUART1+0xa>

			/* Send data from sensors on MCU pins. */
			case MCU_DATA_OPCODE:
				handlerGetMCUData( );
    28d8:	0e 94 29 14 	call	0x2852	; 0x2852 <handlerGetMCUData>
				break;
    28dc:	ce cf       	rjmp	.-100    	; 0x287a <vBluetoothReceiveCommandUART1+0xa>

000028de <vPeriodicTask>:
		Bit 4     ADIF: ADC Interrupt Flag
		Bit 3     ADIE: ADC Interrupt Enable
		Bits 2:0  ADPS2:0: ADC Prescaler Select Bits
	              **Selected division factor 16 (ADPS2:0 - 100), that is sufficient for 8 bit resolution**
	*/
	ADCSRA = ( 1 << ADEN ) | ( 1 << ADPS2 ) | ( 0 << ADPS1 ) | ( 0 << ADPS0 );
    28de:	84 e8       	ldi	r24, 0x84	; 132
    28e0:	86 b9       	out	0x06, r24	; 6
	     Bit 5     ADLAR: ADC Left Adjust Result
		           **Enabled: result is formated so that high byte contains 8 bits of data and low remaining 2 bits.
				    Only high byte is used (8 bit resolution), low byte is discarded.
		 Bits 4:0  MUX4:0: Analog Channel and Gain Selection Bits
	*/
	ADMUX = ( 1 << REFS0 ) | ( 1 << ADLAR );
    28e2:	80 e6       	ldi	r24, 0x60	; 96
    28e4:	87 b9       	out	0x07, r24	; 7

	for( ;; ) {

		/* Poll ADC channels and store data in sensorDataMCU[ ]. */
		for( uint8_t activeSensor = 0; activeSensor < ADC_CHANNELS_USED; ++activeSensor ) {
    28e6:	80 e0       	ldi	r24, 0x00	; 0
    28e8:	12 c0       	rjmp	.+36     	; 0x290e <vPeriodicTask+0x30>

			/* Clear MUX4:0 (ADC channel selection bits). */
			ADMUX &= 0xF0;
    28ea:	97 b1       	in	r25, 0x07	; 7
    28ec:	90 7f       	andi	r25, 0xF0	; 240
    28ee:	97 b9       	out	0x07, r25	; 7

			/* Set MUX4:0 bits with new sensor. */
			ADMUX |= activeSensor;
    28f0:	97 b1       	in	r25, 0x07	; 7
    28f2:	98 2b       	or	r25, r24
    28f4:	97 b9       	out	0x07, r25	; 7
		
			/* Start ADC in single conversion mode. */
			ADCSRA |= ( 1 << ADSC );
    28f6:	96 b1       	in	r25, 0x06	; 6
    28f8:	90 64       	ori	r25, 0x40	; 64
    28fa:	96 b9       	out	0x06, r25	; 6

			/* Wait for AD conversion to complete.
			   TODO: Implement interrupt driven ADC. */
			while( ( ADCSRA & ( 1 << ADSC ) ) != 0 );
    28fc:	36 99       	sbic	0x06, 6	; 6
    28fe:	fe cf       	rjmp	.-4      	; 0x28fc <vPeriodicTask+0x1e>
		
			/* Write sensor data in 8 bit resolution. */
			sensorDataMCU[ activeSensor ] = ADCH;
    2900:	e8 2f       	mov	r30, r24
    2902:	f0 e0       	ldi	r31, 0x00	; 0
    2904:	95 b1       	in	r25, 0x05	; 5
    2906:	ed 53       	subi	r30, 0x3D	; 61
    2908:	f2 4f       	sbci	r31, 0xF2	; 242
    290a:	90 83       	st	Z, r25
	ADMUX = ( 1 << REFS0 ) | ( 1 << ADLAR );

	for( ;; ) {

		/* Poll ADC channels and store data in sensorDataMCU[ ]. */
		for( uint8_t activeSensor = 0; activeSensor < ADC_CHANNELS_USED; ++activeSensor ) {
    290c:	8f 5f       	subi	r24, 0xFF	; 255
    290e:	88 23       	and	r24, r24
    2910:	61 f3       	breq	.-40     	; 0x28ea <vPeriodicTask+0xc>
			sensorDataMCU[ activeSensor ] = ADCH;

		}		

		/* Periodic delay. */
		vTaskDelay( pdMS_TO_TICKS( 100 ) );
    2912:	8a e0       	ldi	r24, 0x0A	; 10
    2914:	90 e0       	ldi	r25, 0x00	; 0
    2916:	0e 94 9c 0e 	call	0x1d38	; 0x1d38 <vTaskDelay>
	}
    291a:	e5 cf       	rjmp	.-54     	; 0x28e6 <vPeriodicTask+0x8>

0000291c <main>:
/*************************************************************/
/*                           MAIN                            */
/*************************************************************/


int main( void ) {
    291c:	ef 92       	push	r14
    291e:	ff 92       	push	r15
    2920:	0f 93       	push	r16

	/* MCU pins direction setup. */
	DDRB |= ( 1 << PB0 );
    2922:	87 b3       	in	r24, 0x17	; 23
    2924:	81 60       	ori	r24, 0x01	; 1
    2926:	87 bb       	out	0x17, r24	; 23
	DDRB |= ( 1 << PB1 );
    2928:	87 b3       	in	r24, 0x17	; 23
    292a:	82 60       	ori	r24, 0x02	; 2
    292c:	87 bb       	out	0x17, r24	; 23

	/* Set baud rate UART0. */
	UBRR0H = ( uint8_t ) ( UBRR_UART0 >> 8 );
    292e:	10 92 90 00 	sts	0x0090, r1	; 0x800090 <__TEXT_REGION_LENGTH__+0x7e0090>
	UBRR0L = ( uint8_t )   UBRR_UART0;
    2932:	85 e0       	ldi	r24, 0x05	; 5
    2934:	89 b9       	out	0x09, r24	; 9

	/* Set baud rate UART1. */
	UBRR1H = ( uint8_t ) ( UBRR_UART1 >> 8 );
    2936:	10 92 98 00 	sts	0x0098, r1	; 0x800098 <__TEXT_REGION_LENGTH__+0x7e0098>
	UBRR1L = ( uint8_t )   UBRR_UART1;
    293a:	87 e4       	ldi	r24, 0x47	; 71
    293c:	80 93 99 00 	sts	0x0099, r24	; 0x800099 <__TEXT_REGION_LENGTH__+0x7e0099>

	/* Enable receiver and transmitter UART0. */
	UCSR0B = ( 1 << RXEN0 ) | ( 1 << TXEN0 );
    2940:	88 e1       	ldi	r24, 0x18	; 24
    2942:	8a b9       	out	0x0a, r24	; 10

	/* Enable receiver and transmitter UART1. */
	UCSR1B = ( 1 << RXEN1 ) | ( 1 << TXEN1 );
    2944:	ea e9       	ldi	r30, 0x9A	; 154
    2946:	f0 e0       	ldi	r31, 0x00	; 0
    2948:	80 83       	st	Z, r24

	/* Enable interrupts. */
	UCSR0B |= ( 1 << RXCIE0 );
    294a:	8a b1       	in	r24, 0x0a	; 10
    294c:	80 68       	ori	r24, 0x80	; 128
    294e:	8a b9       	out	0x0a, r24	; 10
	UCSR1B |= ( 1 << RXCIE1 );
    2950:	80 81       	ld	r24, Z
    2952:	80 68       	ori	r24, 0x80	; 128
    2954:	80 83       	st	Z, r24
	sei( );
    2956:	78 94       	sei

	/* Create queues. */
	bufferRoombaSendUART0		= xQueueCreate( 32, sizeof( uint8_t ) );
    2958:	40 e0       	ldi	r20, 0x00	; 0
    295a:	61 e0       	ldi	r22, 0x01	; 1
    295c:	80 e2       	ldi	r24, 0x20	; 32
    295e:	0e 94 c2 07 	call	0xf84	; 0xf84 <xQueueGenericCreate>
    2962:	90 93 bc 0d 	sts	0x0DBC, r25	; 0x800dbc <bufferRoombaSendUART0+0x1>
    2966:	80 93 bb 0d 	sts	0x0DBB, r24	; 0x800dbb <bufferRoombaSendUART0>
	bufferRoombaReceiveUART0	= xQueueCreate( 32, sizeof( uint8_t ) );
    296a:	40 e0       	ldi	r20, 0x00	; 0
    296c:	61 e0       	ldi	r22, 0x01	; 1
    296e:	80 e2       	ldi	r24, 0x20	; 32
    2970:	0e 94 c2 07 	call	0xf84	; 0xf84 <xQueueGenericCreate>
    2974:	90 93 e6 0d 	sts	0x0DE6, r25	; 0x800de6 <bufferRoombaReceiveUART0+0x1>
    2978:	80 93 e5 0d 	sts	0x0DE5, r24	; 0x800de5 <bufferRoombaReceiveUART0>
	bufferBluetoothSendUART1	= xQueueCreate( 32, sizeof( uint8_t ) );
    297c:	40 e0       	ldi	r20, 0x00	; 0
    297e:	61 e0       	ldi	r22, 0x01	; 1
    2980:	80 e2       	ldi	r24, 0x20	; 32
    2982:	0e 94 c2 07 	call	0xf84	; 0xf84 <xQueueGenericCreate>
    2986:	90 93 be 0d 	sts	0x0DBE, r25	; 0x800dbe <bufferBluetoothSendUART1+0x1>
    298a:	80 93 bd 0d 	sts	0x0DBD, r24	; 0x800dbd <bufferBluetoothSendUART1>
	bufferBluetoothReceiveUART1 = xQueueCreate( 32, sizeof( uint8_t ) );
    298e:	40 e0       	ldi	r20, 0x00	; 0
    2990:	61 e0       	ldi	r22, 0x01	; 1
    2992:	80 e2       	ldi	r24, 0x20	; 32
    2994:	0e 94 c2 07 	call	0xf84	; 0xf84 <xQueueGenericCreate>
    2998:	90 93 c2 0d 	sts	0x0DC2, r25	; 0x800dc2 <bufferBluetoothReceiveUART1+0x1>
    299c:	80 93 c1 0d 	sts	0x0DC1, r24	; 0x800dc1 <bufferBluetoothReceiveUART1>
	globalError					= xQueueCreate(  1, sizeof( uint8_t ) );
    29a0:	40 e0       	ldi	r20, 0x00	; 0
    29a2:	61 e0       	ldi	r22, 0x01	; 1
    29a4:	81 e0       	ldi	r24, 0x01	; 1
    29a6:	0e 94 c2 07 	call	0xf84	; 0xf84 <xQueueGenericCreate>
    29aa:	90 93 c0 0d 	sts	0x0DC0, r25	; 0x800dc0 <globalError+0x1>
    29ae:	80 93 bf 0d 	sts	0x0DBF, r24	; 0x800dbf <globalError>

	/* Create the tasks. */
	xTaskCreate( vPeriodicTask,                  "Periodic", configMINIMAL_STACK_SIZE, NULL, mainNORMAL_PRIORITY,    NULL );
    29b2:	e1 2c       	mov	r14, r1
    29b4:	f1 2c       	mov	r15, r1
    29b6:	02 e0       	ldi	r16, 0x02	; 2
    29b8:	20 e0       	ldi	r18, 0x00	; 0
    29ba:	30 e0       	ldi	r19, 0x00	; 0
    29bc:	45 e5       	ldi	r20, 0x55	; 85
    29be:	50 e0       	ldi	r21, 0x00	; 0
    29c0:	65 e0       	ldi	r22, 0x05	; 5
    29c2:	71 e0       	ldi	r23, 0x01	; 1
    29c4:	8f e6       	ldi	r24, 0x6F	; 111
    29c6:	94 e1       	ldi	r25, 0x14	; 20
    29c8:	0e 94 8b 0c 	call	0x1916	; 0x1916 <xTaskCreate>
	xTaskCreate( vBluetoothReceiveCommandUART1,	 "BTcmd",    configMINIMAL_STACK_SIZE, NULL, mainNORMAL_PRIORITY, NULL );
    29cc:	20 e0       	ldi	r18, 0x00	; 0
    29ce:	30 e0       	ldi	r19, 0x00	; 0
    29d0:	45 e5       	ldi	r20, 0x55	; 85
    29d2:	50 e0       	ldi	r21, 0x00	; 0
    29d4:	6e e0       	ldi	r22, 0x0E	; 14
    29d6:	71 e0       	ldi	r23, 0x01	; 1
    29d8:	88 e3       	ldi	r24, 0x38	; 56
    29da:	94 e1       	ldi	r25, 0x14	; 20
    29dc:	0e 94 8b 0c 	call	0x1916	; 0x1916 <xTaskCreate>
	xTaskCreate( vRoombaTransmitServiceUART0,    "UART0Tx",  configMINIMAL_STACK_SIZE, NULL, mainNORMAL_PRIORITY,   NULL );
    29e0:	20 e0       	ldi	r18, 0x00	; 0
    29e2:	30 e0       	ldi	r19, 0x00	; 0
    29e4:	45 e5       	ldi	r20, 0x55	; 85
    29e6:	50 e0       	ldi	r21, 0x00	; 0
    29e8:	64 e1       	ldi	r22, 0x14	; 20
    29ea:	71 e0       	ldi	r23, 0x01	; 1
    29ec:	8c e3       	ldi	r24, 0x3C	; 60
    29ee:	93 e1       	ldi	r25, 0x13	; 19
    29f0:	0e 94 8b 0c 	call	0x1916	; 0x1916 <xTaskCreate>
	xTaskCreate( vBluetoothTransmitServiceUART1, "UART1Tx",  configMINIMAL_STACK_SIZE, NULL, mainNORMAL_PRIORITY,   NULL );
    29f4:	20 e0       	ldi	r18, 0x00	; 0
    29f6:	30 e0       	ldi	r19, 0x00	; 0
    29f8:	45 e5       	ldi	r20, 0x55	; 85
    29fa:	50 e0       	ldi	r21, 0x00	; 0
    29fc:	6c e1       	ldi	r22, 0x1C	; 28
    29fe:	71 e0       	ldi	r23, 0x01	; 1
    2a00:	8c e2       	ldi	r24, 0x2C	; 44
    2a02:	93 e1       	ldi	r25, 0x13	; 19
    2a04:	0e 94 8b 0c 	call	0x1916	; 0x1916 <xTaskCreate>
	xTaskCreate( vErrorHandler,                  "Error",    configMINIMAL_STACK_SIZE, NULL, mainNORMAL_PRIORITY,  NULL );
    2a08:	20 e0       	ldi	r18, 0x00	; 0
    2a0a:	30 e0       	ldi	r19, 0x00	; 0
    2a0c:	45 e5       	ldi	r20, 0x55	; 85
    2a0e:	50 e0       	ldi	r21, 0x00	; 0
    2a10:	64 e2       	ldi	r22, 0x24	; 36
    2a12:	71 e0       	ldi	r23, 0x01	; 1
    2a14:	8b e2       	ldi	r24, 0x2B	; 43
    2a16:	93 e1       	ldi	r25, 0x13	; 19
    2a18:	0e 94 8b 0c 	call	0x1916	; 0x1916 <xTaskCreate>

	vTaskStartScheduler( );
    2a1c:	0e 94 df 0c 	call	0x19be	; 0x19be <vTaskStartScheduler>

	return 0;
}
    2a20:	80 e0       	ldi	r24, 0x00	; 0
    2a22:	90 e0       	ldi	r25, 0x00	; 0
    2a24:	0f 91       	pop	r16
    2a26:	ff 90       	pop	r15
    2a28:	ef 90       	pop	r14
    2a2a:	08 95       	ret

00002a2c <vApplicationIdleHook>:

	}
}


void vApplicationIdleHook( void ) {
    2a2c:	08 95       	ret

00002a2e <__vector_18>:
/*************************************************************/
/*                INTERRUPT SERVICE ROUTINES                 */
/*************************************************************/


ISR( USART0_RX_vect ) {
    2a2e:	1f 92       	push	r1
    2a30:	0f 92       	push	r0
    2a32:	0f b6       	in	r0, 0x3f	; 63
    2a34:	0f 92       	push	r0
    2a36:	11 24       	eor	r1, r1
    2a38:	2f 93       	push	r18
    2a3a:	3f 93       	push	r19
    2a3c:	4f 93       	push	r20
    2a3e:	5f 93       	push	r21
    2a40:	6f 93       	push	r22
    2a42:	7f 93       	push	r23
    2a44:	8f 93       	push	r24
    2a46:	9f 93       	push	r25
    2a48:	af 93       	push	r26
    2a4a:	bf 93       	push	r27
    2a4c:	ef 93       	push	r30
    2a4e:	ff 93       	push	r31
	/* UART0 receive complete ISR. 
	   Pushes received byte from UDR0 register on bufferRoombaReceiveUART0 queue. */
	xQueueSendToBackFromISR( bufferRoombaReceiveUART0, &UDR0, NULL );
    2a50:	20 e0       	ldi	r18, 0x00	; 0
    2a52:	40 e0       	ldi	r20, 0x00	; 0
    2a54:	50 e0       	ldi	r21, 0x00	; 0
    2a56:	6c e2       	ldi	r22, 0x2C	; 44
    2a58:	70 e0       	ldi	r23, 0x00	; 0
    2a5a:	80 91 e5 0d 	lds	r24, 0x0DE5	; 0x800de5 <bufferRoombaReceiveUART0>
    2a5e:	90 91 e6 0d 	lds	r25, 0x0DE6	; 0x800de6 <bufferRoombaReceiveUART0+0x1>
    2a62:	0e 94 9c 08 	call	0x1138	; 0x1138 <xQueueGenericSendFromISR>
}
    2a66:	ff 91       	pop	r31
    2a68:	ef 91       	pop	r30
    2a6a:	bf 91       	pop	r27
    2a6c:	af 91       	pop	r26
    2a6e:	9f 91       	pop	r25
    2a70:	8f 91       	pop	r24
    2a72:	7f 91       	pop	r23
    2a74:	6f 91       	pop	r22
    2a76:	5f 91       	pop	r21
    2a78:	4f 91       	pop	r20
    2a7a:	3f 91       	pop	r19
    2a7c:	2f 91       	pop	r18
    2a7e:	0f 90       	pop	r0
    2a80:	0f be       	out	0x3f, r0	; 63
    2a82:	0f 90       	pop	r0
    2a84:	1f 90       	pop	r1
    2a86:	18 95       	reti

00002a88 <__vector_30>:

ISR( USART1_RX_vect ) {
    2a88:	1f 92       	push	r1
    2a8a:	0f 92       	push	r0
    2a8c:	0f b6       	in	r0, 0x3f	; 63
    2a8e:	0f 92       	push	r0
    2a90:	11 24       	eor	r1, r1
    2a92:	2f 93       	push	r18
    2a94:	3f 93       	push	r19
    2a96:	4f 93       	push	r20
    2a98:	5f 93       	push	r21
    2a9a:	6f 93       	push	r22
    2a9c:	7f 93       	push	r23
    2a9e:	8f 93       	push	r24
    2aa0:	9f 93       	push	r25
    2aa2:	af 93       	push	r26
    2aa4:	bf 93       	push	r27
    2aa6:	ef 93       	push	r30
    2aa8:	ff 93       	push	r31
/* UART1 receive complete ISR. 
	   Pushes received byte from UDR1 register on bufferBluetoothReceiveUART1 queue. */
	xQueueSendToBackFromISR( bufferBluetoothReceiveUART1, &UDR1, NULL );
    2aaa:	20 e0       	ldi	r18, 0x00	; 0
    2aac:	40 e0       	ldi	r20, 0x00	; 0
    2aae:	50 e0       	ldi	r21, 0x00	; 0
    2ab0:	6c e9       	ldi	r22, 0x9C	; 156
    2ab2:	70 e0       	ldi	r23, 0x00	; 0
    2ab4:	80 91 c1 0d 	lds	r24, 0x0DC1	; 0x800dc1 <bufferBluetoothReceiveUART1>
    2ab8:	90 91 c2 0d 	lds	r25, 0x0DC2	; 0x800dc2 <bufferBluetoothReceiveUART1+0x1>
    2abc:	0e 94 9c 08 	call	0x1138	; 0x1138 <xQueueGenericSendFromISR>
}
    2ac0:	ff 91       	pop	r31
    2ac2:	ef 91       	pop	r30
    2ac4:	bf 91       	pop	r27
    2ac6:	af 91       	pop	r26
    2ac8:	9f 91       	pop	r25
    2aca:	8f 91       	pop	r24
    2acc:	7f 91       	pop	r23
    2ace:	6f 91       	pop	r22
    2ad0:	5f 91       	pop	r21
    2ad2:	4f 91       	pop	r20
    2ad4:	3f 91       	pop	r19
    2ad6:	2f 91       	pop	r18
    2ad8:	0f 90       	pop	r0
    2ada:	0f be       	out	0x3f, r0	; 63
    2adc:	0f 90       	pop	r0
    2ade:	1f 90       	pop	r1
    2ae0:	18 95       	reti

00002ae2 <__tablejump2__>:
    2ae2:	ee 0f       	add	r30, r30
    2ae4:	ff 1f       	adc	r31, r31
    2ae6:	05 90       	lpm	r0, Z+
    2ae8:	f4 91       	lpm	r31, Z
    2aea:	e0 2d       	mov	r30, r0
    2aec:	09 94       	ijmp

00002aee <memcpy>:
    2aee:	fb 01       	movw	r30, r22
    2af0:	dc 01       	movw	r26, r24
    2af2:	02 c0       	rjmp	.+4      	; 0x2af8 <memcpy+0xa>
    2af4:	01 90       	ld	r0, Z+
    2af6:	0d 92       	st	X+, r0
    2af8:	41 50       	subi	r20, 0x01	; 1
    2afa:	50 40       	sbci	r21, 0x00	; 0
    2afc:	d8 f7       	brcc	.-10     	; 0x2af4 <memcpy+0x6>
    2afe:	08 95       	ret

00002b00 <_exit>:
    2b00:	f8 94       	cli

00002b02 <__stop_program>:
    2b02:	ff cf       	rjmp	.-2      	; 0x2b02 <__stop_program>
