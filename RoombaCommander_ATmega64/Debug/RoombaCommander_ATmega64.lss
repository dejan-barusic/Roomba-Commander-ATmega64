
RoombaCommander_ATmega64.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000022  00800100  000029d0  00002a64  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000029d0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000cbd  00800122  00800122  00002a86  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002a86  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00002ab8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000458  00000000  00000000  00002af4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000540b  00000000  00000000  00002f4c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001504  00000000  00000000  00008357  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002df1  00000000  00000000  0000985b  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000e04  00000000  00000000  0000c64c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000019e6  00000000  00000000  0000d450  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00005014  00000000  00000000  0000ee36  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000460  00000000  00000000  00013e4a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 56 00 	jmp	0xac	; 0xac <__ctors_end>
       4:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
       8:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
       c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      10:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      14:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      18:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      1c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      20:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      24:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      28:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      2c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      30:	0c 94 f9 05 	jmp	0xbf2	; 0xbf2 <__vector_12>
      34:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      38:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      3c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      40:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      44:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      48:	0c 94 7d 14 	jmp	0x28fa	; 0x28fa <__vector_18>
      4c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      50:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      54:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      58:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      5c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      60:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      64:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      68:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      6c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      70:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      74:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      78:	0c 94 aa 14 	jmp	0x2954	; 0x2954 <__vector_30>
      7c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      80:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      84:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      88:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      8c:	e6 13       	cpse	r30, r22
      8e:	ea 13       	cpse	r30, r26
      90:	e6 13       	cpse	r30, r22
      92:	e6 13       	cpse	r30, r22
      94:	e6 13       	cpse	r30, r22
      96:	e6 13       	cpse	r30, r22
      98:	e6 13       	cpse	r30, r22
      9a:	e6 13       	cpse	r30, r22
      9c:	e6 13       	cpse	r30, r22
      9e:	f2 13       	cpse	r31, r18
      a0:	ea 13       	cpse	r30, r26
      a2:	ee 13       	cpse	r30, r30
      a4:	f9 13       	cpse	r31, r25
      a6:	ea 13       	cpse	r30, r26
      a8:	f6 13       	cpse	r31, r22
      aa:	e6 13       	cpse	r30, r22

000000ac <__ctors_end>:
      ac:	11 24       	eor	r1, r1
      ae:	1f be       	out	0x3f, r1	; 63
      b0:	cf ef       	ldi	r28, 0xFF	; 255
      b2:	d0 e1       	ldi	r29, 0x10	; 16
      b4:	de bf       	out	0x3e, r29	; 62
      b6:	cd bf       	out	0x3d, r28	; 61

000000b8 <__do_copy_data>:
      b8:	11 e0       	ldi	r17, 0x01	; 1
      ba:	a0 e0       	ldi	r26, 0x00	; 0
      bc:	b1 e0       	ldi	r27, 0x01	; 1
      be:	e0 ed       	ldi	r30, 0xD0	; 208
      c0:	f9 e2       	ldi	r31, 0x29	; 41
      c2:	02 c0       	rjmp	.+4      	; 0xc8 <__do_copy_data+0x10>
      c4:	05 90       	lpm	r0, Z+
      c6:	0d 92       	st	X+, r0
      c8:	a2 32       	cpi	r26, 0x22	; 34
      ca:	b1 07       	cpc	r27, r17
      cc:	d9 f7       	brne	.-10     	; 0xc4 <__do_copy_data+0xc>

000000ce <__do_clear_bss>:
      ce:	2d e0       	ldi	r18, 0x0D	; 13
      d0:	a2 e2       	ldi	r26, 0x22	; 34
      d2:	b1 e0       	ldi	r27, 0x01	; 1
      d4:	01 c0       	rjmp	.+2      	; 0xd8 <.do_clear_bss_start>

000000d6 <.do_clear_bss_loop>:
      d6:	1d 92       	st	X+, r1

000000d8 <.do_clear_bss_start>:
      d8:	af 3d       	cpi	r26, 0xDF	; 223
      da:	b2 07       	cpc	r27, r18
      dc:	e1 f7       	brne	.-8      	; 0xd6 <.do_clear_bss_loop>
      de:	0e 94 fc 13 	call	0x27f8	; 0x27f8 <main>
      e2:	0c 94 e6 14 	jmp	0x29cc	; 0x29cc <_exit>

000000e6 <__bad_interrupt>:
      e6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ea <prvInitialiseCoRoutineLists>:
	return;
}
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
      ea:	cf 93       	push	r28
UBaseType_t uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
      ec:	c0 e0       	ldi	r28, 0x00	; 0
      ee:	10 c0       	rjmp	.+32     	; 0x110 <prvInitialiseCoRoutineLists+0x26>
	{
		vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
      f0:	8c 2f       	mov	r24, r28
      f2:	90 e0       	ldi	r25, 0x00	; 0
      f4:	9c 01       	movw	r18, r24
      f6:	22 0f       	add	r18, r18
      f8:	33 1f       	adc	r19, r19
      fa:	22 0f       	add	r18, r18
      fc:	33 1f       	adc	r19, r19
      fe:	22 0f       	add	r18, r18
     100:	33 1f       	adc	r19, r19
     102:	82 0f       	add	r24, r18
     104:	93 1f       	adc	r25, r19
     106:	86 5b       	subi	r24, 0xB6	; 182
     108:	9e 4f       	sbci	r25, 0xFE	; 254
     10a:	0e 94 14 04 	call	0x828	; 0x828 <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
     10e:	cf 5f       	subi	r28, 0xFF	; 255
     110:	c2 30       	cpi	r28, 0x02	; 2
     112:	70 f3       	brcs	.-36     	; 0xf0 <prvInitialiseCoRoutineLists+0x6>
	{
		vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
     114:	81 e4       	ldi	r24, 0x41	; 65
     116:	91 e0       	ldi	r25, 0x01	; 1
     118:	0e 94 14 04 	call	0x828	; 0x828 <vListInitialise>
	vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
     11c:	88 e3       	ldi	r24, 0x38	; 56
     11e:	91 e0       	ldi	r25, 0x01	; 1
     120:	0e 94 14 04 	call	0x828	; 0x828 <vListInitialise>
	vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
     124:	8b e2       	ldi	r24, 0x2B	; 43
     126:	91 e0       	ldi	r25, 0x01	; 1
     128:	0e 94 14 04 	call	0x828	; 0x828 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
     12c:	81 e4       	ldi	r24, 0x41	; 65
     12e:	91 e0       	ldi	r25, 0x01	; 1
     130:	90 93 37 01 	sts	0x0137, r25	; 0x800137 <pxDelayedCoRoutineList+0x1>
     134:	80 93 36 01 	sts	0x0136, r24	; 0x800136 <pxDelayedCoRoutineList>
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
     138:	88 e3       	ldi	r24, 0x38	; 56
     13a:	91 e0       	ldi	r25, 0x01	; 1
     13c:	90 93 35 01 	sts	0x0135, r25	; 0x800135 <pxOverflowDelayedCoRoutineList+0x1>
     140:	80 93 34 01 	sts	0x0134, r24	; 0x800134 <pxOverflowDelayedCoRoutineList>
}
     144:	cf 91       	pop	r28
     146:	08 95       	ret

00000148 <prvCheckPendingReadyList>:
	}
}
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
     148:	0f 93       	push	r16
     14a:	1f 93       	push	r17
     14c:	cf 93       	push	r28
     14e:	df 93       	push	r29
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     150:	28 c0       	rjmp	.+80     	; 0x1a2 <prvCheckPendingReadyList+0x5a>
	{
		CRCB_t *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
     152:	f8 94       	cli
		{
			pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
     154:	e0 91 30 01 	lds	r30, 0x0130	; 0x800130 <xPendingReadyCoRoutineList+0x5>
     158:	f0 91 31 01 	lds	r31, 0x0131	; 0x800131 <xPendingReadyCoRoutineList+0x6>
     15c:	c6 81       	ldd	r28, Z+6	; 0x06
     15e:	d7 81       	ldd	r29, Z+7	; 0x07
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     160:	ce 01       	movw	r24, r28
     162:	0c 96       	adiw	r24, 0x0c	; 12
     164:	0e 94 78 04 	call	0x8f0	; 0x8f0 <uxListRemove>
		}
		portENABLE_INTERRUPTS();
     168:	78 94       	sei

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
     16a:	8e 01       	movw	r16, r28
     16c:	0e 5f       	subi	r16, 0xFE	; 254
     16e:	1f 4f       	sbci	r17, 0xFF	; 255
     170:	c8 01       	movw	r24, r16
     172:	0e 94 78 04 	call	0x8f0	; 0x8f0 <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
     176:	8e 89       	ldd	r24, Y+22	; 0x16
     178:	90 91 28 01 	lds	r25, 0x0128	; 0x800128 <uxTopCoRoutineReadyPriority>
     17c:	98 17       	cp	r25, r24
     17e:	10 f4       	brcc	.+4      	; 0x184 <prvCheckPendingReadyList+0x3c>
     180:	80 93 28 01 	sts	0x0128, r24	; 0x800128 <uxTopCoRoutineReadyPriority>
     184:	90 e0       	ldi	r25, 0x00	; 0
     186:	9c 01       	movw	r18, r24
     188:	22 0f       	add	r18, r18
     18a:	33 1f       	adc	r19, r19
     18c:	22 0f       	add	r18, r18
     18e:	33 1f       	adc	r19, r19
     190:	22 0f       	add	r18, r18
     192:	33 1f       	adc	r19, r19
     194:	82 0f       	add	r24, r18
     196:	93 1f       	adc	r25, r19
     198:	b8 01       	movw	r22, r16
     19a:	86 5b       	subi	r24, 0xB6	; 182
     19c:	9e 4f       	sbci	r25, 0xFE	; 254
     19e:	0e 94 26 04 	call	0x84c	; 0x84c <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     1a2:	80 91 2b 01 	lds	r24, 0x012B	; 0x80012b <xPendingReadyCoRoutineList>
     1a6:	81 11       	cpse	r24, r1
     1a8:	d4 cf       	rjmp	.-88     	; 0x152 <prvCheckPendingReadyList+0xa>
		portENABLE_INTERRUPTS();

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
	}
}
     1aa:	df 91       	pop	r29
     1ac:	cf 91       	pop	r28
     1ae:	1f 91       	pop	r17
     1b0:	0f 91       	pop	r16
     1b2:	08 95       	ret

000001b4 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
     1b4:	0f 93       	push	r16
     1b6:	1f 93       	push	r17
     1b8:	cf 93       	push	r28
     1ba:	df 93       	push	r29
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
     1bc:	0e 94 b4 0c 	call	0x1968	; 0x1968 <xTaskGetTickCount>
     1c0:	20 91 24 01 	lds	r18, 0x0124	; 0x800124 <xLastTickCount>
     1c4:	30 91 25 01 	lds	r19, 0x0125	; 0x800125 <xLastTickCount+0x1>
     1c8:	82 1b       	sub	r24, r18
     1ca:	93 0b       	sbc	r25, r19
     1cc:	90 93 23 01 	sts	0x0123, r25	; 0x800123 <__data_end+0x1>
     1d0:	80 93 22 01 	sts	0x0122, r24	; 0x800122 <__data_end>
	while( xPassedTicks )
     1d4:	5e c0       	rjmp	.+188    	; 0x292 <prvCheckDelayedList+0xde>
	{
		xCoRoutineTickCount++;
     1d6:	20 91 26 01 	lds	r18, 0x0126	; 0x800126 <xCoRoutineTickCount>
     1da:	30 91 27 01 	lds	r19, 0x0127	; 0x800127 <xCoRoutineTickCount+0x1>
     1de:	2f 5f       	subi	r18, 0xFF	; 255
     1e0:	3f 4f       	sbci	r19, 0xFF	; 255
     1e2:	30 93 27 01 	sts	0x0127, r19	; 0x800127 <xCoRoutineTickCount+0x1>
     1e6:	20 93 26 01 	sts	0x0126, r18	; 0x800126 <xCoRoutineTickCount>
		xPassedTicks--;
     1ea:	01 97       	sbiw	r24, 0x01	; 1
     1ec:	90 93 23 01 	sts	0x0123, r25	; 0x800123 <__data_end+0x1>
     1f0:	80 93 22 01 	sts	0x0122, r24	; 0x800122 <__data_end>

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
     1f4:	23 2b       	or	r18, r19
     1f6:	09 f0       	breq	.+2      	; 0x1fa <prvCheckDelayedList+0x46>
     1f8:	45 c0       	rjmp	.+138    	; 0x284 <prvCheckDelayedList+0xd0>
		{
			List_t * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
     1fa:	80 91 36 01 	lds	r24, 0x0136	; 0x800136 <pxDelayedCoRoutineList>
     1fe:	90 91 37 01 	lds	r25, 0x0137	; 0x800137 <pxDelayedCoRoutineList+0x1>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
     202:	20 91 34 01 	lds	r18, 0x0134	; 0x800134 <pxOverflowDelayedCoRoutineList>
     206:	30 91 35 01 	lds	r19, 0x0135	; 0x800135 <pxOverflowDelayedCoRoutineList+0x1>
     20a:	30 93 37 01 	sts	0x0137, r19	; 0x800137 <pxDelayedCoRoutineList+0x1>
     20e:	20 93 36 01 	sts	0x0136, r18	; 0x800136 <pxDelayedCoRoutineList>
			pxOverflowDelayedCoRoutineList = pxTemp;
     212:	90 93 35 01 	sts	0x0135, r25	; 0x800135 <pxOverflowDelayedCoRoutineList+0x1>
     216:	80 93 34 01 	sts	0x0134, r24	; 0x800134 <pxOverflowDelayedCoRoutineList>
     21a:	34 c0       	rjmp	.+104    	; 0x284 <prvCheckDelayedList+0xd0>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     21c:	05 80       	ldd	r0, Z+5	; 0x05
     21e:	f6 81       	ldd	r31, Z+6	; 0x06
     220:	e0 2d       	mov	r30, r0
     222:	c6 81       	ldd	r28, Z+6	; 0x06
     224:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
     226:	2a 81       	ldd	r18, Y+2	; 0x02
     228:	3b 81       	ldd	r19, Y+3	; 0x03
     22a:	80 91 26 01 	lds	r24, 0x0126	; 0x800126 <xCoRoutineTickCount>
     22e:	90 91 27 01 	lds	r25, 0x0127	; 0x800127 <xCoRoutineTickCount+0x1>
     232:	82 17       	cp	r24, r18
     234:	93 07       	cpc	r25, r19
     236:	68 f1       	brcs	.+90     	; 0x292 <prvCheckDelayedList+0xde>
			{
				/* Timeout not yet expired. */
				break;
			}

			portDISABLE_INTERRUPTS();
     238:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
     23a:	8e 01       	movw	r16, r28
     23c:	0e 5f       	subi	r16, 0xFE	; 254
     23e:	1f 4f       	sbci	r17, 0xFF	; 255
     240:	c8 01       	movw	r24, r16
     242:	0e 94 78 04 	call	0x8f0	; 0x8f0 <uxListRemove>

				/* Is the co-routine waiting on an event also? */
				if( pxCRCB->xEventListItem.pvContainer )
     246:	8c 89       	ldd	r24, Y+20	; 0x14
     248:	9d 89       	ldd	r25, Y+21	; 0x15
     24a:	89 2b       	or	r24, r25
     24c:	21 f0       	breq	.+8      	; 0x256 <prvCheckDelayedList+0xa2>
				{
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
     24e:	ce 01       	movw	r24, r28
     250:	0c 96       	adiw	r24, 0x0c	; 12
     252:	0e 94 78 04 	call	0x8f0	; 0x8f0 <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
     256:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );
     258:	8e 89       	ldd	r24, Y+22	; 0x16
     25a:	90 91 28 01 	lds	r25, 0x0128	; 0x800128 <uxTopCoRoutineReadyPriority>
     25e:	98 17       	cp	r25, r24
     260:	10 f4       	brcc	.+4      	; 0x266 <prvCheckDelayedList+0xb2>
     262:	80 93 28 01 	sts	0x0128, r24	; 0x800128 <uxTopCoRoutineReadyPriority>
     266:	90 e0       	ldi	r25, 0x00	; 0
     268:	9c 01       	movw	r18, r24
     26a:	22 0f       	add	r18, r18
     26c:	33 1f       	adc	r19, r19
     26e:	22 0f       	add	r18, r18
     270:	33 1f       	adc	r19, r19
     272:	22 0f       	add	r18, r18
     274:	33 1f       	adc	r19, r19
     276:	82 0f       	add	r24, r18
     278:	93 1f       	adc	r25, r19
     27a:	b8 01       	movw	r22, r16
     27c:	86 5b       	subi	r24, 0xB6	; 182
     27e:	9e 4f       	sbci	r25, 0xFE	; 254
     280:	0e 94 26 04 	call	0x84c	; 0x84c <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     284:	e0 91 36 01 	lds	r30, 0x0136	; 0x800136 <pxDelayedCoRoutineList>
     288:	f0 91 37 01 	lds	r31, 0x0137	; 0x800137 <pxDelayedCoRoutineList+0x1>
     28c:	80 81       	ld	r24, Z
     28e:	81 11       	cpse	r24, r1
     290:	c5 cf       	rjmp	.-118    	; 0x21c <prvCheckDelayedList+0x68>
static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
     292:	80 91 22 01 	lds	r24, 0x0122	; 0x800122 <__data_end>
     296:	90 91 23 01 	lds	r25, 0x0123	; 0x800123 <__data_end+0x1>
     29a:	00 97       	sbiw	r24, 0x00	; 0
     29c:	09 f0       	breq	.+2      	; 0x2a0 <prvCheckDelayedList+0xec>
     29e:	9b cf       	rjmp	.-202    	; 0x1d6 <prvCheckDelayedList+0x22>

			prvAddCoRoutineToReadyQueue( pxCRCB );
		}
	}

	xLastTickCount = xCoRoutineTickCount;
     2a0:	80 91 26 01 	lds	r24, 0x0126	; 0x800126 <xCoRoutineTickCount>
     2a4:	90 91 27 01 	lds	r25, 0x0127	; 0x800127 <xCoRoutineTickCount+0x1>
     2a8:	90 93 25 01 	sts	0x0125, r25	; 0x800125 <xLastTickCount+0x1>
     2ac:	80 93 24 01 	sts	0x0124, r24	; 0x800124 <xLastTickCount>
}
     2b0:	df 91       	pop	r29
     2b2:	cf 91       	pop	r28
     2b4:	1f 91       	pop	r17
     2b6:	0f 91       	pop	r16
     2b8:	08 95       	ret

000002ba <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, UBaseType_t uxPriority, UBaseType_t uxIndex )
{
     2ba:	cf 92       	push	r12
     2bc:	df 92       	push	r13
     2be:	ff 92       	push	r15
     2c0:	0f 93       	push	r16
     2c2:	1f 93       	push	r17
     2c4:	cf 93       	push	r28
     2c6:	df 93       	push	r29
     2c8:	6c 01       	movw	r12, r24
     2ca:	f6 2e       	mov	r15, r22
     2cc:	14 2f       	mov	r17, r20
BaseType_t xReturn;
CRCB_t *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
     2ce:	8a e1       	ldi	r24, 0x1A	; 26
     2d0:	90 e0       	ldi	r25, 0x00	; 0
     2d2:	0e 94 fc 05 	call	0xbf8	; 0xbf8 <pvPortMalloc>
     2d6:	ec 01       	movw	r28, r24
	if( pxCoRoutine )
     2d8:	89 2b       	or	r24, r25
     2da:	09 f4       	brne	.+2      	; 0x2de <xCoRoutineCreate+0x24>
     2dc:	42 c0       	rjmp	.+132    	; 0x362 <xCoRoutineCreate+0xa8>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
     2de:	80 91 29 01 	lds	r24, 0x0129	; 0x800129 <pxCurrentCoRoutine>
     2e2:	90 91 2a 01 	lds	r25, 0x012A	; 0x80012a <pxCurrentCoRoutine+0x1>
     2e6:	89 2b       	or	r24, r25
     2e8:	31 f4       	brne	.+12     	; 0x2f6 <xCoRoutineCreate+0x3c>
		{
			pxCurrentCoRoutine = pxCoRoutine;
     2ea:	d0 93 2a 01 	sts	0x012A, r29	; 0x80012a <pxCurrentCoRoutine+0x1>
     2ee:	c0 93 29 01 	sts	0x0129, r28	; 0x800129 <pxCurrentCoRoutine>
			prvInitialiseCoRoutineLists();
     2f2:	0e 94 75 00 	call	0xea	; 0xea <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
     2f6:	81 e0       	ldi	r24, 0x01	; 1
     2f8:	8f 15       	cp	r24, r15
     2fa:	10 f4       	brcc	.+4      	; 0x300 <xCoRoutineCreate+0x46>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
     2fc:	ff 24       	eor	r15, r15
     2fe:	f3 94       	inc	r15
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
     300:	19 8e       	std	Y+25, r1	; 0x19
     302:	18 8e       	std	Y+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
     304:	fe 8a       	std	Y+22, r15	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
     306:	1f 8b       	std	Y+23, r17	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     308:	fe 01       	movw	r30, r28
     30a:	c1 92       	st	Z+, r12
     30c:	d1 92       	st	Z+, r13
     30e:	8f 01       	movw	r16, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     310:	cf 01       	movw	r24, r30
     312:	0e 94 22 04 	call	0x844	; 0x844 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     316:	ce 01       	movw	r24, r28
     318:	0c 96       	adiw	r24, 0x0c	; 12
     31a:	0e 94 22 04 	call	0x844	; 0x844 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the ListItem_t.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     31e:	d9 87       	std	Y+9, r29	; 0x09
     320:	c8 87       	std	Y+8, r28	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     322:	db 8b       	std	Y+19, r29	; 0x13
     324:	ca 8b       	std	Y+18, r28	; 0x12

		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
     326:	82 e0       	ldi	r24, 0x02	; 2
     328:	90 e0       	ldi	r25, 0x00	; 0
     32a:	8f 19       	sub	r24, r15
     32c:	91 09       	sbc	r25, r1
     32e:	9d 87       	std	Y+13, r25	; 0x0d
     330:	8c 87       	std	Y+12, r24	; 0x0c

		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
     332:	8e 89       	ldd	r24, Y+22	; 0x16
     334:	90 91 28 01 	lds	r25, 0x0128	; 0x800128 <uxTopCoRoutineReadyPriority>
     338:	98 17       	cp	r25, r24
     33a:	10 f4       	brcc	.+4      	; 0x340 <xCoRoutineCreate+0x86>
     33c:	80 93 28 01 	sts	0x0128, r24	; 0x800128 <uxTopCoRoutineReadyPriority>
     340:	90 e0       	ldi	r25, 0x00	; 0
     342:	9c 01       	movw	r18, r24
     344:	22 0f       	add	r18, r18
     346:	33 1f       	adc	r19, r19
     348:	22 0f       	add	r18, r18
     34a:	33 1f       	adc	r19, r19
     34c:	22 0f       	add	r18, r18
     34e:	33 1f       	adc	r19, r19
     350:	82 0f       	add	r24, r18
     352:	93 1f       	adc	r25, r19
     354:	b8 01       	movw	r22, r16
     356:	86 5b       	subi	r24, 0xB6	; 182
     358:	9e 4f       	sbci	r25, 0xFE	; 254
     35a:	0e 94 26 04 	call	0x84c	; 0x84c <vListInsertEnd>

		xReturn = pdPASS;
     35e:	81 e0       	ldi	r24, 0x01	; 1
     360:	01 c0       	rjmp	.+2      	; 0x364 <xCoRoutineCreate+0xaa>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     362:	8f ef       	ldi	r24, 0xFF	; 255
	}

	return xReturn;
}
     364:	df 91       	pop	r29
     366:	cf 91       	pop	r28
     368:	1f 91       	pop	r17
     36a:	0f 91       	pop	r16
     36c:	ff 90       	pop	r15
     36e:	df 90       	pop	r13
     370:	cf 90       	pop	r12
     372:	08 95       	ret

00000374 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay, List_t *pxEventList )
{
     374:	0f 93       	push	r16
     376:	1f 93       	push	r17
     378:	cf 93       	push	r28
     37a:	df 93       	push	r29
     37c:	8b 01       	movw	r16, r22
TickType_t xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     37e:	c0 91 26 01 	lds	r28, 0x0126	; 0x800126 <xCoRoutineTickCount>
     382:	d0 91 27 01 	lds	r29, 0x0127	; 0x800127 <xCoRoutineTickCount+0x1>
     386:	c8 0f       	add	r28, r24
     388:	d9 1f       	adc	r29, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     38a:	80 91 29 01 	lds	r24, 0x0129	; 0x800129 <pxCurrentCoRoutine>
     38e:	90 91 2a 01 	lds	r25, 0x012A	; 0x80012a <pxCurrentCoRoutine+0x1>
     392:	02 96       	adiw	r24, 0x02	; 2
     394:	0e 94 78 04 	call	0x8f0	; 0x8f0 <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     398:	e0 91 29 01 	lds	r30, 0x0129	; 0x800129 <pxCurrentCoRoutine>
     39c:	f0 91 2a 01 	lds	r31, 0x012A	; 0x80012a <pxCurrentCoRoutine+0x1>
     3a0:	d3 83       	std	Z+3, r29	; 0x03
     3a2:	c2 83       	std	Z+2, r28	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
     3a4:	80 91 26 01 	lds	r24, 0x0126	; 0x800126 <xCoRoutineTickCount>
     3a8:	90 91 27 01 	lds	r25, 0x0127	; 0x800127 <xCoRoutineTickCount+0x1>
     3ac:	c8 17       	cp	r28, r24
     3ae:	d9 07       	cpc	r29, r25
     3b0:	50 f4       	brcc	.+20     	; 0x3c6 <vCoRoutineAddToDelayedList+0x52>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     3b2:	bf 01       	movw	r22, r30
     3b4:	6e 5f       	subi	r22, 0xFE	; 254
     3b6:	7f 4f       	sbci	r23, 0xFF	; 255
     3b8:	80 91 34 01 	lds	r24, 0x0134	; 0x800134 <pxOverflowDelayedCoRoutineList>
     3bc:	90 91 35 01 	lds	r25, 0x0135	; 0x800135 <pxOverflowDelayedCoRoutineList+0x1>
     3c0:	0e 94 47 04 	call	0x88e	; 0x88e <vListInsert>
     3c4:	09 c0       	rjmp	.+18     	; 0x3d8 <vCoRoutineAddToDelayedList+0x64>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     3c6:	bf 01       	movw	r22, r30
     3c8:	6e 5f       	subi	r22, 0xFE	; 254
     3ca:	7f 4f       	sbci	r23, 0xFF	; 255
     3cc:	80 91 36 01 	lds	r24, 0x0136	; 0x800136 <pxDelayedCoRoutineList>
     3d0:	90 91 37 01 	lds	r25, 0x0137	; 0x800137 <pxDelayedCoRoutineList+0x1>
     3d4:	0e 94 47 04 	call	0x88e	; 0x88e <vListInsert>
	}

	if( pxEventList )
     3d8:	01 15       	cp	r16, r1
     3da:	11 05       	cpc	r17, r1
     3dc:	49 f0       	breq	.+18     	; 0x3f0 <vCoRoutineAddToDelayedList+0x7c>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     3de:	60 91 29 01 	lds	r22, 0x0129	; 0x800129 <pxCurrentCoRoutine>
     3e2:	70 91 2a 01 	lds	r23, 0x012A	; 0x80012a <pxCurrentCoRoutine+0x1>
     3e6:	64 5f       	subi	r22, 0xF4	; 244
     3e8:	7f 4f       	sbci	r23, 0xFF	; 255
     3ea:	c8 01       	movw	r24, r16
     3ec:	0e 94 47 04 	call	0x88e	; 0x88e <vListInsert>
	}
}
     3f0:	df 91       	pop	r29
     3f2:	cf 91       	pop	r28
     3f4:	1f 91       	pop	r17
     3f6:	0f 91       	pop	r16
     3f8:	08 95       	ret

000003fa <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
     3fa:	0e 94 a4 00 	call	0x148	; 0x148 <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
     3fe:	0e 94 da 00 	call	0x1b4	; 0x1b4 <prvCheckDelayedList>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     402:	06 c0       	rjmp	.+12     	; 0x410 <__LOCK_REGION_LENGTH__+0x10>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
     404:	88 23       	and	r24, r24
     406:	09 f4       	brne	.+2      	; 0x40a <__LOCK_REGION_LENGTH__+0xa>
     408:	4f c0       	rjmp	.+158    	; 0x4a8 <__LOCK_REGION_LENGTH__+0xa8>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
     40a:	81 50       	subi	r24, 0x01	; 1
     40c:	80 93 28 01 	sts	0x0128, r24	; 0x800128 <uxTopCoRoutineReadyPriority>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     410:	80 91 28 01 	lds	r24, 0x0128	; 0x800128 <uxTopCoRoutineReadyPriority>
     414:	28 2f       	mov	r18, r24
     416:	30 e0       	ldi	r19, 0x00	; 0
     418:	f9 01       	movw	r30, r18
     41a:	ee 0f       	add	r30, r30
     41c:	ff 1f       	adc	r31, r31
     41e:	ee 0f       	add	r30, r30
     420:	ff 1f       	adc	r31, r31
     422:	ee 0f       	add	r30, r30
     424:	ff 1f       	adc	r31, r31
     426:	e2 0f       	add	r30, r18
     428:	f3 1f       	adc	r31, r19
     42a:	e6 5b       	subi	r30, 0xB6	; 182
     42c:	fe 4f       	sbci	r31, 0xFE	; 254
     42e:	90 81       	ld	r25, Z
     430:	99 23       	and	r25, r25
     432:	41 f3       	breq	.-48     	; 0x404 <__LOCK_REGION_LENGTH__+0x4>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
     434:	c9 01       	movw	r24, r18
     436:	88 0f       	add	r24, r24
     438:	99 1f       	adc	r25, r25
     43a:	88 0f       	add	r24, r24
     43c:	99 1f       	adc	r25, r25
     43e:	88 0f       	add	r24, r24
     440:	99 1f       	adc	r25, r25
     442:	82 0f       	add	r24, r18
     444:	93 1f       	adc	r25, r19
     446:	df 01       	movw	r26, r30
     448:	01 80       	ldd	r0, Z+1	; 0x01
     44a:	f2 81       	ldd	r31, Z+2	; 0x02
     44c:	e0 2d       	mov	r30, r0
     44e:	02 80       	ldd	r0, Z+2	; 0x02
     450:	f3 81       	ldd	r31, Z+3	; 0x03
     452:	e0 2d       	mov	r30, r0
     454:	12 96       	adiw	r26, 0x02	; 2
     456:	fc 93       	st	X, r31
     458:	ee 93       	st	-X, r30
     45a:	11 97       	sbiw	r26, 0x01	; 1
     45c:	83 5b       	subi	r24, 0xB3	; 179
     45e:	9e 4f       	sbci	r25, 0xFE	; 254
     460:	e8 17       	cp	r30, r24
     462:	f9 07       	cpc	r31, r25
     464:	29 f4       	brne	.+10     	; 0x470 <__LOCK_REGION_LENGTH__+0x70>
     466:	82 81       	ldd	r24, Z+2	; 0x02
     468:	93 81       	ldd	r25, Z+3	; 0x03
     46a:	fd 01       	movw	r30, r26
     46c:	92 83       	std	Z+2, r25	; 0x02
     46e:	81 83       	std	Z+1, r24	; 0x01
     470:	f9 01       	movw	r30, r18
     472:	ee 0f       	add	r30, r30
     474:	ff 1f       	adc	r31, r31
     476:	ee 0f       	add	r30, r30
     478:	ff 1f       	adc	r31, r31
     47a:	ee 0f       	add	r30, r30
     47c:	ff 1f       	adc	r31, r31
     47e:	2e 0f       	add	r18, r30
     480:	3f 1f       	adc	r19, r31
     482:	f9 01       	movw	r30, r18
     484:	e6 5b       	subi	r30, 0xB6	; 182
     486:	fe 4f       	sbci	r31, 0xFE	; 254
     488:	01 80       	ldd	r0, Z+1	; 0x01
     48a:	f2 81       	ldd	r31, Z+2	; 0x02
     48c:	e0 2d       	mov	r30, r0
     48e:	86 81       	ldd	r24, Z+6	; 0x06
     490:	97 81       	ldd	r25, Z+7	; 0x07
     492:	90 93 2a 01 	sts	0x012A, r25	; 0x80012a <pxCurrentCoRoutine+0x1>
     496:	80 93 29 01 	sts	0x0129, r24	; 0x800129 <pxCurrentCoRoutine>

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
     49a:	dc 01       	movw	r26, r24
     49c:	ed 91       	ld	r30, X+
     49e:	fc 91       	ld	r31, X
     4a0:	11 97       	sbiw	r26, 0x01	; 1
     4a2:	57 96       	adiw	r26, 0x17	; 23
     4a4:	6c 91       	ld	r22, X
     4a6:	09 95       	icall
     4a8:	08 95       	ret

000004aa <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

BaseType_t xCoRoutineRemoveFromEventList( const List_t *pxEventList )
{
     4aa:	0f 93       	push	r16
     4ac:	1f 93       	push	r17
     4ae:	cf 93       	push	r28
     4b0:	df 93       	push	r29
BaseType_t xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     4b2:	dc 01       	movw	r26, r24
     4b4:	15 96       	adiw	r26, 0x05	; 5
     4b6:	ed 91       	ld	r30, X+
     4b8:	fc 91       	ld	r31, X
     4ba:	16 97       	sbiw	r26, 0x06	; 6
     4bc:	c6 81       	ldd	r28, Z+6	; 0x06
     4be:	d7 81       	ldd	r29, Z+7	; 0x07
	( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     4c0:	8e 01       	movw	r16, r28
     4c2:	04 5f       	subi	r16, 0xF4	; 244
     4c4:	1f 4f       	sbci	r17, 0xFF	; 255
     4c6:	c8 01       	movw	r24, r16
     4c8:	0e 94 78 04 	call	0x8f0	; 0x8f0 <uxListRemove>
	vListInsertEnd( ( List_t * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
     4cc:	b8 01       	movw	r22, r16
     4ce:	8b e2       	ldi	r24, 0x2B	; 43
     4d0:	91 e0       	ldi	r25, 0x01	; 1
     4d2:	0e 94 26 04 	call	0x84c	; 0x84c <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
     4d6:	9e 89       	ldd	r25, Y+22	; 0x16
     4d8:	e0 91 29 01 	lds	r30, 0x0129	; 0x800129 <pxCurrentCoRoutine>
     4dc:	f0 91 2a 01 	lds	r31, 0x012A	; 0x80012a <pxCurrentCoRoutine+0x1>
     4e0:	86 89       	ldd	r24, Z+22	; 0x16
     4e2:	98 17       	cp	r25, r24
     4e4:	10 f0       	brcs	.+4      	; 0x4ea <xCoRoutineRemoveFromEventList+0x40>
	{
		xReturn = pdTRUE;
     4e6:	81 e0       	ldi	r24, 0x01	; 1
     4e8:	01 c0       	rjmp	.+2      	; 0x4ec <xCoRoutineRemoveFromEventList+0x42>
	}
	else
	{
		xReturn = pdFALSE;
     4ea:	80 e0       	ldi	r24, 0x00	; 0
	}

	return xReturn;
}
     4ec:	df 91       	pop	r29
     4ee:	cf 91       	pop	r28
     4f0:	1f 91       	pop	r17
     4f2:	0f 91       	pop	r16
     4f4:	08 95       	ret

000004f6 <prvTestWaitCondition>:

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
BaseType_t xWaitConditionMet = pdFALSE;

	if( xWaitForAllBits == pdFALSE )
     4f6:	41 11       	cpse	r20, r1
     4f8:	06 c0       	rjmp	.+12     	; 0x506 <prvTestWaitCondition+0x10>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
     4fa:	68 23       	and	r22, r24
     4fc:	79 23       	and	r23, r25
     4fe:	67 2b       	or	r22, r23
     500:	49 f4       	brne	.+18     	; 0x514 <prvTestWaitCondition+0x1e>
}
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
BaseType_t xWaitConditionMet = pdFALSE;
     502:	80 e0       	ldi	r24, 0x00	; 0
     504:	08 95       	ret
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
     506:	86 23       	and	r24, r22
     508:	97 23       	and	r25, r23
     50a:	68 17       	cp	r22, r24
     50c:	79 07       	cpc	r23, r25
     50e:	21 f0       	breq	.+8      	; 0x518 <prvTestWaitCondition+0x22>
}
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
BaseType_t xWaitConditionMet = pdFALSE;
     510:	80 e0       	ldi	r24, 0x00	; 0
     512:	08 95       	ret
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
		{
			xWaitConditionMet = pdTRUE;
     514:	81 e0       	ldi	r24, 0x01	; 1
     516:	08 95       	ret
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
		{
			xWaitConditionMet = pdTRUE;
     518:	81 e0       	ldi	r24, 0x01	; 1
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
}
     51a:	08 95       	ret

0000051c <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	EventGroupHandle_t xEventGroupCreate( void )
	{
     51c:	cf 93       	push	r28
     51e:	df 93       	push	r29
	EventGroup_t *pxEventBits;

		/* Allocate the event group. */
		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) );
     520:	8b e0       	ldi	r24, 0x0B	; 11
     522:	90 e0       	ldi	r25, 0x00	; 0
     524:	0e 94 fc 05 	call	0xbf8	; 0xbf8 <pvPortMalloc>
     528:	ec 01       	movw	r28, r24

		if( pxEventBits != NULL )
     52a:	00 97       	sbiw	r24, 0x00	; 0
     52c:	31 f0       	breq	.+12     	; 0x53a <xEventGroupCreate+0x1e>
		{
			pxEventBits->uxEventBits = 0;
     52e:	fc 01       	movw	r30, r24
     530:	11 92       	st	Z+, r1
     532:	11 92       	st	Z+, r1
     534:	cf 01       	movw	r24, r30
			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
     536:	0e 94 14 04 	call	0x828	; 0x828 <vListInitialise>
		{
			traceEVENT_GROUP_CREATE_FAILED();
		}

		return ( EventGroupHandle_t ) pxEventBits;
	}
     53a:	ce 01       	movw	r24, r28
     53c:	df 91       	pop	r29
     53e:	cf 91       	pop	r28
     540:	08 95       	ret

00000542 <xEventGroupWaitBits>:
	return uxReturn;
}
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
     542:	af 92       	push	r10
     544:	bf 92       	push	r11
     546:	cf 92       	push	r12
     548:	df 92       	push	r13
     54a:	ef 92       	push	r14
     54c:	ff 92       	push	r15
     54e:	0f 93       	push	r16
     550:	1f 93       	push	r17
     552:	cf 93       	push	r28
     554:	df 93       	push	r29
     556:	7c 01       	movw	r14, r24
     558:	5b 01       	movw	r10, r22
     55a:	c4 2e       	mov	r12, r20
     55c:	d2 2e       	mov	r13, r18
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     55e:	0e 94 ae 0c 	call	0x195c	; 0x195c <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
     562:	f7 01       	movw	r30, r14
     564:	c0 81       	ld	r28, Z
     566:	d1 81       	ldd	r29, Z+1	; 0x01

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
     568:	4d 2d       	mov	r20, r13
     56a:	b5 01       	movw	r22, r10
     56c:	ce 01       	movw	r24, r28
     56e:	0e 94 7b 02 	call	0x4f6	; 0x4f6 <prvTestWaitCondition>

		if( xWaitConditionMet != pdFALSE )
     572:	88 23       	and	r24, r24
     574:	69 f0       	breq	.+26     	; 0x590 <xEventGroupWaitBits+0x4e>
			block. */
			uxReturn = uxCurrentEventBits;
			xTicksToWait = ( TickType_t ) 0;

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
     576:	cc 20       	and	r12, r12
     578:	09 f1       	breq	.+66     	; 0x5bc <xEventGroupWaitBits+0x7a>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     57a:	c5 01       	movw	r24, r10
     57c:	80 95       	com	r24
     57e:	90 95       	com	r25
     580:	8c 23       	and	r24, r28
     582:	9d 23       	and	r25, r29
     584:	f7 01       	movw	r30, r14
     586:	91 83       	std	Z+1, r25	; 0x01
     588:	80 83       	st	Z, r24
		if( xWaitConditionMet != pdFALSE )
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
			xTicksToWait = ( TickType_t ) 0;
     58a:	00 e0       	ldi	r16, 0x00	; 0
     58c:	10 e0       	ldi	r17, 0x00	; 0
     58e:	18 c0       	rjmp	.+48     	; 0x5c0 <xEventGroupWaitBits+0x7e>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
     590:	01 15       	cp	r16, r1
     592:	11 05       	cpc	r17, r1
     594:	a9 f0       	breq	.+42     	; 0x5c0 <xEventGroupWaitBits+0x7e>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
     596:	c1 10       	cpse	r12, r1
     598:	03 c0       	rjmp	.+6      	; 0x5a0 <xEventGroupWaitBits+0x5e>
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
EventBits_t uxReturn, uxControlBits = 0;
     59a:	60 e0       	ldi	r22, 0x00	; 0
     59c:	70 e0       	ldi	r23, 0x00	; 0
     59e:	02 c0       	rjmp	.+4      	; 0x5a4 <xEventGroupWaitBits+0x62>
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
     5a0:	60 e0       	ldi	r22, 0x00	; 0
     5a2:	71 e0       	ldi	r23, 0x01	; 1
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
     5a4:	d1 10       	cpse	r13, r1
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
     5a6:	74 60       	ori	r23, 0x04	; 4
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
     5a8:	6a 29       	or	r22, r10
     5aa:	7b 29       	or	r23, r11
     5ac:	a8 01       	movw	r20, r16
     5ae:	c7 01       	movw	r24, r14
     5b0:	02 96       	adiw	r24, 0x02	; 2
     5b2:	0e 94 b7 0e 	call	0x1d6e	; 0x1d6e <vTaskPlaceOnUnorderedEventList>

			/* This is obsolete as it will get set after the task unblocks, but
			some compilers mistakenly generate a warning about the variable
			being returned without being set if it is not done. */
			uxReturn = 0;
     5b6:	c0 e0       	ldi	r28, 0x00	; 0
     5b8:	d0 e0       	ldi	r29, 0x00	; 0
     5ba:	02 c0       	rjmp	.+4      	; 0x5c0 <xEventGroupWaitBits+0x7e>
		if( xWaitConditionMet != pdFALSE )
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
			xTicksToWait = ( TickType_t ) 0;
     5bc:	00 e0       	ldi	r16, 0x00	; 0
     5be:	10 e0       	ldi	r17, 0x00	; 0
			uxReturn = 0;

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     5c0:	0e 94 88 0d 	call	0x1b10	; 0x1b10 <xTaskResumeAll>

	if( xTicksToWait != ( TickType_t ) 0 )
     5c4:	01 2b       	or	r16, r17
     5c6:	19 f1       	breq	.+70     	; 0x60e <xEventGroupWaitBits+0xcc>
	{
		if( xAlreadyYielded == pdFALSE )
     5c8:	81 11       	cpse	r24, r1
     5ca:	02 c0       	rjmp	.+4      	; 0x5d0 <xEventGroupWaitBits+0x8e>
		{
			portYIELD_WITHIN_API();
     5cc:	0e 94 44 05 	call	0xa88	; 0xa88 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     5d0:	0e 94 3a 10 	call	0x2074	; 0x2074 <uxTaskResetEventItemValue>
     5d4:	ec 01       	movw	r28, r24

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     5d6:	91 fd       	sbrc	r25, 1
     5d8:	19 c0       	rjmp	.+50     	; 0x60c <xEventGroupWaitBits+0xca>
		{
			taskENTER_CRITICAL();
     5da:	0f b6       	in	r0, 0x3f	; 63
     5dc:	f8 94       	cli
     5de:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     5e0:	f7 01       	movw	r30, r14
     5e2:	c0 81       	ld	r28, Z
     5e4:	d1 81       	ldd	r29, Z+1	; 0x01

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
     5e6:	4d 2d       	mov	r20, r13
     5e8:	b5 01       	movw	r22, r10
     5ea:	ce 01       	movw	r24, r28
     5ec:	0e 94 7b 02 	call	0x4f6	; 0x4f6 <prvTestWaitCondition>
     5f0:	88 23       	and	r24, r24
     5f2:	51 f0       	breq	.+20     	; 0x608 <xEventGroupWaitBits+0xc6>
				{
					if( xClearOnExit != pdFALSE )
     5f4:	cc 20       	and	r12, r12
     5f6:	41 f0       	breq	.+16     	; 0x608 <xEventGroupWaitBits+0xc6>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     5f8:	b5 01       	movw	r22, r10
     5fa:	60 95       	com	r22
     5fc:	70 95       	com	r23
     5fe:	6c 23       	and	r22, r28
     600:	7d 23       	and	r23, r29
     602:	f7 01       	movw	r30, r14
     604:	71 83       	std	Z+1, r23	; 0x01
     606:	60 83       	st	Z, r22
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
     608:	0f 90       	pop	r0
     60a:	0f be       	out	0x3f, r0	; 63
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     60c:	dd 27       	eor	r29, r29
	}
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
}
     60e:	ce 01       	movw	r24, r28
     610:	df 91       	pop	r29
     612:	cf 91       	pop	r28
     614:	1f 91       	pop	r17
     616:	0f 91       	pop	r16
     618:	ff 90       	pop	r15
     61a:	ef 90       	pop	r14
     61c:	df 90       	pop	r13
     61e:	cf 90       	pop	r12
     620:	bf 90       	pop	r11
     622:	af 90       	pop	r10
     624:	08 95       	ret

00000626 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
     626:	fc 01       	movw	r30, r24
	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
     628:	0f b6       	in	r0, 0x3f	; 63
     62a:	f8 94       	cli
     62c:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
     62e:	80 81       	ld	r24, Z
     630:	91 81       	ldd	r25, Z+1	; 0x01

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     632:	60 95       	com	r22
     634:	70 95       	com	r23
     636:	68 23       	and	r22, r24
     638:	79 23       	and	r23, r25
     63a:	71 83       	std	Z+1, r23	; 0x01
     63c:	60 83       	st	Z, r22
	}
	taskEXIT_CRITICAL();
     63e:	0f 90       	pop	r0
     640:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
     642:	08 95       	ret

00000644 <xEventGroupGetBitsFromISR>:
		uxReturn = pxEventBits->uxEventBits;
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
}
     644:	fc 01       	movw	r30, r24
     646:	80 81       	ld	r24, Z
     648:	91 81       	ldd	r25, Z+1	; 0x01
     64a:	08 95       	ret

0000064c <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
     64c:	cf 92       	push	r12
     64e:	df 92       	push	r13
     650:	ef 92       	push	r14
     652:	ff 92       	push	r15
     654:	0f 93       	push	r16
     656:	1f 93       	push	r17
     658:	cf 93       	push	r28
     65a:	df 93       	push	r29
     65c:	7c 01       	movw	r14, r24
     65e:	8b 01       	movw	r16, r22
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     660:	ec 01       	movw	r28, r24
     662:	25 96       	adiw	r28, 0x05	; 5
	vTaskSuspendAll();
     664:	0e 94 ae 0c 	call	0x195c	; 0x195c <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
     668:	d7 01       	movw	r26, r14
     66a:	17 96       	adiw	r26, 0x07	; 7
     66c:	ed 91       	ld	r30, X+
     66e:	fc 91       	ld	r31, X
     670:	18 97       	sbiw	r26, 0x08	; 8

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
     672:	8d 91       	ld	r24, X+
     674:	9c 91       	ld	r25, X
     676:	11 97       	sbiw	r26, 0x01	; 1
     678:	08 2b       	or	r16, r24
     67a:	19 2b       	or	r17, r25
     67c:	0d 93       	st	X+, r16
     67e:	1c 93       	st	X, r17
EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t *pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
     680:	00 e0       	ldi	r16, 0x00	; 0
     682:	10 e0       	ldi	r17, 0x00	; 0

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     684:	2d c0       	rjmp	.+90     	; 0x6e0 <xEventGroupSetBits+0x94>
		{
			pxNext = listGET_NEXT( pxListItem );
     686:	c2 80       	ldd	r12, Z+2	; 0x02
     688:	d3 80       	ldd	r13, Z+3	; 0x03
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
     68a:	80 81       	ld	r24, Z
     68c:	91 81       	ldd	r25, Z+1	; 0x01
			xMatchFound = pdFALSE;

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
     68e:	9c 01       	movw	r18, r24
     690:	33 27       	eor	r19, r19

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
     692:	92 fd       	sbrc	r25, 2
     694:	09 c0       	rjmp	.+18     	; 0x6a8 <xEventGroupSetBits+0x5c>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
     696:	d7 01       	movw	r26, r14
     698:	4d 91       	ld	r20, X+
     69a:	5c 91       	ld	r21, X
     69c:	42 23       	and	r20, r18
     69e:	53 23       	and	r21, r19
     6a0:	45 2b       	or	r20, r21
     6a2:	61 f4       	brne	.+24     	; 0x6bc <xEventGroupSetBits+0x70>
		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
			xMatchFound = pdFALSE;
     6a4:	40 e0       	ldi	r20, 0x00	; 0
     6a6:	0d c0       	rjmp	.+26     	; 0x6c2 <xEventGroupSetBits+0x76>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
     6a8:	d7 01       	movw	r26, r14
     6aa:	4d 91       	ld	r20, X+
     6ac:	5c 91       	ld	r21, X
     6ae:	42 23       	and	r20, r18
     6b0:	53 23       	and	r21, r19
     6b2:	24 17       	cp	r18, r20
     6b4:	35 07       	cpc	r19, r21
     6b6:	21 f0       	breq	.+8      	; 0x6c0 <xEventGroupSetBits+0x74>
		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
			xMatchFound = pdFALSE;
     6b8:	40 e0       	ldi	r20, 0x00	; 0
     6ba:	03 c0       	rjmp	.+6      	; 0x6c2 <xEventGroupSetBits+0x76>
			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
				{
					xMatchFound = pdTRUE;
     6bc:	41 e0       	ldi	r20, 0x01	; 1
     6be:	01 c0       	rjmp	.+2      	; 0x6c2 <xEventGroupSetBits+0x76>
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
     6c0:	41 e0       	ldi	r20, 0x01	; 1
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
     6c2:	44 23       	and	r20, r20
     6c4:	59 f0       	breq	.+22     	; 0x6dc <xEventGroupSetBits+0x90>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
     6c6:	90 ff       	sbrs	r25, 0
     6c8:	02 c0       	rjmp	.+4      	; 0x6ce <xEventGroupSetBits+0x82>
				{
					uxBitsToClear |= uxBitsWaitedFor;
     6ca:	02 2b       	or	r16, r18
     6cc:	13 2b       	or	r17, r19
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				( void ) xTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
     6ce:	d7 01       	movw	r26, r14
     6d0:	6d 91       	ld	r22, X+
     6d2:	7c 91       	ld	r23, X
     6d4:	72 60       	ori	r23, 0x02	; 2
     6d6:	cf 01       	movw	r24, r30
     6d8:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <xTaskRemoveFromUnorderedEventList>
		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
			xMatchFound = pdFALSE;
     6dc:	ec 2d       	mov	r30, r12
     6de:	fd 2d       	mov	r31, r13

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     6e0:	ec 17       	cp	r30, r28
     6e2:	fd 07       	cpc	r31, r29
     6e4:	81 f6       	brne	.-96     	; 0x686 <xEventGroupSetBits+0x3a>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     6e6:	00 95       	com	r16
     6e8:	10 95       	com	r17
     6ea:	f7 01       	movw	r30, r14
     6ec:	80 81       	ld	r24, Z
     6ee:	91 81       	ldd	r25, Z+1	; 0x01
     6f0:	08 23       	and	r16, r24
     6f2:	19 23       	and	r17, r25
     6f4:	11 83       	std	Z+1, r17	; 0x01
     6f6:	00 83       	st	Z, r16
	}
	( void ) xTaskResumeAll();
     6f8:	0e 94 88 0d 	call	0x1b10	; 0x1b10 <xTaskResumeAll>

	return pxEventBits->uxEventBits;
}
     6fc:	d7 01       	movw	r26, r14
     6fe:	8d 91       	ld	r24, X+
     700:	9c 91       	ld	r25, X
     702:	df 91       	pop	r29
     704:	cf 91       	pop	r28
     706:	1f 91       	pop	r17
     708:	0f 91       	pop	r16
     70a:	ff 90       	pop	r15
     70c:	ef 90       	pop	r14
     70e:	df 90       	pop	r13
     710:	cf 90       	pop	r12
     712:	08 95       	ret

00000714 <xEventGroupSync>:

#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
     714:	af 92       	push	r10
     716:	bf 92       	push	r11
     718:	cf 92       	push	r12
     71a:	df 92       	push	r13
     71c:	ef 92       	push	r14
     71e:	ff 92       	push	r15
     720:	0f 93       	push	r16
     722:	1f 93       	push	r17
     724:	cf 93       	push	r28
     726:	df 93       	push	r29
     728:	8c 01       	movw	r16, r24
     72a:	eb 01       	movw	r28, r22
     72c:	7a 01       	movw	r14, r20
     72e:	69 01       	movw	r12, r18
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     730:	0e 94 ae 0c 	call	0x195c	; 0x195c <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
     734:	f8 01       	movw	r30, r16
     736:	a0 80       	ld	r10, Z
     738:	b1 80       	ldd	r11, Z+1	; 0x01

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
     73a:	be 01       	movw	r22, r28
     73c:	c8 01       	movw	r24, r16
     73e:	0e 94 26 03 	call	0x64c	; 0x64c <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
     742:	ca 29       	or	r28, r10
     744:	db 29       	or	r29, r11
     746:	ce 01       	movw	r24, r28
     748:	8e 21       	and	r24, r14
     74a:	9f 21       	and	r25, r15
     74c:	e8 16       	cp	r14, r24
     74e:	f9 06       	cpc	r15, r25
     750:	69 f4       	brne	.+26     	; 0x76c <xEventGroupSync+0x58>
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     752:	f8 01       	movw	r30, r16
     754:	20 81       	ld	r18, Z
     756:	31 81       	ldd	r19, Z+1	; 0x01
     758:	c7 01       	movw	r24, r14
     75a:	80 95       	com	r24
     75c:	90 95       	com	r25
     75e:	82 23       	and	r24, r18
     760:	93 23       	and	r25, r19
     762:	91 83       	std	Z+1, r25	; 0x01
     764:	80 83       	st	Z, r24

			xTicksToWait = 0;
     766:	c1 2c       	mov	r12, r1
     768:	d1 2c       	mov	r13, r1
     76a:	10 c0       	rjmp	.+32     	; 0x78c <xEventGroupSync+0x78>
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
     76c:	c1 14       	cp	r12, r1
     76e:	d1 04       	cpc	r13, r1
     770:	51 f0       	breq	.+20     	; 0x786 <xEventGroupSync+0x72>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
     772:	a6 01       	movw	r20, r12
     774:	b7 01       	movw	r22, r14
     776:	75 60       	ori	r23, 0x05	; 5
     778:	c8 01       	movw	r24, r16
     77a:	02 96       	adiw	r24, 0x02	; 2
     77c:	0e 94 b7 0e 	call	0x1d6e	; 0x1d6e <vTaskPlaceOnUnorderedEventList>

				/* This assignment is obsolete as uxReturn will get set after
				the task unblocks, but some compilers mistakenly generate a
				warning about uxReturn being returned without being set if the
				assignment is omitted. */
				uxReturn = 0;
     780:	c0 e0       	ldi	r28, 0x00	; 0
     782:	d0 e0       	ldi	r29, 0x00	; 0
     784:	03 c0       	rjmp	.+6      	; 0x78c <xEventGroupSync+0x78>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     786:	f8 01       	movw	r30, r16
     788:	c0 81       	ld	r28, Z
     78a:	d1 81       	ldd	r29, Z+1	; 0x01
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     78c:	0e 94 88 0d 	call	0x1b10	; 0x1b10 <xTaskResumeAll>

	if( xTicksToWait != ( TickType_t ) 0 )
     790:	cd 28       	or	r12, r13
     792:	f9 f0       	breq	.+62     	; 0x7d2 <xEventGroupSync+0xbe>
	{
		if( xAlreadyYielded == pdFALSE )
     794:	81 11       	cpse	r24, r1
     796:	02 c0       	rjmp	.+4      	; 0x79c <xEventGroupSync+0x88>
		{
			portYIELD_WITHIN_API();
     798:	0e 94 44 05 	call	0xa88	; 0xa88 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     79c:	0e 94 3a 10 	call	0x2074	; 0x2074 <uxTaskResetEventItemValue>

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     7a0:	91 fd       	sbrc	r25, 1
     7a2:	15 c0       	rjmp	.+42     	; 0x7ce <xEventGroupSync+0xba>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
     7a4:	0f b6       	in	r0, 0x3f	; 63
     7a6:	f8 94       	cli
     7a8:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
     7aa:	f8 01       	movw	r30, r16
     7ac:	80 81       	ld	r24, Z
     7ae:	91 81       	ldd	r25, Z+1	; 0x01

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
     7b0:	97 01       	movw	r18, r14
     7b2:	28 23       	and	r18, r24
     7b4:	39 23       	and	r19, r25
     7b6:	e2 16       	cp	r14, r18
     7b8:	f3 06       	cpc	r15, r19
     7ba:	39 f4       	brne	.+14     	; 0x7ca <xEventGroupSync+0xb6>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     7bc:	a7 01       	movw	r20, r14
     7be:	40 95       	com	r20
     7c0:	50 95       	com	r21
     7c2:	48 23       	and	r20, r24
     7c4:	59 23       	and	r21, r25
     7c6:	51 83       	std	Z+1, r21	; 0x01
     7c8:	40 83       	st	Z, r20
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
     7ca:	0f 90       	pop	r0
     7cc:	0f be       	out	0x3f, r0	; 63
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     7ce:	ec 01       	movw	r28, r24
     7d0:	dd 27       	eor	r29, r29
	}

	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
}
     7d2:	ce 01       	movw	r24, r28
     7d4:	df 91       	pop	r29
     7d6:	cf 91       	pop	r28
     7d8:	1f 91       	pop	r17
     7da:	0f 91       	pop	r16
     7dc:	ff 90       	pop	r15
     7de:	ef 90       	pop	r14
     7e0:	df 90       	pop	r13
     7e2:	cf 90       	pop	r12
     7e4:	bf 90       	pop	r11
     7e6:	af 90       	pop	r10
     7e8:	08 95       	ret

000007ea <vEventGroupDelete>:
	return pxEventBits->uxEventBits;
}
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
     7ea:	cf 93       	push	r28
     7ec:	df 93       	push	r29
     7ee:	ec 01       	movw	r28, r24
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );

	vTaskSuspendAll();
     7f0:	0e 94 ae 0c 	call	0x195c	; 0x195c <vTaskSuspendAll>
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
     7f4:	06 c0       	rjmp	.+12     	; 0x802 <vEventGroupDelete+0x18>
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and	cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			( void ) xTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
     7f6:	60 e0       	ldi	r22, 0x00	; 0
     7f8:	72 e0       	ldi	r23, 0x02	; 2
     7fa:	8f 81       	ldd	r24, Y+7	; 0x07
     7fc:	98 85       	ldd	r25, Y+8	; 0x08
     7fe:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <xTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
     802:	8a 81       	ldd	r24, Y+2	; 0x02
     804:	81 11       	cpse	r24, r1
     806:	f7 cf       	rjmp	.-18     	; 0x7f6 <vEventGroupDelete+0xc>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
		{
			/* The event group can only have been allocated dynamically - free
			it again. */
			vPortFree( pxEventBits );
     808:	ce 01       	movw	r24, r28
     80a:	0e 94 31 06 	call	0xc62	; 0xc62 <vPortFree>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
     80e:	0e 94 88 0d 	call	0x1b10	; 0x1b10 <xTaskResumeAll>
}
     812:	df 91       	pop	r29
     814:	cf 91       	pop	r28
     816:	08 95       	ret

00000818 <vEventGroupSetBitsCallback>:

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet );
     818:	ba 01       	movw	r22, r20
     81a:	0e 94 26 03 	call	0x64c	; 0x64c <xEventGroupSetBits>
     81e:	08 95       	ret

00000820 <vEventGroupClearBitsCallback>:

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear );
     820:	ba 01       	movw	r22, r20
     822:	0e 94 13 03 	call	0x626	; 0x626 <xEventGroupClearBits>
     826:	08 95       	ret

00000828 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     828:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     82a:	03 96       	adiw	r24, 0x03	; 3
     82c:	92 83       	std	Z+2, r25	; 0x02
     82e:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     830:	2f ef       	ldi	r18, 0xFF	; 255
     832:	3f ef       	ldi	r19, 0xFF	; 255
     834:	34 83       	std	Z+4, r19	; 0x04
     836:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     838:	96 83       	std	Z+6, r25	; 0x06
     83a:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     83c:	90 87       	std	Z+8, r25	; 0x08
     83e:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     840:	10 82       	st	Z, r1
     842:	08 95       	ret

00000844 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     844:	fc 01       	movw	r30, r24
     846:	11 86       	std	Z+9, r1	; 0x09
     848:	10 86       	std	Z+8, r1	; 0x08
     84a:	08 95       	ret

0000084c <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     84c:	cf 93       	push	r28
     84e:	df 93       	push	r29
     850:	9c 01       	movw	r18, r24
     852:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     854:	dc 01       	movw	r26, r24
     856:	11 96       	adiw	r26, 0x01	; 1
     858:	cd 91       	ld	r28, X+
     85a:	dc 91       	ld	r29, X
     85c:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     85e:	d3 83       	std	Z+3, r29	; 0x03
     860:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     862:	8c 81       	ldd	r24, Y+4	; 0x04
     864:	9d 81       	ldd	r25, Y+5	; 0x05
     866:	95 83       	std	Z+5, r25	; 0x05
     868:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     86a:	8c 81       	ldd	r24, Y+4	; 0x04
     86c:	9d 81       	ldd	r25, Y+5	; 0x05
     86e:	dc 01       	movw	r26, r24
     870:	13 96       	adiw	r26, 0x03	; 3
     872:	7c 93       	st	X, r23
     874:	6e 93       	st	-X, r22
     876:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     878:	7d 83       	std	Y+5, r23	; 0x05
     87a:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     87c:	31 87       	std	Z+9, r19	; 0x09
     87e:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     880:	f9 01       	movw	r30, r18
     882:	80 81       	ld	r24, Z
     884:	8f 5f       	subi	r24, 0xFF	; 255
     886:	80 83       	st	Z, r24
}
     888:	df 91       	pop	r29
     88a:	cf 91       	pop	r28
     88c:	08 95       	ret

0000088e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     88e:	cf 93       	push	r28
     890:	df 93       	push	r29
     892:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     894:	48 81       	ld	r20, Y
     896:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     898:	4f 3f       	cpi	r20, 0xFF	; 255
     89a:	2f ef       	ldi	r18, 0xFF	; 255
     89c:	52 07       	cpc	r21, r18
     89e:	21 f4       	brne	.+8      	; 0x8a8 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     8a0:	fc 01       	movw	r30, r24
     8a2:	a7 81       	ldd	r26, Z+7	; 0x07
     8a4:	b0 85       	ldd	r27, Z+8	; 0x08
     8a6:	0d c0       	rjmp	.+26     	; 0x8c2 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     8a8:	dc 01       	movw	r26, r24
     8aa:	13 96       	adiw	r26, 0x03	; 3
     8ac:	01 c0       	rjmp	.+2      	; 0x8b0 <vListInsert+0x22>
     8ae:	df 01       	movw	r26, r30
     8b0:	12 96       	adiw	r26, 0x02	; 2
     8b2:	ed 91       	ld	r30, X+
     8b4:	fc 91       	ld	r31, X
     8b6:	13 97       	sbiw	r26, 0x03	; 3
     8b8:	20 81       	ld	r18, Z
     8ba:	31 81       	ldd	r19, Z+1	; 0x01
     8bc:	42 17       	cp	r20, r18
     8be:	53 07       	cpc	r21, r19
     8c0:	b0 f7       	brcc	.-20     	; 0x8ae <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     8c2:	12 96       	adiw	r26, 0x02	; 2
     8c4:	ed 91       	ld	r30, X+
     8c6:	fc 91       	ld	r31, X
     8c8:	13 97       	sbiw	r26, 0x03	; 3
     8ca:	fb 83       	std	Y+3, r31	; 0x03
     8cc:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     8ce:	d5 83       	std	Z+5, r29	; 0x05
     8d0:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     8d2:	bd 83       	std	Y+5, r27	; 0x05
     8d4:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     8d6:	13 96       	adiw	r26, 0x03	; 3
     8d8:	dc 93       	st	X, r29
     8da:	ce 93       	st	-X, r28
     8dc:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     8de:	99 87       	std	Y+9, r25	; 0x09
     8e0:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     8e2:	fc 01       	movw	r30, r24
     8e4:	20 81       	ld	r18, Z
     8e6:	2f 5f       	subi	r18, 0xFF	; 255
     8e8:	20 83       	st	Z, r18
}
     8ea:	df 91       	pop	r29
     8ec:	cf 91       	pop	r28
     8ee:	08 95       	ret

000008f0 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     8f0:	cf 93       	push	r28
     8f2:	df 93       	push	r29
     8f4:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     8f6:	a0 85       	ldd	r26, Z+8	; 0x08
     8f8:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     8fa:	c2 81       	ldd	r28, Z+2	; 0x02
     8fc:	d3 81       	ldd	r29, Z+3	; 0x03
     8fe:	84 81       	ldd	r24, Z+4	; 0x04
     900:	95 81       	ldd	r25, Z+5	; 0x05
     902:	9d 83       	std	Y+5, r25	; 0x05
     904:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     906:	c4 81       	ldd	r28, Z+4	; 0x04
     908:	d5 81       	ldd	r29, Z+5	; 0x05
     90a:	82 81       	ldd	r24, Z+2	; 0x02
     90c:	93 81       	ldd	r25, Z+3	; 0x03
     90e:	9b 83       	std	Y+3, r25	; 0x03
     910:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     912:	11 96       	adiw	r26, 0x01	; 1
     914:	8d 91       	ld	r24, X+
     916:	9c 91       	ld	r25, X
     918:	12 97       	sbiw	r26, 0x02	; 2
     91a:	e8 17       	cp	r30, r24
     91c:	f9 07       	cpc	r31, r25
     91e:	31 f4       	brne	.+12     	; 0x92c <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     920:	84 81       	ldd	r24, Z+4	; 0x04
     922:	95 81       	ldd	r25, Z+5	; 0x05
     924:	12 96       	adiw	r26, 0x02	; 2
     926:	9c 93       	st	X, r25
     928:	8e 93       	st	-X, r24
     92a:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     92c:	11 86       	std	Z+9, r1	; 0x09
     92e:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     930:	8c 91       	ld	r24, X
     932:	81 50       	subi	r24, 0x01	; 1
     934:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     936:	df 91       	pop	r29
     938:	cf 91       	pop	r28
     93a:	08 95       	ret

0000093c <prvSetupTimerInterrupt>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	OCR1AH = ucHighByte;
     93c:	86 e0       	ldi	r24, 0x06	; 6
     93e:	8b bd       	out	0x2b, r24	; 43
	OCR1AL = ucLowByte;
     940:	8f eb       	ldi	r24, 0xBF	; 191
     942:	8a bd       	out	0x2a, r24	; 42

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
     944:	8b e0       	ldi	r24, 0x0B	; 11
     946:	8e bd       	out	0x2e, r24	; 46

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
     948:	87 b7       	in	r24, 0x37	; 55
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     94a:	80 61       	ori	r24, 0x10	; 16
	TIMSK = ucLowByte;
     94c:	87 bf       	out	0x37, r24	; 55
     94e:	08 95       	ret

00000950 <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     950:	31 e1       	ldi	r19, 0x11	; 17
     952:	fc 01       	movw	r30, r24
     954:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
     956:	31 97       	sbiw	r30, 0x01	; 1
     958:	22 e2       	ldi	r18, 0x22	; 34
     95a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
     95c:	31 97       	sbiw	r30, 0x01	; 1
     95e:	a3 e3       	ldi	r26, 0x33	; 51
     960:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     962:	31 97       	sbiw	r30, 0x01	; 1
     964:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     966:	31 97       	sbiw	r30, 0x01	; 1
     968:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
     96a:	31 97       	sbiw	r30, 0x01	; 1
     96c:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     96e:	31 97       	sbiw	r30, 0x01	; 1
     970:	60 e8       	ldi	r22, 0x80	; 128
     972:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
     974:	31 97       	sbiw	r30, 0x01	; 1
     976:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
     978:	31 97       	sbiw	r30, 0x01	; 1
     97a:	62 e0       	ldi	r22, 0x02	; 2
     97c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
     97e:	31 97       	sbiw	r30, 0x01	; 1
     980:	63 e0       	ldi	r22, 0x03	; 3
     982:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
     984:	31 97       	sbiw	r30, 0x01	; 1
     986:	64 e0       	ldi	r22, 0x04	; 4
     988:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
     98a:	31 97       	sbiw	r30, 0x01	; 1
     98c:	65 e0       	ldi	r22, 0x05	; 5
     98e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
     990:	31 97       	sbiw	r30, 0x01	; 1
     992:	66 e0       	ldi	r22, 0x06	; 6
     994:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
     996:	31 97       	sbiw	r30, 0x01	; 1
     998:	67 e0       	ldi	r22, 0x07	; 7
     99a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
     99c:	31 97       	sbiw	r30, 0x01	; 1
     99e:	68 e0       	ldi	r22, 0x08	; 8
     9a0:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
     9a2:	31 97       	sbiw	r30, 0x01	; 1
     9a4:	69 e0       	ldi	r22, 0x09	; 9
     9a6:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
     9a8:	31 97       	sbiw	r30, 0x01	; 1
     9aa:	60 e1       	ldi	r22, 0x10	; 16
     9ac:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
     9ae:	31 97       	sbiw	r30, 0x01	; 1
     9b0:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
     9b2:	31 97       	sbiw	r30, 0x01	; 1
     9b4:	32 e1       	ldi	r19, 0x12	; 18
     9b6:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
     9b8:	31 97       	sbiw	r30, 0x01	; 1
     9ba:	33 e1       	ldi	r19, 0x13	; 19
     9bc:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
     9be:	31 97       	sbiw	r30, 0x01	; 1
     9c0:	34 e1       	ldi	r19, 0x14	; 20
     9c2:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
     9c4:	31 97       	sbiw	r30, 0x01	; 1
     9c6:	35 e1       	ldi	r19, 0x15	; 21
     9c8:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
     9ca:	31 97       	sbiw	r30, 0x01	; 1
     9cc:	36 e1       	ldi	r19, 0x16	; 22
     9ce:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
     9d0:	31 97       	sbiw	r30, 0x01	; 1
     9d2:	37 e1       	ldi	r19, 0x17	; 23
     9d4:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
     9d6:	31 97       	sbiw	r30, 0x01	; 1
     9d8:	38 e1       	ldi	r19, 0x18	; 24
     9da:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
     9dc:	31 97       	sbiw	r30, 0x01	; 1
     9de:	39 e1       	ldi	r19, 0x19	; 25
     9e0:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
     9e2:	31 97       	sbiw	r30, 0x01	; 1
     9e4:	30 e2       	ldi	r19, 0x20	; 32
     9e6:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
     9e8:	31 97       	sbiw	r30, 0x01	; 1
     9ea:	31 e2       	ldi	r19, 0x21	; 33
     9ec:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
     9ee:	31 97       	sbiw	r30, 0x01	; 1
     9f0:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
     9f2:	31 97       	sbiw	r30, 0x01	; 1
     9f4:	23 e2       	ldi	r18, 0x23	; 35
     9f6:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     9f8:	31 97       	sbiw	r30, 0x01	; 1
     9fa:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     9fc:	31 97       	sbiw	r30, 0x01	; 1
     9fe:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
     a00:	31 97       	sbiw	r30, 0x01	; 1
     a02:	26 e2       	ldi	r18, 0x26	; 38
     a04:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
     a06:	31 97       	sbiw	r30, 0x01	; 1
     a08:	27 e2       	ldi	r18, 0x27	; 39
     a0a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
     a0c:	31 97       	sbiw	r30, 0x01	; 1
     a0e:	28 e2       	ldi	r18, 0x28	; 40
     a10:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
     a12:	31 97       	sbiw	r30, 0x01	; 1
     a14:	29 e2       	ldi	r18, 0x29	; 41
     a16:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
     a18:	31 97       	sbiw	r30, 0x01	; 1
     a1a:	20 e3       	ldi	r18, 0x30	; 48
     a1c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
     a1e:	31 97       	sbiw	r30, 0x01	; 1
     a20:	21 e3       	ldi	r18, 0x31	; 49
     a22:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
     a24:	86 97       	sbiw	r24, 0x26	; 38
     a26:	08 95       	ret

00000a28 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
     a28:	0e 94 9e 04 	call	0x93c	; 0x93c <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     a2c:	a0 91 b1 0d 	lds	r26, 0x0DB1	; 0x800db1 <pxCurrentTCB>
     a30:	b0 91 b2 0d 	lds	r27, 0x0DB2	; 0x800db2 <pxCurrentTCB+0x1>
     a34:	cd 91       	ld	r28, X+
     a36:	cd bf       	out	0x3d, r28	; 61
     a38:	dd 91       	ld	r29, X+
     a3a:	de bf       	out	0x3e, r29	; 62
     a3c:	ff 91       	pop	r31
     a3e:	ef 91       	pop	r30
     a40:	df 91       	pop	r29
     a42:	cf 91       	pop	r28
     a44:	bf 91       	pop	r27
     a46:	af 91       	pop	r26
     a48:	9f 91       	pop	r25
     a4a:	8f 91       	pop	r24
     a4c:	7f 91       	pop	r23
     a4e:	6f 91       	pop	r22
     a50:	5f 91       	pop	r21
     a52:	4f 91       	pop	r20
     a54:	3f 91       	pop	r19
     a56:	2f 91       	pop	r18
     a58:	1f 91       	pop	r17
     a5a:	0f 91       	pop	r16
     a5c:	ff 90       	pop	r15
     a5e:	ef 90       	pop	r14
     a60:	df 90       	pop	r13
     a62:	cf 90       	pop	r12
     a64:	bf 90       	pop	r11
     a66:	af 90       	pop	r10
     a68:	9f 90       	pop	r9
     a6a:	8f 90       	pop	r8
     a6c:	7f 90       	pop	r7
     a6e:	6f 90       	pop	r6
     a70:	5f 90       	pop	r5
     a72:	4f 90       	pop	r4
     a74:	3f 90       	pop	r3
     a76:	2f 90       	pop	r2
     a78:	1f 90       	pop	r1
     a7a:	0f 90       	pop	r0
     a7c:	0f be       	out	0x3f, r0	; 63
     a7e:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     a80:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
     a82:	81 e0       	ldi	r24, 0x01	; 1
     a84:	08 95       	ret

00000a86 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     a86:	08 95       	ret

00000a88 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     a88:	0f 92       	push	r0
     a8a:	0f b6       	in	r0, 0x3f	; 63
     a8c:	f8 94       	cli
     a8e:	0f 92       	push	r0
     a90:	1f 92       	push	r1
     a92:	11 24       	eor	r1, r1
     a94:	2f 92       	push	r2
     a96:	3f 92       	push	r3
     a98:	4f 92       	push	r4
     a9a:	5f 92       	push	r5
     a9c:	6f 92       	push	r6
     a9e:	7f 92       	push	r7
     aa0:	8f 92       	push	r8
     aa2:	9f 92       	push	r9
     aa4:	af 92       	push	r10
     aa6:	bf 92       	push	r11
     aa8:	cf 92       	push	r12
     aaa:	df 92       	push	r13
     aac:	ef 92       	push	r14
     aae:	ff 92       	push	r15
     ab0:	0f 93       	push	r16
     ab2:	1f 93       	push	r17
     ab4:	2f 93       	push	r18
     ab6:	3f 93       	push	r19
     ab8:	4f 93       	push	r20
     aba:	5f 93       	push	r21
     abc:	6f 93       	push	r22
     abe:	7f 93       	push	r23
     ac0:	8f 93       	push	r24
     ac2:	9f 93       	push	r25
     ac4:	af 93       	push	r26
     ac6:	bf 93       	push	r27
     ac8:	cf 93       	push	r28
     aca:	df 93       	push	r29
     acc:	ef 93       	push	r30
     ace:	ff 93       	push	r31
     ad0:	a0 91 b1 0d 	lds	r26, 0x0DB1	; 0x800db1 <pxCurrentTCB>
     ad4:	b0 91 b2 0d 	lds	r27, 0x0DB2	; 0x800db2 <pxCurrentTCB+0x1>
     ad8:	0d b6       	in	r0, 0x3d	; 61
     ada:	0d 92       	st	X+, r0
     adc:	0e b6       	in	r0, 0x3e	; 62
     ade:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     ae0:	0e 94 51 0e 	call	0x1ca2	; 0x1ca2 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     ae4:	a0 91 b1 0d 	lds	r26, 0x0DB1	; 0x800db1 <pxCurrentTCB>
     ae8:	b0 91 b2 0d 	lds	r27, 0x0DB2	; 0x800db2 <pxCurrentTCB+0x1>
     aec:	cd 91       	ld	r28, X+
     aee:	cd bf       	out	0x3d, r28	; 61
     af0:	dd 91       	ld	r29, X+
     af2:	de bf       	out	0x3e, r29	; 62
     af4:	ff 91       	pop	r31
     af6:	ef 91       	pop	r30
     af8:	df 91       	pop	r29
     afa:	cf 91       	pop	r28
     afc:	bf 91       	pop	r27
     afe:	af 91       	pop	r26
     b00:	9f 91       	pop	r25
     b02:	8f 91       	pop	r24
     b04:	7f 91       	pop	r23
     b06:	6f 91       	pop	r22
     b08:	5f 91       	pop	r21
     b0a:	4f 91       	pop	r20
     b0c:	3f 91       	pop	r19
     b0e:	2f 91       	pop	r18
     b10:	1f 91       	pop	r17
     b12:	0f 91       	pop	r16
     b14:	ff 90       	pop	r15
     b16:	ef 90       	pop	r14
     b18:	df 90       	pop	r13
     b1a:	cf 90       	pop	r12
     b1c:	bf 90       	pop	r11
     b1e:	af 90       	pop	r10
     b20:	9f 90       	pop	r9
     b22:	8f 90       	pop	r8
     b24:	7f 90       	pop	r7
     b26:	6f 90       	pop	r6
     b28:	5f 90       	pop	r5
     b2a:	4f 90       	pop	r4
     b2c:	3f 90       	pop	r3
     b2e:	2f 90       	pop	r2
     b30:	1f 90       	pop	r1
     b32:	0f 90       	pop	r0
     b34:	0f be       	out	0x3f, r0	; 63
     b36:	0f 90       	pop	r0

	asm volatile ( "ret" );
     b38:	08 95       	ret

00000b3a <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     b3a:	0f 92       	push	r0
     b3c:	0f b6       	in	r0, 0x3f	; 63
     b3e:	f8 94       	cli
     b40:	0f 92       	push	r0
     b42:	1f 92       	push	r1
     b44:	11 24       	eor	r1, r1
     b46:	2f 92       	push	r2
     b48:	3f 92       	push	r3
     b4a:	4f 92       	push	r4
     b4c:	5f 92       	push	r5
     b4e:	6f 92       	push	r6
     b50:	7f 92       	push	r7
     b52:	8f 92       	push	r8
     b54:	9f 92       	push	r9
     b56:	af 92       	push	r10
     b58:	bf 92       	push	r11
     b5a:	cf 92       	push	r12
     b5c:	df 92       	push	r13
     b5e:	ef 92       	push	r14
     b60:	ff 92       	push	r15
     b62:	0f 93       	push	r16
     b64:	1f 93       	push	r17
     b66:	2f 93       	push	r18
     b68:	3f 93       	push	r19
     b6a:	4f 93       	push	r20
     b6c:	5f 93       	push	r21
     b6e:	6f 93       	push	r22
     b70:	7f 93       	push	r23
     b72:	8f 93       	push	r24
     b74:	9f 93       	push	r25
     b76:	af 93       	push	r26
     b78:	bf 93       	push	r27
     b7a:	cf 93       	push	r28
     b7c:	df 93       	push	r29
     b7e:	ef 93       	push	r30
     b80:	ff 93       	push	r31
     b82:	a0 91 b1 0d 	lds	r26, 0x0DB1	; 0x800db1 <pxCurrentTCB>
     b86:	b0 91 b2 0d 	lds	r27, 0x0DB2	; 0x800db2 <pxCurrentTCB+0x1>
     b8a:	0d b6       	in	r0, 0x3d	; 61
     b8c:	0d 92       	st	X+, r0
     b8e:	0e b6       	in	r0, 0x3e	; 62
     b90:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     b92:	0e 94 ce 0c 	call	0x199c	; 0x199c <xTaskIncrementTick>
     b96:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     b98:	0e 94 51 0e 	call	0x1ca2	; 0x1ca2 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     b9c:	a0 91 b1 0d 	lds	r26, 0x0DB1	; 0x800db1 <pxCurrentTCB>
     ba0:	b0 91 b2 0d 	lds	r27, 0x0DB2	; 0x800db2 <pxCurrentTCB+0x1>
     ba4:	cd 91       	ld	r28, X+
     ba6:	cd bf       	out	0x3d, r28	; 61
     ba8:	dd 91       	ld	r29, X+
     baa:	de bf       	out	0x3e, r29	; 62
     bac:	ff 91       	pop	r31
     bae:	ef 91       	pop	r30
     bb0:	df 91       	pop	r29
     bb2:	cf 91       	pop	r28
     bb4:	bf 91       	pop	r27
     bb6:	af 91       	pop	r26
     bb8:	9f 91       	pop	r25
     bba:	8f 91       	pop	r24
     bbc:	7f 91       	pop	r23
     bbe:	6f 91       	pop	r22
     bc0:	5f 91       	pop	r21
     bc2:	4f 91       	pop	r20
     bc4:	3f 91       	pop	r19
     bc6:	2f 91       	pop	r18
     bc8:	1f 91       	pop	r17
     bca:	0f 91       	pop	r16
     bcc:	ff 90       	pop	r15
     bce:	ef 90       	pop	r14
     bd0:	df 90       	pop	r13
     bd2:	cf 90       	pop	r12
     bd4:	bf 90       	pop	r11
     bd6:	af 90       	pop	r10
     bd8:	9f 90       	pop	r9
     bda:	8f 90       	pop	r8
     bdc:	7f 90       	pop	r7
     bde:	6f 90       	pop	r6
     be0:	5f 90       	pop	r5
     be2:	4f 90       	pop	r4
     be4:	3f 90       	pop	r3
     be6:	2f 90       	pop	r2
     be8:	1f 90       	pop	r1
     bea:	0f 90       	pop	r0
     bec:	0f be       	out	0x3f, r0	; 63
     bee:	0f 90       	pop	r0

	asm volatile ( "ret" );
     bf0:	08 95       	ret

00000bf2 <__vector_12>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     bf2:	0e 94 9d 05 	call	0xb3a	; 0xb3a <vPortYieldFromTick>
		asm volatile ( "reti" );
     bf6:	18 95       	reti

00000bf8 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     bf8:	cf 93       	push	r28
     bfa:	df 93       	push	r29
     bfc:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
     bfe:	0e 94 ae 0c 	call	0x195c	; 0x195c <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     c02:	80 91 5c 01 	lds	r24, 0x015C	; 0x80015c <pucAlignedHeap.2069>
     c06:	90 91 5d 01 	lds	r25, 0x015D	; 0x80015d <pucAlignedHeap.2069+0x1>
     c0a:	89 2b       	or	r24, r25
     c0c:	31 f4       	brne	.+12     	; 0xc1a <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     c0e:	81 e6       	ldi	r24, 0x61	; 97
     c10:	91 e0       	ldi	r25, 0x01	; 1
     c12:	90 93 5d 01 	sts	0x015D, r25	; 0x80015d <pucAlignedHeap.2069+0x1>
     c16:	80 93 5c 01 	sts	0x015C, r24	; 0x80015c <pucAlignedHeap.2069>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     c1a:	20 91 5e 01 	lds	r18, 0x015E	; 0x80015e <xNextFreeByte>
     c1e:	30 91 5f 01 	lds	r19, 0x015F	; 0x80015f <xNextFreeByte+0x1>
     c22:	c9 01       	movw	r24, r18
     c24:	8c 0f       	add	r24, r28
     c26:	9d 1f       	adc	r25, r29
     c28:	8f 3f       	cpi	r24, 0xFF	; 255
     c2a:	4b e0       	ldi	r20, 0x0B	; 11
     c2c:	94 07       	cpc	r25, r20
     c2e:	70 f4       	brcc	.+28     	; 0xc4c <pvPortMalloc+0x54>
     c30:	28 17       	cp	r18, r24
     c32:	39 07       	cpc	r19, r25
     c34:	70 f4       	brcc	.+28     	; 0xc52 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     c36:	c0 91 5c 01 	lds	r28, 0x015C	; 0x80015c <pucAlignedHeap.2069>
     c3a:	d0 91 5d 01 	lds	r29, 0x015D	; 0x80015d <pucAlignedHeap.2069+0x1>
     c3e:	c2 0f       	add	r28, r18
     c40:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
     c42:	90 93 5f 01 	sts	0x015F, r25	; 0x80015f <xNextFreeByte+0x1>
     c46:	80 93 5e 01 	sts	0x015E, r24	; 0x80015e <xNextFreeByte>
     c4a:	05 c0       	rjmp	.+10     	; 0xc56 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     c4c:	c0 e0       	ldi	r28, 0x00	; 0
     c4e:	d0 e0       	ldi	r29, 0x00	; 0
     c50:	02 c0       	rjmp	.+4      	; 0xc56 <pvPortMalloc+0x5e>
     c52:	c0 e0       	ldi	r28, 0x00	; 0
     c54:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     c56:	0e 94 88 0d 	call	0x1b10	; 0x1b10 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     c5a:	ce 01       	movw	r24, r28
     c5c:	df 91       	pop	r29
     c5e:	cf 91       	pop	r28
     c60:	08 95       	ret

00000c62 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     c62:	08 95       	ret

00000c64 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
     c64:	10 92 5f 01 	sts	0x015F, r1	; 0x80015f <xNextFreeByte+0x1>
     c68:	10 92 5e 01 	sts	0x015E, r1	; 0x80015e <xNextFreeByte>
     c6c:	08 95       	ret

00000c6e <xPortGetFreeHeapSize>:
}
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
     c6e:	20 91 5e 01 	lds	r18, 0x015E	; 0x80015e <xNextFreeByte>
     c72:	30 91 5f 01 	lds	r19, 0x015F	; 0x80015f <xNextFreeByte+0x1>
}
     c76:	8f ef       	ldi	r24, 0xFF	; 255
     c78:	9b e0       	ldi	r25, 0x0B	; 11
     c7a:	82 1b       	sub	r24, r18
     c7c:	93 0b       	sbc	r25, r19
     c7e:	08 95       	ret

00000c80 <prvIsQueueEmpty>:

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
     c80:	0f b6       	in	r0, 0x3f	; 63
     c82:	f8 94       	cli
     c84:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
     c86:	fc 01       	movw	r30, r24
     c88:	82 8d       	ldd	r24, Z+26	; 0x1a
     c8a:	81 11       	cpse	r24, r1
     c8c:	02 c0       	rjmp	.+4      	; 0xc92 <prvIsQueueEmpty+0x12>
		{
			xReturn = pdTRUE;
     c8e:	81 e0       	ldi	r24, 0x01	; 1
     c90:	01 c0       	rjmp	.+2      	; 0xc94 <prvIsQueueEmpty+0x14>
		}
		else
		{
			xReturn = pdFALSE;
     c92:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	taskEXIT_CRITICAL();
     c94:	0f 90       	pop	r0
     c96:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
     c98:	08 95       	ret

00000c9a <prvIsQueueFull>:

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
     c9a:	0f b6       	in	r0, 0x3f	; 63
     c9c:	f8 94       	cli
     c9e:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
     ca0:	fc 01       	movw	r30, r24
     ca2:	22 8d       	ldd	r18, Z+26	; 0x1a
     ca4:	83 8d       	ldd	r24, Z+27	; 0x1b
     ca6:	28 13       	cpse	r18, r24
     ca8:	02 c0       	rjmp	.+4      	; 0xcae <prvIsQueueFull+0x14>
		{
			xReturn = pdTRUE;
     caa:	81 e0       	ldi	r24, 0x01	; 1
     cac:	01 c0       	rjmp	.+2      	; 0xcb0 <prvIsQueueFull+0x16>
		}
		else
		{
			xReturn = pdFALSE;
     cae:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	taskEXIT_CRITICAL();
     cb0:	0f 90       	pop	r0
     cb2:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
     cb4:	08 95       	ret

00000cb6 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
     cb6:	0f 93       	push	r16
     cb8:	1f 93       	push	r17
     cba:	cf 93       	push	r28
     cbc:	df 93       	push	r29
     cbe:	ec 01       	movw	r28, r24
     cc0:	04 2f       	mov	r16, r20
BaseType_t xReturn = pdFALSE;
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
     cc2:	1a 8d       	ldd	r17, Y+26	; 0x1a

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
     cc4:	4c 8d       	ldd	r20, Y+28	; 0x1c
     cc6:	41 11       	cpse	r20, r1
     cc8:	0c c0       	rjmp	.+24     	; 0xce2 <prvCopyDataToQueue+0x2c>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     cca:	88 81       	ld	r24, Y
     ccc:	99 81       	ldd	r25, Y+1	; 0x01
     cce:	89 2b       	or	r24, r25
     cd0:	09 f0       	breq	.+2      	; 0xcd4 <prvCopyDataToQueue+0x1e>
     cd2:	42 c0       	rjmp	.+132    	; 0xd58 <prvCopyDataToQueue+0xa2>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
     cd4:	8a 81       	ldd	r24, Y+2	; 0x02
     cd6:	9b 81       	ldd	r25, Y+3	; 0x03
     cd8:	0e 94 fa 0f 	call	0x1ff4	; 0x1ff4 <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
     cdc:	1b 82       	std	Y+3, r1	; 0x03
     cde:	1a 82       	std	Y+2, r1	; 0x02
     ce0:	42 c0       	rjmp	.+132    	; 0xd66 <prvCopyDataToQueue+0xb0>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
     ce2:	01 11       	cpse	r16, r1
     ce4:	17 c0       	rjmp	.+46     	; 0xd14 <prvCopyDataToQueue+0x5e>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
     ce6:	50 e0       	ldi	r21, 0x00	; 0
     ce8:	8c 81       	ldd	r24, Y+4	; 0x04
     cea:	9d 81       	ldd	r25, Y+5	; 0x05
     cec:	0e 94 dd 14 	call	0x29ba	; 0x29ba <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     cf0:	2c 8d       	ldd	r18, Y+28	; 0x1c
     cf2:	8c 81       	ldd	r24, Y+4	; 0x04
     cf4:	9d 81       	ldd	r25, Y+5	; 0x05
     cf6:	82 0f       	add	r24, r18
     cf8:	91 1d       	adc	r25, r1
     cfa:	9d 83       	std	Y+5, r25	; 0x05
     cfc:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     cfe:	2a 81       	ldd	r18, Y+2	; 0x02
     d00:	3b 81       	ldd	r19, Y+3	; 0x03
     d02:	82 17       	cp	r24, r18
     d04:	93 07       	cpc	r25, r19
     d06:	50 f1       	brcs	.+84     	; 0xd5c <prvCopyDataToQueue+0xa6>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
     d08:	88 81       	ld	r24, Y
     d0a:	99 81       	ldd	r25, Y+1	; 0x01
     d0c:	9d 83       	std	Y+5, r25	; 0x05
     d0e:	8c 83       	std	Y+4, r24	; 0x04
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
     d10:	80 e0       	ldi	r24, 0x00	; 0
     d12:	29 c0       	rjmp	.+82     	; 0xd66 <prvCopyDataToQueue+0xb0>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     d14:	50 e0       	ldi	r21, 0x00	; 0
     d16:	8e 81       	ldd	r24, Y+6	; 0x06
     d18:	9f 81       	ldd	r25, Y+7	; 0x07
     d1a:	0e 94 dd 14 	call	0x29ba	; 0x29ba <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
     d1e:	8c 8d       	ldd	r24, Y+28	; 0x1c
     d20:	90 e0       	ldi	r25, 0x00	; 0
     d22:	91 95       	neg	r25
     d24:	81 95       	neg	r24
     d26:	91 09       	sbc	r25, r1
     d28:	2e 81       	ldd	r18, Y+6	; 0x06
     d2a:	3f 81       	ldd	r19, Y+7	; 0x07
     d2c:	28 0f       	add	r18, r24
     d2e:	39 1f       	adc	r19, r25
     d30:	3f 83       	std	Y+7, r19	; 0x07
     d32:	2e 83       	std	Y+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     d34:	48 81       	ld	r20, Y
     d36:	59 81       	ldd	r21, Y+1	; 0x01
     d38:	24 17       	cp	r18, r20
     d3a:	35 07       	cpc	r19, r21
     d3c:	30 f4       	brcc	.+12     	; 0xd4a <prvCopyDataToQueue+0x94>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
     d3e:	2a 81       	ldd	r18, Y+2	; 0x02
     d40:	3b 81       	ldd	r19, Y+3	; 0x03
     d42:	82 0f       	add	r24, r18
     d44:	93 1f       	adc	r25, r19
     d46:	9f 83       	std	Y+7, r25	; 0x07
     d48:	8e 83       	std	Y+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
     d4a:	02 30       	cpi	r16, 0x02	; 2
     d4c:	49 f4       	brne	.+18     	; 0xd60 <prvCopyDataToQueue+0xaa>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
     d4e:	11 23       	and	r17, r17
     d50:	49 f0       	breq	.+18     	; 0xd64 <prvCopyDataToQueue+0xae>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
     d52:	11 50       	subi	r17, 0x01	; 1
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
     d54:	80 e0       	ldi	r24, 0x00	; 0
     d56:	07 c0       	rjmp	.+14     	; 0xd66 <prvCopyDataToQueue+0xb0>
     d58:	80 e0       	ldi	r24, 0x00	; 0
     d5a:	05 c0       	rjmp	.+10     	; 0xd66 <prvCopyDataToQueue+0xb0>
     d5c:	80 e0       	ldi	r24, 0x00	; 0
     d5e:	03 c0       	rjmp	.+6      	; 0xd66 <prvCopyDataToQueue+0xb0>
     d60:	80 e0       	ldi	r24, 0x00	; 0
     d62:	01 c0       	rjmp	.+2      	; 0xd66 <prvCopyDataToQueue+0xb0>
     d64:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
     d66:	1f 5f       	subi	r17, 0xFF	; 255
     d68:	1a 8f       	std	Y+26, r17	; 0x1a

	return xReturn;
}
     d6a:	df 91       	pop	r29
     d6c:	cf 91       	pop	r28
     d6e:	1f 91       	pop	r17
     d70:	0f 91       	pop	r16
     d72:	08 95       	ret

00000d74 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
     d74:	fc 01       	movw	r30, r24
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
     d76:	44 8d       	ldd	r20, Z+28	; 0x1c
     d78:	44 23       	and	r20, r20
     d7a:	a9 f0       	breq	.+42     	; 0xda6 <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
     d7c:	50 e0       	ldi	r21, 0x00	; 0
     d7e:	26 81       	ldd	r18, Z+6	; 0x06
     d80:	37 81       	ldd	r19, Z+7	; 0x07
     d82:	24 0f       	add	r18, r20
     d84:	35 1f       	adc	r19, r21
     d86:	37 83       	std	Z+7, r19	; 0x07
     d88:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
     d8a:	82 81       	ldd	r24, Z+2	; 0x02
     d8c:	93 81       	ldd	r25, Z+3	; 0x03
     d8e:	28 17       	cp	r18, r24
     d90:	39 07       	cpc	r19, r25
     d92:	20 f0       	brcs	.+8      	; 0xd9c <prvCopyDataFromQueue+0x28>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
     d94:	80 81       	ld	r24, Z
     d96:	91 81       	ldd	r25, Z+1	; 0x01
     d98:	97 83       	std	Z+7, r25	; 0x07
     d9a:	86 83       	std	Z+6, r24	; 0x06
     d9c:	cb 01       	movw	r24, r22
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
     d9e:	66 81       	ldd	r22, Z+6	; 0x06
     da0:	77 81       	ldd	r23, Z+7	; 0x07
     da2:	0e 94 dd 14 	call	0x29ba	; 0x29ba <memcpy>
     da6:	08 95       	ret

00000da8 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
     da8:	1f 93       	push	r17
     daa:	cf 93       	push	r28
     dac:	df 93       	push	r29
     dae:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
     db0:	0f b6       	in	r0, 0x3f	; 63
     db2:	f8 94       	cli
     db4:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
     db6:	1e 8d       	ldd	r17, Y+30	; 0x1e

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
     db8:	0b c0       	rjmp	.+22     	; 0xdd0 <prvUnlockQueue+0x28>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     dba:	89 89       	ldd	r24, Y+17	; 0x11
     dbc:	88 23       	and	r24, r24
     dbe:	51 f0       	breq	.+20     	; 0xdd4 <prvUnlockQueue+0x2c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     dc0:	ce 01       	movw	r24, r28
     dc2:	41 96       	adiw	r24, 0x11	; 17
     dc4:	0e 94 d0 0e 	call	0x1da0	; 0x1da0 <xTaskRemoveFromEventList>
     dc8:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
     dca:	0e 94 8f 0f 	call	0x1f1e	; 0x1f1e <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
     dce:	11 50       	subi	r17, 0x01	; 1
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
     dd0:	11 16       	cp	r1, r17
     dd2:	9c f3       	brlt	.-26     	; 0xdba <prvUnlockQueue+0x12>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
     dd4:	8f ef       	ldi	r24, 0xFF	; 255
     dd6:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
     dd8:	0f 90       	pop	r0
     dda:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
     ddc:	0f b6       	in	r0, 0x3f	; 63
     dde:	f8 94       	cli
     de0:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
     de2:	1d 8d       	ldd	r17, Y+29	; 0x1d

		while( cRxLock > queueLOCKED_UNMODIFIED )
     de4:	0b c0       	rjmp	.+22     	; 0xdfc <prvUnlockQueue+0x54>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     de6:	88 85       	ldd	r24, Y+8	; 0x08
     de8:	88 23       	and	r24, r24
     dea:	51 f0       	breq	.+20     	; 0xe00 <prvUnlockQueue+0x58>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     dec:	ce 01       	movw	r24, r28
     dee:	08 96       	adiw	r24, 0x08	; 8
     df0:	0e 94 d0 0e 	call	0x1da0	; 0x1da0 <xTaskRemoveFromEventList>
     df4:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
     df6:	0e 94 8f 0f 	call	0x1f1e	; 0x1f1e <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
     dfa:	11 50       	subi	r17, 0x01	; 1
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
     dfc:	11 16       	cp	r1, r17
     dfe:	9c f3       	brlt	.-26     	; 0xde6 <prvUnlockQueue+0x3e>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
     e00:	8f ef       	ldi	r24, 0xFF	; 255
     e02:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
     e04:	0f 90       	pop	r0
     e06:	0f be       	out	0x3f, r0	; 63
}
     e08:	df 91       	pop	r29
     e0a:	cf 91       	pop	r28
     e0c:	1f 91       	pop	r17
     e0e:	08 95       	ret

00000e10 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
     e10:	cf 93       	push	r28
     e12:	df 93       	push	r29
     e14:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
     e16:	0f b6       	in	r0, 0x3f	; 63
     e18:	f8 94       	cli
     e1a:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
     e1c:	e8 81       	ld	r30, Y
     e1e:	f9 81       	ldd	r31, Y+1	; 0x01
     e20:	8b 8d       	ldd	r24, Y+27	; 0x1b
     e22:	90 e0       	ldi	r25, 0x00	; 0
     e24:	2c 8d       	ldd	r18, Y+28	; 0x1c
     e26:	30 e0       	ldi	r19, 0x00	; 0
     e28:	82 9f       	mul	r24, r18
     e2a:	a0 01       	movw	r20, r0
     e2c:	83 9f       	mul	r24, r19
     e2e:	50 0d       	add	r21, r0
     e30:	92 9f       	mul	r25, r18
     e32:	50 0d       	add	r21, r0
     e34:	11 24       	eor	r1, r1
     e36:	4e 0f       	add	r20, r30
     e38:	5f 1f       	adc	r21, r31
     e3a:	5b 83       	std	Y+3, r21	; 0x03
     e3c:	4a 83       	std	Y+2, r20	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
     e3e:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
     e40:	fd 83       	std	Y+5, r31	; 0x05
     e42:	ec 83       	std	Y+4, r30	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
     e44:	01 97       	sbiw	r24, 0x01	; 1
     e46:	28 9f       	mul	r18, r24
     e48:	a0 01       	movw	r20, r0
     e4a:	29 9f       	mul	r18, r25
     e4c:	50 0d       	add	r21, r0
     e4e:	38 9f       	mul	r19, r24
     e50:	50 0d       	add	r21, r0
     e52:	11 24       	eor	r1, r1
     e54:	cf 01       	movw	r24, r30
     e56:	84 0f       	add	r24, r20
     e58:	95 1f       	adc	r25, r21
     e5a:	9f 83       	std	Y+7, r25	; 0x07
     e5c:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
     e5e:	8f ef       	ldi	r24, 0xFF	; 255
     e60:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
     e62:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
     e64:	61 11       	cpse	r22, r1
     e66:	0c c0       	rjmp	.+24     	; 0xe80 <xQueueGenericReset+0x70>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     e68:	88 85       	ldd	r24, Y+8	; 0x08
     e6a:	88 23       	and	r24, r24
     e6c:	89 f0       	breq	.+34     	; 0xe90 <xQueueGenericReset+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     e6e:	ce 01       	movw	r24, r28
     e70:	08 96       	adiw	r24, 0x08	; 8
     e72:	0e 94 d0 0e 	call	0x1da0	; 0x1da0 <xTaskRemoveFromEventList>
     e76:	88 23       	and	r24, r24
     e78:	59 f0       	breq	.+22     	; 0xe90 <xQueueGenericReset+0x80>
				{
					queueYIELD_IF_USING_PREEMPTION();
     e7a:	0e 94 44 05 	call	0xa88	; 0xa88 <vPortYield>
     e7e:	08 c0       	rjmp	.+16     	; 0xe90 <xQueueGenericReset+0x80>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
     e80:	ce 01       	movw	r24, r28
     e82:	08 96       	adiw	r24, 0x08	; 8
     e84:	0e 94 14 04 	call	0x828	; 0x828 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
     e88:	ce 01       	movw	r24, r28
     e8a:	41 96       	adiw	r24, 0x11	; 17
     e8c:	0e 94 14 04 	call	0x828	; 0x828 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
     e90:	0f 90       	pop	r0
     e92:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
     e94:	81 e0       	ldi	r24, 0x01	; 1
     e96:	df 91       	pop	r29
     e98:	cf 91       	pop	r28
     e9a:	08 95       	ret

00000e9c <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
     e9c:	0f 93       	push	r16
     e9e:	1f 93       	push	r17
     ea0:	f8 01       	movw	r30, r16
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
     ea2:	61 11       	cpse	r22, r1
     ea4:	03 c0       	rjmp	.+6      	; 0xeac <prvInitialiseNewQueue+0x10>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
     ea6:	11 83       	std	Z+1, r17	; 0x01
     ea8:	00 83       	st	Z, r16
     eaa:	02 c0       	rjmp	.+4      	; 0xeb0 <prvInitialiseNewQueue+0x14>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
     eac:	51 83       	std	Z+1, r21	; 0x01
     eae:	40 83       	st	Z, r20
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
     eb0:	83 8f       	std	Z+27, r24	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
     eb2:	64 8f       	std	Z+28, r22	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
     eb4:	61 e0       	ldi	r22, 0x01	; 1
     eb6:	cf 01       	movw	r24, r30
     eb8:	0e 94 08 07 	call	0xe10	; 0xe10 <xQueueGenericReset>
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
     ebc:	1f 91       	pop	r17
     ebe:	0f 91       	pop	r16
     ec0:	08 95       	ret

00000ec2 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
     ec2:	df 92       	push	r13
     ec4:	ef 92       	push	r14
     ec6:	ff 92       	push	r15
     ec8:	0f 93       	push	r16
     eca:	1f 93       	push	r17
     ecc:	cf 93       	push	r28
     ece:	df 93       	push	r29
     ed0:	e8 2e       	mov	r14, r24
     ed2:	f6 2e       	mov	r15, r22
     ed4:	d4 2e       	mov	r13, r20
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
     ed6:	66 23       	and	r22, r22
     ed8:	21 f0       	breq	.+8      	; 0xee2 <xQueueGenericCreate+0x20>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     eda:	86 9f       	mul	r24, r22
     edc:	c0 01       	movw	r24, r0
     ede:	11 24       	eor	r1, r1
     ee0:	02 c0       	rjmp	.+4      	; 0xee6 <xQueueGenericCreate+0x24>
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
     ee2:	80 e0       	ldi	r24, 0x00	; 0
     ee4:	90 e0       	ldi	r25, 0x00	; 0
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
		}

		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
     ee6:	4f 96       	adiw	r24, 0x1f	; 31
     ee8:	0e 94 fc 05 	call	0xbf8	; 0xbf8 <pvPortMalloc>
     eec:	ec 01       	movw	r28, r24

		if( pxNewQueue != NULL )
     eee:	00 97       	sbiw	r24, 0x00	; 0
     ef0:	49 f0       	breq	.+18     	; 0xf04 <xQueueGenericCreate+0x42>
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
     ef2:	8c 01       	movw	r16, r24
     ef4:	2d 2d       	mov	r18, r13
     ef6:	ac 01       	movw	r20, r24
     ef8:	41 5e       	subi	r20, 0xE1	; 225
     efa:	5f 4f       	sbci	r21, 0xFF	; 255
     efc:	6f 2d       	mov	r22, r15
     efe:	8e 2d       	mov	r24, r14
     f00:	0e 94 4e 07 	call	0xe9c	; 0xe9c <prvInitialiseNewQueue>
		}

		return pxNewQueue;
	}
     f04:	ce 01       	movw	r24, r28
     f06:	df 91       	pop	r29
     f08:	cf 91       	pop	r28
     f0a:	1f 91       	pop	r17
     f0c:	0f 91       	pop	r16
     f0e:	ff 90       	pop	r15
     f10:	ef 90       	pop	r14
     f12:	df 90       	pop	r13
     f14:	08 95       	ret

00000f16 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
     f16:	cf 92       	push	r12
     f18:	df 92       	push	r13
     f1a:	ef 92       	push	r14
     f1c:	ff 92       	push	r15
     f1e:	0f 93       	push	r16
     f20:	1f 93       	push	r17
     f22:	cf 93       	push	r28
     f24:	df 93       	push	r29
     f26:	00 d0       	rcall	.+0      	; 0xf28 <xQueueGenericSend+0x12>
     f28:	00 d0       	rcall	.+0      	; 0xf2a <xQueueGenericSend+0x14>
     f2a:	1f 92       	push	r1
     f2c:	cd b7       	in	r28, 0x3d	; 61
     f2e:	de b7       	in	r29, 0x3e	; 62
     f30:	8c 01       	movw	r16, r24
     f32:	7b 01       	movw	r14, r22
     f34:	5d 83       	std	Y+5, r21	; 0x05
     f36:	4c 83       	std	Y+4, r20	; 0x04
     f38:	c2 2e       	mov	r12, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
     f3a:	d1 2c       	mov	r13, r1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
     f3c:	0f b6       	in	r0, 0x3f	; 63
     f3e:	f8 94       	cli
     f40:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
     f42:	f8 01       	movw	r30, r16
     f44:	92 8d       	ldd	r25, Z+26	; 0x1a
     f46:	83 8d       	ldd	r24, Z+27	; 0x1b
     f48:	98 17       	cp	r25, r24
     f4a:	18 f0       	brcs	.+6      	; 0xf52 <xQueueGenericSend+0x3c>
     f4c:	f2 e0       	ldi	r31, 0x02	; 2
     f4e:	cf 12       	cpse	r12, r31
     f50:	19 c0       	rjmp	.+50     	; 0xf84 <xQueueGenericSend+0x6e>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     f52:	4c 2d       	mov	r20, r12
     f54:	b7 01       	movw	r22, r14
     f56:	c8 01       	movw	r24, r16
     f58:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     f5c:	f8 01       	movw	r30, r16
     f5e:	91 89       	ldd	r25, Z+17	; 0x11
     f60:	99 23       	and	r25, r25
     f62:	49 f0       	breq	.+18     	; 0xf76 <xQueueGenericSend+0x60>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     f64:	c8 01       	movw	r24, r16
     f66:	41 96       	adiw	r24, 0x11	; 17
     f68:	0e 94 d0 0e 	call	0x1da0	; 0x1da0 <xTaskRemoveFromEventList>
     f6c:	88 23       	and	r24, r24
     f6e:	31 f0       	breq	.+12     	; 0xf7c <xQueueGenericSend+0x66>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
     f70:	0e 94 44 05 	call	0xa88	; 0xa88 <vPortYield>
     f74:	03 c0       	rjmp	.+6      	; 0xf7c <xQueueGenericSend+0x66>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
     f76:	81 11       	cpse	r24, r1
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
     f78:	0e 94 44 05 	call	0xa88	; 0xa88 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
     f7c:	0f 90       	pop	r0
     f7e:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     f80:	81 e0       	ldi	r24, 0x01	; 1
     f82:	4d c0       	rjmp	.+154    	; 0x101e <xQueueGenericSend+0x108>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
     f84:	8c 81       	ldd	r24, Y+4	; 0x04
     f86:	9d 81       	ldd	r25, Y+5	; 0x05
     f88:	89 2b       	or	r24, r25
     f8a:	21 f4       	brne	.+8      	; 0xf94 <xQueueGenericSend+0x7e>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     f8c:	0f 90       	pop	r0
     f8e:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
     f90:	80 e0       	ldi	r24, 0x00	; 0
     f92:	45 c0       	rjmp	.+138    	; 0x101e <xQueueGenericSend+0x108>
				}
				else if( xEntryTimeSet == pdFALSE )
     f94:	d1 10       	cpse	r13, r1
     f96:	06 c0       	rjmp	.+12     	; 0xfa4 <xQueueGenericSend+0x8e>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     f98:	ce 01       	movw	r24, r28
     f9a:	01 96       	adiw	r24, 0x01	; 1
     f9c:	0e 94 52 0f 	call	0x1ea4	; 0x1ea4 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     fa0:	dd 24       	eor	r13, r13
     fa2:	d3 94       	inc	r13
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
     fa4:	0f 90       	pop	r0
     fa6:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     fa8:	0e 94 ae 0c 	call	0x195c	; 0x195c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     fac:	0f b6       	in	r0, 0x3f	; 63
     fae:	f8 94       	cli
     fb0:	0f 92       	push	r0
     fb2:	f8 01       	movw	r30, r16
     fb4:	85 8d       	ldd	r24, Z+29	; 0x1d
     fb6:	8f 3f       	cpi	r24, 0xFF	; 255
     fb8:	09 f4       	brne	.+2      	; 0xfbc <xQueueGenericSend+0xa6>
     fba:	15 8e       	std	Z+29, r1	; 0x1d
     fbc:	f8 01       	movw	r30, r16
     fbe:	86 8d       	ldd	r24, Z+30	; 0x1e
     fc0:	8f 3f       	cpi	r24, 0xFF	; 255
     fc2:	09 f4       	brne	.+2      	; 0xfc6 <xQueueGenericSend+0xb0>
     fc4:	16 8e       	std	Z+30, r1	; 0x1e
     fc6:	0f 90       	pop	r0
     fc8:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     fca:	be 01       	movw	r22, r28
     fcc:	6c 5f       	subi	r22, 0xFC	; 252
     fce:	7f 4f       	sbci	r23, 0xFF	; 255
     fd0:	ce 01       	movw	r24, r28
     fd2:	01 96       	adiw	r24, 0x01	; 1
     fd4:	0e 94 5d 0f 	call	0x1eba	; 0x1eba <xTaskCheckForTimeOut>
     fd8:	81 11       	cpse	r24, r1
     fda:	1b c0       	rjmp	.+54     	; 0x1012 <xQueueGenericSend+0xfc>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
     fdc:	c8 01       	movw	r24, r16
     fde:	0e 94 4d 06 	call	0xc9a	; 0xc9a <prvIsQueueFull>
     fe2:	88 23       	and	r24, r24
     fe4:	81 f0       	breq	.+32     	; 0x1006 <xQueueGenericSend+0xf0>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     fe6:	6c 81       	ldd	r22, Y+4	; 0x04
     fe8:	7d 81       	ldd	r23, Y+5	; 0x05
     fea:	c8 01       	movw	r24, r16
     fec:	08 96       	adiw	r24, 0x08	; 8
     fee:	0e 94 a5 0e 	call	0x1d4a	; 0x1d4a <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
     ff2:	c8 01       	movw	r24, r16
     ff4:	0e 94 d4 06 	call	0xda8	; 0xda8 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
     ff8:	0e 94 88 0d 	call	0x1b10	; 0x1b10 <xTaskResumeAll>
     ffc:	81 11       	cpse	r24, r1
     ffe:	9e cf       	rjmp	.-196    	; 0xf3c <xQueueGenericSend+0x26>
				{
					portYIELD_WITHIN_API();
    1000:	0e 94 44 05 	call	0xa88	; 0xa88 <vPortYield>
    1004:	9b cf       	rjmp	.-202    	; 0xf3c <xQueueGenericSend+0x26>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1006:	c8 01       	movw	r24, r16
    1008:	0e 94 d4 06 	call	0xda8	; 0xda8 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    100c:	0e 94 88 0d 	call	0x1b10	; 0x1b10 <xTaskResumeAll>
    1010:	95 cf       	rjmp	.-214    	; 0xf3c <xQueueGenericSend+0x26>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1012:	c8 01       	movw	r24, r16
    1014:	0e 94 d4 06 	call	0xda8	; 0xda8 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1018:	0e 94 88 0d 	call	0x1b10	; 0x1b10 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    101c:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    101e:	0f 90       	pop	r0
    1020:	0f 90       	pop	r0
    1022:	0f 90       	pop	r0
    1024:	0f 90       	pop	r0
    1026:	0f 90       	pop	r0
    1028:	df 91       	pop	r29
    102a:	cf 91       	pop	r28
    102c:	1f 91       	pop	r17
    102e:	0f 91       	pop	r16
    1030:	ff 90       	pop	r15
    1032:	ef 90       	pop	r14
    1034:	df 90       	pop	r13
    1036:	cf 90       	pop	r12
    1038:	08 95       	ret

0000103a <prvInitialiseMutex>:

#if( configUSE_MUTEXES == 1 )

	static void prvInitialiseMutex( Queue_t *pxNewQueue )
	{
		if( pxNewQueue != NULL )
    103a:	00 97       	sbiw	r24, 0x00	; 0
    103c:	69 f0       	breq	.+26     	; 0x1058 <prvInitialiseMutex+0x1e>
    103e:	fc 01       	movw	r30, r24
		{
			/* The queue create function will set all the queue structure members
			correctly for a generic queue, but this function is creating a
			mutex.  Overwrite those members that need to be set differently -
			in particular the information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    1040:	13 82       	std	Z+3, r1	; 0x03
    1042:	12 82       	std	Z+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    1044:	11 82       	std	Z+1, r1	; 0x01
    1046:	10 82       	st	Z, r1

			/* In case this is a recursive mutex. */
			pxNewQueue->u.uxRecursiveCallCount = 0;
    1048:	16 82       	std	Z+6, r1	; 0x06

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    104a:	20 e0       	ldi	r18, 0x00	; 0
    104c:	40 e0       	ldi	r20, 0x00	; 0
    104e:	50 e0       	ldi	r21, 0x00	; 0
    1050:	60 e0       	ldi	r22, 0x00	; 0
    1052:	70 e0       	ldi	r23, 0x00	; 0
    1054:	0e 94 8b 07 	call	0xf16	; 0xf16 <xQueueGenericSend>
    1058:	08 95       	ret

0000105a <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    105a:	cf 93       	push	r28
    105c:	df 93       	push	r29
	Queue_t *pxNewQueue;
	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;

		pxNewQueue = ( Queue_t * ) xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
    105e:	48 2f       	mov	r20, r24
    1060:	60 e0       	ldi	r22, 0x00	; 0
    1062:	81 e0       	ldi	r24, 0x01	; 1
    1064:	0e 94 61 07 	call	0xec2	; 0xec2 <xQueueGenericCreate>
    1068:	ec 01       	movw	r28, r24
		prvInitialiseMutex( pxNewQueue );
    106a:	0e 94 1d 08 	call	0x103a	; 0x103a <prvInitialiseMutex>

		return pxNewQueue;
	}
    106e:	ce 01       	movw	r24, r28
    1070:	df 91       	pop	r29
    1072:	cf 91       	pop	r28
    1074:	08 95       	ret

00001076 <xQueueGenericSendFromISR>:
	}
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    1076:	ef 92       	push	r14
    1078:	ff 92       	push	r15
    107a:	0f 93       	push	r16
    107c:	1f 93       	push	r17
    107e:	cf 93       	push	r28
    1080:	df 93       	push	r29
    1082:	8a 01       	movw	r16, r20
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1084:	fc 01       	movw	r30, r24
    1086:	52 8d       	ldd	r21, Z+26	; 0x1a
    1088:	33 8d       	ldd	r19, Z+27	; 0x1b
    108a:	53 17       	cp	r21, r19
    108c:	10 f0       	brcs	.+4      	; 0x1092 <xQueueGenericSendFromISR+0x1c>
    108e:	22 30       	cpi	r18, 0x02	; 2
    1090:	f1 f4       	brne	.+60     	; 0x10ce <xQueueGenericSendFromISR+0x58>
    1092:	42 2f       	mov	r20, r18
    1094:	78 01       	movw	r14, r16
    1096:	ec 01       	movw	r28, r24
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    1098:	1e 8d       	ldd	r17, Y+30	; 0x1e
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    109a:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    109e:	1f 3f       	cpi	r17, 0xFF	; 255
    10a0:	81 f4       	brne	.+32     	; 0x10c2 <xQueueGenericSendFromISR+0x4c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    10a2:	89 89       	ldd	r24, Y+17	; 0x11
    10a4:	88 23       	and	r24, r24
    10a6:	a9 f0       	breq	.+42     	; 0x10d2 <xQueueGenericSendFromISR+0x5c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    10a8:	ce 01       	movw	r24, r28
    10aa:	41 96       	adiw	r24, 0x11	; 17
    10ac:	0e 94 d0 0e 	call	0x1da0	; 0x1da0 <xTaskRemoveFromEventList>
    10b0:	88 23       	and	r24, r24
    10b2:	89 f0       	breq	.+34     	; 0x10d6 <xQueueGenericSendFromISR+0x60>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    10b4:	e1 14       	cp	r14, r1
    10b6:	f1 04       	cpc	r15, r1
    10b8:	81 f0       	breq	.+32     	; 0x10da <xQueueGenericSendFromISR+0x64>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    10ba:	81 e0       	ldi	r24, 0x01	; 1
    10bc:	f7 01       	movw	r30, r14
    10be:	80 83       	st	Z, r24
    10c0:	0d c0       	rjmp	.+26     	; 0x10dc <xQueueGenericSendFromISR+0x66>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    10c2:	ff 24       	eor	r15, r15
    10c4:	f3 94       	inc	r15
    10c6:	f1 0e       	add	r15, r17
    10c8:	fe 8e       	std	Y+30, r15	; 0x1e
			}

			xReturn = pdPASS;
    10ca:	81 e0       	ldi	r24, 0x01	; 1
    10cc:	07 c0       	rjmp	.+14     	; 0x10dc <xQueueGenericSendFromISR+0x66>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    10ce:	80 e0       	ldi	r24, 0x00	; 0
    10d0:	05 c0       	rjmp	.+10     	; 0x10dc <xQueueGenericSendFromISR+0x66>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
			}

			xReturn = pdPASS;
    10d2:	81 e0       	ldi	r24, 0x01	; 1
    10d4:	03 c0       	rjmp	.+6      	; 0x10dc <xQueueGenericSendFromISR+0x66>
    10d6:	81 e0       	ldi	r24, 0x01	; 1
    10d8:	01 c0       	rjmp	.+2      	; 0x10dc <xQueueGenericSendFromISR+0x66>
    10da:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    10dc:	df 91       	pop	r29
    10de:	cf 91       	pop	r28
    10e0:	1f 91       	pop	r17
    10e2:	0f 91       	pop	r16
    10e4:	ff 90       	pop	r15
    10e6:	ef 90       	pop	r14
    10e8:	08 95       	ret

000010ea <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    10ea:	cf 93       	push	r28
    10ec:	df 93       	push	r29
    10ee:	fc 01       	movw	r30, r24
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    10f0:	82 8d       	ldd	r24, Z+26	; 0x1a

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    10f2:	93 8d       	ldd	r25, Z+27	; 0x1b
    10f4:	89 17       	cp	r24, r25
    10f6:	c0 f4       	brcc	.+48     	; 0x1128 <__stack+0x29>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    10f8:	96 8d       	ldd	r25, Z+30	; 0x1e
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
    10fa:	8f 5f       	subi	r24, 0xFF	; 255
    10fc:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    10fe:	9f 3f       	cpi	r25, 0xFF	; 255
    1100:	79 f4       	brne	.+30     	; 0x1120 <__stack+0x21>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1102:	81 89       	ldd	r24, Z+17	; 0x11
    1104:	88 23       	and	r24, r24
    1106:	91 f0       	breq	.+36     	; 0x112c <__stack+0x2d>
    1108:	eb 01       	movw	r28, r22
    110a:	cf 01       	movw	r24, r30
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    110c:	41 96       	adiw	r24, 0x11	; 17
    110e:	0e 94 d0 0e 	call	0x1da0	; 0x1da0 <xTaskRemoveFromEventList>
    1112:	88 23       	and	r24, r24
    1114:	69 f0       	breq	.+26     	; 0x1130 <__stack+0x31>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1116:	20 97       	sbiw	r28, 0x00	; 0
    1118:	69 f0       	breq	.+26     	; 0x1134 <__stack+0x35>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    111a:	81 e0       	ldi	r24, 0x01	; 1
    111c:	88 83       	st	Y, r24
    111e:	0b c0       	rjmp	.+22     	; 0x1136 <__stack+0x37>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    1120:	9f 5f       	subi	r25, 0xFF	; 255
    1122:	96 8f       	std	Z+30, r25	; 0x1e
			}

			xReturn = pdPASS;
    1124:	81 e0       	ldi	r24, 0x01	; 1
    1126:	07 c0       	rjmp	.+14     	; 0x1136 <__stack+0x37>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1128:	80 e0       	ldi	r24, 0x00	; 0
    112a:	05 c0       	rjmp	.+10     	; 0x1136 <__stack+0x37>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
			}

			xReturn = pdPASS;
    112c:	81 e0       	ldi	r24, 0x01	; 1
    112e:	03 c0       	rjmp	.+6      	; 0x1136 <__stack+0x37>
    1130:	81 e0       	ldi	r24, 0x01	; 1
    1132:	01 c0       	rjmp	.+2      	; 0x1136 <__stack+0x37>
    1134:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1136:	df 91       	pop	r29
    1138:	cf 91       	pop	r28
    113a:	08 95       	ret

0000113c <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    113c:	8f 92       	push	r8
    113e:	9f 92       	push	r9
    1140:	bf 92       	push	r11
    1142:	cf 92       	push	r12
    1144:	df 92       	push	r13
    1146:	ef 92       	push	r14
    1148:	ff 92       	push	r15
    114a:	0f 93       	push	r16
    114c:	1f 93       	push	r17
    114e:	cf 93       	push	r28
    1150:	df 93       	push	r29
    1152:	00 d0       	rcall	.+0      	; 0x1154 <xQueueGenericReceive+0x18>
    1154:	00 d0       	rcall	.+0      	; 0x1156 <xQueueGenericReceive+0x1a>
    1156:	1f 92       	push	r1
    1158:	cd b7       	in	r28, 0x3d	; 61
    115a:	de b7       	in	r29, 0x3e	; 62
    115c:	8c 01       	movw	r16, r24
    115e:	6b 01       	movw	r12, r22
    1160:	5d 83       	std	Y+5, r21	; 0x05
    1162:	4c 83       	std	Y+4, r20	; 0x04
    1164:	b2 2e       	mov	r11, r18
BaseType_t xEntryTimeSet = pdFALSE;
    1166:	e1 2c       	mov	r14, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1168:	0f b6       	in	r0, 0x3f	; 63
    116a:	f8 94       	cli
    116c:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    116e:	f8 01       	movw	r30, r16
    1170:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1172:	ff 20       	and	r15, r15
    1174:	91 f1       	breq	.+100    	; 0x11da <xQueueGenericReceive+0x9e>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    1176:	86 80       	ldd	r8, Z+6	; 0x06
    1178:	97 80       	ldd	r9, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    117a:	b6 01       	movw	r22, r12
    117c:	c8 01       	movw	r24, r16
    117e:	0e 94 ba 06 	call	0xd74	; 0xd74 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1182:	b1 10       	cpse	r11, r1
    1184:	19 c0       	rjmp	.+50     	; 0x11b8 <xQueueGenericReceive+0x7c>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
    1186:	fa 94       	dec	r15
    1188:	f8 01       	movw	r30, r16
    118a:	f2 8e       	std	Z+26, r15	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    118c:	80 81       	ld	r24, Z
    118e:	91 81       	ldd	r25, Z+1	; 0x01
    1190:	89 2b       	or	r24, r25
    1192:	29 f4       	brne	.+10     	; 0x119e <xQueueGenericReceive+0x62>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    1194:	0e 94 51 10 	call	0x20a2	; 0x20a2 <pvTaskIncrementMutexHeldCount>
    1198:	f8 01       	movw	r30, r16
    119a:	93 83       	std	Z+3, r25	; 0x03
    119c:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    119e:	f8 01       	movw	r30, r16
    11a0:	80 85       	ldd	r24, Z+8	; 0x08
    11a2:	88 23       	and	r24, r24
    11a4:	b1 f0       	breq	.+44     	; 0x11d2 <xQueueGenericReceive+0x96>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    11a6:	c8 01       	movw	r24, r16
    11a8:	08 96       	adiw	r24, 0x08	; 8
    11aa:	0e 94 d0 0e 	call	0x1da0	; 0x1da0 <xTaskRemoveFromEventList>
    11ae:	88 23       	and	r24, r24
    11b0:	81 f0       	breq	.+32     	; 0x11d2 <xQueueGenericReceive+0x96>
						{
							queueYIELD_IF_USING_PREEMPTION();
    11b2:	0e 94 44 05 	call	0xa88	; 0xa88 <vPortYield>
    11b6:	0d c0       	rjmp	.+26     	; 0x11d2 <xQueueGenericReceive+0x96>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    11b8:	f8 01       	movw	r30, r16
    11ba:	97 82       	std	Z+7, r9	; 0x07
    11bc:	86 82       	std	Z+6, r8	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    11be:	81 89       	ldd	r24, Z+17	; 0x11
    11c0:	88 23       	and	r24, r24
    11c2:	39 f0       	breq	.+14     	; 0x11d2 <xQueueGenericReceive+0x96>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    11c4:	c8 01       	movw	r24, r16
    11c6:	41 96       	adiw	r24, 0x11	; 17
    11c8:	0e 94 d0 0e 	call	0x1da0	; 0x1da0 <xTaskRemoveFromEventList>
    11cc:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    11ce:	0e 94 44 05 	call	0xa88	; 0xa88 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    11d2:	0f 90       	pop	r0
    11d4:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    11d6:	81 e0       	ldi	r24, 0x01	; 1
    11d8:	61 c0       	rjmp	.+194    	; 0x129c <xQueueGenericReceive+0x160>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    11da:	8c 81       	ldd	r24, Y+4	; 0x04
    11dc:	9d 81       	ldd	r25, Y+5	; 0x05
    11de:	89 2b       	or	r24, r25
    11e0:	21 f4       	brne	.+8      	; 0x11ea <xQueueGenericReceive+0xae>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    11e2:	0f 90       	pop	r0
    11e4:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    11e6:	80 e0       	ldi	r24, 0x00	; 0
    11e8:	59 c0       	rjmp	.+178    	; 0x129c <xQueueGenericReceive+0x160>
				}
				else if( xEntryTimeSet == pdFALSE )
    11ea:	e1 10       	cpse	r14, r1
    11ec:	06 c0       	rjmp	.+12     	; 0x11fa <xQueueGenericReceive+0xbe>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    11ee:	ce 01       	movw	r24, r28
    11f0:	01 96       	adiw	r24, 0x01	; 1
    11f2:	0e 94 52 0f 	call	0x1ea4	; 0x1ea4 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    11f6:	ee 24       	eor	r14, r14
    11f8:	e3 94       	inc	r14
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    11fa:	0f 90       	pop	r0
    11fc:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    11fe:	0e 94 ae 0c 	call	0x195c	; 0x195c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1202:	0f b6       	in	r0, 0x3f	; 63
    1204:	f8 94       	cli
    1206:	0f 92       	push	r0
    1208:	f8 01       	movw	r30, r16
    120a:	85 8d       	ldd	r24, Z+29	; 0x1d
    120c:	8f 3f       	cpi	r24, 0xFF	; 255
    120e:	09 f4       	brne	.+2      	; 0x1212 <xQueueGenericReceive+0xd6>
    1210:	15 8e       	std	Z+29, r1	; 0x1d
    1212:	f8 01       	movw	r30, r16
    1214:	86 8d       	ldd	r24, Z+30	; 0x1e
    1216:	8f 3f       	cpi	r24, 0xFF	; 255
    1218:	09 f4       	brne	.+2      	; 0x121c <xQueueGenericReceive+0xe0>
    121a:	16 8e       	std	Z+30, r1	; 0x1e
    121c:	0f 90       	pop	r0
    121e:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1220:	be 01       	movw	r22, r28
    1222:	6c 5f       	subi	r22, 0xFC	; 252
    1224:	7f 4f       	sbci	r23, 0xFF	; 255
    1226:	ce 01       	movw	r24, r28
    1228:	01 96       	adiw	r24, 0x01	; 1
    122a:	0e 94 5d 0f 	call	0x1eba	; 0x1eba <xTaskCheckForTimeOut>
    122e:	81 11       	cpse	r24, r1
    1230:	29 c0       	rjmp	.+82     	; 0x1284 <xQueueGenericReceive+0x148>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1232:	c8 01       	movw	r24, r16
    1234:	0e 94 40 06 	call	0xc80	; 0xc80 <prvIsQueueEmpty>
    1238:	88 23       	and	r24, r24
    123a:	f1 f0       	breq	.+60     	; 0x1278 <xQueueGenericReceive+0x13c>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    123c:	f8 01       	movw	r30, r16
    123e:	80 81       	ld	r24, Z
    1240:	91 81       	ldd	r25, Z+1	; 0x01
    1242:	89 2b       	or	r24, r25
    1244:	49 f4       	brne	.+18     	; 0x1258 <xQueueGenericReceive+0x11c>
					{
						taskENTER_CRITICAL();
    1246:	0f b6       	in	r0, 0x3f	; 63
    1248:	f8 94       	cli
    124a:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    124c:	82 81       	ldd	r24, Z+2	; 0x02
    124e:	93 81       	ldd	r25, Z+3	; 0x03
    1250:	0e 94 98 0f 	call	0x1f30	; 0x1f30 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    1254:	0f 90       	pop	r0
    1256:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1258:	6c 81       	ldd	r22, Y+4	; 0x04
    125a:	7d 81       	ldd	r23, Y+5	; 0x05
    125c:	c8 01       	movw	r24, r16
    125e:	41 96       	adiw	r24, 0x11	; 17
    1260:	0e 94 a5 0e 	call	0x1d4a	; 0x1d4a <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1264:	c8 01       	movw	r24, r16
    1266:	0e 94 d4 06 	call	0xda8	; 0xda8 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    126a:	0e 94 88 0d 	call	0x1b10	; 0x1b10 <xTaskResumeAll>
    126e:	81 11       	cpse	r24, r1
    1270:	7b cf       	rjmp	.-266    	; 0x1168 <xQueueGenericReceive+0x2c>
				{
					portYIELD_WITHIN_API();
    1272:	0e 94 44 05 	call	0xa88	; 0xa88 <vPortYield>
    1276:	78 cf       	rjmp	.-272    	; 0x1168 <xQueueGenericReceive+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1278:	c8 01       	movw	r24, r16
    127a:	0e 94 d4 06 	call	0xda8	; 0xda8 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    127e:	0e 94 88 0d 	call	0x1b10	; 0x1b10 <xTaskResumeAll>
    1282:	72 cf       	rjmp	.-284    	; 0x1168 <xQueueGenericReceive+0x2c>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1284:	c8 01       	movw	r24, r16
    1286:	0e 94 d4 06 	call	0xda8	; 0xda8 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    128a:	0e 94 88 0d 	call	0x1b10	; 0x1b10 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    128e:	c8 01       	movw	r24, r16
    1290:	0e 94 40 06 	call	0xc80	; 0xc80 <prvIsQueueEmpty>
    1294:	88 23       	and	r24, r24
    1296:	09 f4       	brne	.+2      	; 0x129a <xQueueGenericReceive+0x15e>
    1298:	67 cf       	rjmp	.-306    	; 0x1168 <xQueueGenericReceive+0x2c>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    129a:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
    129c:	0f 90       	pop	r0
    129e:	0f 90       	pop	r0
    12a0:	0f 90       	pop	r0
    12a2:	0f 90       	pop	r0
    12a4:	0f 90       	pop	r0
    12a6:	df 91       	pop	r29
    12a8:	cf 91       	pop	r28
    12aa:	1f 91       	pop	r17
    12ac:	0f 91       	pop	r16
    12ae:	ff 90       	pop	r15
    12b0:	ef 90       	pop	r14
    12b2:	df 90       	pop	r13
    12b4:	cf 90       	pop	r12
    12b6:	bf 90       	pop	r11
    12b8:	9f 90       	pop	r9
    12ba:	8f 90       	pop	r8
    12bc:	08 95       	ret

000012be <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    12be:	ef 92       	push	r14
    12c0:	ff 92       	push	r15
    12c2:	0f 93       	push	r16
    12c4:	1f 93       	push	r17
    12c6:	cf 93       	push	r28
    12c8:	df 93       	push	r29
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    12ca:	fc 01       	movw	r30, r24
    12cc:	c2 8d       	ldd	r28, Z+26	; 0x1a

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    12ce:	cc 23       	and	r28, r28
    12d0:	f9 f0       	breq	.+62     	; 0x1310 <xQueueReceiveFromISR+0x52>
    12d2:	7a 01       	movw	r14, r20
    12d4:	8c 01       	movw	r16, r24
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    12d6:	d5 8d       	ldd	r29, Z+29	; 0x1d

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    12d8:	0e 94 ba 06 	call	0xd74	; 0xd74 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
    12dc:	c1 50       	subi	r28, 0x01	; 1
    12de:	f8 01       	movw	r30, r16
    12e0:	c2 8f       	std	Z+26, r28	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    12e2:	df 3f       	cpi	r29, 0xFF	; 255
    12e4:	81 f4       	brne	.+32     	; 0x1306 <xQueueReceiveFromISR+0x48>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    12e6:	80 85       	ldd	r24, Z+8	; 0x08
    12e8:	88 23       	and	r24, r24
    12ea:	a1 f0       	breq	.+40     	; 0x1314 <xQueueReceiveFromISR+0x56>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    12ec:	c8 01       	movw	r24, r16
    12ee:	08 96       	adiw	r24, 0x08	; 8
    12f0:	0e 94 d0 0e 	call	0x1da0	; 0x1da0 <xTaskRemoveFromEventList>
    12f4:	88 23       	and	r24, r24
    12f6:	81 f0       	breq	.+32     	; 0x1318 <xQueueReceiveFromISR+0x5a>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    12f8:	e1 14       	cp	r14, r1
    12fa:	f1 04       	cpc	r15, r1
    12fc:	79 f0       	breq	.+30     	; 0x131c <xQueueReceiveFromISR+0x5e>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    12fe:	81 e0       	ldi	r24, 0x01	; 1
    1300:	f7 01       	movw	r30, r14
    1302:	80 83       	st	Z, r24
    1304:	0c c0       	rjmp	.+24     	; 0x131e <xQueueReceiveFromISR+0x60>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    1306:	df 5f       	subi	r29, 0xFF	; 255
    1308:	f8 01       	movw	r30, r16
    130a:	d5 8f       	std	Z+29, r29	; 0x1d
			}

			xReturn = pdPASS;
    130c:	81 e0       	ldi	r24, 0x01	; 1
    130e:	07 c0       	rjmp	.+14     	; 0x131e <xQueueReceiveFromISR+0x60>
		}
		else
		{
			xReturn = pdFAIL;
    1310:	80 e0       	ldi	r24, 0x00	; 0
    1312:	05 c0       	rjmp	.+10     	; 0x131e <xQueueReceiveFromISR+0x60>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
			}

			xReturn = pdPASS;
    1314:	81 e0       	ldi	r24, 0x01	; 1
    1316:	03 c0       	rjmp	.+6      	; 0x131e <xQueueReceiveFromISR+0x60>
    1318:	81 e0       	ldi	r24, 0x01	; 1
    131a:	01 c0       	rjmp	.+2      	; 0x131e <xQueueReceiveFromISR+0x60>
    131c:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    131e:	df 91       	pop	r29
    1320:	cf 91       	pop	r28
    1322:	1f 91       	pop	r17
    1324:	0f 91       	pop	r16
    1326:	ff 90       	pop	r15
    1328:	ef 90       	pop	r14
    132a:	08 95       	ret

0000132c <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    132c:	0f 93       	push	r16
    132e:	1f 93       	push	r17
    1330:	cf 93       	push	r28
    1332:	df 93       	push	r29
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1334:	fc 01       	movw	r30, r24
    1336:	22 8d       	ldd	r18, Z+26	; 0x1a
    1338:	22 23       	and	r18, r18
    133a:	49 f0       	breq	.+18     	; 0x134e <xQueuePeekFromISR+0x22>
    133c:	ec 01       	movw	r28, r24
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    133e:	06 81       	ldd	r16, Z+6	; 0x06
    1340:	17 81       	ldd	r17, Z+7	; 0x07
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1342:	0e 94 ba 06 	call	0xd74	; 0xd74 <prvCopyDataFromQueue>
			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    1346:	1f 83       	std	Y+7, r17	; 0x07
    1348:	0e 83       	std	Y+6, r16	; 0x06

			xReturn = pdPASS;
    134a:	81 e0       	ldi	r24, 0x01	; 1
    134c:	01 c0       	rjmp	.+2      	; 0x1350 <xQueuePeekFromISR+0x24>
		}
		else
		{
			xReturn = pdFAIL;
    134e:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1350:	df 91       	pop	r29
    1352:	cf 91       	pop	r28
    1354:	1f 91       	pop	r17
    1356:	0f 91       	pop	r16
    1358:	08 95       	ret

0000135a <uxQueueMessagesWaiting>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    135a:	0f b6       	in	r0, 0x3f	; 63
    135c:	f8 94       	cli
    135e:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    1360:	fc 01       	movw	r30, r24
    1362:	82 8d       	ldd	r24, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    1364:	0f 90       	pop	r0
    1366:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1368:	08 95       	ret

0000136a <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    136a:	fc 01       	movw	r30, r24
Queue_t *pxQueue;

	pxQueue = ( Queue_t * ) xQueue;
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    136c:	0f b6       	in	r0, 0x3f	; 63
    136e:	f8 94       	cli
    1370:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    1372:	93 8d       	ldd	r25, Z+27	; 0x1b
    1374:	82 8d       	ldd	r24, Z+26	; 0x1a
    1376:	98 1b       	sub	r25, r24
    1378:	89 2f       	mov	r24, r25
	}
	taskEXIT_CRITICAL();
    137a:	0f 90       	pop	r0
    137c:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    137e:	08 95       	ret

00001380 <uxQueueMessagesWaitingFromISR>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    1380:	fc 01       	movw	r30, r24
    1382:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1384:	08 95       	ret

00001386 <vQueueDelete>:

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    1386:	0e 94 31 06 	call	0xc62	; 0xc62 <vPortFree>
    138a:	08 95       	ret

0000138c <xQueueIsQueueEmptyFromISR>:
BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
    138c:	fc 01       	movw	r30, r24
    138e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1390:	81 11       	cpse	r24, r1
    1392:	02 c0       	rjmp	.+4      	; 0x1398 <xQueueIsQueueEmptyFromISR+0xc>
	{
		xReturn = pdTRUE;
    1394:	81 e0       	ldi	r24, 0x01	; 1
    1396:	08 95       	ret
	}
	else
	{
		xReturn = pdFALSE;
    1398:	80 e0       	ldi	r24, 0x00	; 0
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    139a:	08 95       	ret

0000139c <xQueueIsQueueFullFromISR>:
BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
    139c:	fc 01       	movw	r30, r24
    139e:	22 8d       	ldd	r18, Z+26	; 0x1a
    13a0:	83 8d       	ldd	r24, Z+27	; 0x1b
    13a2:	28 13       	cpse	r18, r24
    13a4:	02 c0       	rjmp	.+4      	; 0x13aa <xQueueIsQueueFullFromISR+0xe>
	{
		xReturn = pdTRUE;
    13a6:	81 e0       	ldi	r24, 0x01	; 1
    13a8:	08 95       	ret
	}
	else
	{
		xReturn = pdFALSE;
    13aa:	80 e0       	ldi	r24, 0x00	; 0
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    13ac:	08 95       	ret

000013ae <xQueueCRSend>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait )
	{
    13ae:	ef 92       	push	r14
    13b0:	ff 92       	push	r15
    13b2:	0f 93       	push	r16
    13b4:	1f 93       	push	r17
    13b6:	cf 93       	push	r28
    13b8:	df 93       	push	r29
    13ba:	ec 01       	movw	r28, r24
    13bc:	7b 01       	movw	r14, r22
    13be:	8a 01       	movw	r16, r20
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;

		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    13c0:	f8 94       	cli
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    13c2:	0e 94 4d 06 	call	0xc9a	; 0xc9a <prvIsQueueFull>
    13c6:	88 23       	and	r24, r24
    13c8:	79 f0       	breq	.+30     	; 0x13e8 <xQueueCRSend+0x3a>
			{
				/* The queue is full - do we want to block or just leave without
				posting? */
				if( xTicksToWait > ( TickType_t ) 0 )
    13ca:	01 15       	cp	r16, r1
    13cc:	11 05       	cpc	r17, r1
    13ce:	49 f0       	breq	.+18     	; 0x13e2 <xQueueCRSend+0x34>
				{
					/* As this is called from a coroutine we cannot block directly, but
					return indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    13d0:	be 01       	movw	r22, r28
    13d2:	68 5f       	subi	r22, 0xF8	; 248
    13d4:	7f 4f       	sbci	r23, 0xFF	; 255
    13d6:	c8 01       	movw	r24, r16
    13d8:	0e 94 ba 01 	call	0x374	; 0x374 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    13dc:	78 94       	sei
					return errQUEUE_BLOCKED;
    13de:	8c ef       	ldi	r24, 0xFC	; 252
    13e0:	1f c0       	rjmp	.+62     	; 0x1420 <xQueueCRSend+0x72>
				}
				else
				{
					portENABLE_INTERRUPTS();
    13e2:	78 94       	sei
					return errQUEUE_FULL;
    13e4:	80 e0       	ldi	r24, 0x00	; 0
    13e6:	1c c0       	rjmp	.+56     	; 0x1420 <xQueueCRSend+0x72>
				}
			}
		}
		portENABLE_INTERRUPTS();
    13e8:	78 94       	sei

		portDISABLE_INTERRUPTS();
    13ea:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    13ec:	9a 8d       	ldd	r25, Y+26	; 0x1a
    13ee:	8b 8d       	ldd	r24, Y+27	; 0x1b
    13f0:	98 17       	cp	r25, r24
    13f2:	80 f4       	brcc	.+32     	; 0x1414 <xQueueCRSend+0x66>
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    13f4:	40 e0       	ldi	r20, 0x00	; 0
    13f6:	b7 01       	movw	r22, r14
    13f8:	ce 01       	movw	r24, r28
    13fa:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <prvCopyDataToQueue>
				xReturn = pdPASS;

				/* Were any co-routines waiting for data to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    13fe:	89 89       	ldd	r24, Y+17	; 0x11
    1400:	88 23       	and	r24, r24
    1402:	51 f0       	breq	.+20     	; 0x1418 <xQueueCRSend+0x6a>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1404:	ce 01       	movw	r24, r28
    1406:	41 96       	adiw	r24, 0x11	; 17
    1408:	0e 94 55 02 	call	0x4aa	; 0x4aa <xCoRoutineRemoveFromEventList>
    140c:	81 11       	cpse	r24, r1
    140e:	06 c0       	rjmp	.+12     	; 0x141c <xQueueCRSend+0x6e>
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
				xReturn = pdPASS;
    1410:	81 e0       	ldi	r24, 0x01	; 1
    1412:	05 c0       	rjmp	.+10     	; 0x141e <xQueueCRSend+0x70>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = errQUEUE_FULL;
    1414:	80 e0       	ldi	r24, 0x00	; 0
    1416:	03 c0       	rjmp	.+6      	; 0x141e <xQueueCRSend+0x70>
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
				xReturn = pdPASS;
    1418:	81 e0       	ldi	r24, 0x01	; 1
    141a:	01 c0       	rjmp	.+2      	; 0x141e <xQueueCRSend+0x70>
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
					{
						/* The co-routine waiting has a higher priority so record
						that a yield might be appropriate. */
						xReturn = errQUEUE_YIELD;
    141c:	8b ef       	ldi	r24, 0xFB	; 251
			else
			{
				xReturn = errQUEUE_FULL;
			}
		}
		portENABLE_INTERRUPTS();
    141e:	78 94       	sei

		return xReturn;
	}
    1420:	df 91       	pop	r29
    1422:	cf 91       	pop	r28
    1424:	1f 91       	pop	r17
    1426:	0f 91       	pop	r16
    1428:	ff 90       	pop	r15
    142a:	ef 90       	pop	r14
    142c:	08 95       	ret

0000142e <xQueueCRReceive>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
	{
    142e:	cf 93       	push	r28
    1430:	df 93       	push	r29
    1432:	ec 01       	movw	r28, r24
    1434:	9b 01       	movw	r18, r22
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;

		/* If the queue is already empty we may have to block.  A critical section
		is required to prevent an interrupt adding something to the queue
		between the check to see if the queue is empty and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    1436:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1438:	9a 8d       	ldd	r25, Y+26	; 0x1a
    143a:	91 11       	cpse	r25, r1
    143c:	0f c0       	rjmp	.+30     	; 0x145c <xQueueCRReceive+0x2e>
			{
				/* There are no messages in the queue, do we want to block or just
				leave with nothing? */
				if( xTicksToWait > ( TickType_t ) 0 )
    143e:	41 15       	cp	r20, r1
    1440:	51 05       	cpc	r21, r1
    1442:	49 f0       	breq	.+18     	; 0x1456 <xQueueCRReceive+0x28>
				{
					/* As this is a co-routine we cannot block directly, but return
					indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    1444:	be 01       	movw	r22, r28
    1446:	6f 5e       	subi	r22, 0xEF	; 239
    1448:	7f 4f       	sbci	r23, 0xFF	; 255
    144a:	ca 01       	movw	r24, r20
    144c:	0e 94 ba 01 	call	0x374	; 0x374 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    1450:	78 94       	sei
					return errQUEUE_BLOCKED;
    1452:	8c ef       	ldi	r24, 0xFC	; 252
    1454:	32 c0       	rjmp	.+100    	; 0x14ba <xQueueCRReceive+0x8c>
				}
				else
				{
					portENABLE_INTERRUPTS();
    1456:	78 94       	sei
					return errQUEUE_FULL;
    1458:	80 e0       	ldi	r24, 0x00	; 0
    145a:	2f c0       	rjmp	.+94     	; 0x14ba <xQueueCRReceive+0x8c>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portENABLE_INTERRUPTS();
    145c:	78 94       	sei

		portDISABLE_INTERRUPTS();
    145e:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1460:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1462:	88 23       	and	r24, r24
    1464:	21 f1       	breq	.+72     	; 0x14ae <xQueueCRReceive+0x80>
			{
				/* Data is available from the queue. */
				pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    1466:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1468:	50 e0       	ldi	r21, 0x00	; 0
    146a:	8e 81       	ldd	r24, Y+6	; 0x06
    146c:	9f 81       	ldd	r25, Y+7	; 0x07
    146e:	84 0f       	add	r24, r20
    1470:	95 1f       	adc	r25, r21
    1472:	9f 83       	std	Y+7, r25	; 0x07
    1474:	8e 83       	std	Y+6, r24	; 0x06
				if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
    1476:	6a 81       	ldd	r22, Y+2	; 0x02
    1478:	7b 81       	ldd	r23, Y+3	; 0x03
    147a:	86 17       	cp	r24, r22
    147c:	97 07       	cpc	r25, r23
    147e:	20 f0       	brcs	.+8      	; 0x1488 <xQueueCRReceive+0x5a>
				{
					pxQueue->u.pcReadFrom = pxQueue->pcHead;
    1480:	88 81       	ld	r24, Y
    1482:	99 81       	ldd	r25, Y+1	; 0x01
    1484:	9f 83       	std	Y+7, r25	; 0x07
    1486:	8e 83       	std	Y+6, r24	; 0x06
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
    1488:	8a 8d       	ldd	r24, Y+26	; 0x1a
    148a:	81 50       	subi	r24, 0x01	; 1
    148c:	8a 8f       	std	Y+26, r24	; 0x1a
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    148e:	6e 81       	ldd	r22, Y+6	; 0x06
    1490:	7f 81       	ldd	r23, Y+7	; 0x07
    1492:	c9 01       	movw	r24, r18
    1494:	0e 94 dd 14 	call	0x29ba	; 0x29ba <memcpy>

				xReturn = pdPASS;

				/* Were any co-routines waiting for space to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1498:	88 85       	ldd	r24, Y+8	; 0x08
    149a:	88 23       	and	r24, r24
    149c:	51 f0       	breq	.+20     	; 0x14b2 <xQueueCRReceive+0x84>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    149e:	ce 01       	movw	r24, r28
    14a0:	08 96       	adiw	r24, 0x08	; 8
    14a2:	0e 94 55 02 	call	0x4aa	; 0x4aa <xCoRoutineRemoveFromEventList>
    14a6:	81 11       	cpse	r24, r1
    14a8:	06 c0       	rjmp	.+12     	; 0x14b6 <xQueueCRReceive+0x88>
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

				xReturn = pdPASS;
    14aa:	81 e0       	ldi	r24, 0x01	; 1
    14ac:	05 c0       	rjmp	.+10     	; 0x14b8 <xQueueCRReceive+0x8a>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = pdFAIL;
    14ae:	80 e0       	ldi	r24, 0x00	; 0
    14b0:	03 c0       	rjmp	.+6      	; 0x14b8 <xQueueCRReceive+0x8a>
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

				xReturn = pdPASS;
    14b2:	81 e0       	ldi	r24, 0x01	; 1
    14b4:	01 c0       	rjmp	.+2      	; 0x14b8 <xQueueCRReceive+0x8a>
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
					{
						xReturn = errQUEUE_YIELD;
    14b6:	8b ef       	ldi	r24, 0xFB	; 251
			else
			{
				xReturn = pdFAIL;
			}
		}
		portENABLE_INTERRUPTS();
    14b8:	78 94       	sei

		return xReturn;
	}
    14ba:	df 91       	pop	r29
    14bc:	cf 91       	pop	r28
    14be:	08 95       	ret

000014c0 <xQueueCRSendFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken )
	{
    14c0:	0f 93       	push	r16
    14c2:	1f 93       	push	r17
    14c4:	cf 93       	push	r28
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;

		/* Cannot block within an ISR so if there is no space on the queue then
		exit without doing anything. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    14c6:	fc 01       	movw	r30, r24
    14c8:	32 8d       	ldd	r19, Z+26	; 0x1a
    14ca:	23 8d       	ldd	r18, Z+27	; 0x1b
    14cc:	32 17       	cp	r19, r18
    14ce:	98 f4       	brcc	.+38     	; 0x14f6 <xQueueCRSendFromISR+0x36>
    14d0:	c4 2f       	mov	r28, r20
    14d2:	8c 01       	movw	r16, r24
		{
			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    14d4:	40 e0       	ldi	r20, 0x00	; 0
    14d6:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <prvCopyDataToQueue>

			/* We only want to wake one co-routine per ISR, so check that a
			co-routine has not already been woken. */
			if( xCoRoutinePreviouslyWoken == pdFALSE )
    14da:	c1 11       	cpse	r28, r1
    14dc:	0e c0       	rjmp	.+28     	; 0x14fa <xQueueCRSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    14de:	f8 01       	movw	r30, r16
    14e0:	81 89       	ldd	r24, Z+17	; 0x11
    14e2:	88 23       	and	r24, r24
    14e4:	61 f0       	breq	.+24     	; 0x14fe <xQueueCRSendFromISR+0x3e>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    14e6:	c8 01       	movw	r24, r16
    14e8:	41 96       	adiw	r24, 0x11	; 17
    14ea:	0e 94 55 02 	call	0x4aa	; 0x4aa <xCoRoutineRemoveFromEventList>
    14ee:	88 23       	and	r24, r24
    14f0:	41 f0       	breq	.+16     	; 0x1502 <xQueueCRSendFromISR+0x42>
					{
						return pdTRUE;
    14f2:	81 e0       	ldi	r24, 0x01	; 1
    14f4:	07 c0       	rjmp	.+14     	; 0x1504 <xQueueCRSendFromISR+0x44>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xCoRoutinePreviouslyWoken;
    14f6:	84 2f       	mov	r24, r20
    14f8:	05 c0       	rjmp	.+10     	; 0x1504 <xQueueCRSendFromISR+0x44>
    14fa:	8c 2f       	mov	r24, r28
    14fc:	03 c0       	rjmp	.+6      	; 0x1504 <xQueueCRSendFromISR+0x44>
    14fe:	8c 2f       	mov	r24, r28
    1500:	01 c0       	rjmp	.+2      	; 0x1504 <xQueueCRSendFromISR+0x44>
    1502:	8c 2f       	mov	r24, r28
	}
    1504:	cf 91       	pop	r28
    1506:	1f 91       	pop	r17
    1508:	0f 91       	pop	r16
    150a:	08 95       	ret

0000150c <xQueueCRReceiveFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWoken )
	{
    150c:	0f 93       	push	r16
    150e:	1f 93       	push	r17
    1510:	cf 93       	push	r28
    1512:	df 93       	push	r29
    1514:	fc 01       	movw	r30, r24
	BaseType_t xReturn;
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;

		/* We cannot block from an ISR, so check there is data available. If
		not then just leave without doing anything. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1516:	82 8d       	ldd	r24, Z+26	; 0x1a
    1518:	88 23       	and	r24, r24
    151a:	69 f1       	breq	.+90     	; 0x1576 <xQueueCRReceiveFromISR+0x6a>
		{
			/* Copy the data from the queue. */
			pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    151c:	24 8d       	ldd	r18, Z+28	; 0x1c
    151e:	30 e0       	ldi	r19, 0x00	; 0
    1520:	a6 81       	ldd	r26, Z+6	; 0x06
    1522:	b7 81       	ldd	r27, Z+7	; 0x07
    1524:	a2 0f       	add	r26, r18
    1526:	b3 1f       	adc	r27, r19
    1528:	b7 83       	std	Z+7, r27	; 0x07
    152a:	a6 83       	std	Z+6, r26	; 0x06
			if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
    152c:	82 81       	ldd	r24, Z+2	; 0x02
    152e:	93 81       	ldd	r25, Z+3	; 0x03
    1530:	a8 17       	cp	r26, r24
    1532:	b9 07       	cpc	r27, r25
    1534:	20 f0       	brcs	.+8      	; 0x153e <xQueueCRReceiveFromISR+0x32>
			{
				pxQueue->u.pcReadFrom = pxQueue->pcHead;
    1536:	80 81       	ld	r24, Z
    1538:	91 81       	ldd	r25, Z+1	; 0x01
    153a:	97 83       	std	Z+7, r25	; 0x07
    153c:	86 83       	std	Z+6, r24	; 0x06
    153e:	8a 01       	movw	r16, r20
    1540:	cb 01       	movw	r24, r22
    1542:	ef 01       	movw	r28, r30
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
			--( pxQueue->uxMessagesWaiting );
    1544:	42 8d       	ldd	r20, Z+26	; 0x1a
    1546:	41 50       	subi	r20, 0x01	; 1
    1548:	42 8f       	std	Z+26, r20	; 0x1a
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    154a:	66 81       	ldd	r22, Z+6	; 0x06
    154c:	77 81       	ldd	r23, Z+7	; 0x07
    154e:	a9 01       	movw	r20, r18
    1550:	0e 94 dd 14 	call	0x29ba	; 0x29ba <memcpy>

			if( ( *pxCoRoutineWoken ) == pdFALSE )
    1554:	f8 01       	movw	r30, r16
    1556:	80 81       	ld	r24, Z
    1558:	81 11       	cpse	r24, r1
    155a:	0f c0       	rjmp	.+30     	; 0x157a <xQueueCRReceiveFromISR+0x6e>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    155c:	88 85       	ldd	r24, Y+8	; 0x08
    155e:	88 23       	and	r24, r24
    1560:	71 f0       	breq	.+28     	; 0x157e <xQueueCRReceiveFromISR+0x72>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1562:	ce 01       	movw	r24, r28
    1564:	08 96       	adiw	r24, 0x08	; 8
    1566:	0e 94 55 02 	call	0x4aa	; 0x4aa <xCoRoutineRemoveFromEventList>
    156a:	88 23       	and	r24, r24
    156c:	51 f0       	breq	.+20     	; 0x1582 <xQueueCRReceiveFromISR+0x76>
					{
						*pxCoRoutineWoken = pdTRUE;
    156e:	81 e0       	ldi	r24, 0x01	; 1
    1570:	f8 01       	movw	r30, r16
    1572:	80 83       	st	Z, r24
    1574:	07 c0       	rjmp	.+14     	; 0x1584 <xQueueCRReceiveFromISR+0x78>

			xReturn = pdPASS;
		}
		else
		{
			xReturn = pdFAIL;
    1576:	80 e0       	ldi	r24, 0x00	; 0
    1578:	05 c0       	rjmp	.+10     	; 0x1584 <xQueueCRReceiveFromISR+0x78>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			xReturn = pdPASS;
    157a:	81 e0       	ldi	r24, 0x01	; 1
    157c:	03 c0       	rjmp	.+6      	; 0x1584 <xQueueCRReceiveFromISR+0x78>
    157e:	81 e0       	ldi	r24, 0x01	; 1
    1580:	01 c0       	rjmp	.+2      	; 0x1584 <xQueueCRReceiveFromISR+0x78>
    1582:	81 e0       	ldi	r24, 0x01	; 1
		{
			xReturn = pdFAIL;
		}

		return xReturn;
	}
    1584:	df 91       	pop	r29
    1586:	cf 91       	pop	r28
    1588:	1f 91       	pop	r17
    158a:	0f 91       	pop	r16
    158c:	08 95       	ret

0000158e <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    158e:	e0 91 79 0d 	lds	r30, 0x0D79	; 0x800d79 <pxDelayedTaskList>
    1592:	f0 91 7a 0d 	lds	r31, 0x0D7A	; 0x800d7a <pxDelayedTaskList+0x1>
    1596:	80 81       	ld	r24, Z
    1598:	81 11       	cpse	r24, r1
    159a:	07 c0       	rjmp	.+14     	; 0x15aa <prvResetNextTaskUnblockTime+0x1c>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    159c:	8f ef       	ldi	r24, 0xFF	; 255
    159e:	9f ef       	ldi	r25, 0xFF	; 255
    15a0:	90 93 64 0d 	sts	0x0D64, r25	; 0x800d64 <xNextTaskUnblockTime+0x1>
    15a4:	80 93 63 0d 	sts	0x0D63, r24	; 0x800d63 <xNextTaskUnblockTime>
    15a8:	08 95       	ret
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    15aa:	e0 91 79 0d 	lds	r30, 0x0D79	; 0x800d79 <pxDelayedTaskList>
    15ae:	f0 91 7a 0d 	lds	r31, 0x0D7A	; 0x800d7a <pxDelayedTaskList+0x1>
    15b2:	05 80       	ldd	r0, Z+5	; 0x05
    15b4:	f6 81       	ldd	r31, Z+6	; 0x06
    15b6:	e0 2d       	mov	r30, r0
    15b8:	06 80       	ldd	r0, Z+6	; 0x06
    15ba:	f7 81       	ldd	r31, Z+7	; 0x07
    15bc:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    15be:	82 81       	ldd	r24, Z+2	; 0x02
    15c0:	93 81       	ldd	r25, Z+3	; 0x03
    15c2:	90 93 64 0d 	sts	0x0D64, r25	; 0x800d64 <xNextTaskUnblockTime+0x1>
    15c6:	80 93 63 0d 	sts	0x0D63, r24	; 0x800d63 <xNextTaskUnblockTime>
    15ca:	08 95       	ret

000015cc <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    15cc:	6f 92       	push	r6
    15ce:	7f 92       	push	r7
    15d0:	8f 92       	push	r8
    15d2:	9f 92       	push	r9
    15d4:	af 92       	push	r10
    15d6:	bf 92       	push	r11
    15d8:	cf 92       	push	r12
    15da:	df 92       	push	r13
    15dc:	ef 92       	push	r14
    15de:	0f 93       	push	r16
    15e0:	1f 93       	push	r17
    15e2:	cf 93       	push	r28
    15e4:	df 93       	push	r29
    15e6:	cd b7       	in	r28, 0x3d	; 61
    15e8:	de b7       	in	r29, 0x3e	; 62
    15ea:	4c 01       	movw	r8, r24
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
    15ec:	f5 01       	movw	r30, r10
    15ee:	87 89       	ldd	r24, Z+23	; 0x17
    15f0:	90 8d       	ldd	r25, Z+24	; 0x18
    15f2:	21 50       	subi	r18, 0x01	; 1
    15f4:	31 09       	sbc	r19, r1
    15f6:	3c 01       	movw	r6, r24
    15f8:	62 0e       	add	r6, r18
    15fa:	73 1e       	adc	r7, r19
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    15fc:	20 e0       	ldi	r18, 0x00	; 0
    15fe:	0f c0       	rjmp	.+30     	; 0x161e <prvInitialiseNewTask+0x52>
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    1600:	82 2f       	mov	r24, r18
    1602:	90 e0       	ldi	r25, 0x00	; 0
    1604:	fb 01       	movw	r30, r22
    1606:	e8 0f       	add	r30, r24
    1608:	f9 1f       	adc	r31, r25
    160a:	30 81       	ld	r19, Z
    160c:	d5 01       	movw	r26, r10
    160e:	a8 0f       	add	r26, r24
    1610:	b9 1f       	adc	r27, r25
    1612:	59 96       	adiw	r26, 0x19	; 25
    1614:	3c 93       	st	X, r19

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    1616:	80 81       	ld	r24, Z
    1618:	88 23       	and	r24, r24
    161a:	19 f0       	breq	.+6      	; 0x1622 <prvInitialiseNewTask+0x56>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    161c:	2f 5f       	subi	r18, 0xFF	; 255
    161e:	28 30       	cpi	r18, 0x08	; 8
    1620:	78 f3       	brcs	.-34     	; 0x1600 <prvInitialiseNewTask+0x34>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    1622:	f5 01       	movw	r30, r10
    1624:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    1626:	f3 e0       	ldi	r31, 0x03	; 3
    1628:	fe 15       	cp	r31, r14
    162a:	20 f4       	brcc	.+8      	; 0x1634 <prvInitialiseNewTask+0x68>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    162c:	0f 2e       	mov	r0, r31
    162e:	f3 e0       	ldi	r31, 0x03	; 3
    1630:	ef 2e       	mov	r14, r31
    1632:	f0 2d       	mov	r31, r0
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    1634:	f5 01       	movw	r30, r10
    1636:	e6 8a       	std	Z+22, r14	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
    1638:	e1 a2       	std	Z+33, r14	; 0x21
		pxNewTCB->uxMutexesHeld = 0;
    163a:	12 a2       	std	Z+34, r1	; 0x22
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    163c:	c5 01       	movw	r24, r10
    163e:	02 96       	adiw	r24, 0x02	; 2
    1640:	0e 94 22 04 	call	0x844	; 0x844 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    1644:	c5 01       	movw	r24, r10
    1646:	0c 96       	adiw	r24, 0x0c	; 12
    1648:	0e 94 22 04 	call	0x844	; 0x844 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    164c:	f5 01       	movw	r30, r10
    164e:	b1 86       	std	Z+9, r11	; 0x09
    1650:	a0 86       	std	Z+8, r10	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1652:	84 e0       	ldi	r24, 0x04	; 4
    1654:	90 e0       	ldi	r25, 0x00	; 0
    1656:	8e 19       	sub	r24, r14
    1658:	91 09       	sbc	r25, r1
    165a:	95 87       	std	Z+13, r25	; 0x0d
    165c:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    165e:	b3 8a       	std	Z+19, r11	; 0x13
    1660:	a2 8a       	std	Z+18, r10	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    1662:	13 a2       	std	Z+35, r1	; 0x23
    1664:	14 a2       	std	Z+36, r1	; 0x24
    1666:	15 a2       	std	Z+37, r1	; 0x25
    1668:	16 a2       	std	Z+38, r1	; 0x26
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    166a:	17 a2       	std	Z+39, r1	; 0x27
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    166c:	a8 01       	movw	r20, r16
    166e:	b4 01       	movw	r22, r8
    1670:	c3 01       	movw	r24, r6
    1672:	0e 94 a8 04 	call	0x950	; 0x950 <pxPortInitialiseStack>
    1676:	f5 01       	movw	r30, r10
    1678:	91 83       	std	Z+1, r25	; 0x01
    167a:	80 83       	st	Z, r24
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( ( void * ) pxCreatedTask != NULL )
    167c:	c1 14       	cp	r12, r1
    167e:	d1 04       	cpc	r13, r1
    1680:	19 f0       	breq	.+6      	; 0x1688 <prvInitialiseNewTask+0xbc>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    1682:	f6 01       	movw	r30, r12
    1684:	b1 82       	std	Z+1, r11	; 0x01
    1686:	a0 82       	st	Z, r10
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    1688:	df 91       	pop	r29
    168a:	cf 91       	pop	r28
    168c:	1f 91       	pop	r17
    168e:	0f 91       	pop	r16
    1690:	ef 90       	pop	r14
    1692:	df 90       	pop	r13
    1694:	cf 90       	pop	r12
    1696:	bf 90       	pop	r11
    1698:	af 90       	pop	r10
    169a:	9f 90       	pop	r9
    169c:	8f 90       	pop	r8
    169e:	7f 90       	pop	r7
    16a0:	6f 90       	pop	r6
    16a2:	08 95       	ret

000016a4 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    16a4:	cf 93       	push	r28
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    16a6:	c0 e0       	ldi	r28, 0x00	; 0
    16a8:	10 c0       	rjmp	.+32     	; 0x16ca <prvInitialiseTaskLists+0x26>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    16aa:	8c 2f       	mov	r24, r28
    16ac:	90 e0       	ldi	r25, 0x00	; 0
    16ae:	9c 01       	movw	r18, r24
    16b0:	22 0f       	add	r18, r18
    16b2:	33 1f       	adc	r19, r19
    16b4:	22 0f       	add	r18, r18
    16b6:	33 1f       	adc	r19, r19
    16b8:	22 0f       	add	r18, r18
    16ba:	33 1f       	adc	r19, r19
    16bc:	82 0f       	add	r24, r18
    16be:	93 1f       	adc	r25, r19
    16c0:	83 57       	subi	r24, 0x73	; 115
    16c2:	92 4f       	sbci	r25, 0xF2	; 242
    16c4:	0e 94 14 04 	call	0x828	; 0x828 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    16c8:	cf 5f       	subi	r28, 0xFF	; 255
    16ca:	c4 30       	cpi	r28, 0x04	; 4
    16cc:	70 f3       	brcs	.-36     	; 0x16aa <prvInitialiseTaskLists+0x6>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    16ce:	84 e8       	ldi	r24, 0x84	; 132
    16d0:	9d e0       	ldi	r25, 0x0D	; 13
    16d2:	0e 94 14 04 	call	0x828	; 0x828 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    16d6:	8b e7       	ldi	r24, 0x7B	; 123
    16d8:	9d e0       	ldi	r25, 0x0D	; 13
    16da:	0e 94 14 04 	call	0x828	; 0x828 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    16de:	8e e6       	ldi	r24, 0x6E	; 110
    16e0:	9d e0       	ldi	r25, 0x0D	; 13
    16e2:	0e 94 14 04 	call	0x828	; 0x828 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    16e6:	84 e8       	ldi	r24, 0x84	; 132
    16e8:	9d e0       	ldi	r25, 0x0D	; 13
    16ea:	90 93 7a 0d 	sts	0x0D7A, r25	; 0x800d7a <pxDelayedTaskList+0x1>
    16ee:	80 93 79 0d 	sts	0x0D79, r24	; 0x800d79 <pxDelayedTaskList>
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    16f2:	8b e7       	ldi	r24, 0x7B	; 123
    16f4:	9d e0       	ldi	r25, 0x0D	; 13
    16f6:	90 93 78 0d 	sts	0x0D78, r25	; 0x800d78 <pxOverflowDelayedTaskList+0x1>
    16fa:	80 93 77 0d 	sts	0x0D77, r24	; 0x800d77 <pxOverflowDelayedTaskList>
}
    16fe:	cf 91       	pop	r28
    1700:	08 95       	ret

00001702 <prvAddNewTaskToReadyList>:
	}
}
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
    1702:	cf 93       	push	r28
    1704:	df 93       	push	r29
    1706:	ec 01       	movw	r28, r24
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    1708:	0f b6       	in	r0, 0x3f	; 63
    170a:	f8 94       	cli
    170c:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    170e:	80 91 6d 0d 	lds	r24, 0x0D6D	; 0x800d6d <uxCurrentNumberOfTasks>
    1712:	8f 5f       	subi	r24, 0xFF	; 255
    1714:	80 93 6d 0d 	sts	0x0D6D, r24	; 0x800d6d <uxCurrentNumberOfTasks>
		if( pxCurrentTCB == NULL )
    1718:	80 91 b1 0d 	lds	r24, 0x0DB1	; 0x800db1 <pxCurrentTCB>
    171c:	90 91 b2 0d 	lds	r25, 0x0DB2	; 0x800db2 <pxCurrentTCB+0x1>
    1720:	89 2b       	or	r24, r25
    1722:	59 f4       	brne	.+22     	; 0x173a <prvAddNewTaskToReadyList+0x38>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    1724:	d0 93 b2 0d 	sts	0x0DB2, r29	; 0x800db2 <pxCurrentTCB+0x1>
    1728:	c0 93 b1 0d 	sts	0x0DB1, r28	; 0x800db1 <pxCurrentTCB>

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    172c:	80 91 6d 0d 	lds	r24, 0x0D6D	; 0x800d6d <uxCurrentNumberOfTasks>
    1730:	81 30       	cpi	r24, 0x01	; 1
    1732:	99 f4       	brne	.+38     	; 0x175a <prvAddNewTaskToReadyList+0x58>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
    1734:	0e 94 52 0b 	call	0x16a4	; 0x16a4 <prvInitialiseTaskLists>
    1738:	10 c0       	rjmp	.+32     	; 0x175a <prvAddNewTaskToReadyList+0x58>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    173a:	80 91 69 0d 	lds	r24, 0x0D69	; 0x800d69 <xSchedulerRunning>
    173e:	81 11       	cpse	r24, r1
    1740:	0c c0       	rjmp	.+24     	; 0x175a <prvAddNewTaskToReadyList+0x58>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    1742:	e0 91 b1 0d 	lds	r30, 0x0DB1	; 0x800db1 <pxCurrentTCB>
    1746:	f0 91 b2 0d 	lds	r31, 0x0DB2	; 0x800db2 <pxCurrentTCB+0x1>
    174a:	96 89       	ldd	r25, Z+22	; 0x16
    174c:	8e 89       	ldd	r24, Y+22	; 0x16
    174e:	89 17       	cp	r24, r25
    1750:	20 f0       	brcs	.+8      	; 0x175a <prvAddNewTaskToReadyList+0x58>
				{
					pxCurrentTCB = pxNewTCB;
    1752:	d0 93 b2 0d 	sts	0x0DB2, r29	; 0x800db2 <pxCurrentTCB+0x1>
    1756:	c0 93 b1 0d 	sts	0x0DB1, r28	; 0x800db1 <pxCurrentTCB>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    175a:	80 91 65 0d 	lds	r24, 0x0D65	; 0x800d65 <uxTaskNumber>
    175e:	8f 5f       	subi	r24, 0xFF	; 255
    1760:	80 93 65 0d 	sts	0x0D65, r24	; 0x800d65 <uxTaskNumber>
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    1764:	8e 89       	ldd	r24, Y+22	; 0x16
    1766:	90 91 6a 0d 	lds	r25, 0x0D6A	; 0x800d6a <uxTopReadyPriority>
    176a:	98 17       	cp	r25, r24
    176c:	10 f4       	brcc	.+4      	; 0x1772 <prvAddNewTaskToReadyList+0x70>
    176e:	80 93 6a 0d 	sts	0x0D6A, r24	; 0x800d6a <uxTopReadyPriority>
    1772:	90 e0       	ldi	r25, 0x00	; 0
    1774:	9c 01       	movw	r18, r24
    1776:	22 0f       	add	r18, r18
    1778:	33 1f       	adc	r19, r19
    177a:	22 0f       	add	r18, r18
    177c:	33 1f       	adc	r19, r19
    177e:	22 0f       	add	r18, r18
    1780:	33 1f       	adc	r19, r19
    1782:	82 0f       	add	r24, r18
    1784:	93 1f       	adc	r25, r19
    1786:	be 01       	movw	r22, r28
    1788:	6e 5f       	subi	r22, 0xFE	; 254
    178a:	7f 4f       	sbci	r23, 0xFF	; 255
    178c:	83 57       	subi	r24, 0x73	; 115
    178e:	92 4f       	sbci	r25, 0xF2	; 242
    1790:	0e 94 26 04 	call	0x84c	; 0x84c <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    1794:	0f 90       	pop	r0
    1796:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    1798:	80 91 69 0d 	lds	r24, 0x0D69	; 0x800d69 <xSchedulerRunning>
    179c:	88 23       	and	r24, r24
    179e:	51 f0       	breq	.+20     	; 0x17b4 <prvAddNewTaskToReadyList+0xb2>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    17a0:	e0 91 b1 0d 	lds	r30, 0x0DB1	; 0x800db1 <pxCurrentTCB>
    17a4:	f0 91 b2 0d 	lds	r31, 0x0DB2	; 0x800db2 <pxCurrentTCB+0x1>
    17a8:	96 89       	ldd	r25, Z+22	; 0x16
    17aa:	8e 89       	ldd	r24, Y+22	; 0x16
    17ac:	98 17       	cp	r25, r24
    17ae:	10 f4       	brcc	.+4      	; 0x17b4 <prvAddNewTaskToReadyList+0xb2>
		{
			taskYIELD_IF_USING_PREEMPTION();
    17b0:	0e 94 44 05 	call	0xa88	; 0xa88 <vPortYield>
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    17b4:	df 91       	pop	r29
    17b6:	cf 91       	pop	r28
    17b8:	08 95       	ret

000017ba <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    17ba:	0f 93       	push	r16
    17bc:	1f 93       	push	r17
    17be:	cf 93       	push	r28
    17c0:	df 93       	push	r29
    17c2:	ec 01       	movw	r28, r24
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    17c4:	00 91 6b 0d 	lds	r16, 0x0D6B	; 0x800d6b <xTickCount>
    17c8:	10 91 6c 0d 	lds	r17, 0x0D6C	; 0x800d6c <xTickCount+0x1>
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    17cc:	80 91 b1 0d 	lds	r24, 0x0DB1	; 0x800db1 <pxCurrentTCB>
    17d0:	90 91 b2 0d 	lds	r25, 0x0DB2	; 0x800db2 <pxCurrentTCB+0x1>
    17d4:	02 96       	adiw	r24, 0x02	; 2
    17d6:	0e 94 78 04 	call	0x8f0	; 0x8f0 <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
		/* Calculate the time at which the task should be woken if the event
		does not occur.  This may overflow but this doesn't matter, the kernel
		will manage it correctly. */
		xTimeToWake = xConstTickCount + xTicksToWait;
    17da:	c0 0f       	add	r28, r16
    17dc:	d1 1f       	adc	r29, r17

		/* The list item will be inserted in wake time order. */
		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    17de:	e0 91 b1 0d 	lds	r30, 0x0DB1	; 0x800db1 <pxCurrentTCB>
    17e2:	f0 91 b2 0d 	lds	r31, 0x0DB2	; 0x800db2 <pxCurrentTCB+0x1>
    17e6:	d3 83       	std	Z+3, r29	; 0x03
    17e8:	c2 83       	std	Z+2, r28	; 0x02

		if( xTimeToWake < xConstTickCount )
    17ea:	c0 17       	cp	r28, r16
    17ec:	d1 07       	cpc	r29, r17
    17ee:	68 f4       	brcc	.+26     	; 0x180a <prvAddCurrentTaskToDelayedList+0x50>
		{
			/* Wake time has overflowed.  Place this item in the overflow list. */
			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    17f0:	60 91 b1 0d 	lds	r22, 0x0DB1	; 0x800db1 <pxCurrentTCB>
    17f4:	70 91 b2 0d 	lds	r23, 0x0DB2	; 0x800db2 <pxCurrentTCB+0x1>
    17f8:	80 91 77 0d 	lds	r24, 0x0D77	; 0x800d77 <pxOverflowDelayedTaskList>
    17fc:	90 91 78 0d 	lds	r25, 0x0D78	; 0x800d78 <pxOverflowDelayedTaskList+0x1>
    1800:	6e 5f       	subi	r22, 0xFE	; 254
    1802:	7f 4f       	sbci	r23, 0xFF	; 255
    1804:	0e 94 47 04 	call	0x88e	; 0x88e <vListInsert>
    1808:	17 c0       	rjmp	.+46     	; 0x1838 <prvAddCurrentTaskToDelayedList+0x7e>
		}
		else
		{
			/* The wake time has not overflowed, so the current block list is used. */
			vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    180a:	60 91 b1 0d 	lds	r22, 0x0DB1	; 0x800db1 <pxCurrentTCB>
    180e:	70 91 b2 0d 	lds	r23, 0x0DB2	; 0x800db2 <pxCurrentTCB+0x1>
    1812:	80 91 79 0d 	lds	r24, 0x0D79	; 0x800d79 <pxDelayedTaskList>
    1816:	90 91 7a 0d 	lds	r25, 0x0D7A	; 0x800d7a <pxDelayedTaskList+0x1>
    181a:	6e 5f       	subi	r22, 0xFE	; 254
    181c:	7f 4f       	sbci	r23, 0xFF	; 255
    181e:	0e 94 47 04 	call	0x88e	; 0x88e <vListInsert>

			/* If the task entering the blocked state was placed at the head of the
			list of blocked tasks then xNextTaskUnblockTime needs to be updated
			too. */
			if( xTimeToWake < xNextTaskUnblockTime )
    1822:	80 91 63 0d 	lds	r24, 0x0D63	; 0x800d63 <xNextTaskUnblockTime>
    1826:	90 91 64 0d 	lds	r25, 0x0D64	; 0x800d64 <xNextTaskUnblockTime+0x1>
    182a:	c8 17       	cp	r28, r24
    182c:	d9 07       	cpc	r29, r25
    182e:	20 f4       	brcc	.+8      	; 0x1838 <prvAddCurrentTaskToDelayedList+0x7e>
			{
				xNextTaskUnblockTime = xTimeToWake;
    1830:	d0 93 64 0d 	sts	0x0D64, r29	; 0x800d64 <xNextTaskUnblockTime+0x1>
    1834:	c0 93 63 0d 	sts	0x0D63, r28	; 0x800d63 <xNextTaskUnblockTime>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    1838:	df 91       	pop	r29
    183a:	cf 91       	pop	r28
    183c:	1f 91       	pop	r17
    183e:	0f 91       	pop	r16
    1840:	08 95       	ret

00001842 <prvIdleTask>:

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    1842:	80 91 8d 0d 	lds	r24, 0x0D8D	; 0x800d8d <pxReadyTasksLists>
    1846:	82 30       	cpi	r24, 0x02	; 2
    1848:	10 f0       	brcs	.+4      	; 0x184e <prvIdleTask+0xc>
			{
				taskYIELD();
    184a:	0e 94 44 05 	call	0xa88	; 0xa88 <vPortYield>
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
    184e:	0e 94 7c 14 	call	0x28f8	; 0x28f8 <vApplicationIdleHook>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
    1852:	f7 cf       	rjmp	.-18     	; 0x1842 <prvIdleTask>

00001854 <xTaskCreate>:
							const char * const pcName,
							const uint16_t usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
    1854:	2f 92       	push	r2
    1856:	3f 92       	push	r3
    1858:	4f 92       	push	r4
    185a:	5f 92       	push	r5
    185c:	6f 92       	push	r6
    185e:	7f 92       	push	r7
    1860:	8f 92       	push	r8
    1862:	9f 92       	push	r9
    1864:	af 92       	push	r10
    1866:	bf 92       	push	r11
    1868:	cf 92       	push	r12
    186a:	df 92       	push	r13
    186c:	ef 92       	push	r14
    186e:	ff 92       	push	r15
    1870:	0f 93       	push	r16
    1872:	1f 93       	push	r17
    1874:	cf 93       	push	r28
    1876:	df 93       	push	r29
    1878:	3c 01       	movw	r6, r24
    187a:	1b 01       	movw	r2, r22
    187c:	5a 01       	movw	r10, r20
    187e:	29 01       	movw	r4, r18
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1880:	ca 01       	movw	r24, r20
    1882:	0e 94 fc 05 	call	0xbf8	; 0xbf8 <pvPortMalloc>
    1886:	6c 01       	movw	r12, r24

			if( pxStack != NULL )
    1888:	89 2b       	or	r24, r25
    188a:	71 f0       	breq	.+28     	; 0x18a8 <xTaskCreate+0x54>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
    188c:	88 e2       	ldi	r24, 0x28	; 40
    188e:	90 e0       	ldi	r25, 0x00	; 0
    1890:	0e 94 fc 05 	call	0xbf8	; 0xbf8 <pvPortMalloc>
    1894:	ec 01       	movw	r28, r24

				if( pxNewTCB != NULL )
    1896:	89 2b       	or	r24, r25
    1898:	19 f0       	breq	.+6      	; 0x18a0 <xTaskCreate+0x4c>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    189a:	d8 8e       	std	Y+24, r13	; 0x18
    189c:	cf 8a       	std	Y+23, r12	; 0x17
    189e:	06 c0       	rjmp	.+12     	; 0x18ac <xTaskCreate+0x58>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    18a0:	c6 01       	movw	r24, r12
    18a2:	0e 94 31 06 	call	0xc62	; 0xc62 <vPortFree>
    18a6:	02 c0       	rjmp	.+4      	; 0x18ac <xTaskCreate+0x58>
				}
			}
			else
			{
				pxNewTCB = NULL;
    18a8:	c0 e0       	ldi	r28, 0x00	; 0
    18aa:	d0 e0       	ldi	r29, 0x00	; 0
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
    18ac:	20 97       	sbiw	r28, 0x00	; 0
    18ae:	91 f0       	breq	.+36     	; 0x18d4 <xTaskCreate+0x80>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    18b0:	95 01       	movw	r18, r10
    18b2:	40 e0       	ldi	r20, 0x00	; 0
    18b4:	50 e0       	ldi	r21, 0x00	; 0
    18b6:	81 2c       	mov	r8, r1
    18b8:	91 2c       	mov	r9, r1
    18ba:	5e 01       	movw	r10, r28
    18bc:	67 01       	movw	r12, r14
    18be:	e0 2e       	mov	r14, r16
    18c0:	82 01       	movw	r16, r4
    18c2:	b1 01       	movw	r22, r2
    18c4:	c3 01       	movw	r24, r6
    18c6:	0e 94 e6 0a 	call	0x15cc	; 0x15cc <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
    18ca:	ce 01       	movw	r24, r28
    18cc:	0e 94 81 0b 	call	0x1702	; 0x1702 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
    18d0:	81 e0       	ldi	r24, 0x01	; 1
    18d2:	01 c0       	rjmp	.+2      	; 0x18d6 <xTaskCreate+0x82>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    18d4:	8f ef       	ldi	r24, 0xFF	; 255
		}

		return xReturn;
	}
    18d6:	df 91       	pop	r29
    18d8:	cf 91       	pop	r28
    18da:	1f 91       	pop	r17
    18dc:	0f 91       	pop	r16
    18de:	ff 90       	pop	r15
    18e0:	ef 90       	pop	r14
    18e2:	df 90       	pop	r13
    18e4:	cf 90       	pop	r12
    18e6:	bf 90       	pop	r11
    18e8:	af 90       	pop	r10
    18ea:	9f 90       	pop	r9
    18ec:	8f 90       	pop	r8
    18ee:	7f 90       	pop	r7
    18f0:	6f 90       	pop	r6
    18f2:	5f 90       	pop	r5
    18f4:	4f 90       	pop	r4
    18f6:	3f 90       	pop	r3
    18f8:	2f 90       	pop	r2
    18fa:	08 95       	ret

000018fc <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    18fc:	ef 92       	push	r14
    18fe:	ff 92       	push	r15
    1900:	0f 93       	push	r16
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    1902:	0f 2e       	mov	r0, r31
    1904:	f1 e6       	ldi	r31, 0x61	; 97
    1906:	ef 2e       	mov	r14, r31
    1908:	fd e0       	ldi	r31, 0x0D	; 13
    190a:	ff 2e       	mov	r15, r31
    190c:	f0 2d       	mov	r31, r0
    190e:	00 e0       	ldi	r16, 0x00	; 0
    1910:	20 e0       	ldi	r18, 0x00	; 0
    1912:	30 e0       	ldi	r19, 0x00	; 0
    1914:	45 e5       	ldi	r20, 0x55	; 85
    1916:	50 e0       	ldi	r21, 0x00	; 0
    1918:	60 e0       	ldi	r22, 0x00	; 0
    191a:	71 e0       	ldi	r23, 0x01	; 1
    191c:	81 e2       	ldi	r24, 0x21	; 33
    191e:	9c e0       	ldi	r25, 0x0C	; 12
    1920:	0e 94 2a 0c 	call	0x1854	; 0x1854 <xTaskCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    1924:	81 30       	cpi	r24, 0x01	; 1
    1926:	81 f4       	brne	.+32     	; 0x1948 <vTaskStartScheduler+0x4c>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    1928:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    192a:	8f ef       	ldi	r24, 0xFF	; 255
    192c:	9f ef       	ldi	r25, 0xFF	; 255
    192e:	90 93 64 0d 	sts	0x0D64, r25	; 0x800d64 <xNextTaskUnblockTime+0x1>
    1932:	80 93 63 0d 	sts	0x0D63, r24	; 0x800d63 <xNextTaskUnblockTime>
		xSchedulerRunning = pdTRUE;
    1936:	81 e0       	ldi	r24, 0x01	; 1
    1938:	80 93 69 0d 	sts	0x0D69, r24	; 0x800d69 <xSchedulerRunning>
		xTickCount = ( TickType_t ) 0U;
    193c:	10 92 6c 0d 	sts	0x0D6C, r1	; 0x800d6c <xTickCount+0x1>
    1940:	10 92 6b 0d 	sts	0x0D6B, r1	; 0x800d6b <xTickCount>
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    1944:	0e 94 14 05 	call	0xa28	; 0xa28 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    1948:	0f 91       	pop	r16
    194a:	ff 90       	pop	r15
    194c:	ef 90       	pop	r14
    194e:	08 95       	ret

00001950 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    1950:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    1952:	10 92 69 0d 	sts	0x0D69, r1	; 0x800d69 <xSchedulerRunning>
	vPortEndScheduler();
    1956:	0e 94 43 05 	call	0xa86	; 0xa86 <vPortEndScheduler>
    195a:	08 95       	ret

0000195c <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    195c:	80 91 60 0d 	lds	r24, 0x0D60	; 0x800d60 <uxSchedulerSuspended>
    1960:	8f 5f       	subi	r24, 0xFF	; 255
    1962:	80 93 60 0d 	sts	0x0D60, r24	; 0x800d60 <uxSchedulerSuspended>
    1966:	08 95       	ret

00001968 <xTaskGetTickCount>:
TickType_t xTaskGetTickCount( void )
{
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    1968:	0f b6       	in	r0, 0x3f	; 63
    196a:	f8 94       	cli
    196c:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    196e:	80 91 6b 0d 	lds	r24, 0x0D6B	; 0x800d6b <xTickCount>
    1972:	90 91 6c 0d 	lds	r25, 0x0D6C	; 0x800d6c <xTickCount+0x1>
	}
	portTICK_TYPE_EXIT_CRITICAL();
    1976:	0f 90       	pop	r0
    1978:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    197a:	08 95       	ret

0000197c <xTaskGetTickCountFromISR>:
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
	{
		xReturn = xTickCount;
    197c:	80 91 6b 0d 	lds	r24, 0x0D6B	; 0x800d6b <xTickCount>
    1980:	90 91 6c 0d 	lds	r25, 0x0D6C	; 0x800d6c <xTickCount+0x1>
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1984:	08 95       	ret

00001986 <uxTaskGetNumberOfTasks>:

UBaseType_t uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    1986:	80 91 6d 0d 	lds	r24, 0x0D6D	; 0x800d6d <uxCurrentNumberOfTasks>
}
    198a:	08 95       	ret

0000198c <pcTaskGetName>:
{
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    198c:	00 97       	sbiw	r24, 0x00	; 0
    198e:	21 f4       	brne	.+8      	; 0x1998 <pcTaskGetName+0xc>
    1990:	80 91 b1 0d 	lds	r24, 0x0DB1	; 0x800db1 <pxCurrentTCB>
    1994:	90 91 b2 0d 	lds	r25, 0x0DB2	; 0x800db2 <pxCurrentTCB+0x1>
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
}
    1998:	49 96       	adiw	r24, 0x19	; 25
    199a:	08 95       	ret

0000199c <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    199c:	df 92       	push	r13
    199e:	ef 92       	push	r14
    19a0:	ff 92       	push	r15
    19a2:	0f 93       	push	r16
    19a4:	1f 93       	push	r17
    19a6:	cf 93       	push	r28
    19a8:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    19aa:	80 91 60 0d 	lds	r24, 0x0D60	; 0x800d60 <uxSchedulerSuspended>
    19ae:	81 11       	cpse	r24, r1
    19b0:	97 c0       	rjmp	.+302    	; 0x1ae0 <xTaskIncrementTick+0x144>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + 1;
    19b2:	e0 90 6b 0d 	lds	r14, 0x0D6B	; 0x800d6b <xTickCount>
    19b6:	f0 90 6c 0d 	lds	r15, 0x0D6C	; 0x800d6c <xTickCount+0x1>
    19ba:	8f ef       	ldi	r24, 0xFF	; 255
    19bc:	e8 1a       	sub	r14, r24
    19be:	f8 0a       	sbc	r15, r24

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    19c0:	f0 92 6c 0d 	sts	0x0D6C, r15	; 0x800d6c <xTickCount+0x1>
    19c4:	e0 92 6b 0d 	sts	0x0D6B, r14	; 0x800d6b <xTickCount>

		if( xConstTickCount == ( TickType_t ) 0U )
    19c8:	e1 14       	cp	r14, r1
    19ca:	f1 04       	cpc	r15, r1
    19cc:	b9 f4       	brne	.+46     	; 0x19fc <xTaskIncrementTick+0x60>
		{
			taskSWITCH_DELAYED_LISTS();
    19ce:	80 91 79 0d 	lds	r24, 0x0D79	; 0x800d79 <pxDelayedTaskList>
    19d2:	90 91 7a 0d 	lds	r25, 0x0D7A	; 0x800d7a <pxDelayedTaskList+0x1>
    19d6:	20 91 77 0d 	lds	r18, 0x0D77	; 0x800d77 <pxOverflowDelayedTaskList>
    19da:	30 91 78 0d 	lds	r19, 0x0D78	; 0x800d78 <pxOverflowDelayedTaskList+0x1>
    19de:	30 93 7a 0d 	sts	0x0D7A, r19	; 0x800d7a <pxDelayedTaskList+0x1>
    19e2:	20 93 79 0d 	sts	0x0D79, r18	; 0x800d79 <pxDelayedTaskList>
    19e6:	90 93 78 0d 	sts	0x0D78, r25	; 0x800d78 <pxOverflowDelayedTaskList+0x1>
    19ea:	80 93 77 0d 	sts	0x0D77, r24	; 0x800d77 <pxOverflowDelayedTaskList>
    19ee:	80 91 66 0d 	lds	r24, 0x0D66	; 0x800d66 <xNumOfOverflows>
    19f2:	8f 5f       	subi	r24, 0xFF	; 255
    19f4:	80 93 66 0d 	sts	0x0D66, r24	; 0x800d66 <xNumOfOverflows>
    19f8:	0e 94 c7 0a 	call	0x158e	; 0x158e <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    19fc:	80 91 63 0d 	lds	r24, 0x0D63	; 0x800d63 <xNextTaskUnblockTime>
    1a00:	90 91 64 0d 	lds	r25, 0x0D64	; 0x800d64 <xNextTaskUnblockTime+0x1>
    1a04:	e8 16       	cp	r14, r24
    1a06:	f9 06       	cpc	r15, r25
    1a08:	28 f4       	brcc	.+10     	; 0x1a14 <xTaskIncrementTick+0x78>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    1a0a:	d1 2c       	mov	r13, r1
    1a0c:	53 c0       	rjmp	.+166    	; 0x1ab4 <xTaskIncrementTick+0x118>
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
						{
							xSwitchRequired = pdTRUE;
    1a0e:	dd 24       	eor	r13, r13
    1a10:	d3 94       	inc	r13
    1a12:	01 c0       	rjmp	.+2      	; 0x1a16 <xTaskIncrementTick+0x7a>
    1a14:	d1 2c       	mov	r13, r1
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    1a16:	e0 91 79 0d 	lds	r30, 0x0D79	; 0x800d79 <pxDelayedTaskList>
    1a1a:	f0 91 7a 0d 	lds	r31, 0x0D7A	; 0x800d7a <pxDelayedTaskList+0x1>
    1a1e:	80 81       	ld	r24, Z
    1a20:	81 11       	cpse	r24, r1
    1a22:	07 c0       	rjmp	.+14     	; 0x1a32 <xTaskIncrementTick+0x96>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1a24:	8f ef       	ldi	r24, 0xFF	; 255
    1a26:	9f ef       	ldi	r25, 0xFF	; 255
    1a28:	90 93 64 0d 	sts	0x0D64, r25	; 0x800d64 <xNextTaskUnblockTime+0x1>
    1a2c:	80 93 63 0d 	sts	0x0D63, r24	; 0x800d63 <xNextTaskUnblockTime>
					break;
    1a30:	41 c0       	rjmp	.+130    	; 0x1ab4 <xTaskIncrementTick+0x118>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    1a32:	e0 91 79 0d 	lds	r30, 0x0D79	; 0x800d79 <pxDelayedTaskList>
    1a36:	f0 91 7a 0d 	lds	r31, 0x0D7A	; 0x800d7a <pxDelayedTaskList+0x1>
    1a3a:	05 80       	ldd	r0, Z+5	; 0x05
    1a3c:	f6 81       	ldd	r31, Z+6	; 0x06
    1a3e:	e0 2d       	mov	r30, r0
    1a40:	c6 81       	ldd	r28, Z+6	; 0x06
    1a42:	d7 81       	ldd	r29, Z+7	; 0x07
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    1a44:	8a 81       	ldd	r24, Y+2	; 0x02
    1a46:	9b 81       	ldd	r25, Y+3	; 0x03

					if( xConstTickCount < xItemValue )
    1a48:	e8 16       	cp	r14, r24
    1a4a:	f9 06       	cpc	r15, r25
    1a4c:	28 f4       	brcc	.+10     	; 0x1a58 <xTaskIncrementTick+0xbc>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    1a4e:	90 93 64 0d 	sts	0x0D64, r25	; 0x800d64 <xNextTaskUnblockTime+0x1>
    1a52:	80 93 63 0d 	sts	0x0D63, r24	; 0x800d63 <xNextTaskUnblockTime>
						break;
    1a56:	2e c0       	rjmp	.+92     	; 0x1ab4 <xTaskIncrementTick+0x118>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1a58:	8e 01       	movw	r16, r28
    1a5a:	0e 5f       	subi	r16, 0xFE	; 254
    1a5c:	1f 4f       	sbci	r17, 0xFF	; 255
    1a5e:	c8 01       	movw	r24, r16
    1a60:	0e 94 78 04 	call	0x8f0	; 0x8f0 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    1a64:	8c 89       	ldd	r24, Y+20	; 0x14
    1a66:	9d 89       	ldd	r25, Y+21	; 0x15
    1a68:	89 2b       	or	r24, r25
    1a6a:	21 f0       	breq	.+8      	; 0x1a74 <xTaskIncrementTick+0xd8>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    1a6c:	ce 01       	movw	r24, r28
    1a6e:	0c 96       	adiw	r24, 0x0c	; 12
    1a70:	0e 94 78 04 	call	0x8f0	; 0x8f0 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    1a74:	8e 89       	ldd	r24, Y+22	; 0x16
    1a76:	90 91 6a 0d 	lds	r25, 0x0D6A	; 0x800d6a <uxTopReadyPriority>
    1a7a:	98 17       	cp	r25, r24
    1a7c:	10 f4       	brcc	.+4      	; 0x1a82 <xTaskIncrementTick+0xe6>
    1a7e:	80 93 6a 0d 	sts	0x0D6A, r24	; 0x800d6a <uxTopReadyPriority>
    1a82:	90 e0       	ldi	r25, 0x00	; 0
    1a84:	9c 01       	movw	r18, r24
    1a86:	22 0f       	add	r18, r18
    1a88:	33 1f       	adc	r19, r19
    1a8a:	22 0f       	add	r18, r18
    1a8c:	33 1f       	adc	r19, r19
    1a8e:	22 0f       	add	r18, r18
    1a90:	33 1f       	adc	r19, r19
    1a92:	82 0f       	add	r24, r18
    1a94:	93 1f       	adc	r25, r19
    1a96:	b8 01       	movw	r22, r16
    1a98:	83 57       	subi	r24, 0x73	; 115
    1a9a:	92 4f       	sbci	r25, 0xF2	; 242
    1a9c:	0e 94 26 04 	call	0x84c	; 0x84c <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1aa0:	9e 89       	ldd	r25, Y+22	; 0x16
    1aa2:	e0 91 b1 0d 	lds	r30, 0x0DB1	; 0x800db1 <pxCurrentTCB>
    1aa6:	f0 91 b2 0d 	lds	r31, 0x0DB2	; 0x800db2 <pxCurrentTCB+0x1>
    1aaa:	86 89       	ldd	r24, Z+22	; 0x16
    1aac:	98 17       	cp	r25, r24
    1aae:	08 f0       	brcs	.+2      	; 0x1ab2 <xTaskIncrementTick+0x116>
    1ab0:	ae cf       	rjmp	.-164    	; 0x1a0e <xTaskIncrementTick+0x72>
    1ab2:	b1 cf       	rjmp	.-158    	; 0x1a16 <xTaskIncrementTick+0x7a>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    1ab4:	e0 91 b1 0d 	lds	r30, 0x0DB1	; 0x800db1 <pxCurrentTCB>
    1ab8:	f0 91 b2 0d 	lds	r31, 0x0DB2	; 0x800db2 <pxCurrentTCB+0x1>
    1abc:	86 89       	ldd	r24, Z+22	; 0x16
    1abe:	90 e0       	ldi	r25, 0x00	; 0
    1ac0:	fc 01       	movw	r30, r24
    1ac2:	ee 0f       	add	r30, r30
    1ac4:	ff 1f       	adc	r31, r31
    1ac6:	ee 0f       	add	r30, r30
    1ac8:	ff 1f       	adc	r31, r31
    1aca:	ee 0f       	add	r30, r30
    1acc:	ff 1f       	adc	r31, r31
    1ace:	8e 0f       	add	r24, r30
    1ad0:	9f 1f       	adc	r25, r31
    1ad2:	fc 01       	movw	r30, r24
    1ad4:	e3 57       	subi	r30, 0x73	; 115
    1ad6:	f2 4f       	sbci	r31, 0xF2	; 242
    1ad8:	80 81       	ld	r24, Z
    1ada:	82 30       	cpi	r24, 0x02	; 2
    1adc:	40 f4       	brcc	.+16     	; 0x1aee <xTaskIncrementTick+0x152>
    1ade:	09 c0       	rjmp	.+18     	; 0x1af2 <xTaskIncrementTick+0x156>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    1ae0:	80 91 68 0d 	lds	r24, 0x0D68	; 0x800d68 <uxPendedTicks>
    1ae4:	8f 5f       	subi	r24, 0xFF	; 255
    1ae6:	80 93 68 0d 	sts	0x0D68, r24	; 0x800d68 <uxPendedTicks>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    1aea:	d1 2c       	mov	r13, r1
    1aec:	02 c0       	rjmp	.+4      	; 0x1af2 <xTaskIncrementTick+0x156>
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
			{
				xSwitchRequired = pdTRUE;
    1aee:	dd 24       	eor	r13, r13
    1af0:	d3 94       	inc	r13
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    1af2:	80 91 67 0d 	lds	r24, 0x0D67	; 0x800d67 <xYieldPending>
    1af6:	88 23       	and	r24, r24
    1af8:	11 f0       	breq	.+4      	; 0x1afe <xTaskIncrementTick+0x162>
		{
			xSwitchRequired = pdTRUE;
    1afa:	dd 24       	eor	r13, r13
    1afc:	d3 94       	inc	r13
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
    1afe:	8d 2d       	mov	r24, r13
    1b00:	df 91       	pop	r29
    1b02:	cf 91       	pop	r28
    1b04:	1f 91       	pop	r17
    1b06:	0f 91       	pop	r16
    1b08:	ff 90       	pop	r15
    1b0a:	ef 90       	pop	r14
    1b0c:	df 90       	pop	r13
    1b0e:	08 95       	ret

00001b10 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    1b10:	0f 93       	push	r16
    1b12:	1f 93       	push	r17
    1b14:	cf 93       	push	r28
    1b16:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    1b18:	0f b6       	in	r0, 0x3f	; 63
    1b1a:	f8 94       	cli
    1b1c:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    1b1e:	80 91 60 0d 	lds	r24, 0x0D60	; 0x800d60 <uxSchedulerSuspended>
    1b22:	81 50       	subi	r24, 0x01	; 1
    1b24:	80 93 60 0d 	sts	0x0D60, r24	; 0x800d60 <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1b28:	80 91 60 0d 	lds	r24, 0x0D60	; 0x800d60 <uxSchedulerSuspended>
    1b2c:	81 11       	cpse	r24, r1
    1b2e:	58 c0       	rjmp	.+176    	; 0x1be0 <xTaskResumeAll+0xd0>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    1b30:	80 91 6d 0d 	lds	r24, 0x0D6D	; 0x800d6d <uxCurrentNumberOfTasks>
    1b34:	81 11       	cpse	r24, r1
    1b36:	33 c0       	rjmp	.+102    	; 0x1b9e <xTaskResumeAll+0x8e>
    1b38:	56 c0       	rjmp	.+172    	; 0x1be6 <xTaskResumeAll+0xd6>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    1b3a:	e0 91 73 0d 	lds	r30, 0x0D73	; 0x800d73 <xPendingReadyList+0x5>
    1b3e:	f0 91 74 0d 	lds	r31, 0x0D74	; 0x800d74 <xPendingReadyList+0x6>
    1b42:	c6 81       	ldd	r28, Z+6	; 0x06
    1b44:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    1b46:	ce 01       	movw	r24, r28
    1b48:	0c 96       	adiw	r24, 0x0c	; 12
    1b4a:	0e 94 78 04 	call	0x8f0	; 0x8f0 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1b4e:	8e 01       	movw	r16, r28
    1b50:	0e 5f       	subi	r16, 0xFE	; 254
    1b52:	1f 4f       	sbci	r17, 0xFF	; 255
    1b54:	c8 01       	movw	r24, r16
    1b56:	0e 94 78 04 	call	0x8f0	; 0x8f0 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    1b5a:	8e 89       	ldd	r24, Y+22	; 0x16
    1b5c:	90 91 6a 0d 	lds	r25, 0x0D6A	; 0x800d6a <uxTopReadyPriority>
    1b60:	98 17       	cp	r25, r24
    1b62:	10 f4       	brcc	.+4      	; 0x1b68 <xTaskResumeAll+0x58>
    1b64:	80 93 6a 0d 	sts	0x0D6A, r24	; 0x800d6a <uxTopReadyPriority>
    1b68:	90 e0       	ldi	r25, 0x00	; 0
    1b6a:	9c 01       	movw	r18, r24
    1b6c:	22 0f       	add	r18, r18
    1b6e:	33 1f       	adc	r19, r19
    1b70:	22 0f       	add	r18, r18
    1b72:	33 1f       	adc	r19, r19
    1b74:	22 0f       	add	r18, r18
    1b76:	33 1f       	adc	r19, r19
    1b78:	82 0f       	add	r24, r18
    1b7a:	93 1f       	adc	r25, r19
    1b7c:	b8 01       	movw	r22, r16
    1b7e:	83 57       	subi	r24, 0x73	; 115
    1b80:	92 4f       	sbci	r25, 0xF2	; 242
    1b82:	0e 94 26 04 	call	0x84c	; 0x84c <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1b86:	9e 89       	ldd	r25, Y+22	; 0x16
    1b88:	e0 91 b1 0d 	lds	r30, 0x0DB1	; 0x800db1 <pxCurrentTCB>
    1b8c:	f0 91 b2 0d 	lds	r31, 0x0DB2	; 0x800db2 <pxCurrentTCB+0x1>
    1b90:	86 89       	ldd	r24, Z+22	; 0x16
    1b92:	98 17       	cp	r25, r24
    1b94:	30 f0       	brcs	.+12     	; 0x1ba2 <xTaskResumeAll+0x92>
					{
						xYieldPending = pdTRUE;
    1b96:	81 e0       	ldi	r24, 0x01	; 1
    1b98:	80 93 67 0d 	sts	0x0D67, r24	; 0x800d67 <xYieldPending>
    1b9c:	02 c0       	rjmp	.+4      	; 0x1ba2 <xTaskResumeAll+0x92>
    1b9e:	c0 e0       	ldi	r28, 0x00	; 0
    1ba0:	d0 e0       	ldi	r29, 0x00	; 0
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    1ba2:	80 91 6e 0d 	lds	r24, 0x0D6E	; 0x800d6e <xPendingReadyList>
    1ba6:	81 11       	cpse	r24, r1
    1ba8:	c8 cf       	rjmp	.-112    	; 0x1b3a <xTaskResumeAll+0x2a>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    1baa:	cd 2b       	or	r28, r29
    1bac:	11 f0       	breq	.+4      	; 0x1bb2 <xTaskResumeAll+0xa2>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    1bae:	0e 94 c7 0a 	call	0x158e	; 0x158e <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    1bb2:	c0 91 68 0d 	lds	r28, 0x0D68	; 0x800d68 <uxPendedTicks>

					if( uxPendedCounts > ( UBaseType_t ) 0U )
    1bb6:	cc 23       	and	r28, r28
    1bb8:	59 f0       	breq	.+22     	; 0x1bd0 <xTaskResumeAll+0xc0>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    1bba:	0e 94 ce 0c 	call	0x199c	; 0x199c <xTaskIncrementTick>
    1bbe:	88 23       	and	r24, r24
    1bc0:	19 f0       	breq	.+6      	; 0x1bc8 <xTaskResumeAll+0xb8>
							{
								xYieldPending = pdTRUE;
    1bc2:	81 e0       	ldi	r24, 0x01	; 1
    1bc4:	80 93 67 0d 	sts	0x0D67, r24	; 0x800d67 <xYieldPending>
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
    1bc8:	c1 50       	subi	r28, 0x01	; 1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    1bca:	b9 f7       	brne	.-18     	; 0x1bba <xTaskResumeAll+0xaa>

						uxPendedTicks = 0;
    1bcc:	10 92 68 0d 	sts	0x0D68, r1	; 0x800d68 <uxPendedTicks>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    1bd0:	80 91 67 0d 	lds	r24, 0x0D67	; 0x800d67 <xYieldPending>
    1bd4:	88 23       	and	r24, r24
    1bd6:	31 f0       	breq	.+12     	; 0x1be4 <xTaskResumeAll+0xd4>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    1bd8:	0e 94 44 05 	call	0xa88	; 0xa88 <vPortYield>

				if( xYieldPending != pdFALSE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    1bdc:	81 e0       	ldi	r24, 0x01	; 1
    1bde:	03 c0       	rjmp	.+6      	; 0x1be6 <xTaskResumeAll+0xd6>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB = NULL;
BaseType_t xAlreadyYielded = pdFALSE;
    1be0:	80 e0       	ldi	r24, 0x00	; 0
    1be2:	01 c0       	rjmp	.+2      	; 0x1be6 <xTaskResumeAll+0xd6>
    1be4:	80 e0       	ldi	r24, 0x00	; 0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    1be6:	0f 90       	pop	r0
    1be8:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    1bea:	df 91       	pop	r29
    1bec:	cf 91       	pop	r28
    1bee:	1f 91       	pop	r17
    1bf0:	0f 91       	pop	r16
    1bf2:	08 95       	ret

00001bf4 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    1bf4:	0f 93       	push	r16
    1bf6:	1f 93       	push	r17
    1bf8:	cf 93       	push	r28
    1bfa:	df 93       	push	r29
    1bfc:	8c 01       	movw	r16, r24
    1bfe:	eb 01       	movw	r28, r22

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    1c00:	0e 94 ae 0c 	call	0x195c	; 0x195c <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    1c04:	40 91 6b 0d 	lds	r20, 0x0D6B	; 0x800d6b <xTickCount>
    1c08:	50 91 6c 0d 	lds	r21, 0x0D6C	; 0x800d6c <xTickCount+0x1>

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    1c0c:	f8 01       	movw	r30, r16
    1c0e:	20 81       	ld	r18, Z
    1c10:	31 81       	ldd	r19, Z+1	; 0x01
    1c12:	c9 01       	movw	r24, r18
    1c14:	8c 0f       	add	r24, r28
    1c16:	9d 1f       	adc	r25, r29

			if( xConstTickCount < *pxPreviousWakeTime )
    1c18:	42 17       	cp	r20, r18
    1c1a:	53 07       	cpc	r21, r19
    1c1c:	40 f4       	brcc	.+16     	; 0x1c2e <vTaskDelayUntil+0x3a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    1c1e:	82 17       	cp	r24, r18
    1c20:	93 07       	cpc	r25, r19
    1c22:	68 f4       	brcc	.+26     	; 0x1c3e <vTaskDelayUntil+0x4a>
    1c24:	48 17       	cp	r20, r24
    1c26:	59 07       	cpc	r21, r25
    1c28:	60 f0       	brcs	.+24     	; 0x1c42 <vTaskDelayUntil+0x4e>
#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    1c2a:	20 e0       	ldi	r18, 0x00	; 0
    1c2c:	0f c0       	rjmp	.+30     	; 0x1c4c <vTaskDelayUntil+0x58>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    1c2e:	82 17       	cp	r24, r18
    1c30:	93 07       	cpc	r25, r19
    1c32:	48 f0       	brcs	.+18     	; 0x1c46 <vTaskDelayUntil+0x52>
    1c34:	48 17       	cp	r20, r24
    1c36:	59 07       	cpc	r21, r25
    1c38:	40 f0       	brcs	.+16     	; 0x1c4a <vTaskDelayUntil+0x56>
#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    1c3a:	20 e0       	ldi	r18, 0x00	; 0
    1c3c:	07 c0       	rjmp	.+14     	; 0x1c4c <vTaskDelayUntil+0x58>
    1c3e:	20 e0       	ldi	r18, 0x00	; 0
    1c40:	05 c0       	rjmp	.+10     	; 0x1c4c <vTaskDelayUntil+0x58>
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
				{
					xShouldDelay = pdTRUE;
    1c42:	21 e0       	ldi	r18, 0x01	; 1
    1c44:	03 c0       	rjmp	.+6      	; 0x1c4c <vTaskDelayUntil+0x58>
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
				{
					xShouldDelay = pdTRUE;
    1c46:	21 e0       	ldi	r18, 0x01	; 1
    1c48:	01 c0       	rjmp	.+2      	; 0x1c4c <vTaskDelayUntil+0x58>
    1c4a:	21 e0       	ldi	r18, 0x01	; 1
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    1c4c:	f8 01       	movw	r30, r16
    1c4e:	91 83       	std	Z+1, r25	; 0x01
    1c50:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    1c52:	22 23       	and	r18, r18
    1c54:	29 f0       	breq	.+10     	; 0x1c60 <vTaskDelayUntil+0x6c>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    1c56:	60 e0       	ldi	r22, 0x00	; 0
    1c58:	84 1b       	sub	r24, r20
    1c5a:	95 0b       	sbc	r25, r21
    1c5c:	0e 94 dd 0b 	call	0x17ba	; 0x17ba <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    1c60:	0e 94 88 0d 	call	0x1b10	; 0x1b10 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1c64:	81 11       	cpse	r24, r1
    1c66:	02 c0       	rjmp	.+4      	; 0x1c6c <vTaskDelayUntil+0x78>
		{
			portYIELD_WITHIN_API();
    1c68:	0e 94 44 05 	call	0xa88	; 0xa88 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    1c6c:	df 91       	pop	r29
    1c6e:	cf 91       	pop	r28
    1c70:	1f 91       	pop	r17
    1c72:	0f 91       	pop	r16
    1c74:	08 95       	ret

00001c76 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    1c76:	cf 93       	push	r28
    1c78:	df 93       	push	r29
    1c7a:	ec 01       	movw	r28, r24
	BaseType_t xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    1c7c:	89 2b       	or	r24, r25
    1c7e:	49 f0       	breq	.+18     	; 0x1c92 <vTaskDelay+0x1c>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    1c80:	0e 94 ae 0c 	call	0x195c	; 0x195c <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    1c84:	60 e0       	ldi	r22, 0x00	; 0
    1c86:	ce 01       	movw	r24, r28
    1c88:	0e 94 dd 0b 	call	0x17ba	; 0x17ba <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    1c8c:	0e 94 88 0d 	call	0x1b10	; 0x1b10 <xTaskResumeAll>
    1c90:	01 c0       	rjmp	.+2      	; 0x1c94 <vTaskDelay+0x1e>

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
	BaseType_t xAlreadyYielded = pdFALSE;
    1c92:	80 e0       	ldi	r24, 0x00	; 0
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1c94:	81 11       	cpse	r24, r1
    1c96:	02 c0       	rjmp	.+4      	; 0x1c9c <vTaskDelay+0x26>
		{
			portYIELD_WITHIN_API();
    1c98:	0e 94 44 05 	call	0xa88	; 0xa88 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    1c9c:	df 91       	pop	r29
    1c9e:	cf 91       	pop	r28
    1ca0:	08 95       	ret

00001ca2 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    1ca2:	80 91 60 0d 	lds	r24, 0x0D60	; 0x800d60 <uxSchedulerSuspended>
    1ca6:	88 23       	and	r24, r24
    1ca8:	21 f0       	breq	.+8      	; 0x1cb2 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    1caa:	81 e0       	ldi	r24, 0x01	; 1
    1cac:	80 93 67 0d 	sts	0x0D67, r24	; 0x800d67 <xYieldPending>
    1cb0:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
    1cb2:	10 92 67 0d 	sts	0x0D67, r1	; 0x800d67 <xYieldPending>
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    1cb6:	20 91 6a 0d 	lds	r18, 0x0D6A	; 0x800d6a <uxTopReadyPriority>
    1cba:	01 c0       	rjmp	.+2      	; 0x1cbe <vTaskSwitchContext+0x1c>
    1cbc:	21 50       	subi	r18, 0x01	; 1
    1cbe:	82 2f       	mov	r24, r18
    1cc0:	90 e0       	ldi	r25, 0x00	; 0
    1cc2:	fc 01       	movw	r30, r24
    1cc4:	ee 0f       	add	r30, r30
    1cc6:	ff 1f       	adc	r31, r31
    1cc8:	ee 0f       	add	r30, r30
    1cca:	ff 1f       	adc	r31, r31
    1ccc:	ee 0f       	add	r30, r30
    1cce:	ff 1f       	adc	r31, r31
    1cd0:	e8 0f       	add	r30, r24
    1cd2:	f9 1f       	adc	r31, r25
    1cd4:	e3 57       	subi	r30, 0x73	; 115
    1cd6:	f2 4f       	sbci	r31, 0xF2	; 242
    1cd8:	30 81       	ld	r19, Z
    1cda:	33 23       	and	r19, r19
    1cdc:	79 f3       	breq	.-34     	; 0x1cbc <vTaskSwitchContext+0x1a>
    1cde:	ac 01       	movw	r20, r24
    1ce0:	44 0f       	add	r20, r20
    1ce2:	55 1f       	adc	r21, r21
    1ce4:	44 0f       	add	r20, r20
    1ce6:	55 1f       	adc	r21, r21
    1ce8:	44 0f       	add	r20, r20
    1cea:	55 1f       	adc	r21, r21
    1cec:	48 0f       	add	r20, r24
    1cee:	59 1f       	adc	r21, r25
    1cf0:	df 01       	movw	r26, r30
    1cf2:	01 80       	ldd	r0, Z+1	; 0x01
    1cf4:	f2 81       	ldd	r31, Z+2	; 0x02
    1cf6:	e0 2d       	mov	r30, r0
    1cf8:	02 80       	ldd	r0, Z+2	; 0x02
    1cfa:	f3 81       	ldd	r31, Z+3	; 0x03
    1cfc:	e0 2d       	mov	r30, r0
    1cfe:	12 96       	adiw	r26, 0x02	; 2
    1d00:	fc 93       	st	X, r31
    1d02:	ee 93       	st	-X, r30
    1d04:	11 97       	sbiw	r26, 0x01	; 1
    1d06:	40 57       	subi	r20, 0x70	; 112
    1d08:	52 4f       	sbci	r21, 0xF2	; 242
    1d0a:	e4 17       	cp	r30, r20
    1d0c:	f5 07       	cpc	r31, r21
    1d0e:	29 f4       	brne	.+10     	; 0x1d1a <vTaskSwitchContext+0x78>
    1d10:	42 81       	ldd	r20, Z+2	; 0x02
    1d12:	53 81       	ldd	r21, Z+3	; 0x03
    1d14:	fd 01       	movw	r30, r26
    1d16:	52 83       	std	Z+2, r21	; 0x02
    1d18:	41 83       	std	Z+1, r20	; 0x01
    1d1a:	fc 01       	movw	r30, r24
    1d1c:	ee 0f       	add	r30, r30
    1d1e:	ff 1f       	adc	r31, r31
    1d20:	ee 0f       	add	r30, r30
    1d22:	ff 1f       	adc	r31, r31
    1d24:	ee 0f       	add	r30, r30
    1d26:	ff 1f       	adc	r31, r31
    1d28:	8e 0f       	add	r24, r30
    1d2a:	9f 1f       	adc	r25, r31
    1d2c:	fc 01       	movw	r30, r24
    1d2e:	e3 57       	subi	r30, 0x73	; 115
    1d30:	f2 4f       	sbci	r31, 0xF2	; 242
    1d32:	01 80       	ldd	r0, Z+1	; 0x01
    1d34:	f2 81       	ldd	r31, Z+2	; 0x02
    1d36:	e0 2d       	mov	r30, r0
    1d38:	86 81       	ldd	r24, Z+6	; 0x06
    1d3a:	97 81       	ldd	r25, Z+7	; 0x07
    1d3c:	90 93 b2 0d 	sts	0x0DB2, r25	; 0x800db2 <pxCurrentTCB+0x1>
    1d40:	80 93 b1 0d 	sts	0x0DB1, r24	; 0x800db1 <pxCurrentTCB>
    1d44:	20 93 6a 0d 	sts	0x0D6A, r18	; 0x800d6a <uxTopReadyPriority>
    1d48:	08 95       	ret

00001d4a <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    1d4a:	cf 93       	push	r28
    1d4c:	df 93       	push	r29
    1d4e:	eb 01       	movw	r28, r22

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    1d50:	60 91 b1 0d 	lds	r22, 0x0DB1	; 0x800db1 <pxCurrentTCB>
    1d54:	70 91 b2 0d 	lds	r23, 0x0DB2	; 0x800db2 <pxCurrentTCB+0x1>
    1d58:	64 5f       	subi	r22, 0xF4	; 244
    1d5a:	7f 4f       	sbci	r23, 0xFF	; 255
    1d5c:	0e 94 47 04 	call	0x88e	; 0x88e <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    1d60:	61 e0       	ldi	r22, 0x01	; 1
    1d62:	ce 01       	movw	r24, r28
    1d64:	0e 94 dd 0b 	call	0x17ba	; 0x17ba <prvAddCurrentTaskToDelayedList>
}
    1d68:	df 91       	pop	r29
    1d6a:	cf 91       	pop	r28
    1d6c:	08 95       	ret

00001d6e <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    1d6e:	cf 93       	push	r28
    1d70:	df 93       	push	r29
    1d72:	ea 01       	movw	r28, r20
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    1d74:	e0 91 b1 0d 	lds	r30, 0x0DB1	; 0x800db1 <pxCurrentTCB>
    1d78:	f0 91 b2 0d 	lds	r31, 0x0DB2	; 0x800db2 <pxCurrentTCB+0x1>
    1d7c:	70 68       	ori	r23, 0x80	; 128
    1d7e:	75 87       	std	Z+13, r23	; 0x0d
    1d80:	64 87       	std	Z+12, r22	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    1d82:	60 91 b1 0d 	lds	r22, 0x0DB1	; 0x800db1 <pxCurrentTCB>
    1d86:	70 91 b2 0d 	lds	r23, 0x0DB2	; 0x800db2 <pxCurrentTCB+0x1>
    1d8a:	64 5f       	subi	r22, 0xF4	; 244
    1d8c:	7f 4f       	sbci	r23, 0xFF	; 255
    1d8e:	0e 94 26 04 	call	0x84c	; 0x84c <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    1d92:	61 e0       	ldi	r22, 0x01	; 1
    1d94:	ce 01       	movw	r24, r28
    1d96:	0e 94 dd 0b 	call	0x17ba	; 0x17ba <prvAddCurrentTaskToDelayedList>
}
    1d9a:	df 91       	pop	r29
    1d9c:	cf 91       	pop	r28
    1d9e:	08 95       	ret

00001da0 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    1da0:	0f 93       	push	r16
    1da2:	1f 93       	push	r17
    1da4:	cf 93       	push	r28
    1da6:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1da8:	dc 01       	movw	r26, r24
    1daa:	15 96       	adiw	r26, 0x05	; 5
    1dac:	ed 91       	ld	r30, X+
    1dae:	fc 91       	ld	r31, X
    1db0:	16 97       	sbiw	r26, 0x06	; 6
    1db2:	c6 81       	ldd	r28, Z+6	; 0x06
    1db4:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    1db6:	8e 01       	movw	r16, r28
    1db8:	04 5f       	subi	r16, 0xF4	; 244
    1dba:	1f 4f       	sbci	r17, 0xFF	; 255
    1dbc:	c8 01       	movw	r24, r16
    1dbe:	0e 94 78 04 	call	0x8f0	; 0x8f0 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1dc2:	80 91 60 0d 	lds	r24, 0x0D60	; 0x800d60 <uxSchedulerSuspended>
    1dc6:	81 11       	cpse	r24, r1
    1dc8:	1c c0       	rjmp	.+56     	; 0x1e02 <xTaskRemoveFromEventList+0x62>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    1dca:	0a 50       	subi	r16, 0x0A	; 10
    1dcc:	11 09       	sbc	r17, r1
    1dce:	c8 01       	movw	r24, r16
    1dd0:	0e 94 78 04 	call	0x8f0	; 0x8f0 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    1dd4:	8e 89       	ldd	r24, Y+22	; 0x16
    1dd6:	90 91 6a 0d 	lds	r25, 0x0D6A	; 0x800d6a <uxTopReadyPriority>
    1dda:	98 17       	cp	r25, r24
    1ddc:	10 f4       	brcc	.+4      	; 0x1de2 <xTaskRemoveFromEventList+0x42>
    1dde:	80 93 6a 0d 	sts	0x0D6A, r24	; 0x800d6a <uxTopReadyPriority>
    1de2:	90 e0       	ldi	r25, 0x00	; 0
    1de4:	9c 01       	movw	r18, r24
    1de6:	22 0f       	add	r18, r18
    1de8:	33 1f       	adc	r19, r19
    1dea:	22 0f       	add	r18, r18
    1dec:	33 1f       	adc	r19, r19
    1dee:	22 0f       	add	r18, r18
    1df0:	33 1f       	adc	r19, r19
    1df2:	82 0f       	add	r24, r18
    1df4:	93 1f       	adc	r25, r19
    1df6:	b8 01       	movw	r22, r16
    1df8:	83 57       	subi	r24, 0x73	; 115
    1dfa:	92 4f       	sbci	r25, 0xF2	; 242
    1dfc:	0e 94 26 04 	call	0x84c	; 0x84c <vListInsertEnd>
    1e00:	05 c0       	rjmp	.+10     	; 0x1e0c <xTaskRemoveFromEventList+0x6c>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    1e02:	b8 01       	movw	r22, r16
    1e04:	8e e6       	ldi	r24, 0x6E	; 110
    1e06:	9d e0       	ldi	r25, 0x0D	; 13
    1e08:	0e 94 26 04 	call	0x84c	; 0x84c <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    1e0c:	9e 89       	ldd	r25, Y+22	; 0x16
    1e0e:	e0 91 b1 0d 	lds	r30, 0x0DB1	; 0x800db1 <pxCurrentTCB>
    1e12:	f0 91 b2 0d 	lds	r31, 0x0DB2	; 0x800db2 <pxCurrentTCB+0x1>
    1e16:	86 89       	ldd	r24, Z+22	; 0x16
    1e18:	89 17       	cp	r24, r25
    1e1a:	20 f4       	brcc	.+8      	; 0x1e24 <xTaskRemoveFromEventList+0x84>
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    1e1c:	81 e0       	ldi	r24, 0x01	; 1
    1e1e:	80 93 67 0d 	sts	0x0D67, r24	; 0x800d67 <xYieldPending>
    1e22:	01 c0       	rjmp	.+2      	; 0x1e26 <xTaskRemoveFromEventList+0x86>
	}
	else
	{
		xReturn = pdFALSE;
    1e24:	80 e0       	ldi	r24, 0x00	; 0
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
}
    1e26:	df 91       	pop	r29
    1e28:	cf 91       	pop	r28
    1e2a:	1f 91       	pop	r17
    1e2c:	0f 91       	pop	r16
    1e2e:	08 95       	ret

00001e30 <xTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    1e30:	0f 93       	push	r16
    1e32:	1f 93       	push	r17
    1e34:	cf 93       	push	r28
    1e36:	df 93       	push	r29
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    1e38:	70 68       	ori	r23, 0x80	; 128
    1e3a:	fc 01       	movw	r30, r24
    1e3c:	71 83       	std	Z+1, r23	; 0x01
    1e3e:	60 83       	st	Z, r22

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
    1e40:	c6 81       	ldd	r28, Z+6	; 0x06
    1e42:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    1e44:	0e 94 78 04 	call	0x8f0	; 0x8f0 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    1e48:	8e 01       	movw	r16, r28
    1e4a:	0e 5f       	subi	r16, 0xFE	; 254
    1e4c:	1f 4f       	sbci	r17, 0xFF	; 255
    1e4e:	c8 01       	movw	r24, r16
    1e50:	0e 94 78 04 	call	0x8f0	; 0x8f0 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    1e54:	8e 89       	ldd	r24, Y+22	; 0x16
    1e56:	90 91 6a 0d 	lds	r25, 0x0D6A	; 0x800d6a <uxTopReadyPriority>
    1e5a:	98 17       	cp	r25, r24
    1e5c:	10 f4       	brcc	.+4      	; 0x1e62 <xTaskRemoveFromUnorderedEventList+0x32>
    1e5e:	80 93 6a 0d 	sts	0x0D6A, r24	; 0x800d6a <uxTopReadyPriority>
    1e62:	90 e0       	ldi	r25, 0x00	; 0
    1e64:	9c 01       	movw	r18, r24
    1e66:	22 0f       	add	r18, r18
    1e68:	33 1f       	adc	r19, r19
    1e6a:	22 0f       	add	r18, r18
    1e6c:	33 1f       	adc	r19, r19
    1e6e:	22 0f       	add	r18, r18
    1e70:	33 1f       	adc	r19, r19
    1e72:	82 0f       	add	r24, r18
    1e74:	93 1f       	adc	r25, r19
    1e76:	b8 01       	movw	r22, r16
    1e78:	83 57       	subi	r24, 0x73	; 115
    1e7a:	92 4f       	sbci	r25, 0xF2	; 242
    1e7c:	0e 94 26 04 	call	0x84c	; 0x84c <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    1e80:	9e 89       	ldd	r25, Y+22	; 0x16
    1e82:	e0 91 b1 0d 	lds	r30, 0x0DB1	; 0x800db1 <pxCurrentTCB>
    1e86:	f0 91 b2 0d 	lds	r31, 0x0DB2	; 0x800db2 <pxCurrentTCB+0x1>
    1e8a:	86 89       	ldd	r24, Z+22	; 0x16
    1e8c:	89 17       	cp	r24, r25
    1e8e:	20 f4       	brcc	.+8      	; 0x1e98 <xTaskRemoveFromUnorderedEventList+0x68>
		switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    1e90:	81 e0       	ldi	r24, 0x01	; 1
    1e92:	80 93 67 0d 	sts	0x0D67, r24	; 0x800d67 <xYieldPending>
    1e96:	01 c0       	rjmp	.+2      	; 0x1e9a <xTaskRemoveFromUnorderedEventList+0x6a>
	}
	else
	{
		xReturn = pdFALSE;
    1e98:	80 e0       	ldi	r24, 0x00	; 0
	}

	return xReturn;
}
    1e9a:	df 91       	pop	r29
    1e9c:	cf 91       	pop	r28
    1e9e:	1f 91       	pop	r17
    1ea0:	0f 91       	pop	r16
    1ea2:	08 95       	ret

00001ea4 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    1ea4:	20 91 66 0d 	lds	r18, 0x0D66	; 0x800d66 <xNumOfOverflows>
    1ea8:	fc 01       	movw	r30, r24
    1eaa:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    1eac:	20 91 6b 0d 	lds	r18, 0x0D6B	; 0x800d6b <xTickCount>
    1eb0:	30 91 6c 0d 	lds	r19, 0x0D6C	; 0x800d6c <xTickCount+0x1>
    1eb4:	32 83       	std	Z+2, r19	; 0x02
    1eb6:	21 83       	std	Z+1, r18	; 0x01
    1eb8:	08 95       	ret

00001eba <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    1eba:	cf 93       	push	r28
    1ebc:	df 93       	push	r29
    1ebe:	fc 01       	movw	r30, r24
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    1ec0:	0f b6       	in	r0, 0x3f	; 63
    1ec2:	f8 94       	cli
    1ec4:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    1ec6:	40 91 6b 0d 	lds	r20, 0x0D6B	; 0x800d6b <xTickCount>
    1eca:	50 91 6c 0d 	lds	r21, 0x0D6C	; 0x800d6c <xTickCount+0x1>
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    1ece:	90 81       	ld	r25, Z
    1ed0:	80 91 66 0d 	lds	r24, 0x0D66	; 0x800d66 <xNumOfOverflows>
    1ed4:	98 17       	cp	r25, r24
    1ed6:	29 f0       	breq	.+10     	; 0x1ee2 <xTaskCheckForTimeOut+0x28>
    1ed8:	81 81       	ldd	r24, Z+1	; 0x01
    1eda:	92 81       	ldd	r25, Z+2	; 0x02
    1edc:	48 17       	cp	r20, r24
    1ede:	59 07       	cpc	r21, r25
    1ee0:	b0 f4       	brcc	.+44     	; 0x1f0e <xTaskCheckForTimeOut+0x54>
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    1ee2:	21 81       	ldd	r18, Z+1	; 0x01
    1ee4:	32 81       	ldd	r19, Z+2	; 0x02
    1ee6:	ca 01       	movw	r24, r20
    1ee8:	82 1b       	sub	r24, r18
    1eea:	93 0b       	sbc	r25, r19
    1eec:	eb 01       	movw	r28, r22
    1eee:	a8 81       	ld	r26, Y
    1ef0:	b9 81       	ldd	r27, Y+1	; 0x01
    1ef2:	8a 17       	cp	r24, r26
    1ef4:	9b 07       	cpc	r25, r27
    1ef6:	68 f4       	brcc	.+26     	; 0x1f12 <xTaskCheckForTimeOut+0x58>
    1ef8:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
    1efa:	24 1b       	sub	r18, r20
    1efc:	35 0b       	sbc	r19, r21
    1efe:	2a 0f       	add	r18, r26
    1f00:	3b 1f       	adc	r19, r27
    1f02:	39 83       	std	Y+1, r19	; 0x01
    1f04:	28 83       	st	Y, r18
			vTaskSetTimeOutState( pxTimeOut );
    1f06:	0e 94 52 0f 	call	0x1ea4	; 0x1ea4 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    1f0a:	80 e0       	ldi	r24, 0x00	; 0
    1f0c:	03 c0       	rjmp	.+6      	; 0x1f14 <xTaskCheckForTimeOut+0x5a>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    1f0e:	81 e0       	ldi	r24, 0x01	; 1
    1f10:	01 c0       	rjmp	.+2      	; 0x1f14 <xTaskCheckForTimeOut+0x5a>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    1f12:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    1f14:	0f 90       	pop	r0
    1f16:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    1f18:	df 91       	pop	r29
    1f1a:	cf 91       	pop	r28
    1f1c:	08 95       	ret

00001f1e <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    1f1e:	81 e0       	ldi	r24, 0x01	; 1
    1f20:	80 93 67 0d 	sts	0x0D67, r24	; 0x800d67 <xYieldPending>
    1f24:	08 95       	ret

00001f26 <xTaskGetCurrentTaskHandle>:
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    1f26:	80 91 b1 0d 	lds	r24, 0x0DB1	; 0x800db1 <pxCurrentTCB>
    1f2a:	90 91 b2 0d 	lds	r25, 0x0DB2	; 0x800db2 <pxCurrentTCB+0x1>

		return xReturn;
	}
    1f2e:	08 95       	ret

00001f30 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
    1f30:	0f 93       	push	r16
    1f32:	1f 93       	push	r17
    1f34:	cf 93       	push	r28
    1f36:	df 93       	push	r29
    1f38:	fc 01       	movw	r30, r24
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
    1f3a:	89 2b       	or	r24, r25
    1f3c:	09 f4       	brne	.+2      	; 0x1f40 <vTaskPriorityInherit+0x10>
    1f3e:	55 c0       	rjmp	.+170    	; 0x1fea <vTaskPriorityInherit+0xba>
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    1f40:	26 89       	ldd	r18, Z+22	; 0x16
    1f42:	a0 91 b1 0d 	lds	r26, 0x0DB1	; 0x800db1 <pxCurrentTCB>
    1f46:	b0 91 b2 0d 	lds	r27, 0x0DB2	; 0x800db2 <pxCurrentTCB+0x1>
    1f4a:	56 96       	adiw	r26, 0x16	; 22
    1f4c:	8c 91       	ld	r24, X
    1f4e:	28 17       	cp	r18, r24
    1f50:	08 f0       	brcs	.+2      	; 0x1f54 <vTaskPriorityInherit+0x24>
    1f52:	4b c0       	rjmp	.+150    	; 0x1fea <vTaskPriorityInherit+0xba>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not	being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    1f54:	84 85       	ldd	r24, Z+12	; 0x0c
    1f56:	95 85       	ldd	r25, Z+13	; 0x0d
    1f58:	99 23       	and	r25, r25
    1f5a:	64 f0       	brlt	.+24     	; 0x1f74 <vTaskPriorityInherit+0x44>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1f5c:	a0 91 b1 0d 	lds	r26, 0x0DB1	; 0x800db1 <pxCurrentTCB>
    1f60:	b0 91 b2 0d 	lds	r27, 0x0DB2	; 0x800db2 <pxCurrentTCB+0x1>
    1f64:	56 96       	adiw	r26, 0x16	; 22
    1f66:	3c 91       	ld	r19, X
    1f68:	84 e0       	ldi	r24, 0x04	; 4
    1f6a:	90 e0       	ldi	r25, 0x00	; 0
    1f6c:	83 1b       	sub	r24, r19
    1f6e:	91 09       	sbc	r25, r1
    1f70:	95 87       	std	Z+13, r25	; 0x0d
    1f72:	84 87       	std	Z+12, r24	; 0x0c
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
    1f74:	82 85       	ldd	r24, Z+10	; 0x0a
    1f76:	93 85       	ldd	r25, Z+11	; 0x0b
    1f78:	30 e0       	ldi	r19, 0x00	; 0
    1f7a:	a9 01       	movw	r20, r18
    1f7c:	44 0f       	add	r20, r20
    1f7e:	55 1f       	adc	r21, r21
    1f80:	44 0f       	add	r20, r20
    1f82:	55 1f       	adc	r21, r21
    1f84:	44 0f       	add	r20, r20
    1f86:	55 1f       	adc	r21, r21
    1f88:	24 0f       	add	r18, r20
    1f8a:	35 1f       	adc	r19, r21
    1f8c:	23 57       	subi	r18, 0x73	; 115
    1f8e:	32 4f       	sbci	r19, 0xF2	; 242
    1f90:	82 17       	cp	r24, r18
    1f92:	93 07       	cpc	r25, r19
    1f94:	19 f5       	brne	.+70     	; 0x1fdc <vTaskPriorityInherit+0xac>
    1f96:	8f 01       	movw	r16, r30
				{
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    1f98:	ef 01       	movw	r28, r30
    1f9a:	22 96       	adiw	r28, 0x02	; 2
    1f9c:	ce 01       	movw	r24, r28
    1f9e:	0e 94 78 04 	call	0x8f0	; 0x8f0 <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    1fa2:	e0 91 b1 0d 	lds	r30, 0x0DB1	; 0x800db1 <pxCurrentTCB>
    1fa6:	f0 91 b2 0d 	lds	r31, 0x0DB2	; 0x800db2 <pxCurrentTCB+0x1>
    1faa:	86 89       	ldd	r24, Z+22	; 0x16
    1fac:	f8 01       	movw	r30, r16
    1fae:	86 8b       	std	Z+22, r24	; 0x16
					prvAddTaskToReadyList( pxTCB );
    1fb0:	90 91 6a 0d 	lds	r25, 0x0D6A	; 0x800d6a <uxTopReadyPriority>
    1fb4:	98 17       	cp	r25, r24
    1fb6:	10 f4       	brcc	.+4      	; 0x1fbc <vTaskPriorityInherit+0x8c>
    1fb8:	80 93 6a 0d 	sts	0x0D6A, r24	; 0x800d6a <uxTopReadyPriority>
    1fbc:	90 e0       	ldi	r25, 0x00	; 0
    1fbe:	9c 01       	movw	r18, r24
    1fc0:	22 0f       	add	r18, r18
    1fc2:	33 1f       	adc	r19, r19
    1fc4:	22 0f       	add	r18, r18
    1fc6:	33 1f       	adc	r19, r19
    1fc8:	22 0f       	add	r18, r18
    1fca:	33 1f       	adc	r19, r19
    1fcc:	82 0f       	add	r24, r18
    1fce:	93 1f       	adc	r25, r19
    1fd0:	be 01       	movw	r22, r28
    1fd2:	83 57       	subi	r24, 0x73	; 115
    1fd4:	92 4f       	sbci	r25, 0xF2	; 242
    1fd6:	0e 94 26 04 	call	0x84c	; 0x84c <vListInsertEnd>
    1fda:	07 c0       	rjmp	.+14     	; 0x1fea <vTaskPriorityInherit+0xba>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    1fdc:	a0 91 b1 0d 	lds	r26, 0x0DB1	; 0x800db1 <pxCurrentTCB>
    1fe0:	b0 91 b2 0d 	lds	r27, 0x0DB2	; 0x800db2 <pxCurrentTCB+0x1>
    1fe4:	56 96       	adiw	r26, 0x16	; 22
    1fe6:	8c 91       	ld	r24, X
    1fe8:	86 8b       	std	Z+22, r24	; 0x16
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    1fea:	df 91       	pop	r29
    1fec:	cf 91       	pop	r28
    1fee:	1f 91       	pop	r17
    1ff0:	0f 91       	pop	r16
    1ff2:	08 95       	ret

00001ff4 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    1ff4:	0f 93       	push	r16
    1ff6:	1f 93       	push	r17
    1ff8:	cf 93       	push	r28
    1ffa:	df 93       	push	r29
    1ffc:	fc 01       	movw	r30, r24
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;

		if( pxMutexHolder != NULL )
    1ffe:	89 2b       	or	r24, r25
    2000:	79 f1       	breq	.+94     	; 0x2060 <xTaskPriorityDisinherit+0x6c>
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );

			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
    2002:	82 a1       	ldd	r24, Z+34	; 0x22
    2004:	81 50       	subi	r24, 0x01	; 1
    2006:	82 a3       	std	Z+34, r24	; 0x22

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    2008:	26 89       	ldd	r18, Z+22	; 0x16
    200a:	91 a1       	ldd	r25, Z+33	; 0x21
    200c:	29 17       	cp	r18, r25
    200e:	51 f1       	breq	.+84     	; 0x2064 <xTaskPriorityDisinherit+0x70>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    2010:	81 11       	cpse	r24, r1
    2012:	2a c0       	rjmp	.+84     	; 0x2068 <xTaskPriorityDisinherit+0x74>
    2014:	ef 01       	movw	r28, r30
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding	task then it must be the running state task.  Remove
					the	holding task from the ready	list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    2016:	8f 01       	movw	r16, r30
    2018:	0e 5f       	subi	r16, 0xFE	; 254
    201a:	1f 4f       	sbci	r17, 0xFF	; 255
    201c:	c8 01       	movw	r24, r16
    201e:	0e 94 78 04 	call	0x8f0	; 0x8f0 <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    2022:	89 a1       	ldd	r24, Y+33	; 0x21
    2024:	8e 8b       	std	Y+22, r24	; 0x16

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2026:	24 e0       	ldi	r18, 0x04	; 4
    2028:	30 e0       	ldi	r19, 0x00	; 0
    202a:	28 1b       	sub	r18, r24
    202c:	31 09       	sbc	r19, r1
    202e:	3d 87       	std	Y+13, r19	; 0x0d
    2030:	2c 87       	std	Y+12, r18	; 0x0c
					prvAddTaskToReadyList( pxTCB );
    2032:	90 91 6a 0d 	lds	r25, 0x0D6A	; 0x800d6a <uxTopReadyPriority>
    2036:	98 17       	cp	r25, r24
    2038:	10 f4       	brcc	.+4      	; 0x203e <xTaskPriorityDisinherit+0x4a>
    203a:	80 93 6a 0d 	sts	0x0D6A, r24	; 0x800d6a <uxTopReadyPriority>
    203e:	90 e0       	ldi	r25, 0x00	; 0
    2040:	9c 01       	movw	r18, r24
    2042:	22 0f       	add	r18, r18
    2044:	33 1f       	adc	r19, r19
    2046:	22 0f       	add	r18, r18
    2048:	33 1f       	adc	r19, r19
    204a:	22 0f       	add	r18, r18
    204c:	33 1f       	adc	r19, r19
    204e:	82 0f       	add	r24, r18
    2050:	93 1f       	adc	r25, r19
    2052:	b8 01       	movw	r22, r16
    2054:	83 57       	subi	r24, 0x73	; 115
    2056:	92 4f       	sbci	r25, 0xF2	; 242
    2058:	0e 94 26 04 	call	0x84c	; 0x84c <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
    205c:	81 e0       	ldi	r24, 0x01	; 1
    205e:	05 c0       	rjmp	.+10     	; 0x206a <xTaskPriorityDisinherit+0x76>
#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;
    2060:	80 e0       	ldi	r24, 0x00	; 0
    2062:	03 c0       	rjmp	.+6      	; 0x206a <xTaskPriorityDisinherit+0x76>
    2064:	80 e0       	ldi	r24, 0x00	; 0
    2066:	01 c0       	rjmp	.+2      	; 0x206a <xTaskPriorityDisinherit+0x76>
    2068:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
    206a:	df 91       	pop	r29
    206c:	cf 91       	pop	r28
    206e:	1f 91       	pop	r17
    2070:	0f 91       	pop	r16
    2072:	08 95       	ret

00002074 <uxTaskResetEventItemValue>:

TickType_t uxTaskResetEventItemValue( void )
{
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    2074:	e0 91 b1 0d 	lds	r30, 0x0DB1	; 0x800db1 <pxCurrentTCB>
    2078:	f0 91 b2 0d 	lds	r31, 0x0DB2	; 0x800db2 <pxCurrentTCB+0x1>
    207c:	84 85       	ldd	r24, Z+12	; 0x0c
    207e:	95 85       	ldd	r25, Z+13	; 0x0d

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2080:	e0 91 b1 0d 	lds	r30, 0x0DB1	; 0x800db1 <pxCurrentTCB>
    2084:	f0 91 b2 0d 	lds	r31, 0x0DB2	; 0x800db2 <pxCurrentTCB+0x1>
    2088:	a0 91 b1 0d 	lds	r26, 0x0DB1	; 0x800db1 <pxCurrentTCB>
    208c:	b0 91 b2 0d 	lds	r27, 0x0DB2	; 0x800db2 <pxCurrentTCB+0x1>
    2090:	56 96       	adiw	r26, 0x16	; 22
    2092:	4c 91       	ld	r20, X
    2094:	24 e0       	ldi	r18, 0x04	; 4
    2096:	30 e0       	ldi	r19, 0x00	; 0
    2098:	24 1b       	sub	r18, r20
    209a:	31 09       	sbc	r19, r1
    209c:	35 87       	std	Z+13, r19	; 0x0d
    209e:	24 87       	std	Z+12, r18	; 0x0c

	return uxReturn;
}
    20a0:	08 95       	ret

000020a2 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    20a2:	80 91 b1 0d 	lds	r24, 0x0DB1	; 0x800db1 <pxCurrentTCB>
    20a6:	90 91 b2 0d 	lds	r25, 0x0DB2	; 0x800db2 <pxCurrentTCB+0x1>
    20aa:	89 2b       	or	r24, r25
    20ac:	39 f0       	breq	.+14     	; 0x20bc <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    20ae:	e0 91 b1 0d 	lds	r30, 0x0DB1	; 0x800db1 <pxCurrentTCB>
    20b2:	f0 91 b2 0d 	lds	r31, 0x0DB2	; 0x800db2 <pxCurrentTCB+0x1>
    20b6:	82 a1       	ldd	r24, Z+34	; 0x22
    20b8:	8f 5f       	subi	r24, 0xFF	; 255
    20ba:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    20bc:	80 91 b1 0d 	lds	r24, 0x0DB1	; 0x800db1 <pxCurrentTCB>
    20c0:	90 91 b2 0d 	lds	r25, 0x0DB2	; 0x800db2 <pxCurrentTCB+0x1>
	}
    20c4:	08 95       	ret

000020c6 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    20c6:	0f 93       	push	r16
    20c8:	1f 93       	push	r17
    20ca:	cf 93       	push	r28
    20cc:	c8 2f       	mov	r28, r24
    20ce:	cb 01       	movw	r24, r22
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    20d0:	0f b6       	in	r0, 0x3f	; 63
    20d2:	f8 94       	cli
    20d4:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    20d6:	e0 91 b1 0d 	lds	r30, 0x0DB1	; 0x800db1 <pxCurrentTCB>
    20da:	f0 91 b2 0d 	lds	r31, 0x0DB2	; 0x800db2 <pxCurrentTCB+0x1>
    20de:	43 a1       	ldd	r20, Z+35	; 0x23
    20e0:	54 a1       	ldd	r21, Z+36	; 0x24
    20e2:	65 a1       	ldd	r22, Z+37	; 0x25
    20e4:	76 a1       	ldd	r23, Z+38	; 0x26
    20e6:	45 2b       	or	r20, r21
    20e8:	46 2b       	or	r20, r22
    20ea:	47 2b       	or	r20, r23
    20ec:	69 f4       	brne	.+26     	; 0x2108 <ulTaskNotifyTake+0x42>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    20ee:	e0 91 b1 0d 	lds	r30, 0x0DB1	; 0x800db1 <pxCurrentTCB>
    20f2:	f0 91 b2 0d 	lds	r31, 0x0DB2	; 0x800db2 <pxCurrentTCB+0x1>
    20f6:	21 e0       	ldi	r18, 0x01	; 1
    20f8:	27 a3       	std	Z+39, r18	; 0x27

				if( xTicksToWait > ( TickType_t ) 0 )
    20fa:	00 97       	sbiw	r24, 0x00	; 0
    20fc:	29 f0       	breq	.+10     	; 0x2108 <ulTaskNotifyTake+0x42>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    20fe:	61 e0       	ldi	r22, 0x01	; 1
    2100:	0e 94 dd 0b 	call	0x17ba	; 0x17ba <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    2104:	0e 94 44 05 	call	0xa88	; 0xa88 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    2108:	0f 90       	pop	r0
    210a:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    210c:	0f b6       	in	r0, 0x3f	; 63
    210e:	f8 94       	cli
    2110:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    2112:	e0 91 b1 0d 	lds	r30, 0x0DB1	; 0x800db1 <pxCurrentTCB>
    2116:	f0 91 b2 0d 	lds	r31, 0x0DB2	; 0x800db2 <pxCurrentTCB+0x1>
    211a:	63 a1       	ldd	r22, Z+35	; 0x23
    211c:	74 a1       	ldd	r23, Z+36	; 0x24
    211e:	85 a1       	ldd	r24, Z+37	; 0x25
    2120:	96 a1       	ldd	r25, Z+38	; 0x26

			if( ulReturn != 0UL )
    2122:	61 15       	cp	r22, r1
    2124:	71 05       	cpc	r23, r1
    2126:	81 05       	cpc	r24, r1
    2128:	91 05       	cpc	r25, r1
    212a:	c9 f0       	breq	.+50     	; 0x215e <ulTaskNotifyTake+0x98>
			{
				if( xClearCountOnExit != pdFALSE )
    212c:	cc 23       	and	r28, r28
    212e:	49 f0       	breq	.+18     	; 0x2142 <ulTaskNotifyTake+0x7c>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    2130:	e0 91 b1 0d 	lds	r30, 0x0DB1	; 0x800db1 <pxCurrentTCB>
    2134:	f0 91 b2 0d 	lds	r31, 0x0DB2	; 0x800db2 <pxCurrentTCB+0x1>
    2138:	13 a2       	std	Z+35, r1	; 0x23
    213a:	14 a2       	std	Z+36, r1	; 0x24
    213c:	15 a2       	std	Z+37, r1	; 0x25
    213e:	16 a2       	std	Z+38, r1	; 0x26
    2140:	0e c0       	rjmp	.+28     	; 0x215e <ulTaskNotifyTake+0x98>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - 1;
    2142:	e0 91 b1 0d 	lds	r30, 0x0DB1	; 0x800db1 <pxCurrentTCB>
    2146:	f0 91 b2 0d 	lds	r31, 0x0DB2	; 0x800db2 <pxCurrentTCB+0x1>
    214a:	8b 01       	movw	r16, r22
    214c:	9c 01       	movw	r18, r24
    214e:	01 50       	subi	r16, 0x01	; 1
    2150:	11 09       	sbc	r17, r1
    2152:	21 09       	sbc	r18, r1
    2154:	31 09       	sbc	r19, r1
    2156:	03 a3       	std	Z+35, r16	; 0x23
    2158:	14 a3       	std	Z+36, r17	; 0x24
    215a:	25 a3       	std	Z+37, r18	; 0x25
    215c:	36 a3       	std	Z+38, r19	; 0x26
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    215e:	e0 91 b1 0d 	lds	r30, 0x0DB1	; 0x800db1 <pxCurrentTCB>
    2162:	f0 91 b2 0d 	lds	r31, 0x0DB2	; 0x800db2 <pxCurrentTCB+0x1>
    2166:	17 a2       	std	Z+39, r1	; 0x27
		}
		taskEXIT_CRITICAL();
    2168:	0f 90       	pop	r0
    216a:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
	}
    216c:	cf 91       	pop	r28
    216e:	1f 91       	pop	r17
    2170:	0f 91       	pop	r16
    2172:	08 95       	ret

00002174 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    2174:	4f 92       	push	r4
    2176:	5f 92       	push	r5
    2178:	6f 92       	push	r6
    217a:	7f 92       	push	r7
    217c:	8f 92       	push	r8
    217e:	9f 92       	push	r9
    2180:	af 92       	push	r10
    2182:	bf 92       	push	r11
    2184:	ef 92       	push	r14
    2186:	ff 92       	push	r15
    2188:	0f 93       	push	r16
    218a:	1f 93       	push	r17
    218c:	49 01       	movw	r8, r18
    218e:	5a 01       	movw	r10, r20
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    2190:	0f b6       	in	r0, 0x3f	; 63
    2192:	f8 94       	cli
    2194:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    2196:	e0 91 b1 0d 	lds	r30, 0x0DB1	; 0x800db1 <pxCurrentTCB>
    219a:	f0 91 b2 0d 	lds	r31, 0x0DB2	; 0x800db2 <pxCurrentTCB+0x1>
    219e:	27 a1       	ldd	r18, Z+39	; 0x27
    21a0:	22 30       	cpi	r18, 0x02	; 2
    21a2:	29 f1       	breq	.+74     	; 0x21ee <xTaskNotifyWait+0x7a>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    21a4:	e0 91 b1 0d 	lds	r30, 0x0DB1	; 0x800db1 <pxCurrentTCB>
    21a8:	f0 91 b2 0d 	lds	r31, 0x0DB2	; 0x800db2 <pxCurrentTCB+0x1>
    21ac:	43 a0       	ldd	r4, Z+35	; 0x23
    21ae:	54 a0       	ldd	r5, Z+36	; 0x24
    21b0:	65 a0       	ldd	r6, Z+37	; 0x25
    21b2:	76 a0       	ldd	r7, Z+38	; 0x26
    21b4:	dc 01       	movw	r26, r24
    21b6:	cb 01       	movw	r24, r22
    21b8:	80 95       	com	r24
    21ba:	90 95       	com	r25
    21bc:	a0 95       	com	r26
    21be:	b0 95       	com	r27
    21c0:	84 21       	and	r24, r4
    21c2:	95 21       	and	r25, r5
    21c4:	a6 21       	and	r26, r6
    21c6:	b7 21       	and	r27, r7
    21c8:	83 a3       	std	Z+35, r24	; 0x23
    21ca:	94 a3       	std	Z+36, r25	; 0x24
    21cc:	a5 a3       	std	Z+37, r26	; 0x25
    21ce:	b6 a3       	std	Z+38, r27	; 0x26

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    21d0:	e0 91 b1 0d 	lds	r30, 0x0DB1	; 0x800db1 <pxCurrentTCB>
    21d4:	f0 91 b2 0d 	lds	r31, 0x0DB2	; 0x800db2 <pxCurrentTCB+0x1>
    21d8:	81 e0       	ldi	r24, 0x01	; 1
    21da:	87 a3       	std	Z+39, r24	; 0x27

				if( xTicksToWait > ( TickType_t ) 0 )
    21dc:	e1 14       	cp	r14, r1
    21de:	f1 04       	cpc	r15, r1
    21e0:	31 f0       	breq	.+12     	; 0x21ee <xTaskNotifyWait+0x7a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    21e2:	61 e0       	ldi	r22, 0x01	; 1
    21e4:	c7 01       	movw	r24, r14
    21e6:	0e 94 dd 0b 	call	0x17ba	; 0x17ba <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    21ea:	0e 94 44 05 	call	0xa88	; 0xa88 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    21ee:	0f 90       	pop	r0
    21f0:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    21f2:	0f b6       	in	r0, 0x3f	; 63
    21f4:	f8 94       	cli
    21f6:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    21f8:	01 15       	cp	r16, r1
    21fa:	11 05       	cpc	r17, r1
    21fc:	69 f0       	breq	.+26     	; 0x2218 <xTaskNotifyWait+0xa4>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    21fe:	e0 91 b1 0d 	lds	r30, 0x0DB1	; 0x800db1 <pxCurrentTCB>
    2202:	f0 91 b2 0d 	lds	r31, 0x0DB2	; 0x800db2 <pxCurrentTCB+0x1>
    2206:	83 a1       	ldd	r24, Z+35	; 0x23
    2208:	94 a1       	ldd	r25, Z+36	; 0x24
    220a:	a5 a1       	ldd	r26, Z+37	; 0x25
    220c:	b6 a1       	ldd	r27, Z+38	; 0x26
    220e:	f8 01       	movw	r30, r16
    2210:	80 83       	st	Z, r24
    2212:	91 83       	std	Z+1, r25	; 0x01
    2214:	a2 83       	std	Z+2, r26	; 0x02
    2216:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState == taskWAITING_NOTIFICATION )
    2218:	e0 91 b1 0d 	lds	r30, 0x0DB1	; 0x800db1 <pxCurrentTCB>
    221c:	f0 91 b2 0d 	lds	r31, 0x0DB2	; 0x800db2 <pxCurrentTCB+0x1>
    2220:	87 a1       	ldd	r24, Z+39	; 0x27
    2222:	81 30       	cpi	r24, 0x01	; 1
    2224:	b1 f0       	breq	.+44     	; 0x2252 <xTaskNotifyWait+0xde>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    2226:	e0 91 b1 0d 	lds	r30, 0x0DB1	; 0x800db1 <pxCurrentTCB>
    222a:	f0 91 b2 0d 	lds	r31, 0x0DB2	; 0x800db2 <pxCurrentTCB+0x1>
    222e:	83 a1       	ldd	r24, Z+35	; 0x23
    2230:	94 a1       	ldd	r25, Z+36	; 0x24
    2232:	a5 a1       	ldd	r26, Z+37	; 0x25
    2234:	b6 a1       	ldd	r27, Z+38	; 0x26
    2236:	80 94       	com	r8
    2238:	90 94       	com	r9
    223a:	a0 94       	com	r10
    223c:	b0 94       	com	r11
    223e:	88 22       	and	r8, r24
    2240:	99 22       	and	r9, r25
    2242:	aa 22       	and	r10, r26
    2244:	bb 22       	and	r11, r27
    2246:	83 a2       	std	Z+35, r8	; 0x23
    2248:	94 a2       	std	Z+36, r9	; 0x24
    224a:	a5 a2       	std	Z+37, r10	; 0x25
    224c:	b6 a2       	std	Z+38, r11	; 0x26
				xReturn = pdTRUE;
    224e:	81 e0       	ldi	r24, 0x01	; 1
    2250:	01 c0       	rjmp	.+2      	; 0x2254 <xTaskNotifyWait+0xe0>
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState == taskWAITING_NOTIFICATION )
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    2252:	80 e0       	ldi	r24, 0x00	; 0
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
				xReturn = pdTRUE;
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    2254:	e0 91 b1 0d 	lds	r30, 0x0DB1	; 0x800db1 <pxCurrentTCB>
    2258:	f0 91 b2 0d 	lds	r31, 0x0DB2	; 0x800db2 <pxCurrentTCB+0x1>
    225c:	17 a2       	std	Z+39, r1	; 0x27
		}
		taskEXIT_CRITICAL();
    225e:	0f 90       	pop	r0
    2260:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    2262:	1f 91       	pop	r17
    2264:	0f 91       	pop	r16
    2266:	ff 90       	pop	r15
    2268:	ef 90       	pop	r14
    226a:	bf 90       	pop	r11
    226c:	af 90       	pop	r10
    226e:	9f 90       	pop	r9
    2270:	8f 90       	pop	r8
    2272:	7f 90       	pop	r7
    2274:	6f 90       	pop	r6
    2276:	5f 90       	pop	r5
    2278:	4f 90       	pop	r4
    227a:	08 95       	ret

0000227c <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    227c:	ef 92       	push	r14
    227e:	ff 92       	push	r15
    2280:	0f 93       	push	r16
    2282:	1f 93       	push	r17
    2284:	cf 93       	push	r28
    2286:	df 93       	push	r29
    2288:	fc 01       	movw	r30, r24
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = ( TCB_t * ) xTaskToNotify;

		taskENTER_CRITICAL();
    228a:	0f b6       	in	r0, 0x3f	; 63
    228c:	f8 94       	cli
    228e:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    2290:	01 15       	cp	r16, r1
    2292:	11 05       	cpc	r17, r1
    2294:	49 f0       	breq	.+18     	; 0x22a8 <xTaskGenericNotify+0x2c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    2296:	83 a1       	ldd	r24, Z+35	; 0x23
    2298:	94 a1       	ldd	r25, Z+36	; 0x24
    229a:	a5 a1       	ldd	r26, Z+37	; 0x25
    229c:	b6 a1       	ldd	r27, Z+38	; 0x26
    229e:	e8 01       	movw	r28, r16
    22a0:	88 83       	st	Y, r24
    22a2:	99 83       	std	Y+1, r25	; 0x01
    22a4:	aa 83       	std	Y+2, r26	; 0x02
    22a6:	bb 83       	std	Y+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    22a8:	87 a1       	ldd	r24, Z+39	; 0x27

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    22aa:	92 e0       	ldi	r25, 0x02	; 2
    22ac:	97 a3       	std	Z+39, r25	; 0x27

			switch( eAction )
    22ae:	22 30       	cpi	r18, 0x02	; 2
    22b0:	b9 f0       	breq	.+46     	; 0x22e0 <xTaskGenericNotify+0x64>
    22b2:	18 f4       	brcc	.+6      	; 0x22ba <xTaskGenericNotify+0x3e>
    22b4:	21 30       	cpi	r18, 0x01	; 1
    22b6:	31 f0       	breq	.+12     	; 0x22c4 <xTaskGenericNotify+0x48>
    22b8:	2f c0       	rjmp	.+94     	; 0x2318 <xTaskGenericNotify+0x9c>
    22ba:	23 30       	cpi	r18, 0x03	; 3
    22bc:	f9 f0       	breq	.+62     	; 0x22fc <xTaskGenericNotify+0x80>
    22be:	24 30       	cpi	r18, 0x04	; 4
    22c0:	19 f1       	breq	.+70     	; 0x2308 <xTaskGenericNotify+0x8c>
    22c2:	2a c0       	rjmp	.+84     	; 0x2318 <xTaskGenericNotify+0x9c>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    22c4:	03 a1       	ldd	r16, Z+35	; 0x23
    22c6:	14 a1       	ldd	r17, Z+36	; 0x24
    22c8:	25 a1       	ldd	r18, Z+37	; 0x25
    22ca:	36 a1       	ldd	r19, Z+38	; 0x26
    22cc:	40 2b       	or	r20, r16
    22ce:	51 2b       	or	r21, r17
    22d0:	62 2b       	or	r22, r18
    22d2:	73 2b       	or	r23, r19
    22d4:	43 a3       	std	Z+35, r20	; 0x23
    22d6:	54 a3       	std	Z+36, r21	; 0x24
    22d8:	65 a3       	std	Z+37, r22	; 0x25
    22da:	76 a3       	std	Z+38, r23	; 0x26
#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    22dc:	11 e0       	ldi	r17, 0x01	; 1

			switch( eAction )
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
					break;
    22de:	1f c0       	rjmp	.+62     	; 0x231e <xTaskGenericNotify+0xa2>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    22e0:	43 a1       	ldd	r20, Z+35	; 0x23
    22e2:	54 a1       	ldd	r21, Z+36	; 0x24
    22e4:	65 a1       	ldd	r22, Z+37	; 0x25
    22e6:	76 a1       	ldd	r23, Z+38	; 0x26
    22e8:	4f 5f       	subi	r20, 0xFF	; 255
    22ea:	5f 4f       	sbci	r21, 0xFF	; 255
    22ec:	6f 4f       	sbci	r22, 0xFF	; 255
    22ee:	7f 4f       	sbci	r23, 0xFF	; 255
    22f0:	43 a3       	std	Z+35, r20	; 0x23
    22f2:	54 a3       	std	Z+36, r21	; 0x24
    22f4:	65 a3       	std	Z+37, r22	; 0x25
    22f6:	76 a3       	std	Z+38, r23	; 0x26
#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    22f8:	11 e0       	ldi	r17, 0x01	; 1
					pxTCB->ulNotifiedValue |= ulValue;
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
					break;
    22fa:	11 c0       	rjmp	.+34     	; 0x231e <xTaskGenericNotify+0xa2>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    22fc:	43 a3       	std	Z+35, r20	; 0x23
    22fe:	54 a3       	std	Z+36, r21	; 0x24
    2300:	65 a3       	std	Z+37, r22	; 0x25
    2302:	76 a3       	std	Z+38, r23	; 0x26
#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    2304:	11 e0       	ldi	r17, 0x01	; 1
					( pxTCB->ulNotifiedValue )++;
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
					break;
    2306:	0b c0       	rjmp	.+22     	; 0x231e <xTaskGenericNotify+0xa2>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    2308:	82 30       	cpi	r24, 0x02	; 2
    230a:	41 f0       	breq	.+16     	; 0x231c <xTaskGenericNotify+0xa0>
					{
						pxTCB->ulNotifiedValue = ulValue;
    230c:	43 a3       	std	Z+35, r20	; 0x23
    230e:	54 a3       	std	Z+36, r21	; 0x24
    2310:	65 a3       	std	Z+37, r22	; 0x25
    2312:	76 a3       	std	Z+38, r23	; 0x26
#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    2314:	11 e0       	ldi	r17, 0x01	; 1
    2316:	03 c0       	rjmp	.+6      	; 0x231e <xTaskGenericNotify+0xa2>
    2318:	11 e0       	ldi	r17, 0x01	; 1
    231a:	01 c0       	rjmp	.+2      	; 0x231e <xTaskGenericNotify+0xa2>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    231c:	10 e0       	ldi	r17, 0x00	; 0

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    231e:	81 30       	cpi	r24, 0x01	; 1
    2320:	41 f5       	brne	.+80     	; 0x2372 <xTaskGenericNotify+0xf6>
    2322:	ef 01       	movw	r28, r30
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    2324:	7f 01       	movw	r14, r30
    2326:	82 e0       	ldi	r24, 0x02	; 2
    2328:	e8 0e       	add	r14, r24
    232a:	f1 1c       	adc	r15, r1
    232c:	c7 01       	movw	r24, r14
    232e:	0e 94 78 04 	call	0x8f0	; 0x8f0 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    2332:	8e 89       	ldd	r24, Y+22	; 0x16
    2334:	90 91 6a 0d 	lds	r25, 0x0D6A	; 0x800d6a <uxTopReadyPriority>
    2338:	98 17       	cp	r25, r24
    233a:	10 f4       	brcc	.+4      	; 0x2340 <xTaskGenericNotify+0xc4>
    233c:	80 93 6a 0d 	sts	0x0D6A, r24	; 0x800d6a <uxTopReadyPriority>
    2340:	90 e0       	ldi	r25, 0x00	; 0
    2342:	9c 01       	movw	r18, r24
    2344:	22 0f       	add	r18, r18
    2346:	33 1f       	adc	r19, r19
    2348:	22 0f       	add	r18, r18
    234a:	33 1f       	adc	r19, r19
    234c:	22 0f       	add	r18, r18
    234e:	33 1f       	adc	r19, r19
    2350:	82 0f       	add	r24, r18
    2352:	93 1f       	adc	r25, r19
    2354:	b7 01       	movw	r22, r14
    2356:	83 57       	subi	r24, 0x73	; 115
    2358:	92 4f       	sbci	r25, 0xF2	; 242
    235a:	0e 94 26 04 	call	0x84c	; 0x84c <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    235e:	9e 89       	ldd	r25, Y+22	; 0x16
    2360:	e0 91 b1 0d 	lds	r30, 0x0DB1	; 0x800db1 <pxCurrentTCB>
    2364:	f0 91 b2 0d 	lds	r31, 0x0DB2	; 0x800db2 <pxCurrentTCB+0x1>
    2368:	86 89       	ldd	r24, Z+22	; 0x16
    236a:	89 17       	cp	r24, r25
    236c:	10 f4       	brcc	.+4      	; 0x2372 <xTaskGenericNotify+0xf6>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    236e:	0e 94 44 05 	call	0xa88	; 0xa88 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    2372:	0f 90       	pop	r0
    2374:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    2376:	81 2f       	mov	r24, r17
    2378:	df 91       	pop	r29
    237a:	cf 91       	pop	r28
    237c:	1f 91       	pop	r17
    237e:	0f 91       	pop	r16
    2380:	ff 90       	pop	r15
    2382:	ef 90       	pop	r14
    2384:	08 95       	ret

00002386 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    2386:	cf 92       	push	r12
    2388:	df 92       	push	r13
    238a:	ef 92       	push	r14
    238c:	ff 92       	push	r15
    238e:	0f 93       	push	r16
    2390:	1f 93       	push	r17
    2392:	cf 93       	push	r28
    2394:	df 93       	push	r29
    2396:	fc 01       	movw	r30, r24

		pxTCB = ( TCB_t * ) xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			if( pulPreviousNotificationValue != NULL )
    2398:	01 15       	cp	r16, r1
    239a:	11 05       	cpc	r17, r1
    239c:	49 f0       	breq	.+18     	; 0x23b0 <xTaskGenericNotifyFromISR+0x2a>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    239e:	83 a1       	ldd	r24, Z+35	; 0x23
    23a0:	94 a1       	ldd	r25, Z+36	; 0x24
    23a2:	a5 a1       	ldd	r26, Z+37	; 0x25
    23a4:	b6 a1       	ldd	r27, Z+38	; 0x26
    23a6:	e8 01       	movw	r28, r16
    23a8:	88 83       	st	Y, r24
    23aa:	99 83       	std	Y+1, r25	; 0x01
    23ac:	aa 83       	std	Y+2, r26	; 0x02
    23ae:	bb 83       	std	Y+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    23b0:	87 a1       	ldd	r24, Z+39	; 0x27
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    23b2:	92 e0       	ldi	r25, 0x02	; 2
    23b4:	97 a3       	std	Z+39, r25	; 0x27

			switch( eAction )
    23b6:	22 30       	cpi	r18, 0x02	; 2
    23b8:	b9 f0       	breq	.+46     	; 0x23e8 <xTaskGenericNotifyFromISR+0x62>
    23ba:	18 f4       	brcc	.+6      	; 0x23c2 <xTaskGenericNotifyFromISR+0x3c>
    23bc:	21 30       	cpi	r18, 0x01	; 1
    23be:	31 f0       	breq	.+12     	; 0x23cc <xTaskGenericNotifyFromISR+0x46>
    23c0:	2f c0       	rjmp	.+94     	; 0x2420 <xTaskGenericNotifyFromISR+0x9a>
    23c2:	23 30       	cpi	r18, 0x03	; 3
    23c4:	f9 f0       	breq	.+62     	; 0x2404 <xTaskGenericNotifyFromISR+0x7e>
    23c6:	24 30       	cpi	r18, 0x04	; 4
    23c8:	19 f1       	breq	.+70     	; 0x2410 <xTaskGenericNotifyFromISR+0x8a>
    23ca:	2a c0       	rjmp	.+84     	; 0x2420 <xTaskGenericNotifyFromISR+0x9a>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    23cc:	03 a1       	ldd	r16, Z+35	; 0x23
    23ce:	14 a1       	ldd	r17, Z+36	; 0x24
    23d0:	25 a1       	ldd	r18, Z+37	; 0x25
    23d2:	36 a1       	ldd	r19, Z+38	; 0x26
    23d4:	40 2b       	or	r20, r16
    23d6:	51 2b       	or	r21, r17
    23d8:	62 2b       	or	r22, r18
    23da:	73 2b       	or	r23, r19
    23dc:	43 a3       	std	Z+35, r20	; 0x23
    23de:	54 a3       	std	Z+36, r21	; 0x24
    23e0:	65 a3       	std	Z+37, r22	; 0x25
    23e2:	76 a3       	std	Z+38, r23	; 0x26

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    23e4:	11 e0       	ldi	r17, 0x01	; 1

			switch( eAction )
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
					break;
    23e6:	1f c0       	rjmp	.+62     	; 0x2426 <xTaskGenericNotifyFromISR+0xa0>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    23e8:	43 a1       	ldd	r20, Z+35	; 0x23
    23ea:	54 a1       	ldd	r21, Z+36	; 0x24
    23ec:	65 a1       	ldd	r22, Z+37	; 0x25
    23ee:	76 a1       	ldd	r23, Z+38	; 0x26
    23f0:	4f 5f       	subi	r20, 0xFF	; 255
    23f2:	5f 4f       	sbci	r21, 0xFF	; 255
    23f4:	6f 4f       	sbci	r22, 0xFF	; 255
    23f6:	7f 4f       	sbci	r23, 0xFF	; 255
    23f8:	43 a3       	std	Z+35, r20	; 0x23
    23fa:	54 a3       	std	Z+36, r21	; 0x24
    23fc:	65 a3       	std	Z+37, r22	; 0x25
    23fe:	76 a3       	std	Z+38, r23	; 0x26

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    2400:	11 e0       	ldi	r17, 0x01	; 1
					pxTCB->ulNotifiedValue |= ulValue;
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
					break;
    2402:	11 c0       	rjmp	.+34     	; 0x2426 <xTaskGenericNotifyFromISR+0xa0>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    2404:	43 a3       	std	Z+35, r20	; 0x23
    2406:	54 a3       	std	Z+36, r21	; 0x24
    2408:	65 a3       	std	Z+37, r22	; 0x25
    240a:	76 a3       	std	Z+38, r23	; 0x26

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    240c:	11 e0       	ldi	r17, 0x01	; 1
					( pxTCB->ulNotifiedValue )++;
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
					break;
    240e:	0b c0       	rjmp	.+22     	; 0x2426 <xTaskGenericNotifyFromISR+0xa0>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    2410:	82 30       	cpi	r24, 0x02	; 2
    2412:	41 f0       	breq	.+16     	; 0x2424 <xTaskGenericNotifyFromISR+0x9e>
					{
						pxTCB->ulNotifiedValue = ulValue;
    2414:	43 a3       	std	Z+35, r20	; 0x23
    2416:	54 a3       	std	Z+36, r21	; 0x24
    2418:	65 a3       	std	Z+37, r22	; 0x25
    241a:	76 a3       	std	Z+38, r23	; 0x26

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    241c:	11 e0       	ldi	r17, 0x01	; 1
    241e:	03 c0       	rjmp	.+6      	; 0x2426 <xTaskGenericNotifyFromISR+0xa0>
    2420:	11 e0       	ldi	r17, 0x01	; 1
    2422:	01 c0       	rjmp	.+2      	; 0x2426 <xTaskGenericNotifyFromISR+0xa0>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    2424:	10 e0       	ldi	r17, 0x00	; 0

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    2426:	81 30       	cpi	r24, 0x01	; 1
    2428:	e1 f5       	brne	.+120    	; 0x24a2 <xTaskGenericNotifyFromISR+0x11c>
    242a:	ef 01       	movw	r28, r30
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    242c:	80 91 60 0d 	lds	r24, 0x0D60	; 0x800d60 <uxSchedulerSuspended>
    2430:	81 11       	cpse	r24, r1
    2432:	1e c0       	rjmp	.+60     	; 0x2470 <xTaskGenericNotifyFromISR+0xea>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    2434:	6f 01       	movw	r12, r30
    2436:	e2 e0       	ldi	r30, 0x02	; 2
    2438:	ce 0e       	add	r12, r30
    243a:	d1 1c       	adc	r13, r1
    243c:	c6 01       	movw	r24, r12
    243e:	0e 94 78 04 	call	0x8f0	; 0x8f0 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    2442:	8e 89       	ldd	r24, Y+22	; 0x16
    2444:	90 91 6a 0d 	lds	r25, 0x0D6A	; 0x800d6a <uxTopReadyPriority>
    2448:	98 17       	cp	r25, r24
    244a:	10 f4       	brcc	.+4      	; 0x2450 <xTaskGenericNotifyFromISR+0xca>
    244c:	80 93 6a 0d 	sts	0x0D6A, r24	; 0x800d6a <uxTopReadyPriority>
    2450:	90 e0       	ldi	r25, 0x00	; 0
    2452:	9c 01       	movw	r18, r24
    2454:	22 0f       	add	r18, r18
    2456:	33 1f       	adc	r19, r19
    2458:	22 0f       	add	r18, r18
    245a:	33 1f       	adc	r19, r19
    245c:	22 0f       	add	r18, r18
    245e:	33 1f       	adc	r19, r19
    2460:	82 0f       	add	r24, r18
    2462:	93 1f       	adc	r25, r19
    2464:	b6 01       	movw	r22, r12
    2466:	83 57       	subi	r24, 0x73	; 115
    2468:	92 4f       	sbci	r25, 0xF2	; 242
    246a:	0e 94 26 04 	call	0x84c	; 0x84c <vListInsertEnd>
    246e:	07 c0       	rjmp	.+14     	; 0x247e <xTaskGenericNotifyFromISR+0xf8>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    2470:	bf 01       	movw	r22, r30
    2472:	64 5f       	subi	r22, 0xF4	; 244
    2474:	7f 4f       	sbci	r23, 0xFF	; 255
    2476:	8e e6       	ldi	r24, 0x6E	; 110
    2478:	9d e0       	ldi	r25, 0x0D	; 13
    247a:	0e 94 26 04 	call	0x84c	; 0x84c <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    247e:	9e 89       	ldd	r25, Y+22	; 0x16
    2480:	e0 91 b1 0d 	lds	r30, 0x0DB1	; 0x800db1 <pxCurrentTCB>
    2484:	f0 91 b2 0d 	lds	r31, 0x0DB2	; 0x800db2 <pxCurrentTCB+0x1>
    2488:	86 89       	ldd	r24, Z+22	; 0x16
    248a:	89 17       	cp	r24, r25
    248c:	50 f4       	brcc	.+20     	; 0x24a2 <xTaskGenericNotifyFromISR+0x11c>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    248e:	e1 14       	cp	r14, r1
    2490:	f1 04       	cpc	r15, r1
    2492:	21 f0       	breq	.+8      	; 0x249c <xTaskGenericNotifyFromISR+0x116>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    2494:	81 e0       	ldi	r24, 0x01	; 1
    2496:	e7 01       	movw	r28, r14
    2498:	88 83       	st	Y, r24
    249a:	03 c0       	rjmp	.+6      	; 0x24a2 <xTaskGenericNotifyFromISR+0x11c>
					else
					{
						/* Mark that a yield is pending in case the user is not
						using the "xHigherPriorityTaskWoken" parameter to an ISR
						safe FreeRTOS function. */
						xYieldPending = pdTRUE;
    249c:	81 e0       	ldi	r24, 0x01	; 1
    249e:	80 93 67 0d 	sts	0x0D67, r24	; 0x800d67 <xYieldPending>
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
	}
    24a2:	81 2f       	mov	r24, r17
    24a4:	df 91       	pop	r29
    24a6:	cf 91       	pop	r28
    24a8:	1f 91       	pop	r17
    24aa:	0f 91       	pop	r16
    24ac:	ff 90       	pop	r15
    24ae:	ef 90       	pop	r14
    24b0:	df 90       	pop	r13
    24b2:	cf 90       	pop	r12
    24b4:	08 95       	ret

000024b6 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    24b6:	ef 92       	push	r14
    24b8:	ff 92       	push	r15
    24ba:	0f 93       	push	r16
    24bc:	1f 93       	push	r17
    24be:	cf 93       	push	r28
    24c0:	df 93       	push	r29
    24c2:	fc 01       	movw	r30, r24

		pxTCB = ( TCB_t * ) xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    24c4:	27 a1       	ldd	r18, Z+39	; 0x27
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    24c6:	82 e0       	ldi	r24, 0x02	; 2
    24c8:	87 a3       	std	Z+39, r24	; 0x27

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    24ca:	83 a1       	ldd	r24, Z+35	; 0x23
    24cc:	94 a1       	ldd	r25, Z+36	; 0x24
    24ce:	a5 a1       	ldd	r26, Z+37	; 0x25
    24d0:	b6 a1       	ldd	r27, Z+38	; 0x26
    24d2:	01 96       	adiw	r24, 0x01	; 1
    24d4:	a1 1d       	adc	r26, r1
    24d6:	b1 1d       	adc	r27, r1
    24d8:	83 a3       	std	Z+35, r24	; 0x23
    24da:	94 a3       	std	Z+36, r25	; 0x24
    24dc:	a5 a3       	std	Z+37, r26	; 0x25
    24de:	b6 a3       	std	Z+38, r27	; 0x26

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    24e0:	21 30       	cpi	r18, 0x01	; 1
    24e2:	e9 f5       	brne	.+122    	; 0x255e <vTaskNotifyGiveFromISR+0xa8>
    24e4:	8b 01       	movw	r16, r22
    24e6:	ef 01       	movw	r28, r30
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    24e8:	80 91 60 0d 	lds	r24, 0x0D60	; 0x800d60 <uxSchedulerSuspended>
    24ec:	81 11       	cpse	r24, r1
    24ee:	1e c0       	rjmp	.+60     	; 0x252c <vTaskNotifyGiveFromISR+0x76>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    24f0:	7f 01       	movw	r14, r30
    24f2:	82 e0       	ldi	r24, 0x02	; 2
    24f4:	e8 0e       	add	r14, r24
    24f6:	f1 1c       	adc	r15, r1
    24f8:	c7 01       	movw	r24, r14
    24fa:	0e 94 78 04 	call	0x8f0	; 0x8f0 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    24fe:	8e 89       	ldd	r24, Y+22	; 0x16
    2500:	90 91 6a 0d 	lds	r25, 0x0D6A	; 0x800d6a <uxTopReadyPriority>
    2504:	98 17       	cp	r25, r24
    2506:	10 f4       	brcc	.+4      	; 0x250c <vTaskNotifyGiveFromISR+0x56>
    2508:	80 93 6a 0d 	sts	0x0D6A, r24	; 0x800d6a <uxTopReadyPriority>
    250c:	90 e0       	ldi	r25, 0x00	; 0
    250e:	9c 01       	movw	r18, r24
    2510:	22 0f       	add	r18, r18
    2512:	33 1f       	adc	r19, r19
    2514:	22 0f       	add	r18, r18
    2516:	33 1f       	adc	r19, r19
    2518:	22 0f       	add	r18, r18
    251a:	33 1f       	adc	r19, r19
    251c:	82 0f       	add	r24, r18
    251e:	93 1f       	adc	r25, r19
    2520:	b7 01       	movw	r22, r14
    2522:	83 57       	subi	r24, 0x73	; 115
    2524:	92 4f       	sbci	r25, 0xF2	; 242
    2526:	0e 94 26 04 	call	0x84c	; 0x84c <vListInsertEnd>
    252a:	07 c0       	rjmp	.+14     	; 0x253a <vTaskNotifyGiveFromISR+0x84>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    252c:	bf 01       	movw	r22, r30
    252e:	64 5f       	subi	r22, 0xF4	; 244
    2530:	7f 4f       	sbci	r23, 0xFF	; 255
    2532:	8e e6       	ldi	r24, 0x6E	; 110
    2534:	9d e0       	ldi	r25, 0x0D	; 13
    2536:	0e 94 26 04 	call	0x84c	; 0x84c <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    253a:	9e 89       	ldd	r25, Y+22	; 0x16
    253c:	e0 91 b1 0d 	lds	r30, 0x0DB1	; 0x800db1 <pxCurrentTCB>
    2540:	f0 91 b2 0d 	lds	r31, 0x0DB2	; 0x800db2 <pxCurrentTCB+0x1>
    2544:	86 89       	ldd	r24, Z+22	; 0x16
    2546:	89 17       	cp	r24, r25
    2548:	50 f4       	brcc	.+20     	; 0x255e <vTaskNotifyGiveFromISR+0xa8>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    254a:	01 15       	cp	r16, r1
    254c:	11 05       	cpc	r17, r1
    254e:	21 f0       	breq	.+8      	; 0x2558 <vTaskNotifyGiveFromISR+0xa2>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    2550:	81 e0       	ldi	r24, 0x01	; 1
    2552:	f8 01       	movw	r30, r16
    2554:	80 83       	st	Z, r24
    2556:	03 c0       	rjmp	.+6      	; 0x255e <vTaskNotifyGiveFromISR+0xa8>
					else
					{
						/* Mark that a yield is pending in case the user is not
						using the "xHigherPriorityTaskWoken" parameter in an ISR
						safe FreeRTOS function. */
						xYieldPending = pdTRUE;
    2558:	81 e0       	ldi	r24, 0x01	; 1
    255a:	80 93 67 0d 	sts	0x0D67, r24	; 0x800d67 <xYieldPending>
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    255e:	df 91       	pop	r29
    2560:	cf 91       	pop	r28
    2562:	1f 91       	pop	r17
    2564:	0f 91       	pop	r16
    2566:	ff 90       	pop	r15
    2568:	ef 90       	pop	r14
    256a:	08 95       	ret

0000256c <xTaskNotifyStateClear>:
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    256c:	00 97       	sbiw	r24, 0x00	; 0
    256e:	21 f4       	brne	.+8      	; 0x2578 <xTaskNotifyStateClear+0xc>
    2570:	80 91 b1 0d 	lds	r24, 0x0DB1	; 0x800db1 <pxCurrentTCB>
    2574:	90 91 b2 0d 	lds	r25, 0x0DB2	; 0x800db2 <pxCurrentTCB+0x1>

		taskENTER_CRITICAL();
    2578:	0f b6       	in	r0, 0x3f	; 63
    257a:	f8 94       	cli
    257c:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    257e:	fc 01       	movw	r30, r24
    2580:	27 a1       	ldd	r18, Z+39	; 0x27
    2582:	22 30       	cpi	r18, 0x02	; 2
    2584:	19 f4       	brne	.+6      	; 0x258c <xTaskNotifyStateClear+0x20>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    2586:	17 a2       	std	Z+39, r1	; 0x27
				xReturn = pdPASS;
    2588:	81 e0       	ldi	r24, 0x01	; 1
    258a:	01 c0       	rjmp	.+2      	; 0x258e <xTaskNotifyStateClear+0x22>
			}
			else
			{
				xReturn = pdFAIL;
    258c:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		taskEXIT_CRITICAL();
    258e:	0f 90       	pop	r0
    2590:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    2592:	08 95       	ret

00002594 <vErrorHandler>:
		}
	}
}


static void vErrorHandler( void *pvParameters ) {
    2594:	ff cf       	rjmp	.-2      	; 0x2594 <vErrorHandler>

00002596 <vBluetoothTransmitServiceUART1>:
	( void ) pvParameters;
	
	for( ;; ) {
		/* Waits for bufferSendUART1 to fill, then pops first byte of data and
		   copies it to UART1 data register UDR1 effectively transmitting it. */ 
		xQueueReceive( bufferBluetoothSendUART1, &UDR1, portMAX_DELAY );
    2596:	20 e0       	ldi	r18, 0x00	; 0
    2598:	4f ef       	ldi	r20, 0xFF	; 255
    259a:	5f ef       	ldi	r21, 0xFF	; 255
    259c:	6c e9       	ldi	r22, 0x9C	; 156
    259e:	70 e0       	ldi	r23, 0x00	; 0
    25a0:	80 91 b5 0d 	lds	r24, 0x0DB5	; 0x800db5 <bufferBluetoothSendUART1>
    25a4:	90 91 b6 0d 	lds	r25, 0x0DB6	; 0x800db6 <bufferBluetoothSendUART1+0x1>
    25a8:	0e 94 9e 08 	call	0x113c	; 0x113c <xQueueGenericReceive>
		while( ! ( UCSR1A & ( 1 << UDRE1 ) ) );		// Wait for transmit to finish
    25ac:	80 91 9b 00 	lds	r24, 0x009B	; 0x80009b <__TEXT_REGION_LENGTH__+0x7e009b>
    25b0:	85 ff       	sbrs	r24, 5
    25b2:	fc cf       	rjmp	.-8      	; 0x25ac <vBluetoothTransmitServiceUART1+0x16>
    25b4:	f0 cf       	rjmp	.-32     	; 0x2596 <vBluetoothTransmitServiceUART1>

000025b6 <vRoombaTransmitServiceUART0>:
	( void ) pvParameters;
	
	for( ;; ) {
		/* Waits for bufferSendUART0 to fill, then pops first byte of data and
		   copies it to UART0 data register UDR0 effectively transmitting it. */ 
		xQueueReceive( bufferRoombaSendUART0, &UDR0, portMAX_DELAY );
    25b6:	20 e0       	ldi	r18, 0x00	; 0
    25b8:	4f ef       	ldi	r20, 0xFF	; 255
    25ba:	5f ef       	ldi	r21, 0xFF	; 255
    25bc:	6c e2       	ldi	r22, 0x2C	; 44
    25be:	70 e0       	ldi	r23, 0x00	; 0
    25c0:	80 91 b3 0d 	lds	r24, 0x0DB3	; 0x800db3 <bufferRoombaSendUART0>
    25c4:	90 91 b4 0d 	lds	r25, 0x0DB4	; 0x800db4 <bufferRoombaSendUART0+0x1>
    25c8:	0e 94 9e 08 	call	0x113c	; 0x113c <xQueueGenericReceive>
		while( ! ( UCSR0A & ( 1 << UDRE0 ) ) );		// Wait for transmit to finish
    25cc:	5d 9b       	sbis	0x0b, 5	; 11
    25ce:	fe cf       	rjmp	.-4      	; 0x25cc <vRoombaTransmitServiceUART0+0x16>
    25d0:	f2 cf       	rjmp	.-28     	; 0x25b6 <vRoombaTransmitServiceUART0>

000025d2 <error>:
		error( ERROR_BT_RECEIVE );
	}
	return byte;
}

static void error( uint8_t byte ) {
    25d2:	cf 93       	push	r28
    25d4:	df 93       	push	r29
    25d6:	1f 92       	push	r1
    25d8:	cd b7       	in	r28, 0x3d	; 61
    25da:	de b7       	in	r29, 0x3e	; 62
    25dc:	89 83       	std	Y+1, r24	; 0x01
	/* Receives an error and pushes it on globalError queue. */
	xQueueSendToBack( globalError, &byte, 0 );
    25de:	20 e0       	ldi	r18, 0x00	; 0
    25e0:	40 e0       	ldi	r20, 0x00	; 0
    25e2:	50 e0       	ldi	r21, 0x00	; 0
    25e4:	be 01       	movw	r22, r28
    25e6:	6f 5f       	subi	r22, 0xFF	; 255
    25e8:	7f 4f       	sbci	r23, 0xFF	; 255
    25ea:	80 91 b7 0d 	lds	r24, 0x0DB7	; 0x800db7 <globalError>
    25ee:	90 91 b8 0d 	lds	r25, 0x0DB8	; 0x800db8 <globalError+0x1>
    25f2:	0e 94 8b 07 	call	0xf16	; 0xf16 <xQueueGenericSend>
}
    25f6:	0f 90       	pop	r0
    25f8:	df 91       	pop	r29
    25fa:	cf 91       	pop	r28
    25fc:	08 95       	ret

000025fe <getByteFromBT>:
	if( errQUEUE_FULL == xQueueSendToBack( bufferBluetoothSendUART1, &byte, pdMS_TO_TICKS( 30 ) ) ) {
		error( ERROR_BT_SEND );
	}
}

static uint8_t getByteFromBT( void ) {
    25fe:	cf 93       	push	r28
    2600:	df 93       	push	r29
    2602:	1f 92       	push	r1
    2604:	cd b7       	in	r28, 0x3d	; 61
    2606:	de b7       	in	r29, 0x3e	; 62
	/* Gets byte from UART1 receive queue. */
	uint8_t byte;
	if( errQUEUE_EMPTY == xQueueReceive( bufferBluetoothReceiveUART1, &byte, pdMS_TO_TICKS( 30 ) ) ) {
    2608:	20 e0       	ldi	r18, 0x00	; 0
    260a:	43 e0       	ldi	r20, 0x03	; 3
    260c:	50 e0       	ldi	r21, 0x00	; 0
    260e:	be 01       	movw	r22, r28
    2610:	6f 5f       	subi	r22, 0xFF	; 255
    2612:	7f 4f       	sbci	r23, 0xFF	; 255
    2614:	80 91 b9 0d 	lds	r24, 0x0DB9	; 0x800db9 <bufferBluetoothReceiveUART1>
    2618:	90 91 ba 0d 	lds	r25, 0x0DBA	; 0x800dba <bufferBluetoothReceiveUART1+0x1>
    261c:	0e 94 9e 08 	call	0x113c	; 0x113c <xQueueGenericReceive>
    2620:	81 11       	cpse	r24, r1
    2622:	03 c0       	rjmp	.+6      	; 0x262a <getByteFromBT+0x2c>
		error( ERROR_BT_RECEIVE );
    2624:	86 e0       	ldi	r24, 0x06	; 6
    2626:	0e 94 e9 12 	call	0x25d2	; 0x25d2 <error>
	}
	return byte;
}
    262a:	89 81       	ldd	r24, Y+1	; 0x01
    262c:	0f 90       	pop	r0
    262e:	df 91       	pop	r29
    2630:	cf 91       	pop	r28
    2632:	08 95       	ret

00002634 <getByteFromRoomba>:
	if( errQUEUE_FULL == xQueueSendToBack( bufferRoombaSendUART0, &byte, pdMS_TO_TICKS( 30 ) ) ) {
		error( ERROR_ROOMBA_SEND );
	}
}

static uint8_t getByteFromRoomba( void ) {
    2634:	cf 93       	push	r28
    2636:	df 93       	push	r29
    2638:	1f 92       	push	r1
    263a:	cd b7       	in	r28, 0x3d	; 61
    263c:	de b7       	in	r29, 0x3e	; 62
	/* Gets byte from UART0 receive queue. */
	uint8_t byte;
	if( errQUEUE_EMPTY == xQueueReceive( bufferRoombaReceiveUART0, &byte, pdMS_TO_TICKS( 30 ) ) ) {
    263e:	20 e0       	ldi	r18, 0x00	; 0
    2640:	43 e0       	ldi	r20, 0x03	; 3
    2642:	50 e0       	ldi	r21, 0x00	; 0
    2644:	be 01       	movw	r22, r28
    2646:	6f 5f       	subi	r22, 0xFF	; 255
    2648:	7f 4f       	sbci	r23, 0xFF	; 255
    264a:	80 91 dd 0d 	lds	r24, 0x0DDD	; 0x800ddd <bufferRoombaReceiveUART0>
    264e:	90 91 de 0d 	lds	r25, 0x0DDE	; 0x800dde <bufferRoombaReceiveUART0+0x1>
    2652:	0e 94 9e 08 	call	0x113c	; 0x113c <xQueueGenericReceive>
    2656:	81 11       	cpse	r24, r1
    2658:	03 c0       	rjmp	.+6      	; 0x2660 <getByteFromRoomba+0x2c>
		error( ERROR_BT_RECEIVE );
    265a:	86 e0       	ldi	r24, 0x06	; 6
    265c:	0e 94 e9 12 	call	0x25d2	; 0x25d2 <error>
	}
	return byte;
}
    2660:	89 81       	ldd	r24, Y+1	; 0x01
    2662:	0f 90       	pop	r0
    2664:	df 91       	pop	r29
    2666:	cf 91       	pop	r28
    2668:	08 95       	ret

0000266a <sendByteToRoomba>:
	for( uint8_t i = 0; message[ i ] != '\0'; ++i ) {
		xQueueSendToBack( queue, message+i, pdMS_TO_TICKS( 30 ) );
	}
}

static void sendByteToRoomba( uint8_t byte ) {
    266a:	cf 93       	push	r28
    266c:	df 93       	push	r29
    266e:	1f 92       	push	r1
    2670:	cd b7       	in	r28, 0x3d	; 61
    2672:	de b7       	in	r29, 0x3e	; 62
    2674:	89 83       	std	Y+1, r24	; 0x01
	/* Pushes byte on UART0 send queue. */
	if( errQUEUE_FULL == xQueueSendToBack( bufferRoombaSendUART0, &byte, pdMS_TO_TICKS( 30 ) ) ) {
    2676:	20 e0       	ldi	r18, 0x00	; 0
    2678:	43 e0       	ldi	r20, 0x03	; 3
    267a:	50 e0       	ldi	r21, 0x00	; 0
    267c:	be 01       	movw	r22, r28
    267e:	6f 5f       	subi	r22, 0xFF	; 255
    2680:	7f 4f       	sbci	r23, 0xFF	; 255
    2682:	80 91 b3 0d 	lds	r24, 0x0DB3	; 0x800db3 <bufferRoombaSendUART0>
    2686:	90 91 b4 0d 	lds	r25, 0x0DB4	; 0x800db4 <bufferRoombaSendUART0+0x1>
    268a:	0e 94 8b 07 	call	0xf16	; 0xf16 <xQueueGenericSend>
    268e:	81 11       	cpse	r24, r1
    2690:	03 c0       	rjmp	.+6      	; 0x2698 <sendByteToRoomba+0x2e>
		error( ERROR_ROOMBA_SEND );
    2692:	83 e0       	ldi	r24, 0x03	; 3
    2694:	0e 94 e9 12 	call	0x25d2	; 0x25d2 <error>
	}
}
    2698:	0f 90       	pop	r0
    269a:	df 91       	pop	r29
    269c:	cf 91       	pop	r28
    269e:	08 95       	ret

000026a0 <handlerRoombaSCIStandard>:
	for( uint8_t i = uxQueueMessagesWaiting( queue ); i > 0; ++i ) {
		xQueueReceive( queue, NULL, 0 );
	}
}

static void handlerRoombaSCIStandard( uint8_t opcode, uint8_t numberOfDataBytes ) {
    26a0:	cf 93       	push	r28
    26a2:	df 93       	push	r29
    26a4:	c6 2f       	mov	r28, r22

	/* Send opcode byte to Roomba. */
	sendByteToRoomba( opcode );
    26a6:	0e 94 35 13 	call	0x266a	; 0x266a <sendByteToRoomba>

	/* Send data bytes from BT to Roomba. */
	while( numberOfDataBytes-- ) {
    26aa:	05 c0       	rjmp	.+10     	; 0x26b6 <handlerRoombaSCIStandard+0x16>
		sendByteToRoomba( getByteFromBT( ) );
    26ac:	0e 94 ff 12 	call	0x25fe	; 0x25fe <getByteFromBT>
    26b0:	0e 94 35 13 	call	0x266a	; 0x266a <sendByteToRoomba>

	/* Send opcode byte to Roomba. */
	sendByteToRoomba( opcode );

	/* Send data bytes from BT to Roomba. */
	while( numberOfDataBytes-- ) {
    26b4:	cd 2f       	mov	r28, r29
    26b6:	df ef       	ldi	r29, 0xFF	; 255
    26b8:	dc 0f       	add	r29, r28
    26ba:	c1 11       	cpse	r28, r1
    26bc:	f7 cf       	rjmp	.-18     	; 0x26ac <handlerRoombaSCIStandard+0xc>
		sendByteToRoomba( getByteFromBT( ) );
	}
}
    26be:	df 91       	pop	r29
    26c0:	cf 91       	pop	r28
    26c2:	08 95       	ret

000026c4 <handlerRoombaSCISong>:
		sensorDataRoomba[ i ] = getByteFromRoomba( );
		sendByteToBT( sensorDataRoomba[ i ] );
	}
}

static void handlerRoombaSCISong( uint8_t opcode ) {
    26c4:	cf 93       	push	r28
    26c6:	df 93       	push	r29

	uint8_t notes, length;

	/* Send opcode byte to Roomba. */
	sendByteToRoomba( opcode );
    26c8:	0e 94 35 13 	call	0x266a	; 0x266a <sendByteToRoomba>

	/* Receive SCI song number byte from Bluetooth and send it to Roomba. */
	sendByteToRoomba( getByteFromBT( ) );
    26cc:	0e 94 ff 12 	call	0x25fe	; 0x25fe <getByteFromBT>
    26d0:	0e 94 35 13 	call	0x266a	; 0x266a <sendByteToRoomba>

	/* Receive SCI song number of notes byte from Bluetooth and send it to Roomba. */
	notes = getByteFromBT( );
    26d4:	0e 94 ff 12 	call	0x25fe	; 0x25fe <getByteFromBT>
    26d8:	d8 2f       	mov	r29, r24
	sendByteToRoomba( notes );
    26da:	0e 94 35 13 	call	0x266a	; 0x266a <sendByteToRoomba>

	/* Song length is specified in notes. Each note consists of 2 bytes (note number and note duration). */
	length = 2 * notes;
    26de:	dd 0f       	add	r29, r29

	/* Send notes to Roomba. */
	for( uint8_t i = 0; i < length; ++i ) {
    26e0:	c0 e0       	ldi	r28, 0x00	; 0
    26e2:	05 c0       	rjmp	.+10     	; 0x26ee <handlerRoombaSCISong+0x2a>
		sendByteToRoomba( getByteFromBT( ) );
    26e4:	0e 94 ff 12 	call	0x25fe	; 0x25fe <getByteFromBT>
    26e8:	0e 94 35 13 	call	0x266a	; 0x266a <sendByteToRoomba>

	/* Song length is specified in notes. Each note consists of 2 bytes (note number and note duration). */
	length = 2 * notes;

	/* Send notes to Roomba. */
	for( uint8_t i = 0; i < length; ++i ) {
    26ec:	cf 5f       	subi	r28, 0xFF	; 255
    26ee:	cd 17       	cp	r28, r29
    26f0:	c8 f3       	brcs	.-14     	; 0x26e4 <handlerRoombaSCISong+0x20>
		sendByteToRoomba( getByteFromBT( ) );
	}
    26f2:	df 91       	pop	r29
    26f4:	cf 91       	pop	r28
    26f6:	08 95       	ret

000026f8 <sendByteToBT>:
		error( ERROR_BT_RECEIVE );
	}
	return byte;
}

static void sendByteToBT( uint8_t byte ) {
    26f8:	cf 93       	push	r28
    26fa:	df 93       	push	r29
    26fc:	1f 92       	push	r1
    26fe:	cd b7       	in	r28, 0x3d	; 61
    2700:	de b7       	in	r29, 0x3e	; 62
    2702:	89 83       	std	Y+1, r24	; 0x01
	/* Pushes byte on UART1 send queue. */
	if( errQUEUE_FULL == xQueueSendToBack( bufferBluetoothSendUART1, &byte, pdMS_TO_TICKS( 30 ) ) ) {
    2704:	20 e0       	ldi	r18, 0x00	; 0
    2706:	43 e0       	ldi	r20, 0x03	; 3
    2708:	50 e0       	ldi	r21, 0x00	; 0
    270a:	be 01       	movw	r22, r28
    270c:	6f 5f       	subi	r22, 0xFF	; 255
    270e:	7f 4f       	sbci	r23, 0xFF	; 255
    2710:	80 91 b5 0d 	lds	r24, 0x0DB5	; 0x800db5 <bufferBluetoothSendUART1>
    2714:	90 91 b6 0d 	lds	r25, 0x0DB6	; 0x800db6 <bufferBluetoothSendUART1+0x1>
    2718:	0e 94 8b 07 	call	0xf16	; 0xf16 <xQueueGenericSend>
    271c:	81 11       	cpse	r24, r1
    271e:	03 c0       	rjmp	.+6      	; 0x2726 <sendByteToBT+0x2e>
		error( ERROR_BT_SEND );
    2720:	84 e0       	ldi	r24, 0x04	; 4
    2722:	0e 94 e9 12 	call	0x25d2	; 0x25d2 <error>
	}
}
    2726:	0f 90       	pop	r0
    2728:	df 91       	pop	r29
    272a:	cf 91       	pop	r28
    272c:	08 95       	ret

0000272e <handlerRoombaSCISensors>:
	while( numberOfDataBytes-- ) {
		sendByteToRoomba( getByteFromBT( ) );
	}
}

static void handlerRoombaSCISensors( uint8_t opcode ) {
    272e:	0f 93       	push	r16
    2730:	1f 93       	push	r17
    2732:	cf 93       	push	r28
    2734:	df 93       	push	r29

	uint8_t packet, lengthOfSensorData;

	/* Send opcode byte to Roomba. */
	sendByteToRoomba( opcode );
    2736:	0e 94 35 13 	call	0x266a	; 0x266a <sendByteToRoomba>

	/* Receive SCI sensors data packet byte from Bluetooth and send it to Roomba. */
	packet = getByteFromBT( );
    273a:	0e 94 ff 12 	call	0x25fe	; 0x25fe <getByteFromBT>
    273e:	c8 2f       	mov	r28, r24
	sendByteToRoomba( packet );
    2740:	0e 94 35 13 	call	0x266a	; 0x266a <sendByteToRoomba>

	/* Set number of expected data bytes to receive from Roomba according to SCI sensors data byte. */
	switch (packet) {
    2744:	c1 30       	cpi	r28, 0x01	; 1
    2746:	71 f0       	breq	.+28     	; 0x2764 <handlerRoombaSCISensors+0x36>
    2748:	58 f0       	brcs	.+22     	; 0x2760 <handlerRoombaSCISensors+0x32>
    274a:	c2 30       	cpi	r28, 0x02	; 2
    274c:	19 f0       	breq	.+6      	; 0x2754 <handlerRoombaSCISensors+0x26>
    274e:	c3 30       	cpi	r28, 0x03	; 3
    2750:	49 f0       	breq	.+18     	; 0x2764 <handlerRoombaSCISensors+0x36>
    2752:	02 c0       	rjmp	.+4      	; 0x2758 <handlerRoombaSCISensors+0x2a>
		break;
		case SCI_SENSORS_PACKET1:
		lengthOfSensorData = SCI_SENSORS_PACKET1_BYTES;
		break;
		case SCI_SENSORS_PACKET2:
		lengthOfSensorData = SCI_SENSORS_PACKET2_BYTES;
    2754:	06 e0       	ldi	r16, 0x06	; 6
		break;
    2756:	07 c0       	rjmp	.+14     	; 0x2766 <handlerRoombaSCISensors+0x38>
		case SCI_SENSORS_PACKET3:
		lengthOfSensorData = SCI_SENSORS_PACKET3_BYTES;
		break;
		default:
		error( ERROR_DATA );
    2758:	87 e0       	ldi	r24, 0x07	; 7
    275a:	0e 94 e9 12 	call	0x25d2	; 0x25d2 <error>
		return;
    275e:	13 c0       	rjmp	.+38     	; 0x2786 <handlerRoombaSCISensors+0x58>
	sendByteToRoomba( packet );

	/* Set number of expected data bytes to receive from Roomba according to SCI sensors data byte. */
	switch (packet) {
		case SCI_SENSORS_PACKET0:
		lengthOfSensorData = SCI_SENSORS_PACKET0_BYTES;
    2760:	0a e1       	ldi	r16, 0x1A	; 26
    2762:	01 c0       	rjmp	.+2      	; 0x2766 <handlerRoombaSCISensors+0x38>
		break;
		case SCI_SENSORS_PACKET1:
		lengthOfSensorData = SCI_SENSORS_PACKET1_BYTES;
    2764:	0a e0       	ldi	r16, 0x0A	; 10
		return;
	}

	/* Receive and store sensor data bytes from Roomba into 
	   sensorData[] (as first n bytes) and send it to Bluetooth. */
	for( uint8_t i = 0; i < lengthOfSensorData; ++i ) {
    2766:	10 e0       	ldi	r17, 0x00	; 0
    2768:	0c c0       	rjmp	.+24     	; 0x2782 <handlerRoombaSCISensors+0x54>
		sensorDataRoomba[ i ] = getByteFromRoomba( );
    276a:	c1 2f       	mov	r28, r17
    276c:	d0 e0       	ldi	r29, 0x00	; 0
    276e:	0e 94 1a 13 	call	0x2634	; 0x2634 <getByteFromRoomba>
    2772:	fe 01       	movw	r30, r28
    2774:	ed 53       	subi	r30, 0x3D	; 61
    2776:	f2 4f       	sbci	r31, 0xF2	; 242
    2778:	80 83       	st	Z, r24
		sendByteToBT( sensorDataRoomba[ i ] );
    277a:	80 81       	ld	r24, Z
    277c:	0e 94 7c 13 	call	0x26f8	; 0x26f8 <sendByteToBT>
		return;
	}

	/* Receive and store sensor data bytes from Roomba into 
	   sensorData[] (as first n bytes) and send it to Bluetooth. */
	for( uint8_t i = 0; i < lengthOfSensorData; ++i ) {
    2780:	1f 5f       	subi	r17, 0xFF	; 255
    2782:	10 17       	cp	r17, r16
    2784:	90 f3       	brcs	.-28     	; 0x276a <handlerRoombaSCISensors+0x3c>
		sensorDataRoomba[ i ] = getByteFromRoomba( );
		sendByteToBT( sensorDataRoomba[ i ] );
	}
}
    2786:	df 91       	pop	r29
    2788:	cf 91       	pop	r28
    278a:	1f 91       	pop	r17
    278c:	0f 91       	pop	r16
    278e:	08 95       	ret

00002790 <vBluetoothReceiveCommandUART1>:
		while( ! ( UCSR1A & ( 1 << UDRE1 ) ) );		// Wait for transmit to finish
	}
}


static void vBluetoothReceiveCommandUART1( void *pvParameters ) {
    2790:	cf 93       	push	r28
    2792:	df 93       	push	r29
    2794:	1f 92       	push	r1
    2796:	cd b7       	in	r28, 0x3d	; 61
    2798:	de b7       	in	r29, 0x3e	; 62
	( void ) pvParameters;
	
	for( ;; ) {

		/* Wait until opcode is received from Bluetooth. */
		xQueueReceive( bufferBluetoothReceiveUART1, &opcode, portMAX_DELAY );
    279a:	20 e0       	ldi	r18, 0x00	; 0
    279c:	4f ef       	ldi	r20, 0xFF	; 255
    279e:	5f ef       	ldi	r21, 0xFF	; 255
    27a0:	be 01       	movw	r22, r28
    27a2:	6f 5f       	subi	r22, 0xFF	; 255
    27a4:	7f 4f       	sbci	r23, 0xFF	; 255
    27a6:	80 91 b9 0d 	lds	r24, 0x0DB9	; 0x800db9 <bufferBluetoothReceiveUART1>
    27aa:	90 91 ba 0d 	lds	r25, 0x0DBA	; 0x800dba <bufferBluetoothReceiveUART1+0x1>
    27ae:	0e 94 9e 08 	call	0x113c	; 0x113c <xQueueGenericReceive>

		/* Set number of accompanying data bytes according to Roomba SCI specification. */
		switch( opcode ) {
    27b2:	89 81       	ldd	r24, Y+1	; 0x01
    27b4:	48 2f       	mov	r20, r24
    27b6:	50 e0       	ldi	r21, 0x00	; 0
    27b8:	fa 01       	movw	r30, r20
    27ba:	e0 58       	subi	r30, 0x80	; 128
    27bc:	f1 09       	sbc	r31, r1
    27be:	e0 31       	cpi	r30, 0x10	; 16
    27c0:	f1 05       	cpc	r31, r1
    27c2:	58 f7       	brcc	.-42     	; 0x279a <vBluetoothReceiveCommandUART1+0xa>
    27c4:	ea 5b       	subi	r30, 0xBA	; 186
    27c6:	ff 4f       	sbci	r31, 0xFF	; 255
    27c8:	0c 94 d7 14 	jmp	0x29ae	; 0x29ae <__tablejump2__>
			case SCI_POWER_OPCODE:
			case SCI_SPOT_OPCODE:
			case SCI_CLEAN_OPCODE:
			case SCI_MAX_OPCODE:
			case SCI_FORCE_SEEKING_DOCK_OPCODE:
				handlerRoombaSCIStandard( opcode, 0 );
    27cc:	60 e0       	ldi	r22, 0x00	; 0
    27ce:	0e 94 50 13 	call	0x26a0	; 0x26a0 <handlerRoombaSCIStandard>
				break;
    27d2:	e3 cf       	rjmp	.-58     	; 0x279a <vBluetoothReceiveCommandUART1+0xa>

			/* Opcode followed by 1 data bytes. */
			case SCI_BAUD_OPCODE:
			case SCI_MOTORS_OPCODE:
			case SCI_PLAY_OPCODE:
				handlerRoombaSCIStandard( opcode, 1 );
    27d4:	61 e0       	ldi	r22, 0x01	; 1
    27d6:	0e 94 50 13 	call	0x26a0	; 0x26a0 <handlerRoombaSCIStandard>
				break;
    27da:	df cf       	rjmp	.-66     	; 0x279a <vBluetoothReceiveCommandUART1+0xa>

			/* Opcode followed by 3 data bytes. */
			case SCI_LEDS_OPCODE:
				handlerRoombaSCIStandard( opcode, 3 );
    27dc:	63 e0       	ldi	r22, 0x03	; 3
    27de:	0e 94 50 13 	call	0x26a0	; 0x26a0 <handlerRoombaSCIStandard>
				break;
    27e2:	db cf       	rjmp	.-74     	; 0x279a <vBluetoothReceiveCommandUART1+0xa>
			
			/* Opcode followed by 4 data bytes. */
			case SCI_DRIVE_OPCODE:
				handlerRoombaSCIStandard( opcode, 4 );
    27e4:	64 e0       	ldi	r22, 0x04	; 4
    27e6:	0e 94 50 13 	call	0x26a0	; 0x26a0 <handlerRoombaSCIStandard>
				break;
    27ea:	d7 cf       	rjmp	.-82     	; 0x279a <vBluetoothReceiveCommandUART1+0xa>

			/* Opcode followed by 1 data bytes. Roomba returns data. */
			case SCI_SENSORS_OPCODE:
				handlerRoombaSCISensors( opcode );
    27ec:	0e 94 97 13 	call	0x272e	; 0x272e <handlerRoombaSCISensors>
				break;
    27f0:	d4 cf       	rjmp	.-88     	; 0x279a <vBluetoothReceiveCommandUART1+0xa>

			/* Opcode followed by n data bytes. Serial sequence: 
			  [Opcode] [Song Number] [Song Length] [Note Number 1] [Note Duration 1] [Note Number 2] [Note Duration 2] etc. */
			case SCI_SONG_OPCODE:
				handlerRoombaSCISong( opcode );
    27f2:	0e 94 62 13 	call	0x26c4	; 0x26c4 <handlerRoombaSCISong>
				break;
    27f6:	d1 cf       	rjmp	.-94     	; 0x279a <vBluetoothReceiveCommandUART1+0xa>

000027f8 <main>:
/*************************************************************/
/*                           MAIN                            */
/*************************************************************/


int main( void ) {
    27f8:	ef 92       	push	r14
    27fa:	ff 92       	push	r15
    27fc:	0f 93       	push	r16

	/* MCU pins direction setup. */
	DDRB |= ( 1 << PB0 );
    27fe:	87 b3       	in	r24, 0x17	; 23
    2800:	81 60       	ori	r24, 0x01	; 1
    2802:	87 bb       	out	0x17, r24	; 23
	DDRB |= ( 1 << PB1 );
    2804:	87 b3       	in	r24, 0x17	; 23
    2806:	82 60       	ori	r24, 0x02	; 2
    2808:	87 bb       	out	0x17, r24	; 23

	/* Set baud rate UART0. */
	UBRR0H = ( uint8_t ) ( UBRR_UART0 >> 8 );
    280a:	10 92 90 00 	sts	0x0090, r1	; 0x800090 <__TEXT_REGION_LENGTH__+0x7e0090>
	UBRR0L = ( uint8_t )   UBRR_UART0;
    280e:	85 e0       	ldi	r24, 0x05	; 5
    2810:	89 b9       	out	0x09, r24	; 9

	/* Set baud rate UART1. */
	UBRR1H = ( uint8_t ) ( UBRR_UART1 >> 8 );
    2812:	10 92 98 00 	sts	0x0098, r1	; 0x800098 <__TEXT_REGION_LENGTH__+0x7e0098>
	UBRR1L = ( uint8_t )   UBRR_UART1;
    2816:	87 e4       	ldi	r24, 0x47	; 71
    2818:	80 93 99 00 	sts	0x0099, r24	; 0x800099 <__TEXT_REGION_LENGTH__+0x7e0099>

	/* Enable receiver and transmitter UART0. */
	UCSR0B = ( 1 << RXEN0 ) | ( 1 << TXEN0 );
    281c:	88 e1       	ldi	r24, 0x18	; 24
    281e:	8a b9       	out	0x0a, r24	; 10

	/* Enable receiver and transmitter UART1. */
	UCSR1B = ( 1 << RXEN1 ) | ( 1 << TXEN1 );
    2820:	ea e9       	ldi	r30, 0x9A	; 154
    2822:	f0 e0       	ldi	r31, 0x00	; 0
    2824:	80 83       	st	Z, r24

	/* Enable interrupts. */
	UCSR0B |= ( 1 << RXCIE0 );
    2826:	8a b1       	in	r24, 0x0a	; 10
    2828:	80 68       	ori	r24, 0x80	; 128
    282a:	8a b9       	out	0x0a, r24	; 10
	UCSR1B |= ( 1 << RXCIE1 );
    282c:	80 81       	ld	r24, Z
    282e:	80 68       	ori	r24, 0x80	; 128
    2830:	80 83       	st	Z, r24
	sei( );
    2832:	78 94       	sei

	/* Create queues. */
	bufferRoombaSendUART0		= xQueueCreate( 32, sizeof( uint8_t ) );
    2834:	40 e0       	ldi	r20, 0x00	; 0
    2836:	61 e0       	ldi	r22, 0x01	; 1
    2838:	80 e2       	ldi	r24, 0x20	; 32
    283a:	0e 94 61 07 	call	0xec2	; 0xec2 <xQueueGenericCreate>
    283e:	90 93 b4 0d 	sts	0x0DB4, r25	; 0x800db4 <bufferRoombaSendUART0+0x1>
    2842:	80 93 b3 0d 	sts	0x0DB3, r24	; 0x800db3 <bufferRoombaSendUART0>
	bufferRoombaReceiveUART0	= xQueueCreate( 32, sizeof( uint8_t ) );
    2846:	40 e0       	ldi	r20, 0x00	; 0
    2848:	61 e0       	ldi	r22, 0x01	; 1
    284a:	80 e2       	ldi	r24, 0x20	; 32
    284c:	0e 94 61 07 	call	0xec2	; 0xec2 <xQueueGenericCreate>
    2850:	90 93 de 0d 	sts	0x0DDE, r25	; 0x800dde <bufferRoombaReceiveUART0+0x1>
    2854:	80 93 dd 0d 	sts	0x0DDD, r24	; 0x800ddd <bufferRoombaReceiveUART0>
	bufferBluetoothSendUART1	= xQueueCreate( 32, sizeof( uint8_t ) );
    2858:	40 e0       	ldi	r20, 0x00	; 0
    285a:	61 e0       	ldi	r22, 0x01	; 1
    285c:	80 e2       	ldi	r24, 0x20	; 32
    285e:	0e 94 61 07 	call	0xec2	; 0xec2 <xQueueGenericCreate>
    2862:	90 93 b6 0d 	sts	0x0DB6, r25	; 0x800db6 <bufferBluetoothSendUART1+0x1>
    2866:	80 93 b5 0d 	sts	0x0DB5, r24	; 0x800db5 <bufferBluetoothSendUART1>
	bufferBluetoothReceiveUART1 = xQueueCreate( 32, sizeof( uint8_t ) );
    286a:	40 e0       	ldi	r20, 0x00	; 0
    286c:	61 e0       	ldi	r22, 0x01	; 1
    286e:	80 e2       	ldi	r24, 0x20	; 32
    2870:	0e 94 61 07 	call	0xec2	; 0xec2 <xQueueGenericCreate>
    2874:	90 93 ba 0d 	sts	0x0DBA, r25	; 0x800dba <bufferBluetoothReceiveUART1+0x1>
    2878:	80 93 b9 0d 	sts	0x0DB9, r24	; 0x800db9 <bufferBluetoothReceiveUART1>
	globalError					= xQueueCreate(  1, sizeof( uint8_t ) );
    287c:	40 e0       	ldi	r20, 0x00	; 0
    287e:	61 e0       	ldi	r22, 0x01	; 1
    2880:	81 e0       	ldi	r24, 0x01	; 1
    2882:	0e 94 61 07 	call	0xec2	; 0xec2 <xQueueGenericCreate>
    2886:	90 93 b8 0d 	sts	0x0DB8, r25	; 0x800db8 <globalError+0x1>
    288a:	80 93 b7 0d 	sts	0x0DB7, r24	; 0x800db7 <globalError>

	/* Create the tasks. */
	xTaskCreate( vBluetoothReceiveCommandUART1,	 "BTcmd",   configMINIMAL_STACK_SIZE, NULL, mainNORMAL_PRIORITY, NULL );
    288e:	e1 2c       	mov	r14, r1
    2890:	f1 2c       	mov	r15, r1
    2892:	02 e0       	ldi	r16, 0x02	; 2
    2894:	20 e0       	ldi	r18, 0x00	; 0
    2896:	30 e0       	ldi	r19, 0x00	; 0
    2898:	45 e5       	ldi	r20, 0x55	; 85
    289a:	50 e0       	ldi	r21, 0x00	; 0
    289c:	65 e0       	ldi	r22, 0x05	; 5
    289e:	71 e0       	ldi	r23, 0x01	; 1
    28a0:	88 ec       	ldi	r24, 0xC8	; 200
    28a2:	93 e1       	ldi	r25, 0x13	; 19
    28a4:	0e 94 2a 0c 	call	0x1854	; 0x1854 <xTaskCreate>
	xTaskCreate( vRoombaTransmitServiceUART0,    "UART0Tx", configMINIMAL_STACK_SIZE, NULL, mainHIGH_PRIORITY,   NULL );
    28a8:	03 e0       	ldi	r16, 0x03	; 3
    28aa:	20 e0       	ldi	r18, 0x00	; 0
    28ac:	30 e0       	ldi	r19, 0x00	; 0
    28ae:	45 e5       	ldi	r20, 0x55	; 85
    28b0:	50 e0       	ldi	r21, 0x00	; 0
    28b2:	6b e0       	ldi	r22, 0x0B	; 11
    28b4:	71 e0       	ldi	r23, 0x01	; 1
    28b6:	8b ed       	ldi	r24, 0xDB	; 219
    28b8:	92 e1       	ldi	r25, 0x12	; 18
    28ba:	0e 94 2a 0c 	call	0x1854	; 0x1854 <xTaskCreate>
	xTaskCreate( vBluetoothTransmitServiceUART1, "UART1Tx", configMINIMAL_STACK_SIZE, NULL, mainHIGH_PRIORITY,   NULL );
    28be:	20 e0       	ldi	r18, 0x00	; 0
    28c0:	30 e0       	ldi	r19, 0x00	; 0
    28c2:	45 e5       	ldi	r20, 0x55	; 85
    28c4:	50 e0       	ldi	r21, 0x00	; 0
    28c6:	63 e1       	ldi	r22, 0x13	; 19
    28c8:	71 e0       	ldi	r23, 0x01	; 1
    28ca:	8b ec       	ldi	r24, 0xCB	; 203
    28cc:	92 e1       	ldi	r25, 0x12	; 18
    28ce:	0e 94 2a 0c 	call	0x1854	; 0x1854 <xTaskCreate>
	xTaskCreate( vErrorHandler,                  "Error",   configMINIMAL_STACK_SIZE, NULL, mainERROR_PRIORITY,  NULL );
    28d2:	04 e0       	ldi	r16, 0x04	; 4
    28d4:	20 e0       	ldi	r18, 0x00	; 0
    28d6:	30 e0       	ldi	r19, 0x00	; 0
    28d8:	45 e5       	ldi	r20, 0x55	; 85
    28da:	50 e0       	ldi	r21, 0x00	; 0
    28dc:	6b e1       	ldi	r22, 0x1B	; 27
    28de:	71 e0       	ldi	r23, 0x01	; 1
    28e0:	8a ec       	ldi	r24, 0xCA	; 202
    28e2:	92 e1       	ldi	r25, 0x12	; 18
    28e4:	0e 94 2a 0c 	call	0x1854	; 0x1854 <xTaskCreate>

	vTaskStartScheduler( );
    28e8:	0e 94 7e 0c 	call	0x18fc	; 0x18fc <vTaskStartScheduler>

	return 0;
}
    28ec:	80 e0       	ldi	r24, 0x00	; 0
    28ee:	90 e0       	ldi	r25, 0x00	; 0
    28f0:	0f 91       	pop	r16
    28f2:	ff 90       	pop	r15
    28f4:	ef 90       	pop	r14
    28f6:	08 95       	ret

000028f8 <vApplicationIdleHook>:

	}
}


void vApplicationIdleHook( void ) {
    28f8:	08 95       	ret

000028fa <__vector_18>:
/*************************************************************/
/*                INTERRUPT SERVICE ROUTINES                 */
/*************************************************************/


ISR( USART0_RX_vect ) {
    28fa:	1f 92       	push	r1
    28fc:	0f 92       	push	r0
    28fe:	0f b6       	in	r0, 0x3f	; 63
    2900:	0f 92       	push	r0
    2902:	11 24       	eor	r1, r1
    2904:	2f 93       	push	r18
    2906:	3f 93       	push	r19
    2908:	4f 93       	push	r20
    290a:	5f 93       	push	r21
    290c:	6f 93       	push	r22
    290e:	7f 93       	push	r23
    2910:	8f 93       	push	r24
    2912:	9f 93       	push	r25
    2914:	af 93       	push	r26
    2916:	bf 93       	push	r27
    2918:	ef 93       	push	r30
    291a:	ff 93       	push	r31
	/* UART0 receive complete ISR. 
	   Pushes received byte from UDR0 register on bufferRoombaReceiveUART0 queue. */
	xQueueSendToBackFromISR( bufferRoombaReceiveUART0, &UDR0, NULL );
    291c:	20 e0       	ldi	r18, 0x00	; 0
    291e:	40 e0       	ldi	r20, 0x00	; 0
    2920:	50 e0       	ldi	r21, 0x00	; 0
    2922:	6c e2       	ldi	r22, 0x2C	; 44
    2924:	70 e0       	ldi	r23, 0x00	; 0
    2926:	80 91 dd 0d 	lds	r24, 0x0DDD	; 0x800ddd <bufferRoombaReceiveUART0>
    292a:	90 91 de 0d 	lds	r25, 0x0DDE	; 0x800dde <bufferRoombaReceiveUART0+0x1>
    292e:	0e 94 3b 08 	call	0x1076	; 0x1076 <xQueueGenericSendFromISR>
}
    2932:	ff 91       	pop	r31
    2934:	ef 91       	pop	r30
    2936:	bf 91       	pop	r27
    2938:	af 91       	pop	r26
    293a:	9f 91       	pop	r25
    293c:	8f 91       	pop	r24
    293e:	7f 91       	pop	r23
    2940:	6f 91       	pop	r22
    2942:	5f 91       	pop	r21
    2944:	4f 91       	pop	r20
    2946:	3f 91       	pop	r19
    2948:	2f 91       	pop	r18
    294a:	0f 90       	pop	r0
    294c:	0f be       	out	0x3f, r0	; 63
    294e:	0f 90       	pop	r0
    2950:	1f 90       	pop	r1
    2952:	18 95       	reti

00002954 <__vector_30>:

ISR( USART1_RX_vect ) {
    2954:	1f 92       	push	r1
    2956:	0f 92       	push	r0
    2958:	0f b6       	in	r0, 0x3f	; 63
    295a:	0f 92       	push	r0
    295c:	11 24       	eor	r1, r1
    295e:	2f 93       	push	r18
    2960:	3f 93       	push	r19
    2962:	4f 93       	push	r20
    2964:	5f 93       	push	r21
    2966:	6f 93       	push	r22
    2968:	7f 93       	push	r23
    296a:	8f 93       	push	r24
    296c:	9f 93       	push	r25
    296e:	af 93       	push	r26
    2970:	bf 93       	push	r27
    2972:	ef 93       	push	r30
    2974:	ff 93       	push	r31
/* UART1 receive complete ISR. 
	   Pushes received byte from UDR1 register on bufferBluetoothReceiveUART1 queue. */
	xQueueSendToBackFromISR( bufferBluetoothReceiveUART1, &UDR1, NULL );
    2976:	20 e0       	ldi	r18, 0x00	; 0
    2978:	40 e0       	ldi	r20, 0x00	; 0
    297a:	50 e0       	ldi	r21, 0x00	; 0
    297c:	6c e9       	ldi	r22, 0x9C	; 156
    297e:	70 e0       	ldi	r23, 0x00	; 0
    2980:	80 91 b9 0d 	lds	r24, 0x0DB9	; 0x800db9 <bufferBluetoothReceiveUART1>
    2984:	90 91 ba 0d 	lds	r25, 0x0DBA	; 0x800dba <bufferBluetoothReceiveUART1+0x1>
    2988:	0e 94 3b 08 	call	0x1076	; 0x1076 <xQueueGenericSendFromISR>
}
    298c:	ff 91       	pop	r31
    298e:	ef 91       	pop	r30
    2990:	bf 91       	pop	r27
    2992:	af 91       	pop	r26
    2994:	9f 91       	pop	r25
    2996:	8f 91       	pop	r24
    2998:	7f 91       	pop	r23
    299a:	6f 91       	pop	r22
    299c:	5f 91       	pop	r21
    299e:	4f 91       	pop	r20
    29a0:	3f 91       	pop	r19
    29a2:	2f 91       	pop	r18
    29a4:	0f 90       	pop	r0
    29a6:	0f be       	out	0x3f, r0	; 63
    29a8:	0f 90       	pop	r0
    29aa:	1f 90       	pop	r1
    29ac:	18 95       	reti

000029ae <__tablejump2__>:
    29ae:	ee 0f       	add	r30, r30
    29b0:	ff 1f       	adc	r31, r31
    29b2:	05 90       	lpm	r0, Z+
    29b4:	f4 91       	lpm	r31, Z
    29b6:	e0 2d       	mov	r30, r0
    29b8:	09 94       	ijmp

000029ba <memcpy>:
    29ba:	fb 01       	movw	r30, r22
    29bc:	dc 01       	movw	r26, r24
    29be:	02 c0       	rjmp	.+4      	; 0x29c4 <memcpy+0xa>
    29c0:	01 90       	ld	r0, Z+
    29c2:	0d 92       	st	X+, r0
    29c4:	41 50       	subi	r20, 0x01	; 1
    29c6:	50 40       	sbci	r21, 0x00	; 0
    29c8:	d8 f7       	brcc	.-10     	; 0x29c0 <memcpy+0x6>
    29ca:	08 95       	ret

000029cc <_exit>:
    29cc:	f8 94       	cli

000029ce <__stop_program>:
    29ce:	ff cf       	rjmp	.-2      	; 0x29ce <__stop_program>
