
RoombaCommander_ATmega64.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000001e  00800100  00002c52  00002ce6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002c52  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000cba  0080011e  0080011e  00002d04  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002d04  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00002d34  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000004e0  00000000  00000000  00002d70  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000583d  00000000  00000000  00003250  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001811  00000000  00000000  00008a8d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000320c  00000000  00000000  0000a29e  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000f6c  00000000  00000000  0000d4ac  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001ae7  00000000  00000000  0000e418  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00005469  00000000  00000000  0000feff  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000004d0  00000000  00000000  00015368  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 54 00 	jmp	0xa8	; 0xa8 <__ctors_end>
       4:	0c 94 71 00 	jmp	0xe2	; 0xe2 <__bad_interrupt>
       8:	0c 94 71 00 	jmp	0xe2	; 0xe2 <__bad_interrupt>
       c:	0c 94 71 00 	jmp	0xe2	; 0xe2 <__bad_interrupt>
      10:	0c 94 71 00 	jmp	0xe2	; 0xe2 <__bad_interrupt>
      14:	0c 94 71 00 	jmp	0xe2	; 0xe2 <__bad_interrupt>
      18:	0c 94 71 00 	jmp	0xe2	; 0xe2 <__bad_interrupt>
      1c:	0c 94 71 00 	jmp	0xe2	; 0xe2 <__bad_interrupt>
      20:	0c 94 71 00 	jmp	0xe2	; 0xe2 <__bad_interrupt>
      24:	0c 94 71 00 	jmp	0xe2	; 0xe2 <__bad_interrupt>
      28:	0c 94 71 00 	jmp	0xe2	; 0xe2 <__bad_interrupt>
      2c:	0c 94 71 00 	jmp	0xe2	; 0xe2 <__bad_interrupt>
      30:	0c 94 f7 05 	jmp	0xbee	; 0xbee <__vector_12>
      34:	0c 94 71 00 	jmp	0xe2	; 0xe2 <__bad_interrupt>
      38:	0c 94 71 00 	jmp	0xe2	; 0xe2 <__bad_interrupt>
      3c:	0c 94 71 00 	jmp	0xe2	; 0xe2 <__bad_interrupt>
      40:	0c 94 71 00 	jmp	0xe2	; 0xe2 <__bad_interrupt>
      44:	0c 94 71 00 	jmp	0xe2	; 0xe2 <__bad_interrupt>
      48:	0c 94 38 14 	jmp	0x2870	; 0x2870 <__vector_18>
      4c:	0c 94 71 00 	jmp	0xe2	; 0xe2 <__bad_interrupt>
      50:	0c 94 71 00 	jmp	0xe2	; 0xe2 <__bad_interrupt>
      54:	0c 94 71 00 	jmp	0xe2	; 0xe2 <__bad_interrupt>
      58:	0c 94 71 00 	jmp	0xe2	; 0xe2 <__bad_interrupt>
      5c:	0c 94 71 00 	jmp	0xe2	; 0xe2 <__bad_interrupt>
      60:	0c 94 71 00 	jmp	0xe2	; 0xe2 <__bad_interrupt>
      64:	0c 94 71 00 	jmp	0xe2	; 0xe2 <__bad_interrupt>
      68:	0c 94 71 00 	jmp	0xe2	; 0xe2 <__bad_interrupt>
      6c:	0c 94 71 00 	jmp	0xe2	; 0xe2 <__bad_interrupt>
      70:	0c 94 71 00 	jmp	0xe2	; 0xe2 <__bad_interrupt>
      74:	0c 94 71 00 	jmp	0xe2	; 0xe2 <__bad_interrupt>
      78:	0c 94 65 14 	jmp	0x28ca	; 0x28ca <__vector_30>
      7c:	0c 94 71 00 	jmp	0xe2	; 0xe2 <__bad_interrupt>
      80:	0c 94 71 00 	jmp	0xe2	; 0xe2 <__bad_interrupt>
      84:	0c 94 71 00 	jmp	0xe2	; 0xe2 <__bad_interrupt>
      88:	0c 94 71 00 	jmp	0xe2	; 0xe2 <__bad_interrupt>
      8c:	75 13       	cpse	r23, r21
      8e:	6f 13       	cpse	r22, r31
      90:	6f 13       	cpse	r22, r31
      92:	6f 13       	cpse	r22, r31
      94:	6f 13       	cpse	r22, r31
      96:	6f 13       	cpse	r22, r31
      98:	6f 13       	cpse	r22, r31
      9a:	6f 13       	cpse	r22, r31
      9c:	73 13       	cpse	r23, r19
      9e:	75 13       	cpse	r23, r21
      a0:	71 13       	cpse	r23, r17
      a2:	71 13       	cpse	r23, r17
      a4:	75 13       	cpse	r23, r21
      a6:	75 13       	cpse	r23, r21

000000a8 <__ctors_end>:
      a8:	11 24       	eor	r1, r1
      aa:	1f be       	out	0x3f, r1	; 63
      ac:	cf ef       	ldi	r28, 0xFF	; 255
      ae:	d0 e1       	ldi	r29, 0x10	; 16
      b0:	de bf       	out	0x3e, r29	; 62
      b2:	cd bf       	out	0x3d, r28	; 61

000000b4 <__do_copy_data>:
      b4:	11 e0       	ldi	r17, 0x01	; 1
      b6:	a0 e0       	ldi	r26, 0x00	; 0
      b8:	b1 e0       	ldi	r27, 0x01	; 1
      ba:	e2 e5       	ldi	r30, 0x52	; 82
      bc:	fc e2       	ldi	r31, 0x2C	; 44
      be:	02 c0       	rjmp	.+4      	; 0xc4 <__do_copy_data+0x10>
      c0:	05 90       	lpm	r0, Z+
      c2:	0d 92       	st	X+, r0
      c4:	ae 31       	cpi	r26, 0x1E	; 30
      c6:	b1 07       	cpc	r27, r17
      c8:	d9 f7       	brne	.-10     	; 0xc0 <__do_copy_data+0xc>

000000ca <__do_clear_bss>:
      ca:	2d e0       	ldi	r18, 0x0D	; 13
      cc:	ae e1       	ldi	r26, 0x1E	; 30
      ce:	b1 e0       	ldi	r27, 0x01	; 1
      d0:	01 c0       	rjmp	.+2      	; 0xd4 <.do_clear_bss_start>

000000d2 <.do_clear_bss_loop>:
      d2:	1d 92       	st	X+, r1

000000d4 <.do_clear_bss_start>:
      d4:	a8 3d       	cpi	r26, 0xD8	; 216
      d6:	b2 07       	cpc	r27, r18
      d8:	e1 f7       	brne	.-8      	; 0xd2 <.do_clear_bss_loop>
      da:	0e 94 c3 13 	call	0x2786	; 0x2786 <main>
      de:	0c 94 27 16 	jmp	0x2c4e	; 0x2c4e <_exit>

000000e2 <__bad_interrupt>:
      e2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000e6 <prvInitialiseCoRoutineLists>:
	return;
}
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
      e6:	cf 93       	push	r28
UBaseType_t uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
      e8:	c0 e0       	ldi	r28, 0x00	; 0
      ea:	10 c0       	rjmp	.+32     	; 0x10c <prvInitialiseCoRoutineLists+0x26>
	{
		vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
      ec:	8c 2f       	mov	r24, r28
      ee:	90 e0       	ldi	r25, 0x00	; 0
      f0:	9c 01       	movw	r18, r24
      f2:	22 0f       	add	r18, r18
      f4:	33 1f       	adc	r19, r19
      f6:	22 0f       	add	r18, r18
      f8:	33 1f       	adc	r19, r19
      fa:	22 0f       	add	r18, r18
      fc:	33 1f       	adc	r19, r19
      fe:	82 0f       	add	r24, r18
     100:	93 1f       	adc	r25, r19
     102:	8a 5b       	subi	r24, 0xBA	; 186
     104:	9e 4f       	sbci	r25, 0xFE	; 254
     106:	0e 94 12 04 	call	0x824	; 0x824 <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
     10a:	cf 5f       	subi	r28, 0xFF	; 255
     10c:	c2 30       	cpi	r28, 0x02	; 2
     10e:	70 f3       	brcs	.-36     	; 0xec <prvInitialiseCoRoutineLists+0x6>
	{
		vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
     110:	8d e3       	ldi	r24, 0x3D	; 61
     112:	91 e0       	ldi	r25, 0x01	; 1
     114:	0e 94 12 04 	call	0x824	; 0x824 <vListInitialise>
	vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
     118:	84 e3       	ldi	r24, 0x34	; 52
     11a:	91 e0       	ldi	r25, 0x01	; 1
     11c:	0e 94 12 04 	call	0x824	; 0x824 <vListInitialise>
	vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
     120:	87 e2       	ldi	r24, 0x27	; 39
     122:	91 e0       	ldi	r25, 0x01	; 1
     124:	0e 94 12 04 	call	0x824	; 0x824 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
     128:	8d e3       	ldi	r24, 0x3D	; 61
     12a:	91 e0       	ldi	r25, 0x01	; 1
     12c:	90 93 33 01 	sts	0x0133, r25	; 0x800133 <pxDelayedCoRoutineList+0x1>
     130:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <pxDelayedCoRoutineList>
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
     134:	84 e3       	ldi	r24, 0x34	; 52
     136:	91 e0       	ldi	r25, 0x01	; 1
     138:	90 93 31 01 	sts	0x0131, r25	; 0x800131 <pxOverflowDelayedCoRoutineList+0x1>
     13c:	80 93 30 01 	sts	0x0130, r24	; 0x800130 <pxOverflowDelayedCoRoutineList>
}
     140:	cf 91       	pop	r28
     142:	08 95       	ret

00000144 <prvCheckPendingReadyList>:
	}
}
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
     144:	0f 93       	push	r16
     146:	1f 93       	push	r17
     148:	cf 93       	push	r28
     14a:	df 93       	push	r29
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     14c:	28 c0       	rjmp	.+80     	; 0x19e <prvCheckPendingReadyList+0x5a>
	{
		CRCB_t *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
     14e:	f8 94       	cli
		{
			pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
     150:	e0 91 2c 01 	lds	r30, 0x012C	; 0x80012c <xPendingReadyCoRoutineList+0x5>
     154:	f0 91 2d 01 	lds	r31, 0x012D	; 0x80012d <xPendingReadyCoRoutineList+0x6>
     158:	c6 81       	ldd	r28, Z+6	; 0x06
     15a:	d7 81       	ldd	r29, Z+7	; 0x07
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     15c:	ce 01       	movw	r24, r28
     15e:	0c 96       	adiw	r24, 0x0c	; 12
     160:	0e 94 76 04 	call	0x8ec	; 0x8ec <uxListRemove>
		}
		portENABLE_INTERRUPTS();
     164:	78 94       	sei

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
     166:	8e 01       	movw	r16, r28
     168:	0e 5f       	subi	r16, 0xFE	; 254
     16a:	1f 4f       	sbci	r17, 0xFF	; 255
     16c:	c8 01       	movw	r24, r16
     16e:	0e 94 76 04 	call	0x8ec	; 0x8ec <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
     172:	8e 89       	ldd	r24, Y+22	; 0x16
     174:	90 91 24 01 	lds	r25, 0x0124	; 0x800124 <uxTopCoRoutineReadyPriority>
     178:	98 17       	cp	r25, r24
     17a:	10 f4       	brcc	.+4      	; 0x180 <prvCheckPendingReadyList+0x3c>
     17c:	80 93 24 01 	sts	0x0124, r24	; 0x800124 <uxTopCoRoutineReadyPriority>
     180:	90 e0       	ldi	r25, 0x00	; 0
     182:	9c 01       	movw	r18, r24
     184:	22 0f       	add	r18, r18
     186:	33 1f       	adc	r19, r19
     188:	22 0f       	add	r18, r18
     18a:	33 1f       	adc	r19, r19
     18c:	22 0f       	add	r18, r18
     18e:	33 1f       	adc	r19, r19
     190:	82 0f       	add	r24, r18
     192:	93 1f       	adc	r25, r19
     194:	b8 01       	movw	r22, r16
     196:	8a 5b       	subi	r24, 0xBA	; 186
     198:	9e 4f       	sbci	r25, 0xFE	; 254
     19a:	0e 94 24 04 	call	0x848	; 0x848 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     19e:	80 91 27 01 	lds	r24, 0x0127	; 0x800127 <xPendingReadyCoRoutineList>
     1a2:	81 11       	cpse	r24, r1
     1a4:	d4 cf       	rjmp	.-88     	; 0x14e <prvCheckPendingReadyList+0xa>
		portENABLE_INTERRUPTS();

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
	}
}
     1a6:	df 91       	pop	r29
     1a8:	cf 91       	pop	r28
     1aa:	1f 91       	pop	r17
     1ac:	0f 91       	pop	r16
     1ae:	08 95       	ret

000001b0 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
     1b0:	0f 93       	push	r16
     1b2:	1f 93       	push	r17
     1b4:	cf 93       	push	r28
     1b6:	df 93       	push	r29
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
     1b8:	0e 94 b2 0c 	call	0x1964	; 0x1964 <xTaskGetTickCount>
     1bc:	20 91 20 01 	lds	r18, 0x0120	; 0x800120 <xLastTickCount>
     1c0:	30 91 21 01 	lds	r19, 0x0121	; 0x800121 <xLastTickCount+0x1>
     1c4:	82 1b       	sub	r24, r18
     1c6:	93 0b       	sbc	r25, r19
     1c8:	90 93 1f 01 	sts	0x011F, r25	; 0x80011f <__data_end+0x1>
     1cc:	80 93 1e 01 	sts	0x011E, r24	; 0x80011e <__data_end>
	while( xPassedTicks )
     1d0:	5e c0       	rjmp	.+188    	; 0x28e <prvCheckDelayedList+0xde>
	{
		xCoRoutineTickCount++;
     1d2:	20 91 22 01 	lds	r18, 0x0122	; 0x800122 <xCoRoutineTickCount>
     1d6:	30 91 23 01 	lds	r19, 0x0123	; 0x800123 <xCoRoutineTickCount+0x1>
     1da:	2f 5f       	subi	r18, 0xFF	; 255
     1dc:	3f 4f       	sbci	r19, 0xFF	; 255
     1de:	30 93 23 01 	sts	0x0123, r19	; 0x800123 <xCoRoutineTickCount+0x1>
     1e2:	20 93 22 01 	sts	0x0122, r18	; 0x800122 <xCoRoutineTickCount>
		xPassedTicks--;
     1e6:	01 97       	sbiw	r24, 0x01	; 1
     1e8:	90 93 1f 01 	sts	0x011F, r25	; 0x80011f <__data_end+0x1>
     1ec:	80 93 1e 01 	sts	0x011E, r24	; 0x80011e <__data_end>

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
     1f0:	23 2b       	or	r18, r19
     1f2:	09 f0       	breq	.+2      	; 0x1f6 <prvCheckDelayedList+0x46>
     1f4:	45 c0       	rjmp	.+138    	; 0x280 <prvCheckDelayedList+0xd0>
		{
			List_t * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
     1f6:	80 91 32 01 	lds	r24, 0x0132	; 0x800132 <pxDelayedCoRoutineList>
     1fa:	90 91 33 01 	lds	r25, 0x0133	; 0x800133 <pxDelayedCoRoutineList+0x1>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
     1fe:	20 91 30 01 	lds	r18, 0x0130	; 0x800130 <pxOverflowDelayedCoRoutineList>
     202:	30 91 31 01 	lds	r19, 0x0131	; 0x800131 <pxOverflowDelayedCoRoutineList+0x1>
     206:	30 93 33 01 	sts	0x0133, r19	; 0x800133 <pxDelayedCoRoutineList+0x1>
     20a:	20 93 32 01 	sts	0x0132, r18	; 0x800132 <pxDelayedCoRoutineList>
			pxOverflowDelayedCoRoutineList = pxTemp;
     20e:	90 93 31 01 	sts	0x0131, r25	; 0x800131 <pxOverflowDelayedCoRoutineList+0x1>
     212:	80 93 30 01 	sts	0x0130, r24	; 0x800130 <pxOverflowDelayedCoRoutineList>
     216:	34 c0       	rjmp	.+104    	; 0x280 <prvCheckDelayedList+0xd0>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     218:	05 80       	ldd	r0, Z+5	; 0x05
     21a:	f6 81       	ldd	r31, Z+6	; 0x06
     21c:	e0 2d       	mov	r30, r0
     21e:	c6 81       	ldd	r28, Z+6	; 0x06
     220:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
     222:	2a 81       	ldd	r18, Y+2	; 0x02
     224:	3b 81       	ldd	r19, Y+3	; 0x03
     226:	80 91 22 01 	lds	r24, 0x0122	; 0x800122 <xCoRoutineTickCount>
     22a:	90 91 23 01 	lds	r25, 0x0123	; 0x800123 <xCoRoutineTickCount+0x1>
     22e:	82 17       	cp	r24, r18
     230:	93 07       	cpc	r25, r19
     232:	68 f1       	brcs	.+90     	; 0x28e <prvCheckDelayedList+0xde>
			{
				/* Timeout not yet expired. */
				break;
			}

			portDISABLE_INTERRUPTS();
     234:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
     236:	8e 01       	movw	r16, r28
     238:	0e 5f       	subi	r16, 0xFE	; 254
     23a:	1f 4f       	sbci	r17, 0xFF	; 255
     23c:	c8 01       	movw	r24, r16
     23e:	0e 94 76 04 	call	0x8ec	; 0x8ec <uxListRemove>

				/* Is the co-routine waiting on an event also? */
				if( pxCRCB->xEventListItem.pvContainer )
     242:	8c 89       	ldd	r24, Y+20	; 0x14
     244:	9d 89       	ldd	r25, Y+21	; 0x15
     246:	89 2b       	or	r24, r25
     248:	21 f0       	breq	.+8      	; 0x252 <prvCheckDelayedList+0xa2>
				{
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
     24a:	ce 01       	movw	r24, r28
     24c:	0c 96       	adiw	r24, 0x0c	; 12
     24e:	0e 94 76 04 	call	0x8ec	; 0x8ec <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
     252:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );
     254:	8e 89       	ldd	r24, Y+22	; 0x16
     256:	90 91 24 01 	lds	r25, 0x0124	; 0x800124 <uxTopCoRoutineReadyPriority>
     25a:	98 17       	cp	r25, r24
     25c:	10 f4       	brcc	.+4      	; 0x262 <prvCheckDelayedList+0xb2>
     25e:	80 93 24 01 	sts	0x0124, r24	; 0x800124 <uxTopCoRoutineReadyPriority>
     262:	90 e0       	ldi	r25, 0x00	; 0
     264:	9c 01       	movw	r18, r24
     266:	22 0f       	add	r18, r18
     268:	33 1f       	adc	r19, r19
     26a:	22 0f       	add	r18, r18
     26c:	33 1f       	adc	r19, r19
     26e:	22 0f       	add	r18, r18
     270:	33 1f       	adc	r19, r19
     272:	82 0f       	add	r24, r18
     274:	93 1f       	adc	r25, r19
     276:	b8 01       	movw	r22, r16
     278:	8a 5b       	subi	r24, 0xBA	; 186
     27a:	9e 4f       	sbci	r25, 0xFE	; 254
     27c:	0e 94 24 04 	call	0x848	; 0x848 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     280:	e0 91 32 01 	lds	r30, 0x0132	; 0x800132 <pxDelayedCoRoutineList>
     284:	f0 91 33 01 	lds	r31, 0x0133	; 0x800133 <pxDelayedCoRoutineList+0x1>
     288:	80 81       	ld	r24, Z
     28a:	81 11       	cpse	r24, r1
     28c:	c5 cf       	rjmp	.-118    	; 0x218 <prvCheckDelayedList+0x68>
static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
     28e:	80 91 1e 01 	lds	r24, 0x011E	; 0x80011e <__data_end>
     292:	90 91 1f 01 	lds	r25, 0x011F	; 0x80011f <__data_end+0x1>
     296:	00 97       	sbiw	r24, 0x00	; 0
     298:	09 f0       	breq	.+2      	; 0x29c <prvCheckDelayedList+0xec>
     29a:	9b cf       	rjmp	.-202    	; 0x1d2 <prvCheckDelayedList+0x22>

			prvAddCoRoutineToReadyQueue( pxCRCB );
		}
	}

	xLastTickCount = xCoRoutineTickCount;
     29c:	80 91 22 01 	lds	r24, 0x0122	; 0x800122 <xCoRoutineTickCount>
     2a0:	90 91 23 01 	lds	r25, 0x0123	; 0x800123 <xCoRoutineTickCount+0x1>
     2a4:	90 93 21 01 	sts	0x0121, r25	; 0x800121 <xLastTickCount+0x1>
     2a8:	80 93 20 01 	sts	0x0120, r24	; 0x800120 <xLastTickCount>
}
     2ac:	df 91       	pop	r29
     2ae:	cf 91       	pop	r28
     2b0:	1f 91       	pop	r17
     2b2:	0f 91       	pop	r16
     2b4:	08 95       	ret

000002b6 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, UBaseType_t uxPriority, UBaseType_t uxIndex )
{
     2b6:	cf 92       	push	r12
     2b8:	df 92       	push	r13
     2ba:	ff 92       	push	r15
     2bc:	0f 93       	push	r16
     2be:	1f 93       	push	r17
     2c0:	cf 93       	push	r28
     2c2:	df 93       	push	r29
     2c4:	6c 01       	movw	r12, r24
     2c6:	f6 2e       	mov	r15, r22
     2c8:	14 2f       	mov	r17, r20
BaseType_t xReturn;
CRCB_t *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
     2ca:	8a e1       	ldi	r24, 0x1A	; 26
     2cc:	90 e0       	ldi	r25, 0x00	; 0
     2ce:	0e 94 fa 05 	call	0xbf4	; 0xbf4 <pvPortMalloc>
     2d2:	ec 01       	movw	r28, r24
	if( pxCoRoutine )
     2d4:	89 2b       	or	r24, r25
     2d6:	09 f4       	brne	.+2      	; 0x2da <xCoRoutineCreate+0x24>
     2d8:	42 c0       	rjmp	.+132    	; 0x35e <xCoRoutineCreate+0xa8>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
     2da:	80 91 25 01 	lds	r24, 0x0125	; 0x800125 <pxCurrentCoRoutine>
     2de:	90 91 26 01 	lds	r25, 0x0126	; 0x800126 <pxCurrentCoRoutine+0x1>
     2e2:	89 2b       	or	r24, r25
     2e4:	31 f4       	brne	.+12     	; 0x2f2 <xCoRoutineCreate+0x3c>
		{
			pxCurrentCoRoutine = pxCoRoutine;
     2e6:	d0 93 26 01 	sts	0x0126, r29	; 0x800126 <pxCurrentCoRoutine+0x1>
     2ea:	c0 93 25 01 	sts	0x0125, r28	; 0x800125 <pxCurrentCoRoutine>
			prvInitialiseCoRoutineLists();
     2ee:	0e 94 73 00 	call	0xe6	; 0xe6 <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
     2f2:	81 e0       	ldi	r24, 0x01	; 1
     2f4:	8f 15       	cp	r24, r15
     2f6:	10 f4       	brcc	.+4      	; 0x2fc <xCoRoutineCreate+0x46>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
     2f8:	ff 24       	eor	r15, r15
     2fa:	f3 94       	inc	r15
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
     2fc:	19 8e       	std	Y+25, r1	; 0x19
     2fe:	18 8e       	std	Y+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
     300:	fe 8a       	std	Y+22, r15	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
     302:	1f 8b       	std	Y+23, r17	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     304:	fe 01       	movw	r30, r28
     306:	c1 92       	st	Z+, r12
     308:	d1 92       	st	Z+, r13
     30a:	8f 01       	movw	r16, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     30c:	cf 01       	movw	r24, r30
     30e:	0e 94 20 04 	call	0x840	; 0x840 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     312:	ce 01       	movw	r24, r28
     314:	0c 96       	adiw	r24, 0x0c	; 12
     316:	0e 94 20 04 	call	0x840	; 0x840 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the ListItem_t.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     31a:	d9 87       	std	Y+9, r29	; 0x09
     31c:	c8 87       	std	Y+8, r28	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     31e:	db 8b       	std	Y+19, r29	; 0x13
     320:	ca 8b       	std	Y+18, r28	; 0x12

		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
     322:	82 e0       	ldi	r24, 0x02	; 2
     324:	90 e0       	ldi	r25, 0x00	; 0
     326:	8f 19       	sub	r24, r15
     328:	91 09       	sbc	r25, r1
     32a:	9d 87       	std	Y+13, r25	; 0x0d
     32c:	8c 87       	std	Y+12, r24	; 0x0c

		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
     32e:	8e 89       	ldd	r24, Y+22	; 0x16
     330:	90 91 24 01 	lds	r25, 0x0124	; 0x800124 <uxTopCoRoutineReadyPriority>
     334:	98 17       	cp	r25, r24
     336:	10 f4       	brcc	.+4      	; 0x33c <xCoRoutineCreate+0x86>
     338:	80 93 24 01 	sts	0x0124, r24	; 0x800124 <uxTopCoRoutineReadyPriority>
     33c:	90 e0       	ldi	r25, 0x00	; 0
     33e:	9c 01       	movw	r18, r24
     340:	22 0f       	add	r18, r18
     342:	33 1f       	adc	r19, r19
     344:	22 0f       	add	r18, r18
     346:	33 1f       	adc	r19, r19
     348:	22 0f       	add	r18, r18
     34a:	33 1f       	adc	r19, r19
     34c:	82 0f       	add	r24, r18
     34e:	93 1f       	adc	r25, r19
     350:	b8 01       	movw	r22, r16
     352:	8a 5b       	subi	r24, 0xBA	; 186
     354:	9e 4f       	sbci	r25, 0xFE	; 254
     356:	0e 94 24 04 	call	0x848	; 0x848 <vListInsertEnd>

		xReturn = pdPASS;
     35a:	81 e0       	ldi	r24, 0x01	; 1
     35c:	01 c0       	rjmp	.+2      	; 0x360 <xCoRoutineCreate+0xaa>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     35e:	8f ef       	ldi	r24, 0xFF	; 255
	}

	return xReturn;
}
     360:	df 91       	pop	r29
     362:	cf 91       	pop	r28
     364:	1f 91       	pop	r17
     366:	0f 91       	pop	r16
     368:	ff 90       	pop	r15
     36a:	df 90       	pop	r13
     36c:	cf 90       	pop	r12
     36e:	08 95       	ret

00000370 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay, List_t *pxEventList )
{
     370:	0f 93       	push	r16
     372:	1f 93       	push	r17
     374:	cf 93       	push	r28
     376:	df 93       	push	r29
     378:	8b 01       	movw	r16, r22
TickType_t xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     37a:	c0 91 22 01 	lds	r28, 0x0122	; 0x800122 <xCoRoutineTickCount>
     37e:	d0 91 23 01 	lds	r29, 0x0123	; 0x800123 <xCoRoutineTickCount+0x1>
     382:	c8 0f       	add	r28, r24
     384:	d9 1f       	adc	r29, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     386:	80 91 25 01 	lds	r24, 0x0125	; 0x800125 <pxCurrentCoRoutine>
     38a:	90 91 26 01 	lds	r25, 0x0126	; 0x800126 <pxCurrentCoRoutine+0x1>
     38e:	02 96       	adiw	r24, 0x02	; 2
     390:	0e 94 76 04 	call	0x8ec	; 0x8ec <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     394:	e0 91 25 01 	lds	r30, 0x0125	; 0x800125 <pxCurrentCoRoutine>
     398:	f0 91 26 01 	lds	r31, 0x0126	; 0x800126 <pxCurrentCoRoutine+0x1>
     39c:	d3 83       	std	Z+3, r29	; 0x03
     39e:	c2 83       	std	Z+2, r28	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
     3a0:	80 91 22 01 	lds	r24, 0x0122	; 0x800122 <xCoRoutineTickCount>
     3a4:	90 91 23 01 	lds	r25, 0x0123	; 0x800123 <xCoRoutineTickCount+0x1>
     3a8:	c8 17       	cp	r28, r24
     3aa:	d9 07       	cpc	r29, r25
     3ac:	50 f4       	brcc	.+20     	; 0x3c2 <vCoRoutineAddToDelayedList+0x52>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     3ae:	bf 01       	movw	r22, r30
     3b0:	6e 5f       	subi	r22, 0xFE	; 254
     3b2:	7f 4f       	sbci	r23, 0xFF	; 255
     3b4:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <pxOverflowDelayedCoRoutineList>
     3b8:	90 91 31 01 	lds	r25, 0x0131	; 0x800131 <pxOverflowDelayedCoRoutineList+0x1>
     3bc:	0e 94 45 04 	call	0x88a	; 0x88a <vListInsert>
     3c0:	09 c0       	rjmp	.+18     	; 0x3d4 <vCoRoutineAddToDelayedList+0x64>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     3c2:	bf 01       	movw	r22, r30
     3c4:	6e 5f       	subi	r22, 0xFE	; 254
     3c6:	7f 4f       	sbci	r23, 0xFF	; 255
     3c8:	80 91 32 01 	lds	r24, 0x0132	; 0x800132 <pxDelayedCoRoutineList>
     3cc:	90 91 33 01 	lds	r25, 0x0133	; 0x800133 <pxDelayedCoRoutineList+0x1>
     3d0:	0e 94 45 04 	call	0x88a	; 0x88a <vListInsert>
	}

	if( pxEventList )
     3d4:	01 15       	cp	r16, r1
     3d6:	11 05       	cpc	r17, r1
     3d8:	49 f0       	breq	.+18     	; 0x3ec <vCoRoutineAddToDelayedList+0x7c>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     3da:	60 91 25 01 	lds	r22, 0x0125	; 0x800125 <pxCurrentCoRoutine>
     3de:	70 91 26 01 	lds	r23, 0x0126	; 0x800126 <pxCurrentCoRoutine+0x1>
     3e2:	64 5f       	subi	r22, 0xF4	; 244
     3e4:	7f 4f       	sbci	r23, 0xFF	; 255
     3e6:	c8 01       	movw	r24, r16
     3e8:	0e 94 45 04 	call	0x88a	; 0x88a <vListInsert>
	}
}
     3ec:	df 91       	pop	r29
     3ee:	cf 91       	pop	r28
     3f0:	1f 91       	pop	r17
     3f2:	0f 91       	pop	r16
     3f4:	08 95       	ret

000003f6 <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
     3f6:	0e 94 a2 00 	call	0x144	; 0x144 <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
     3fa:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <prvCheckDelayedList>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     3fe:	06 c0       	rjmp	.+12     	; 0x40c <__LOCK_REGION_LENGTH__+0xc>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
     400:	88 23       	and	r24, r24
     402:	09 f4       	brne	.+2      	; 0x406 <__LOCK_REGION_LENGTH__+0x6>
     404:	4f c0       	rjmp	.+158    	; 0x4a4 <__LOCK_REGION_LENGTH__+0xa4>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
     406:	81 50       	subi	r24, 0x01	; 1
     408:	80 93 24 01 	sts	0x0124, r24	; 0x800124 <uxTopCoRoutineReadyPriority>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     40c:	80 91 24 01 	lds	r24, 0x0124	; 0x800124 <uxTopCoRoutineReadyPriority>
     410:	28 2f       	mov	r18, r24
     412:	30 e0       	ldi	r19, 0x00	; 0
     414:	f9 01       	movw	r30, r18
     416:	ee 0f       	add	r30, r30
     418:	ff 1f       	adc	r31, r31
     41a:	ee 0f       	add	r30, r30
     41c:	ff 1f       	adc	r31, r31
     41e:	ee 0f       	add	r30, r30
     420:	ff 1f       	adc	r31, r31
     422:	e2 0f       	add	r30, r18
     424:	f3 1f       	adc	r31, r19
     426:	ea 5b       	subi	r30, 0xBA	; 186
     428:	fe 4f       	sbci	r31, 0xFE	; 254
     42a:	90 81       	ld	r25, Z
     42c:	99 23       	and	r25, r25
     42e:	41 f3       	breq	.-48     	; 0x400 <__LOCK_REGION_LENGTH__>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
     430:	c9 01       	movw	r24, r18
     432:	88 0f       	add	r24, r24
     434:	99 1f       	adc	r25, r25
     436:	88 0f       	add	r24, r24
     438:	99 1f       	adc	r25, r25
     43a:	88 0f       	add	r24, r24
     43c:	99 1f       	adc	r25, r25
     43e:	82 0f       	add	r24, r18
     440:	93 1f       	adc	r25, r19
     442:	df 01       	movw	r26, r30
     444:	01 80       	ldd	r0, Z+1	; 0x01
     446:	f2 81       	ldd	r31, Z+2	; 0x02
     448:	e0 2d       	mov	r30, r0
     44a:	02 80       	ldd	r0, Z+2	; 0x02
     44c:	f3 81       	ldd	r31, Z+3	; 0x03
     44e:	e0 2d       	mov	r30, r0
     450:	12 96       	adiw	r26, 0x02	; 2
     452:	fc 93       	st	X, r31
     454:	ee 93       	st	-X, r30
     456:	11 97       	sbiw	r26, 0x01	; 1
     458:	87 5b       	subi	r24, 0xB7	; 183
     45a:	9e 4f       	sbci	r25, 0xFE	; 254
     45c:	e8 17       	cp	r30, r24
     45e:	f9 07       	cpc	r31, r25
     460:	29 f4       	brne	.+10     	; 0x46c <__LOCK_REGION_LENGTH__+0x6c>
     462:	82 81       	ldd	r24, Z+2	; 0x02
     464:	93 81       	ldd	r25, Z+3	; 0x03
     466:	fd 01       	movw	r30, r26
     468:	92 83       	std	Z+2, r25	; 0x02
     46a:	81 83       	std	Z+1, r24	; 0x01
     46c:	f9 01       	movw	r30, r18
     46e:	ee 0f       	add	r30, r30
     470:	ff 1f       	adc	r31, r31
     472:	ee 0f       	add	r30, r30
     474:	ff 1f       	adc	r31, r31
     476:	ee 0f       	add	r30, r30
     478:	ff 1f       	adc	r31, r31
     47a:	2e 0f       	add	r18, r30
     47c:	3f 1f       	adc	r19, r31
     47e:	f9 01       	movw	r30, r18
     480:	ea 5b       	subi	r30, 0xBA	; 186
     482:	fe 4f       	sbci	r31, 0xFE	; 254
     484:	01 80       	ldd	r0, Z+1	; 0x01
     486:	f2 81       	ldd	r31, Z+2	; 0x02
     488:	e0 2d       	mov	r30, r0
     48a:	86 81       	ldd	r24, Z+6	; 0x06
     48c:	97 81       	ldd	r25, Z+7	; 0x07
     48e:	90 93 26 01 	sts	0x0126, r25	; 0x800126 <pxCurrentCoRoutine+0x1>
     492:	80 93 25 01 	sts	0x0125, r24	; 0x800125 <pxCurrentCoRoutine>

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
     496:	dc 01       	movw	r26, r24
     498:	ed 91       	ld	r30, X+
     49a:	fc 91       	ld	r31, X
     49c:	11 97       	sbiw	r26, 0x01	; 1
     49e:	57 96       	adiw	r26, 0x17	; 23
     4a0:	6c 91       	ld	r22, X
     4a2:	09 95       	icall
     4a4:	08 95       	ret

000004a6 <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

BaseType_t xCoRoutineRemoveFromEventList( const List_t *pxEventList )
{
     4a6:	0f 93       	push	r16
     4a8:	1f 93       	push	r17
     4aa:	cf 93       	push	r28
     4ac:	df 93       	push	r29
BaseType_t xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     4ae:	dc 01       	movw	r26, r24
     4b0:	15 96       	adiw	r26, 0x05	; 5
     4b2:	ed 91       	ld	r30, X+
     4b4:	fc 91       	ld	r31, X
     4b6:	16 97       	sbiw	r26, 0x06	; 6
     4b8:	c6 81       	ldd	r28, Z+6	; 0x06
     4ba:	d7 81       	ldd	r29, Z+7	; 0x07
	( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     4bc:	8e 01       	movw	r16, r28
     4be:	04 5f       	subi	r16, 0xF4	; 244
     4c0:	1f 4f       	sbci	r17, 0xFF	; 255
     4c2:	c8 01       	movw	r24, r16
     4c4:	0e 94 76 04 	call	0x8ec	; 0x8ec <uxListRemove>
	vListInsertEnd( ( List_t * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
     4c8:	b8 01       	movw	r22, r16
     4ca:	87 e2       	ldi	r24, 0x27	; 39
     4cc:	91 e0       	ldi	r25, 0x01	; 1
     4ce:	0e 94 24 04 	call	0x848	; 0x848 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
     4d2:	9e 89       	ldd	r25, Y+22	; 0x16
     4d4:	e0 91 25 01 	lds	r30, 0x0125	; 0x800125 <pxCurrentCoRoutine>
     4d8:	f0 91 26 01 	lds	r31, 0x0126	; 0x800126 <pxCurrentCoRoutine+0x1>
     4dc:	86 89       	ldd	r24, Z+22	; 0x16
     4de:	98 17       	cp	r25, r24
     4e0:	10 f0       	brcs	.+4      	; 0x4e6 <xCoRoutineRemoveFromEventList+0x40>
	{
		xReturn = pdTRUE;
     4e2:	81 e0       	ldi	r24, 0x01	; 1
     4e4:	01 c0       	rjmp	.+2      	; 0x4e8 <xCoRoutineRemoveFromEventList+0x42>
	}
	else
	{
		xReturn = pdFALSE;
     4e6:	80 e0       	ldi	r24, 0x00	; 0
	}

	return xReturn;
}
     4e8:	df 91       	pop	r29
     4ea:	cf 91       	pop	r28
     4ec:	1f 91       	pop	r17
     4ee:	0f 91       	pop	r16
     4f0:	08 95       	ret

000004f2 <prvTestWaitCondition>:

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
BaseType_t xWaitConditionMet = pdFALSE;

	if( xWaitForAllBits == pdFALSE )
     4f2:	41 11       	cpse	r20, r1
     4f4:	06 c0       	rjmp	.+12     	; 0x502 <prvTestWaitCondition+0x10>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
     4f6:	68 23       	and	r22, r24
     4f8:	79 23       	and	r23, r25
     4fa:	67 2b       	or	r22, r23
     4fc:	49 f4       	brne	.+18     	; 0x510 <prvTestWaitCondition+0x1e>
}
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
BaseType_t xWaitConditionMet = pdFALSE;
     4fe:	80 e0       	ldi	r24, 0x00	; 0
     500:	08 95       	ret
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
     502:	86 23       	and	r24, r22
     504:	97 23       	and	r25, r23
     506:	68 17       	cp	r22, r24
     508:	79 07       	cpc	r23, r25
     50a:	21 f0       	breq	.+8      	; 0x514 <prvTestWaitCondition+0x22>
}
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
BaseType_t xWaitConditionMet = pdFALSE;
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	08 95       	ret
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
		{
			xWaitConditionMet = pdTRUE;
     510:	81 e0       	ldi	r24, 0x01	; 1
     512:	08 95       	ret
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
		{
			xWaitConditionMet = pdTRUE;
     514:	81 e0       	ldi	r24, 0x01	; 1
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
}
     516:	08 95       	ret

00000518 <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	EventGroupHandle_t xEventGroupCreate( void )
	{
     518:	cf 93       	push	r28
     51a:	df 93       	push	r29
	EventGroup_t *pxEventBits;

		/* Allocate the event group. */
		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) );
     51c:	8b e0       	ldi	r24, 0x0B	; 11
     51e:	90 e0       	ldi	r25, 0x00	; 0
     520:	0e 94 fa 05 	call	0xbf4	; 0xbf4 <pvPortMalloc>
     524:	ec 01       	movw	r28, r24

		if( pxEventBits != NULL )
     526:	00 97       	sbiw	r24, 0x00	; 0
     528:	31 f0       	breq	.+12     	; 0x536 <xEventGroupCreate+0x1e>
		{
			pxEventBits->uxEventBits = 0;
     52a:	fc 01       	movw	r30, r24
     52c:	11 92       	st	Z+, r1
     52e:	11 92       	st	Z+, r1
     530:	cf 01       	movw	r24, r30
			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
     532:	0e 94 12 04 	call	0x824	; 0x824 <vListInitialise>
		{
			traceEVENT_GROUP_CREATE_FAILED();
		}

		return ( EventGroupHandle_t ) pxEventBits;
	}
     536:	ce 01       	movw	r24, r28
     538:	df 91       	pop	r29
     53a:	cf 91       	pop	r28
     53c:	08 95       	ret

0000053e <xEventGroupWaitBits>:
	return uxReturn;
}
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
     53e:	af 92       	push	r10
     540:	bf 92       	push	r11
     542:	cf 92       	push	r12
     544:	df 92       	push	r13
     546:	ef 92       	push	r14
     548:	ff 92       	push	r15
     54a:	0f 93       	push	r16
     54c:	1f 93       	push	r17
     54e:	cf 93       	push	r28
     550:	df 93       	push	r29
     552:	7c 01       	movw	r14, r24
     554:	5b 01       	movw	r10, r22
     556:	c4 2e       	mov	r12, r20
     558:	d2 2e       	mov	r13, r18
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     55a:	0e 94 ac 0c 	call	0x1958	; 0x1958 <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
     55e:	f7 01       	movw	r30, r14
     560:	c0 81       	ld	r28, Z
     562:	d1 81       	ldd	r29, Z+1	; 0x01

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
     564:	4d 2d       	mov	r20, r13
     566:	b5 01       	movw	r22, r10
     568:	ce 01       	movw	r24, r28
     56a:	0e 94 79 02 	call	0x4f2	; 0x4f2 <prvTestWaitCondition>

		if( xWaitConditionMet != pdFALSE )
     56e:	88 23       	and	r24, r24
     570:	69 f0       	breq	.+26     	; 0x58c <xEventGroupWaitBits+0x4e>
			block. */
			uxReturn = uxCurrentEventBits;
			xTicksToWait = ( TickType_t ) 0;

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
     572:	cc 20       	and	r12, r12
     574:	09 f1       	breq	.+66     	; 0x5b8 <xEventGroupWaitBits+0x7a>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     576:	c5 01       	movw	r24, r10
     578:	80 95       	com	r24
     57a:	90 95       	com	r25
     57c:	8c 23       	and	r24, r28
     57e:	9d 23       	and	r25, r29
     580:	f7 01       	movw	r30, r14
     582:	91 83       	std	Z+1, r25	; 0x01
     584:	80 83       	st	Z, r24
		if( xWaitConditionMet != pdFALSE )
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
			xTicksToWait = ( TickType_t ) 0;
     586:	00 e0       	ldi	r16, 0x00	; 0
     588:	10 e0       	ldi	r17, 0x00	; 0
     58a:	18 c0       	rjmp	.+48     	; 0x5bc <xEventGroupWaitBits+0x7e>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
     58c:	01 15       	cp	r16, r1
     58e:	11 05       	cpc	r17, r1
     590:	a9 f0       	breq	.+42     	; 0x5bc <xEventGroupWaitBits+0x7e>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
     592:	c1 10       	cpse	r12, r1
     594:	03 c0       	rjmp	.+6      	; 0x59c <xEventGroupWaitBits+0x5e>
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
EventBits_t uxReturn, uxControlBits = 0;
     596:	60 e0       	ldi	r22, 0x00	; 0
     598:	70 e0       	ldi	r23, 0x00	; 0
     59a:	02 c0       	rjmp	.+4      	; 0x5a0 <xEventGroupWaitBits+0x62>
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
     59c:	60 e0       	ldi	r22, 0x00	; 0
     59e:	71 e0       	ldi	r23, 0x01	; 1
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
     5a0:	d1 10       	cpse	r13, r1
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
     5a2:	74 60       	ori	r23, 0x04	; 4
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
     5a4:	6a 29       	or	r22, r10
     5a6:	7b 29       	or	r23, r11
     5a8:	a8 01       	movw	r20, r16
     5aa:	c7 01       	movw	r24, r14
     5ac:	02 96       	adiw	r24, 0x02	; 2
     5ae:	0e 94 b5 0e 	call	0x1d6a	; 0x1d6a <vTaskPlaceOnUnorderedEventList>

			/* This is obsolete as it will get set after the task unblocks, but
			some compilers mistakenly generate a warning about the variable
			being returned without being set if it is not done. */
			uxReturn = 0;
     5b2:	c0 e0       	ldi	r28, 0x00	; 0
     5b4:	d0 e0       	ldi	r29, 0x00	; 0
     5b6:	02 c0       	rjmp	.+4      	; 0x5bc <xEventGroupWaitBits+0x7e>
		if( xWaitConditionMet != pdFALSE )
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
			xTicksToWait = ( TickType_t ) 0;
     5b8:	00 e0       	ldi	r16, 0x00	; 0
     5ba:	10 e0       	ldi	r17, 0x00	; 0
			uxReturn = 0;

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     5bc:	0e 94 86 0d 	call	0x1b0c	; 0x1b0c <xTaskResumeAll>

	if( xTicksToWait != ( TickType_t ) 0 )
     5c0:	01 2b       	or	r16, r17
     5c2:	19 f1       	breq	.+70     	; 0x60a <xEventGroupWaitBits+0xcc>
	{
		if( xAlreadyYielded == pdFALSE )
     5c4:	81 11       	cpse	r24, r1
     5c6:	02 c0       	rjmp	.+4      	; 0x5cc <xEventGroupWaitBits+0x8e>
		{
			portYIELD_WITHIN_API();
     5c8:	0e 94 42 05 	call	0xa84	; 0xa84 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     5cc:	0e 94 38 10 	call	0x2070	; 0x2070 <uxTaskResetEventItemValue>
     5d0:	ec 01       	movw	r28, r24

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     5d2:	91 fd       	sbrc	r25, 1
     5d4:	19 c0       	rjmp	.+50     	; 0x608 <xEventGroupWaitBits+0xca>
		{
			taskENTER_CRITICAL();
     5d6:	0f b6       	in	r0, 0x3f	; 63
     5d8:	f8 94       	cli
     5da:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     5dc:	f7 01       	movw	r30, r14
     5de:	c0 81       	ld	r28, Z
     5e0:	d1 81       	ldd	r29, Z+1	; 0x01

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
     5e2:	4d 2d       	mov	r20, r13
     5e4:	b5 01       	movw	r22, r10
     5e6:	ce 01       	movw	r24, r28
     5e8:	0e 94 79 02 	call	0x4f2	; 0x4f2 <prvTestWaitCondition>
     5ec:	88 23       	and	r24, r24
     5ee:	51 f0       	breq	.+20     	; 0x604 <xEventGroupWaitBits+0xc6>
				{
					if( xClearOnExit != pdFALSE )
     5f0:	cc 20       	and	r12, r12
     5f2:	41 f0       	breq	.+16     	; 0x604 <xEventGroupWaitBits+0xc6>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     5f4:	b5 01       	movw	r22, r10
     5f6:	60 95       	com	r22
     5f8:	70 95       	com	r23
     5fa:	6c 23       	and	r22, r28
     5fc:	7d 23       	and	r23, r29
     5fe:	f7 01       	movw	r30, r14
     600:	71 83       	std	Z+1, r23	; 0x01
     602:	60 83       	st	Z, r22
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
     604:	0f 90       	pop	r0
     606:	0f be       	out	0x3f, r0	; 63
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     608:	dd 27       	eor	r29, r29
	}
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
}
     60a:	ce 01       	movw	r24, r28
     60c:	df 91       	pop	r29
     60e:	cf 91       	pop	r28
     610:	1f 91       	pop	r17
     612:	0f 91       	pop	r16
     614:	ff 90       	pop	r15
     616:	ef 90       	pop	r14
     618:	df 90       	pop	r13
     61a:	cf 90       	pop	r12
     61c:	bf 90       	pop	r11
     61e:	af 90       	pop	r10
     620:	08 95       	ret

00000622 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
     622:	fc 01       	movw	r30, r24
	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
     624:	0f b6       	in	r0, 0x3f	; 63
     626:	f8 94       	cli
     628:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
     62a:	80 81       	ld	r24, Z
     62c:	91 81       	ldd	r25, Z+1	; 0x01

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     62e:	60 95       	com	r22
     630:	70 95       	com	r23
     632:	68 23       	and	r22, r24
     634:	79 23       	and	r23, r25
     636:	71 83       	std	Z+1, r23	; 0x01
     638:	60 83       	st	Z, r22
	}
	taskEXIT_CRITICAL();
     63a:	0f 90       	pop	r0
     63c:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
     63e:	08 95       	ret

00000640 <xEventGroupGetBitsFromISR>:
		uxReturn = pxEventBits->uxEventBits;
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
}
     640:	fc 01       	movw	r30, r24
     642:	80 81       	ld	r24, Z
     644:	91 81       	ldd	r25, Z+1	; 0x01
     646:	08 95       	ret

00000648 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
     648:	cf 92       	push	r12
     64a:	df 92       	push	r13
     64c:	ef 92       	push	r14
     64e:	ff 92       	push	r15
     650:	0f 93       	push	r16
     652:	1f 93       	push	r17
     654:	cf 93       	push	r28
     656:	df 93       	push	r29
     658:	7c 01       	movw	r14, r24
     65a:	8b 01       	movw	r16, r22
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     65c:	ec 01       	movw	r28, r24
     65e:	25 96       	adiw	r28, 0x05	; 5
	vTaskSuspendAll();
     660:	0e 94 ac 0c 	call	0x1958	; 0x1958 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
     664:	d7 01       	movw	r26, r14
     666:	17 96       	adiw	r26, 0x07	; 7
     668:	ed 91       	ld	r30, X+
     66a:	fc 91       	ld	r31, X
     66c:	18 97       	sbiw	r26, 0x08	; 8

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
     66e:	8d 91       	ld	r24, X+
     670:	9c 91       	ld	r25, X
     672:	11 97       	sbiw	r26, 0x01	; 1
     674:	08 2b       	or	r16, r24
     676:	19 2b       	or	r17, r25
     678:	0d 93       	st	X+, r16
     67a:	1c 93       	st	X, r17
EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t *pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
     67c:	00 e0       	ldi	r16, 0x00	; 0
     67e:	10 e0       	ldi	r17, 0x00	; 0

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     680:	2d c0       	rjmp	.+90     	; 0x6dc <xEventGroupSetBits+0x94>
		{
			pxNext = listGET_NEXT( pxListItem );
     682:	c2 80       	ldd	r12, Z+2	; 0x02
     684:	d3 80       	ldd	r13, Z+3	; 0x03
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
     686:	80 81       	ld	r24, Z
     688:	91 81       	ldd	r25, Z+1	; 0x01
			xMatchFound = pdFALSE;

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
     68a:	9c 01       	movw	r18, r24
     68c:	33 27       	eor	r19, r19

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
     68e:	92 fd       	sbrc	r25, 2
     690:	09 c0       	rjmp	.+18     	; 0x6a4 <xEventGroupSetBits+0x5c>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
     692:	d7 01       	movw	r26, r14
     694:	4d 91       	ld	r20, X+
     696:	5c 91       	ld	r21, X
     698:	42 23       	and	r20, r18
     69a:	53 23       	and	r21, r19
     69c:	45 2b       	or	r20, r21
     69e:	61 f4       	brne	.+24     	; 0x6b8 <xEventGroupSetBits+0x70>
		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
			xMatchFound = pdFALSE;
     6a0:	40 e0       	ldi	r20, 0x00	; 0
     6a2:	0d c0       	rjmp	.+26     	; 0x6be <xEventGroupSetBits+0x76>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
     6a4:	d7 01       	movw	r26, r14
     6a6:	4d 91       	ld	r20, X+
     6a8:	5c 91       	ld	r21, X
     6aa:	42 23       	and	r20, r18
     6ac:	53 23       	and	r21, r19
     6ae:	24 17       	cp	r18, r20
     6b0:	35 07       	cpc	r19, r21
     6b2:	21 f0       	breq	.+8      	; 0x6bc <xEventGroupSetBits+0x74>
		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
			xMatchFound = pdFALSE;
     6b4:	40 e0       	ldi	r20, 0x00	; 0
     6b6:	03 c0       	rjmp	.+6      	; 0x6be <xEventGroupSetBits+0x76>
			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
				{
					xMatchFound = pdTRUE;
     6b8:	41 e0       	ldi	r20, 0x01	; 1
     6ba:	01 c0       	rjmp	.+2      	; 0x6be <xEventGroupSetBits+0x76>
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
     6bc:	41 e0       	ldi	r20, 0x01	; 1
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
     6be:	44 23       	and	r20, r20
     6c0:	59 f0       	breq	.+22     	; 0x6d8 <xEventGroupSetBits+0x90>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
     6c2:	90 ff       	sbrs	r25, 0
     6c4:	02 c0       	rjmp	.+4      	; 0x6ca <xEventGroupSetBits+0x82>
				{
					uxBitsToClear |= uxBitsWaitedFor;
     6c6:	02 2b       	or	r16, r18
     6c8:	13 2b       	or	r17, r19
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				( void ) xTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
     6ca:	d7 01       	movw	r26, r14
     6cc:	6d 91       	ld	r22, X+
     6ce:	7c 91       	ld	r23, X
     6d0:	72 60       	ori	r23, 0x02	; 2
     6d2:	cf 01       	movw	r24, r30
     6d4:	0e 94 16 0f 	call	0x1e2c	; 0x1e2c <xTaskRemoveFromUnorderedEventList>
		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
			xMatchFound = pdFALSE;
     6d8:	ec 2d       	mov	r30, r12
     6da:	fd 2d       	mov	r31, r13

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     6dc:	ec 17       	cp	r30, r28
     6de:	fd 07       	cpc	r31, r29
     6e0:	81 f6       	brne	.-96     	; 0x682 <xEventGroupSetBits+0x3a>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     6e2:	00 95       	com	r16
     6e4:	10 95       	com	r17
     6e6:	f7 01       	movw	r30, r14
     6e8:	80 81       	ld	r24, Z
     6ea:	91 81       	ldd	r25, Z+1	; 0x01
     6ec:	08 23       	and	r16, r24
     6ee:	19 23       	and	r17, r25
     6f0:	11 83       	std	Z+1, r17	; 0x01
     6f2:	00 83       	st	Z, r16
	}
	( void ) xTaskResumeAll();
     6f4:	0e 94 86 0d 	call	0x1b0c	; 0x1b0c <xTaskResumeAll>

	return pxEventBits->uxEventBits;
}
     6f8:	d7 01       	movw	r26, r14
     6fa:	8d 91       	ld	r24, X+
     6fc:	9c 91       	ld	r25, X
     6fe:	df 91       	pop	r29
     700:	cf 91       	pop	r28
     702:	1f 91       	pop	r17
     704:	0f 91       	pop	r16
     706:	ff 90       	pop	r15
     708:	ef 90       	pop	r14
     70a:	df 90       	pop	r13
     70c:	cf 90       	pop	r12
     70e:	08 95       	ret

00000710 <xEventGroupSync>:

#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
     710:	af 92       	push	r10
     712:	bf 92       	push	r11
     714:	cf 92       	push	r12
     716:	df 92       	push	r13
     718:	ef 92       	push	r14
     71a:	ff 92       	push	r15
     71c:	0f 93       	push	r16
     71e:	1f 93       	push	r17
     720:	cf 93       	push	r28
     722:	df 93       	push	r29
     724:	8c 01       	movw	r16, r24
     726:	eb 01       	movw	r28, r22
     728:	7a 01       	movw	r14, r20
     72a:	69 01       	movw	r12, r18
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     72c:	0e 94 ac 0c 	call	0x1958	; 0x1958 <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
     730:	f8 01       	movw	r30, r16
     732:	a0 80       	ld	r10, Z
     734:	b1 80       	ldd	r11, Z+1	; 0x01

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
     736:	be 01       	movw	r22, r28
     738:	c8 01       	movw	r24, r16
     73a:	0e 94 24 03 	call	0x648	; 0x648 <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
     73e:	ca 29       	or	r28, r10
     740:	db 29       	or	r29, r11
     742:	ce 01       	movw	r24, r28
     744:	8e 21       	and	r24, r14
     746:	9f 21       	and	r25, r15
     748:	e8 16       	cp	r14, r24
     74a:	f9 06       	cpc	r15, r25
     74c:	69 f4       	brne	.+26     	; 0x768 <xEventGroupSync+0x58>
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     74e:	f8 01       	movw	r30, r16
     750:	20 81       	ld	r18, Z
     752:	31 81       	ldd	r19, Z+1	; 0x01
     754:	c7 01       	movw	r24, r14
     756:	80 95       	com	r24
     758:	90 95       	com	r25
     75a:	82 23       	and	r24, r18
     75c:	93 23       	and	r25, r19
     75e:	91 83       	std	Z+1, r25	; 0x01
     760:	80 83       	st	Z, r24

			xTicksToWait = 0;
     762:	c1 2c       	mov	r12, r1
     764:	d1 2c       	mov	r13, r1
     766:	10 c0       	rjmp	.+32     	; 0x788 <xEventGroupSync+0x78>
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
     768:	c1 14       	cp	r12, r1
     76a:	d1 04       	cpc	r13, r1
     76c:	51 f0       	breq	.+20     	; 0x782 <xEventGroupSync+0x72>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
     76e:	a6 01       	movw	r20, r12
     770:	b7 01       	movw	r22, r14
     772:	75 60       	ori	r23, 0x05	; 5
     774:	c8 01       	movw	r24, r16
     776:	02 96       	adiw	r24, 0x02	; 2
     778:	0e 94 b5 0e 	call	0x1d6a	; 0x1d6a <vTaskPlaceOnUnorderedEventList>

				/* This assignment is obsolete as uxReturn will get set after
				the task unblocks, but some compilers mistakenly generate a
				warning about uxReturn being returned without being set if the
				assignment is omitted. */
				uxReturn = 0;
     77c:	c0 e0       	ldi	r28, 0x00	; 0
     77e:	d0 e0       	ldi	r29, 0x00	; 0
     780:	03 c0       	rjmp	.+6      	; 0x788 <xEventGroupSync+0x78>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     782:	f8 01       	movw	r30, r16
     784:	c0 81       	ld	r28, Z
     786:	d1 81       	ldd	r29, Z+1	; 0x01
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     788:	0e 94 86 0d 	call	0x1b0c	; 0x1b0c <xTaskResumeAll>

	if( xTicksToWait != ( TickType_t ) 0 )
     78c:	cd 28       	or	r12, r13
     78e:	f9 f0       	breq	.+62     	; 0x7ce <xEventGroupSync+0xbe>
	{
		if( xAlreadyYielded == pdFALSE )
     790:	81 11       	cpse	r24, r1
     792:	02 c0       	rjmp	.+4      	; 0x798 <xEventGroupSync+0x88>
		{
			portYIELD_WITHIN_API();
     794:	0e 94 42 05 	call	0xa84	; 0xa84 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     798:	0e 94 38 10 	call	0x2070	; 0x2070 <uxTaskResetEventItemValue>

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     79c:	91 fd       	sbrc	r25, 1
     79e:	15 c0       	rjmp	.+42     	; 0x7ca <xEventGroupSync+0xba>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
     7a0:	0f b6       	in	r0, 0x3f	; 63
     7a2:	f8 94       	cli
     7a4:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
     7a6:	f8 01       	movw	r30, r16
     7a8:	80 81       	ld	r24, Z
     7aa:	91 81       	ldd	r25, Z+1	; 0x01

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
     7ac:	97 01       	movw	r18, r14
     7ae:	28 23       	and	r18, r24
     7b0:	39 23       	and	r19, r25
     7b2:	e2 16       	cp	r14, r18
     7b4:	f3 06       	cpc	r15, r19
     7b6:	39 f4       	brne	.+14     	; 0x7c6 <xEventGroupSync+0xb6>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     7b8:	a7 01       	movw	r20, r14
     7ba:	40 95       	com	r20
     7bc:	50 95       	com	r21
     7be:	48 23       	and	r20, r24
     7c0:	59 23       	and	r21, r25
     7c2:	51 83       	std	Z+1, r21	; 0x01
     7c4:	40 83       	st	Z, r20
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
     7c6:	0f 90       	pop	r0
     7c8:	0f be       	out	0x3f, r0	; 63
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     7ca:	ec 01       	movw	r28, r24
     7cc:	dd 27       	eor	r29, r29
	}

	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
}
     7ce:	ce 01       	movw	r24, r28
     7d0:	df 91       	pop	r29
     7d2:	cf 91       	pop	r28
     7d4:	1f 91       	pop	r17
     7d6:	0f 91       	pop	r16
     7d8:	ff 90       	pop	r15
     7da:	ef 90       	pop	r14
     7dc:	df 90       	pop	r13
     7de:	cf 90       	pop	r12
     7e0:	bf 90       	pop	r11
     7e2:	af 90       	pop	r10
     7e4:	08 95       	ret

000007e6 <vEventGroupDelete>:
	return pxEventBits->uxEventBits;
}
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
     7e6:	cf 93       	push	r28
     7e8:	df 93       	push	r29
     7ea:	ec 01       	movw	r28, r24
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );

	vTaskSuspendAll();
     7ec:	0e 94 ac 0c 	call	0x1958	; 0x1958 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
     7f0:	06 c0       	rjmp	.+12     	; 0x7fe <vEventGroupDelete+0x18>
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and	cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			( void ) xTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
     7f2:	60 e0       	ldi	r22, 0x00	; 0
     7f4:	72 e0       	ldi	r23, 0x02	; 2
     7f6:	8f 81       	ldd	r24, Y+7	; 0x07
     7f8:	98 85       	ldd	r25, Y+8	; 0x08
     7fa:	0e 94 16 0f 	call	0x1e2c	; 0x1e2c <xTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
     7fe:	8a 81       	ldd	r24, Y+2	; 0x02
     800:	81 11       	cpse	r24, r1
     802:	f7 cf       	rjmp	.-18     	; 0x7f2 <vEventGroupDelete+0xc>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
		{
			/* The event group can only have been allocated dynamically - free
			it again. */
			vPortFree( pxEventBits );
     804:	ce 01       	movw	r24, r28
     806:	0e 94 2f 06 	call	0xc5e	; 0xc5e <vPortFree>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
     80a:	0e 94 86 0d 	call	0x1b0c	; 0x1b0c <xTaskResumeAll>
}
     80e:	df 91       	pop	r29
     810:	cf 91       	pop	r28
     812:	08 95       	ret

00000814 <vEventGroupSetBitsCallback>:

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet );
     814:	ba 01       	movw	r22, r20
     816:	0e 94 24 03 	call	0x648	; 0x648 <xEventGroupSetBits>
     81a:	08 95       	ret

0000081c <vEventGroupClearBitsCallback>:

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear );
     81c:	ba 01       	movw	r22, r20
     81e:	0e 94 11 03 	call	0x622	; 0x622 <xEventGroupClearBits>
     822:	08 95       	ret

00000824 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     824:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     826:	03 96       	adiw	r24, 0x03	; 3
     828:	92 83       	std	Z+2, r25	; 0x02
     82a:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     82c:	2f ef       	ldi	r18, 0xFF	; 255
     82e:	3f ef       	ldi	r19, 0xFF	; 255
     830:	34 83       	std	Z+4, r19	; 0x04
     832:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     834:	96 83       	std	Z+6, r25	; 0x06
     836:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     838:	90 87       	std	Z+8, r25	; 0x08
     83a:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     83c:	10 82       	st	Z, r1
     83e:	08 95       	ret

00000840 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     840:	fc 01       	movw	r30, r24
     842:	11 86       	std	Z+9, r1	; 0x09
     844:	10 86       	std	Z+8, r1	; 0x08
     846:	08 95       	ret

00000848 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     848:	cf 93       	push	r28
     84a:	df 93       	push	r29
     84c:	9c 01       	movw	r18, r24
     84e:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     850:	dc 01       	movw	r26, r24
     852:	11 96       	adiw	r26, 0x01	; 1
     854:	cd 91       	ld	r28, X+
     856:	dc 91       	ld	r29, X
     858:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     85a:	d3 83       	std	Z+3, r29	; 0x03
     85c:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     85e:	8c 81       	ldd	r24, Y+4	; 0x04
     860:	9d 81       	ldd	r25, Y+5	; 0x05
     862:	95 83       	std	Z+5, r25	; 0x05
     864:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     866:	8c 81       	ldd	r24, Y+4	; 0x04
     868:	9d 81       	ldd	r25, Y+5	; 0x05
     86a:	dc 01       	movw	r26, r24
     86c:	13 96       	adiw	r26, 0x03	; 3
     86e:	7c 93       	st	X, r23
     870:	6e 93       	st	-X, r22
     872:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     874:	7d 83       	std	Y+5, r23	; 0x05
     876:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     878:	31 87       	std	Z+9, r19	; 0x09
     87a:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     87c:	f9 01       	movw	r30, r18
     87e:	80 81       	ld	r24, Z
     880:	8f 5f       	subi	r24, 0xFF	; 255
     882:	80 83       	st	Z, r24
}
     884:	df 91       	pop	r29
     886:	cf 91       	pop	r28
     888:	08 95       	ret

0000088a <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     88a:	cf 93       	push	r28
     88c:	df 93       	push	r29
     88e:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     890:	48 81       	ld	r20, Y
     892:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     894:	4f 3f       	cpi	r20, 0xFF	; 255
     896:	2f ef       	ldi	r18, 0xFF	; 255
     898:	52 07       	cpc	r21, r18
     89a:	21 f4       	brne	.+8      	; 0x8a4 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     89c:	fc 01       	movw	r30, r24
     89e:	a7 81       	ldd	r26, Z+7	; 0x07
     8a0:	b0 85       	ldd	r27, Z+8	; 0x08
     8a2:	0d c0       	rjmp	.+26     	; 0x8be <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     8a4:	dc 01       	movw	r26, r24
     8a6:	13 96       	adiw	r26, 0x03	; 3
     8a8:	01 c0       	rjmp	.+2      	; 0x8ac <vListInsert+0x22>
     8aa:	df 01       	movw	r26, r30
     8ac:	12 96       	adiw	r26, 0x02	; 2
     8ae:	ed 91       	ld	r30, X+
     8b0:	fc 91       	ld	r31, X
     8b2:	13 97       	sbiw	r26, 0x03	; 3
     8b4:	20 81       	ld	r18, Z
     8b6:	31 81       	ldd	r19, Z+1	; 0x01
     8b8:	42 17       	cp	r20, r18
     8ba:	53 07       	cpc	r21, r19
     8bc:	b0 f7       	brcc	.-20     	; 0x8aa <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     8be:	12 96       	adiw	r26, 0x02	; 2
     8c0:	ed 91       	ld	r30, X+
     8c2:	fc 91       	ld	r31, X
     8c4:	13 97       	sbiw	r26, 0x03	; 3
     8c6:	fb 83       	std	Y+3, r31	; 0x03
     8c8:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     8ca:	d5 83       	std	Z+5, r29	; 0x05
     8cc:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     8ce:	bd 83       	std	Y+5, r27	; 0x05
     8d0:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     8d2:	13 96       	adiw	r26, 0x03	; 3
     8d4:	dc 93       	st	X, r29
     8d6:	ce 93       	st	-X, r28
     8d8:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     8da:	99 87       	std	Y+9, r25	; 0x09
     8dc:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     8de:	fc 01       	movw	r30, r24
     8e0:	20 81       	ld	r18, Z
     8e2:	2f 5f       	subi	r18, 0xFF	; 255
     8e4:	20 83       	st	Z, r18
}
     8e6:	df 91       	pop	r29
     8e8:	cf 91       	pop	r28
     8ea:	08 95       	ret

000008ec <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     8ec:	cf 93       	push	r28
     8ee:	df 93       	push	r29
     8f0:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     8f2:	a0 85       	ldd	r26, Z+8	; 0x08
     8f4:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     8f6:	c2 81       	ldd	r28, Z+2	; 0x02
     8f8:	d3 81       	ldd	r29, Z+3	; 0x03
     8fa:	84 81       	ldd	r24, Z+4	; 0x04
     8fc:	95 81       	ldd	r25, Z+5	; 0x05
     8fe:	9d 83       	std	Y+5, r25	; 0x05
     900:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     902:	c4 81       	ldd	r28, Z+4	; 0x04
     904:	d5 81       	ldd	r29, Z+5	; 0x05
     906:	82 81       	ldd	r24, Z+2	; 0x02
     908:	93 81       	ldd	r25, Z+3	; 0x03
     90a:	9b 83       	std	Y+3, r25	; 0x03
     90c:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     90e:	11 96       	adiw	r26, 0x01	; 1
     910:	8d 91       	ld	r24, X+
     912:	9c 91       	ld	r25, X
     914:	12 97       	sbiw	r26, 0x02	; 2
     916:	e8 17       	cp	r30, r24
     918:	f9 07       	cpc	r31, r25
     91a:	31 f4       	brne	.+12     	; 0x928 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     91c:	84 81       	ldd	r24, Z+4	; 0x04
     91e:	95 81       	ldd	r25, Z+5	; 0x05
     920:	12 96       	adiw	r26, 0x02	; 2
     922:	9c 93       	st	X, r25
     924:	8e 93       	st	-X, r24
     926:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     928:	11 86       	std	Z+9, r1	; 0x09
     92a:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     92c:	8c 91       	ld	r24, X
     92e:	81 50       	subi	r24, 0x01	; 1
     930:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     932:	df 91       	pop	r29
     934:	cf 91       	pop	r28
     936:	08 95       	ret

00000938 <prvSetupTimerInterrupt>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	OCR1AH = ucHighByte;
     938:	86 e0       	ldi	r24, 0x06	; 6
     93a:	8b bd       	out	0x2b, r24	; 43
	OCR1AL = ucLowByte;
     93c:	8f eb       	ldi	r24, 0xBF	; 191
     93e:	8a bd       	out	0x2a, r24	; 42

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
     940:	8b e0       	ldi	r24, 0x0B	; 11
     942:	8e bd       	out	0x2e, r24	; 46

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
     944:	87 b7       	in	r24, 0x37	; 55
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     946:	80 61       	ori	r24, 0x10	; 16
	TIMSK = ucLowByte;
     948:	87 bf       	out	0x37, r24	; 55
     94a:	08 95       	ret

0000094c <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     94c:	31 e1       	ldi	r19, 0x11	; 17
     94e:	fc 01       	movw	r30, r24
     950:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
     952:	31 97       	sbiw	r30, 0x01	; 1
     954:	22 e2       	ldi	r18, 0x22	; 34
     956:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
     958:	31 97       	sbiw	r30, 0x01	; 1
     95a:	a3 e3       	ldi	r26, 0x33	; 51
     95c:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     95e:	31 97       	sbiw	r30, 0x01	; 1
     960:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     962:	31 97       	sbiw	r30, 0x01	; 1
     964:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
     966:	31 97       	sbiw	r30, 0x01	; 1
     968:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     96a:	31 97       	sbiw	r30, 0x01	; 1
     96c:	60 e8       	ldi	r22, 0x80	; 128
     96e:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
     970:	31 97       	sbiw	r30, 0x01	; 1
     972:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
     974:	31 97       	sbiw	r30, 0x01	; 1
     976:	62 e0       	ldi	r22, 0x02	; 2
     978:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
     97a:	31 97       	sbiw	r30, 0x01	; 1
     97c:	63 e0       	ldi	r22, 0x03	; 3
     97e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
     980:	31 97       	sbiw	r30, 0x01	; 1
     982:	64 e0       	ldi	r22, 0x04	; 4
     984:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
     986:	31 97       	sbiw	r30, 0x01	; 1
     988:	65 e0       	ldi	r22, 0x05	; 5
     98a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
     98c:	31 97       	sbiw	r30, 0x01	; 1
     98e:	66 e0       	ldi	r22, 0x06	; 6
     990:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
     992:	31 97       	sbiw	r30, 0x01	; 1
     994:	67 e0       	ldi	r22, 0x07	; 7
     996:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
     998:	31 97       	sbiw	r30, 0x01	; 1
     99a:	68 e0       	ldi	r22, 0x08	; 8
     99c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
     99e:	31 97       	sbiw	r30, 0x01	; 1
     9a0:	69 e0       	ldi	r22, 0x09	; 9
     9a2:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
     9a4:	31 97       	sbiw	r30, 0x01	; 1
     9a6:	60 e1       	ldi	r22, 0x10	; 16
     9a8:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
     9aa:	31 97       	sbiw	r30, 0x01	; 1
     9ac:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
     9ae:	31 97       	sbiw	r30, 0x01	; 1
     9b0:	32 e1       	ldi	r19, 0x12	; 18
     9b2:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
     9b4:	31 97       	sbiw	r30, 0x01	; 1
     9b6:	33 e1       	ldi	r19, 0x13	; 19
     9b8:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
     9ba:	31 97       	sbiw	r30, 0x01	; 1
     9bc:	34 e1       	ldi	r19, 0x14	; 20
     9be:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
     9c0:	31 97       	sbiw	r30, 0x01	; 1
     9c2:	35 e1       	ldi	r19, 0x15	; 21
     9c4:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
     9c6:	31 97       	sbiw	r30, 0x01	; 1
     9c8:	36 e1       	ldi	r19, 0x16	; 22
     9ca:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
     9cc:	31 97       	sbiw	r30, 0x01	; 1
     9ce:	37 e1       	ldi	r19, 0x17	; 23
     9d0:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
     9d2:	31 97       	sbiw	r30, 0x01	; 1
     9d4:	38 e1       	ldi	r19, 0x18	; 24
     9d6:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
     9d8:	31 97       	sbiw	r30, 0x01	; 1
     9da:	39 e1       	ldi	r19, 0x19	; 25
     9dc:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
     9de:	31 97       	sbiw	r30, 0x01	; 1
     9e0:	30 e2       	ldi	r19, 0x20	; 32
     9e2:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
     9e4:	31 97       	sbiw	r30, 0x01	; 1
     9e6:	31 e2       	ldi	r19, 0x21	; 33
     9e8:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
     9ea:	31 97       	sbiw	r30, 0x01	; 1
     9ec:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
     9ee:	31 97       	sbiw	r30, 0x01	; 1
     9f0:	23 e2       	ldi	r18, 0x23	; 35
     9f2:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     9f4:	31 97       	sbiw	r30, 0x01	; 1
     9f6:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     9f8:	31 97       	sbiw	r30, 0x01	; 1
     9fa:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
     9fc:	31 97       	sbiw	r30, 0x01	; 1
     9fe:	26 e2       	ldi	r18, 0x26	; 38
     a00:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
     a02:	31 97       	sbiw	r30, 0x01	; 1
     a04:	27 e2       	ldi	r18, 0x27	; 39
     a06:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
     a08:	31 97       	sbiw	r30, 0x01	; 1
     a0a:	28 e2       	ldi	r18, 0x28	; 40
     a0c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
     a0e:	31 97       	sbiw	r30, 0x01	; 1
     a10:	29 e2       	ldi	r18, 0x29	; 41
     a12:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
     a14:	31 97       	sbiw	r30, 0x01	; 1
     a16:	20 e3       	ldi	r18, 0x30	; 48
     a18:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
     a1a:	31 97       	sbiw	r30, 0x01	; 1
     a1c:	21 e3       	ldi	r18, 0x31	; 49
     a1e:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
     a20:	86 97       	sbiw	r24, 0x26	; 38
     a22:	08 95       	ret

00000a24 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
     a24:	0e 94 9c 04 	call	0x938	; 0x938 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     a28:	a0 91 ad 0d 	lds	r26, 0x0DAD	; 0x800dad <pxCurrentTCB>
     a2c:	b0 91 ae 0d 	lds	r27, 0x0DAE	; 0x800dae <pxCurrentTCB+0x1>
     a30:	cd 91       	ld	r28, X+
     a32:	cd bf       	out	0x3d, r28	; 61
     a34:	dd 91       	ld	r29, X+
     a36:	de bf       	out	0x3e, r29	; 62
     a38:	ff 91       	pop	r31
     a3a:	ef 91       	pop	r30
     a3c:	df 91       	pop	r29
     a3e:	cf 91       	pop	r28
     a40:	bf 91       	pop	r27
     a42:	af 91       	pop	r26
     a44:	9f 91       	pop	r25
     a46:	8f 91       	pop	r24
     a48:	7f 91       	pop	r23
     a4a:	6f 91       	pop	r22
     a4c:	5f 91       	pop	r21
     a4e:	4f 91       	pop	r20
     a50:	3f 91       	pop	r19
     a52:	2f 91       	pop	r18
     a54:	1f 91       	pop	r17
     a56:	0f 91       	pop	r16
     a58:	ff 90       	pop	r15
     a5a:	ef 90       	pop	r14
     a5c:	df 90       	pop	r13
     a5e:	cf 90       	pop	r12
     a60:	bf 90       	pop	r11
     a62:	af 90       	pop	r10
     a64:	9f 90       	pop	r9
     a66:	8f 90       	pop	r8
     a68:	7f 90       	pop	r7
     a6a:	6f 90       	pop	r6
     a6c:	5f 90       	pop	r5
     a6e:	4f 90       	pop	r4
     a70:	3f 90       	pop	r3
     a72:	2f 90       	pop	r2
     a74:	1f 90       	pop	r1
     a76:	0f 90       	pop	r0
     a78:	0f be       	out	0x3f, r0	; 63
     a7a:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     a7c:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
     a7e:	81 e0       	ldi	r24, 0x01	; 1
     a80:	08 95       	ret

00000a82 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     a82:	08 95       	ret

00000a84 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     a84:	0f 92       	push	r0
     a86:	0f b6       	in	r0, 0x3f	; 63
     a88:	f8 94       	cli
     a8a:	0f 92       	push	r0
     a8c:	1f 92       	push	r1
     a8e:	11 24       	eor	r1, r1
     a90:	2f 92       	push	r2
     a92:	3f 92       	push	r3
     a94:	4f 92       	push	r4
     a96:	5f 92       	push	r5
     a98:	6f 92       	push	r6
     a9a:	7f 92       	push	r7
     a9c:	8f 92       	push	r8
     a9e:	9f 92       	push	r9
     aa0:	af 92       	push	r10
     aa2:	bf 92       	push	r11
     aa4:	cf 92       	push	r12
     aa6:	df 92       	push	r13
     aa8:	ef 92       	push	r14
     aaa:	ff 92       	push	r15
     aac:	0f 93       	push	r16
     aae:	1f 93       	push	r17
     ab0:	2f 93       	push	r18
     ab2:	3f 93       	push	r19
     ab4:	4f 93       	push	r20
     ab6:	5f 93       	push	r21
     ab8:	6f 93       	push	r22
     aba:	7f 93       	push	r23
     abc:	8f 93       	push	r24
     abe:	9f 93       	push	r25
     ac0:	af 93       	push	r26
     ac2:	bf 93       	push	r27
     ac4:	cf 93       	push	r28
     ac6:	df 93       	push	r29
     ac8:	ef 93       	push	r30
     aca:	ff 93       	push	r31
     acc:	a0 91 ad 0d 	lds	r26, 0x0DAD	; 0x800dad <pxCurrentTCB>
     ad0:	b0 91 ae 0d 	lds	r27, 0x0DAE	; 0x800dae <pxCurrentTCB+0x1>
     ad4:	0d b6       	in	r0, 0x3d	; 61
     ad6:	0d 92       	st	X+, r0
     ad8:	0e b6       	in	r0, 0x3e	; 62
     ada:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     adc:	0e 94 4f 0e 	call	0x1c9e	; 0x1c9e <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     ae0:	a0 91 ad 0d 	lds	r26, 0x0DAD	; 0x800dad <pxCurrentTCB>
     ae4:	b0 91 ae 0d 	lds	r27, 0x0DAE	; 0x800dae <pxCurrentTCB+0x1>
     ae8:	cd 91       	ld	r28, X+
     aea:	cd bf       	out	0x3d, r28	; 61
     aec:	dd 91       	ld	r29, X+
     aee:	de bf       	out	0x3e, r29	; 62
     af0:	ff 91       	pop	r31
     af2:	ef 91       	pop	r30
     af4:	df 91       	pop	r29
     af6:	cf 91       	pop	r28
     af8:	bf 91       	pop	r27
     afa:	af 91       	pop	r26
     afc:	9f 91       	pop	r25
     afe:	8f 91       	pop	r24
     b00:	7f 91       	pop	r23
     b02:	6f 91       	pop	r22
     b04:	5f 91       	pop	r21
     b06:	4f 91       	pop	r20
     b08:	3f 91       	pop	r19
     b0a:	2f 91       	pop	r18
     b0c:	1f 91       	pop	r17
     b0e:	0f 91       	pop	r16
     b10:	ff 90       	pop	r15
     b12:	ef 90       	pop	r14
     b14:	df 90       	pop	r13
     b16:	cf 90       	pop	r12
     b18:	bf 90       	pop	r11
     b1a:	af 90       	pop	r10
     b1c:	9f 90       	pop	r9
     b1e:	8f 90       	pop	r8
     b20:	7f 90       	pop	r7
     b22:	6f 90       	pop	r6
     b24:	5f 90       	pop	r5
     b26:	4f 90       	pop	r4
     b28:	3f 90       	pop	r3
     b2a:	2f 90       	pop	r2
     b2c:	1f 90       	pop	r1
     b2e:	0f 90       	pop	r0
     b30:	0f be       	out	0x3f, r0	; 63
     b32:	0f 90       	pop	r0

	asm volatile ( "ret" );
     b34:	08 95       	ret

00000b36 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     b36:	0f 92       	push	r0
     b38:	0f b6       	in	r0, 0x3f	; 63
     b3a:	f8 94       	cli
     b3c:	0f 92       	push	r0
     b3e:	1f 92       	push	r1
     b40:	11 24       	eor	r1, r1
     b42:	2f 92       	push	r2
     b44:	3f 92       	push	r3
     b46:	4f 92       	push	r4
     b48:	5f 92       	push	r5
     b4a:	6f 92       	push	r6
     b4c:	7f 92       	push	r7
     b4e:	8f 92       	push	r8
     b50:	9f 92       	push	r9
     b52:	af 92       	push	r10
     b54:	bf 92       	push	r11
     b56:	cf 92       	push	r12
     b58:	df 92       	push	r13
     b5a:	ef 92       	push	r14
     b5c:	ff 92       	push	r15
     b5e:	0f 93       	push	r16
     b60:	1f 93       	push	r17
     b62:	2f 93       	push	r18
     b64:	3f 93       	push	r19
     b66:	4f 93       	push	r20
     b68:	5f 93       	push	r21
     b6a:	6f 93       	push	r22
     b6c:	7f 93       	push	r23
     b6e:	8f 93       	push	r24
     b70:	9f 93       	push	r25
     b72:	af 93       	push	r26
     b74:	bf 93       	push	r27
     b76:	cf 93       	push	r28
     b78:	df 93       	push	r29
     b7a:	ef 93       	push	r30
     b7c:	ff 93       	push	r31
     b7e:	a0 91 ad 0d 	lds	r26, 0x0DAD	; 0x800dad <pxCurrentTCB>
     b82:	b0 91 ae 0d 	lds	r27, 0x0DAE	; 0x800dae <pxCurrentTCB+0x1>
     b86:	0d b6       	in	r0, 0x3d	; 61
     b88:	0d 92       	st	X+, r0
     b8a:	0e b6       	in	r0, 0x3e	; 62
     b8c:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     b8e:	0e 94 cc 0c 	call	0x1998	; 0x1998 <xTaskIncrementTick>
     b92:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     b94:	0e 94 4f 0e 	call	0x1c9e	; 0x1c9e <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     b98:	a0 91 ad 0d 	lds	r26, 0x0DAD	; 0x800dad <pxCurrentTCB>
     b9c:	b0 91 ae 0d 	lds	r27, 0x0DAE	; 0x800dae <pxCurrentTCB+0x1>
     ba0:	cd 91       	ld	r28, X+
     ba2:	cd bf       	out	0x3d, r28	; 61
     ba4:	dd 91       	ld	r29, X+
     ba6:	de bf       	out	0x3e, r29	; 62
     ba8:	ff 91       	pop	r31
     baa:	ef 91       	pop	r30
     bac:	df 91       	pop	r29
     bae:	cf 91       	pop	r28
     bb0:	bf 91       	pop	r27
     bb2:	af 91       	pop	r26
     bb4:	9f 91       	pop	r25
     bb6:	8f 91       	pop	r24
     bb8:	7f 91       	pop	r23
     bba:	6f 91       	pop	r22
     bbc:	5f 91       	pop	r21
     bbe:	4f 91       	pop	r20
     bc0:	3f 91       	pop	r19
     bc2:	2f 91       	pop	r18
     bc4:	1f 91       	pop	r17
     bc6:	0f 91       	pop	r16
     bc8:	ff 90       	pop	r15
     bca:	ef 90       	pop	r14
     bcc:	df 90       	pop	r13
     bce:	cf 90       	pop	r12
     bd0:	bf 90       	pop	r11
     bd2:	af 90       	pop	r10
     bd4:	9f 90       	pop	r9
     bd6:	8f 90       	pop	r8
     bd8:	7f 90       	pop	r7
     bda:	6f 90       	pop	r6
     bdc:	5f 90       	pop	r5
     bde:	4f 90       	pop	r4
     be0:	3f 90       	pop	r3
     be2:	2f 90       	pop	r2
     be4:	1f 90       	pop	r1
     be6:	0f 90       	pop	r0
     be8:	0f be       	out	0x3f, r0	; 63
     bea:	0f 90       	pop	r0

	asm volatile ( "ret" );
     bec:	08 95       	ret

00000bee <__vector_12>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     bee:	0e 94 9b 05 	call	0xb36	; 0xb36 <vPortYieldFromTick>
		asm volatile ( "reti" );
     bf2:	18 95       	reti

00000bf4 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     bf4:	cf 93       	push	r28
     bf6:	df 93       	push	r29
     bf8:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
     bfa:	0e 94 ac 0c 	call	0x1958	; 0x1958 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     bfe:	80 91 58 01 	lds	r24, 0x0158	; 0x800158 <pucAlignedHeap.2069>
     c02:	90 91 59 01 	lds	r25, 0x0159	; 0x800159 <pucAlignedHeap.2069+0x1>
     c06:	89 2b       	or	r24, r25
     c08:	31 f4       	brne	.+12     	; 0xc16 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     c0a:	8d e5       	ldi	r24, 0x5D	; 93
     c0c:	91 e0       	ldi	r25, 0x01	; 1
     c0e:	90 93 59 01 	sts	0x0159, r25	; 0x800159 <pucAlignedHeap.2069+0x1>
     c12:	80 93 58 01 	sts	0x0158, r24	; 0x800158 <pucAlignedHeap.2069>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     c16:	20 91 5a 01 	lds	r18, 0x015A	; 0x80015a <xNextFreeByte>
     c1a:	30 91 5b 01 	lds	r19, 0x015B	; 0x80015b <xNextFreeByte+0x1>
     c1e:	c9 01       	movw	r24, r18
     c20:	8c 0f       	add	r24, r28
     c22:	9d 1f       	adc	r25, r29
     c24:	8f 3f       	cpi	r24, 0xFF	; 255
     c26:	4b e0       	ldi	r20, 0x0B	; 11
     c28:	94 07       	cpc	r25, r20
     c2a:	70 f4       	brcc	.+28     	; 0xc48 <pvPortMalloc+0x54>
     c2c:	28 17       	cp	r18, r24
     c2e:	39 07       	cpc	r19, r25
     c30:	70 f4       	brcc	.+28     	; 0xc4e <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     c32:	c0 91 58 01 	lds	r28, 0x0158	; 0x800158 <pucAlignedHeap.2069>
     c36:	d0 91 59 01 	lds	r29, 0x0159	; 0x800159 <pucAlignedHeap.2069+0x1>
     c3a:	c2 0f       	add	r28, r18
     c3c:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
     c3e:	90 93 5b 01 	sts	0x015B, r25	; 0x80015b <xNextFreeByte+0x1>
     c42:	80 93 5a 01 	sts	0x015A, r24	; 0x80015a <xNextFreeByte>
     c46:	05 c0       	rjmp	.+10     	; 0xc52 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     c48:	c0 e0       	ldi	r28, 0x00	; 0
     c4a:	d0 e0       	ldi	r29, 0x00	; 0
     c4c:	02 c0       	rjmp	.+4      	; 0xc52 <pvPortMalloc+0x5e>
     c4e:	c0 e0       	ldi	r28, 0x00	; 0
     c50:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     c52:	0e 94 86 0d 	call	0x1b0c	; 0x1b0c <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     c56:	ce 01       	movw	r24, r28
     c58:	df 91       	pop	r29
     c5a:	cf 91       	pop	r28
     c5c:	08 95       	ret

00000c5e <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     c5e:	08 95       	ret

00000c60 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
     c60:	10 92 5b 01 	sts	0x015B, r1	; 0x80015b <xNextFreeByte+0x1>
     c64:	10 92 5a 01 	sts	0x015A, r1	; 0x80015a <xNextFreeByte>
     c68:	08 95       	ret

00000c6a <xPortGetFreeHeapSize>:
}
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
     c6a:	20 91 5a 01 	lds	r18, 0x015A	; 0x80015a <xNextFreeByte>
     c6e:	30 91 5b 01 	lds	r19, 0x015B	; 0x80015b <xNextFreeByte+0x1>
}
     c72:	8f ef       	ldi	r24, 0xFF	; 255
     c74:	9b e0       	ldi	r25, 0x0B	; 11
     c76:	82 1b       	sub	r24, r18
     c78:	93 0b       	sbc	r25, r19
     c7a:	08 95       	ret

00000c7c <prvIsQueueEmpty>:

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
     c7c:	0f b6       	in	r0, 0x3f	; 63
     c7e:	f8 94       	cli
     c80:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
     c82:	fc 01       	movw	r30, r24
     c84:	82 8d       	ldd	r24, Z+26	; 0x1a
     c86:	81 11       	cpse	r24, r1
     c88:	02 c0       	rjmp	.+4      	; 0xc8e <prvIsQueueEmpty+0x12>
		{
			xReturn = pdTRUE;
     c8a:	81 e0       	ldi	r24, 0x01	; 1
     c8c:	01 c0       	rjmp	.+2      	; 0xc90 <prvIsQueueEmpty+0x14>
		}
		else
		{
			xReturn = pdFALSE;
     c8e:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	taskEXIT_CRITICAL();
     c90:	0f 90       	pop	r0
     c92:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
     c94:	08 95       	ret

00000c96 <prvIsQueueFull>:

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
     c96:	0f b6       	in	r0, 0x3f	; 63
     c98:	f8 94       	cli
     c9a:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
     c9c:	fc 01       	movw	r30, r24
     c9e:	22 8d       	ldd	r18, Z+26	; 0x1a
     ca0:	83 8d       	ldd	r24, Z+27	; 0x1b
     ca2:	28 13       	cpse	r18, r24
     ca4:	02 c0       	rjmp	.+4      	; 0xcaa <prvIsQueueFull+0x14>
		{
			xReturn = pdTRUE;
     ca6:	81 e0       	ldi	r24, 0x01	; 1
     ca8:	01 c0       	rjmp	.+2      	; 0xcac <prvIsQueueFull+0x16>
		}
		else
		{
			xReturn = pdFALSE;
     caa:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	taskEXIT_CRITICAL();
     cac:	0f 90       	pop	r0
     cae:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
     cb0:	08 95       	ret

00000cb2 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
     cb2:	0f 93       	push	r16
     cb4:	1f 93       	push	r17
     cb6:	cf 93       	push	r28
     cb8:	df 93       	push	r29
     cba:	ec 01       	movw	r28, r24
     cbc:	04 2f       	mov	r16, r20
BaseType_t xReturn = pdFALSE;
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
     cbe:	1a 8d       	ldd	r17, Y+26	; 0x1a

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
     cc0:	4c 8d       	ldd	r20, Y+28	; 0x1c
     cc2:	41 11       	cpse	r20, r1
     cc4:	0c c0       	rjmp	.+24     	; 0xcde <prvCopyDataToQueue+0x2c>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     cc6:	88 81       	ld	r24, Y
     cc8:	99 81       	ldd	r25, Y+1	; 0x01
     cca:	89 2b       	or	r24, r25
     ccc:	09 f0       	breq	.+2      	; 0xcd0 <prvCopyDataToQueue+0x1e>
     cce:	42 c0       	rjmp	.+132    	; 0xd54 <prvCopyDataToQueue+0xa2>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
     cd0:	8a 81       	ldd	r24, Y+2	; 0x02
     cd2:	9b 81       	ldd	r25, Y+3	; 0x03
     cd4:	0e 94 f8 0f 	call	0x1ff0	; 0x1ff0 <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
     cd8:	1b 82       	std	Y+3, r1	; 0x03
     cda:	1a 82       	std	Y+2, r1	; 0x02
     cdc:	42 c0       	rjmp	.+132    	; 0xd62 <prvCopyDataToQueue+0xb0>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
     cde:	01 11       	cpse	r16, r1
     ce0:	17 c0       	rjmp	.+46     	; 0xd10 <prvCopyDataToQueue+0x5e>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
     ce2:	50 e0       	ldi	r21, 0x00	; 0
     ce4:	8c 81       	ldd	r24, Y+4	; 0x04
     ce6:	9d 81       	ldd	r25, Y+5	; 0x05
     ce8:	0e 94 1e 16 	call	0x2c3c	; 0x2c3c <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     cec:	2c 8d       	ldd	r18, Y+28	; 0x1c
     cee:	8c 81       	ldd	r24, Y+4	; 0x04
     cf0:	9d 81       	ldd	r25, Y+5	; 0x05
     cf2:	82 0f       	add	r24, r18
     cf4:	91 1d       	adc	r25, r1
     cf6:	9d 83       	std	Y+5, r25	; 0x05
     cf8:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     cfa:	2a 81       	ldd	r18, Y+2	; 0x02
     cfc:	3b 81       	ldd	r19, Y+3	; 0x03
     cfe:	82 17       	cp	r24, r18
     d00:	93 07       	cpc	r25, r19
     d02:	50 f1       	brcs	.+84     	; 0xd58 <prvCopyDataToQueue+0xa6>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
     d04:	88 81       	ld	r24, Y
     d06:	99 81       	ldd	r25, Y+1	; 0x01
     d08:	9d 83       	std	Y+5, r25	; 0x05
     d0a:	8c 83       	std	Y+4, r24	; 0x04
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
     d0c:	80 e0       	ldi	r24, 0x00	; 0
     d0e:	29 c0       	rjmp	.+82     	; 0xd62 <prvCopyDataToQueue+0xb0>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     d10:	50 e0       	ldi	r21, 0x00	; 0
     d12:	8e 81       	ldd	r24, Y+6	; 0x06
     d14:	9f 81       	ldd	r25, Y+7	; 0x07
     d16:	0e 94 1e 16 	call	0x2c3c	; 0x2c3c <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
     d1a:	8c 8d       	ldd	r24, Y+28	; 0x1c
     d1c:	90 e0       	ldi	r25, 0x00	; 0
     d1e:	91 95       	neg	r25
     d20:	81 95       	neg	r24
     d22:	91 09       	sbc	r25, r1
     d24:	2e 81       	ldd	r18, Y+6	; 0x06
     d26:	3f 81       	ldd	r19, Y+7	; 0x07
     d28:	28 0f       	add	r18, r24
     d2a:	39 1f       	adc	r19, r25
     d2c:	3f 83       	std	Y+7, r19	; 0x07
     d2e:	2e 83       	std	Y+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     d30:	48 81       	ld	r20, Y
     d32:	59 81       	ldd	r21, Y+1	; 0x01
     d34:	24 17       	cp	r18, r20
     d36:	35 07       	cpc	r19, r21
     d38:	30 f4       	brcc	.+12     	; 0xd46 <prvCopyDataToQueue+0x94>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
     d3a:	2a 81       	ldd	r18, Y+2	; 0x02
     d3c:	3b 81       	ldd	r19, Y+3	; 0x03
     d3e:	82 0f       	add	r24, r18
     d40:	93 1f       	adc	r25, r19
     d42:	9f 83       	std	Y+7, r25	; 0x07
     d44:	8e 83       	std	Y+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
     d46:	02 30       	cpi	r16, 0x02	; 2
     d48:	49 f4       	brne	.+18     	; 0xd5c <prvCopyDataToQueue+0xaa>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
     d4a:	11 23       	and	r17, r17
     d4c:	49 f0       	breq	.+18     	; 0xd60 <prvCopyDataToQueue+0xae>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
     d4e:	11 50       	subi	r17, 0x01	; 1
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
     d50:	80 e0       	ldi	r24, 0x00	; 0
     d52:	07 c0       	rjmp	.+14     	; 0xd62 <prvCopyDataToQueue+0xb0>
     d54:	80 e0       	ldi	r24, 0x00	; 0
     d56:	05 c0       	rjmp	.+10     	; 0xd62 <prvCopyDataToQueue+0xb0>
     d58:	80 e0       	ldi	r24, 0x00	; 0
     d5a:	03 c0       	rjmp	.+6      	; 0xd62 <prvCopyDataToQueue+0xb0>
     d5c:	80 e0       	ldi	r24, 0x00	; 0
     d5e:	01 c0       	rjmp	.+2      	; 0xd62 <prvCopyDataToQueue+0xb0>
     d60:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
     d62:	1f 5f       	subi	r17, 0xFF	; 255
     d64:	1a 8f       	std	Y+26, r17	; 0x1a

	return xReturn;
}
     d66:	df 91       	pop	r29
     d68:	cf 91       	pop	r28
     d6a:	1f 91       	pop	r17
     d6c:	0f 91       	pop	r16
     d6e:	08 95       	ret

00000d70 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
     d70:	fc 01       	movw	r30, r24
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
     d72:	44 8d       	ldd	r20, Z+28	; 0x1c
     d74:	44 23       	and	r20, r20
     d76:	a9 f0       	breq	.+42     	; 0xda2 <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
     d78:	50 e0       	ldi	r21, 0x00	; 0
     d7a:	26 81       	ldd	r18, Z+6	; 0x06
     d7c:	37 81       	ldd	r19, Z+7	; 0x07
     d7e:	24 0f       	add	r18, r20
     d80:	35 1f       	adc	r19, r21
     d82:	37 83       	std	Z+7, r19	; 0x07
     d84:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
     d86:	82 81       	ldd	r24, Z+2	; 0x02
     d88:	93 81       	ldd	r25, Z+3	; 0x03
     d8a:	28 17       	cp	r18, r24
     d8c:	39 07       	cpc	r19, r25
     d8e:	20 f0       	brcs	.+8      	; 0xd98 <prvCopyDataFromQueue+0x28>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
     d90:	80 81       	ld	r24, Z
     d92:	91 81       	ldd	r25, Z+1	; 0x01
     d94:	97 83       	std	Z+7, r25	; 0x07
     d96:	86 83       	std	Z+6, r24	; 0x06
     d98:	cb 01       	movw	r24, r22
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
     d9a:	66 81       	ldd	r22, Z+6	; 0x06
     d9c:	77 81       	ldd	r23, Z+7	; 0x07
     d9e:	0e 94 1e 16 	call	0x2c3c	; 0x2c3c <memcpy>
     da2:	08 95       	ret

00000da4 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
     da4:	1f 93       	push	r17
     da6:	cf 93       	push	r28
     da8:	df 93       	push	r29
     daa:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
     dac:	0f b6       	in	r0, 0x3f	; 63
     dae:	f8 94       	cli
     db0:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
     db2:	1e 8d       	ldd	r17, Y+30	; 0x1e

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
     db4:	0b c0       	rjmp	.+22     	; 0xdcc <prvUnlockQueue+0x28>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     db6:	89 89       	ldd	r24, Y+17	; 0x11
     db8:	88 23       	and	r24, r24
     dba:	51 f0       	breq	.+20     	; 0xdd0 <prvUnlockQueue+0x2c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     dbc:	ce 01       	movw	r24, r28
     dbe:	41 96       	adiw	r24, 0x11	; 17
     dc0:	0e 94 ce 0e 	call	0x1d9c	; 0x1d9c <xTaskRemoveFromEventList>
     dc4:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
     dc6:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
     dca:	11 50       	subi	r17, 0x01	; 1
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
     dcc:	11 16       	cp	r1, r17
     dce:	9c f3       	brlt	.-26     	; 0xdb6 <prvUnlockQueue+0x12>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
     dd0:	8f ef       	ldi	r24, 0xFF	; 255
     dd2:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
     dd4:	0f 90       	pop	r0
     dd6:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
     dd8:	0f b6       	in	r0, 0x3f	; 63
     dda:	f8 94       	cli
     ddc:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
     dde:	1d 8d       	ldd	r17, Y+29	; 0x1d

		while( cRxLock > queueLOCKED_UNMODIFIED )
     de0:	0b c0       	rjmp	.+22     	; 0xdf8 <prvUnlockQueue+0x54>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     de2:	88 85       	ldd	r24, Y+8	; 0x08
     de4:	88 23       	and	r24, r24
     de6:	51 f0       	breq	.+20     	; 0xdfc <prvUnlockQueue+0x58>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     de8:	ce 01       	movw	r24, r28
     dea:	08 96       	adiw	r24, 0x08	; 8
     dec:	0e 94 ce 0e 	call	0x1d9c	; 0x1d9c <xTaskRemoveFromEventList>
     df0:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
     df2:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
     df6:	11 50       	subi	r17, 0x01	; 1
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
     df8:	11 16       	cp	r1, r17
     dfa:	9c f3       	brlt	.-26     	; 0xde2 <prvUnlockQueue+0x3e>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
     dfc:	8f ef       	ldi	r24, 0xFF	; 255
     dfe:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
     e00:	0f 90       	pop	r0
     e02:	0f be       	out	0x3f, r0	; 63
}
     e04:	df 91       	pop	r29
     e06:	cf 91       	pop	r28
     e08:	1f 91       	pop	r17
     e0a:	08 95       	ret

00000e0c <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
     e0c:	cf 93       	push	r28
     e0e:	df 93       	push	r29
     e10:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
     e12:	0f b6       	in	r0, 0x3f	; 63
     e14:	f8 94       	cli
     e16:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
     e18:	e8 81       	ld	r30, Y
     e1a:	f9 81       	ldd	r31, Y+1	; 0x01
     e1c:	8b 8d       	ldd	r24, Y+27	; 0x1b
     e1e:	90 e0       	ldi	r25, 0x00	; 0
     e20:	2c 8d       	ldd	r18, Y+28	; 0x1c
     e22:	30 e0       	ldi	r19, 0x00	; 0
     e24:	82 9f       	mul	r24, r18
     e26:	a0 01       	movw	r20, r0
     e28:	83 9f       	mul	r24, r19
     e2a:	50 0d       	add	r21, r0
     e2c:	92 9f       	mul	r25, r18
     e2e:	50 0d       	add	r21, r0
     e30:	11 24       	eor	r1, r1
     e32:	4e 0f       	add	r20, r30
     e34:	5f 1f       	adc	r21, r31
     e36:	5b 83       	std	Y+3, r21	; 0x03
     e38:	4a 83       	std	Y+2, r20	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
     e3a:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
     e3c:	fd 83       	std	Y+5, r31	; 0x05
     e3e:	ec 83       	std	Y+4, r30	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
     e40:	01 97       	sbiw	r24, 0x01	; 1
     e42:	28 9f       	mul	r18, r24
     e44:	a0 01       	movw	r20, r0
     e46:	29 9f       	mul	r18, r25
     e48:	50 0d       	add	r21, r0
     e4a:	38 9f       	mul	r19, r24
     e4c:	50 0d       	add	r21, r0
     e4e:	11 24       	eor	r1, r1
     e50:	cf 01       	movw	r24, r30
     e52:	84 0f       	add	r24, r20
     e54:	95 1f       	adc	r25, r21
     e56:	9f 83       	std	Y+7, r25	; 0x07
     e58:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
     e5a:	8f ef       	ldi	r24, 0xFF	; 255
     e5c:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
     e5e:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
     e60:	61 11       	cpse	r22, r1
     e62:	0c c0       	rjmp	.+24     	; 0xe7c <xQueueGenericReset+0x70>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     e64:	88 85       	ldd	r24, Y+8	; 0x08
     e66:	88 23       	and	r24, r24
     e68:	89 f0       	breq	.+34     	; 0xe8c <xQueueGenericReset+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     e6a:	ce 01       	movw	r24, r28
     e6c:	08 96       	adiw	r24, 0x08	; 8
     e6e:	0e 94 ce 0e 	call	0x1d9c	; 0x1d9c <xTaskRemoveFromEventList>
     e72:	88 23       	and	r24, r24
     e74:	59 f0       	breq	.+22     	; 0xe8c <xQueueGenericReset+0x80>
				{
					queueYIELD_IF_USING_PREEMPTION();
     e76:	0e 94 42 05 	call	0xa84	; 0xa84 <vPortYield>
     e7a:	08 c0       	rjmp	.+16     	; 0xe8c <xQueueGenericReset+0x80>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
     e7c:	ce 01       	movw	r24, r28
     e7e:	08 96       	adiw	r24, 0x08	; 8
     e80:	0e 94 12 04 	call	0x824	; 0x824 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
     e84:	ce 01       	movw	r24, r28
     e86:	41 96       	adiw	r24, 0x11	; 17
     e88:	0e 94 12 04 	call	0x824	; 0x824 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
     e8c:	0f 90       	pop	r0
     e8e:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
     e90:	81 e0       	ldi	r24, 0x01	; 1
     e92:	df 91       	pop	r29
     e94:	cf 91       	pop	r28
     e96:	08 95       	ret

00000e98 <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
     e98:	0f 93       	push	r16
     e9a:	1f 93       	push	r17
     e9c:	f8 01       	movw	r30, r16
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
     e9e:	61 11       	cpse	r22, r1
     ea0:	03 c0       	rjmp	.+6      	; 0xea8 <prvInitialiseNewQueue+0x10>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
     ea2:	11 83       	std	Z+1, r17	; 0x01
     ea4:	00 83       	st	Z, r16
     ea6:	02 c0       	rjmp	.+4      	; 0xeac <prvInitialiseNewQueue+0x14>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
     ea8:	51 83       	std	Z+1, r21	; 0x01
     eaa:	40 83       	st	Z, r20
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
     eac:	83 8f       	std	Z+27, r24	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
     eae:	64 8f       	std	Z+28, r22	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
     eb0:	61 e0       	ldi	r22, 0x01	; 1
     eb2:	cf 01       	movw	r24, r30
     eb4:	0e 94 06 07 	call	0xe0c	; 0xe0c <xQueueGenericReset>
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
     eb8:	1f 91       	pop	r17
     eba:	0f 91       	pop	r16
     ebc:	08 95       	ret

00000ebe <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
     ebe:	df 92       	push	r13
     ec0:	ef 92       	push	r14
     ec2:	ff 92       	push	r15
     ec4:	0f 93       	push	r16
     ec6:	1f 93       	push	r17
     ec8:	cf 93       	push	r28
     eca:	df 93       	push	r29
     ecc:	e8 2e       	mov	r14, r24
     ece:	f6 2e       	mov	r15, r22
     ed0:	d4 2e       	mov	r13, r20
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
     ed2:	66 23       	and	r22, r22
     ed4:	21 f0       	breq	.+8      	; 0xede <xQueueGenericCreate+0x20>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     ed6:	86 9f       	mul	r24, r22
     ed8:	c0 01       	movw	r24, r0
     eda:	11 24       	eor	r1, r1
     edc:	02 c0       	rjmp	.+4      	; 0xee2 <xQueueGenericCreate+0x24>
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
     ede:	80 e0       	ldi	r24, 0x00	; 0
     ee0:	90 e0       	ldi	r25, 0x00	; 0
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
		}

		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
     ee2:	4f 96       	adiw	r24, 0x1f	; 31
     ee4:	0e 94 fa 05 	call	0xbf4	; 0xbf4 <pvPortMalloc>
     ee8:	ec 01       	movw	r28, r24

		if( pxNewQueue != NULL )
     eea:	00 97       	sbiw	r24, 0x00	; 0
     eec:	49 f0       	breq	.+18     	; 0xf00 <xQueueGenericCreate+0x42>
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
     eee:	8c 01       	movw	r16, r24
     ef0:	2d 2d       	mov	r18, r13
     ef2:	ac 01       	movw	r20, r24
     ef4:	41 5e       	subi	r20, 0xE1	; 225
     ef6:	5f 4f       	sbci	r21, 0xFF	; 255
     ef8:	6f 2d       	mov	r22, r15
     efa:	8e 2d       	mov	r24, r14
     efc:	0e 94 4c 07 	call	0xe98	; 0xe98 <prvInitialiseNewQueue>
		}

		return pxNewQueue;
	}
     f00:	ce 01       	movw	r24, r28
     f02:	df 91       	pop	r29
     f04:	cf 91       	pop	r28
     f06:	1f 91       	pop	r17
     f08:	0f 91       	pop	r16
     f0a:	ff 90       	pop	r15
     f0c:	ef 90       	pop	r14
     f0e:	df 90       	pop	r13
     f10:	08 95       	ret

00000f12 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
     f12:	cf 92       	push	r12
     f14:	df 92       	push	r13
     f16:	ef 92       	push	r14
     f18:	ff 92       	push	r15
     f1a:	0f 93       	push	r16
     f1c:	1f 93       	push	r17
     f1e:	cf 93       	push	r28
     f20:	df 93       	push	r29
     f22:	00 d0       	rcall	.+0      	; 0xf24 <xQueueGenericSend+0x12>
     f24:	00 d0       	rcall	.+0      	; 0xf26 <xQueueGenericSend+0x14>
     f26:	1f 92       	push	r1
     f28:	cd b7       	in	r28, 0x3d	; 61
     f2a:	de b7       	in	r29, 0x3e	; 62
     f2c:	8c 01       	movw	r16, r24
     f2e:	7b 01       	movw	r14, r22
     f30:	5d 83       	std	Y+5, r21	; 0x05
     f32:	4c 83       	std	Y+4, r20	; 0x04
     f34:	c2 2e       	mov	r12, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
     f36:	d1 2c       	mov	r13, r1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
     f38:	0f b6       	in	r0, 0x3f	; 63
     f3a:	f8 94       	cli
     f3c:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
     f3e:	f8 01       	movw	r30, r16
     f40:	92 8d       	ldd	r25, Z+26	; 0x1a
     f42:	83 8d       	ldd	r24, Z+27	; 0x1b
     f44:	98 17       	cp	r25, r24
     f46:	18 f0       	brcs	.+6      	; 0xf4e <xQueueGenericSend+0x3c>
     f48:	f2 e0       	ldi	r31, 0x02	; 2
     f4a:	cf 12       	cpse	r12, r31
     f4c:	19 c0       	rjmp	.+50     	; 0xf80 <xQueueGenericSend+0x6e>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     f4e:	4c 2d       	mov	r20, r12
     f50:	b7 01       	movw	r22, r14
     f52:	c8 01       	movw	r24, r16
     f54:	0e 94 59 06 	call	0xcb2	; 0xcb2 <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     f58:	f8 01       	movw	r30, r16
     f5a:	91 89       	ldd	r25, Z+17	; 0x11
     f5c:	99 23       	and	r25, r25
     f5e:	49 f0       	breq	.+18     	; 0xf72 <xQueueGenericSend+0x60>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     f60:	c8 01       	movw	r24, r16
     f62:	41 96       	adiw	r24, 0x11	; 17
     f64:	0e 94 ce 0e 	call	0x1d9c	; 0x1d9c <xTaskRemoveFromEventList>
     f68:	88 23       	and	r24, r24
     f6a:	31 f0       	breq	.+12     	; 0xf78 <xQueueGenericSend+0x66>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
     f6c:	0e 94 42 05 	call	0xa84	; 0xa84 <vPortYield>
     f70:	03 c0       	rjmp	.+6      	; 0xf78 <xQueueGenericSend+0x66>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
     f72:	81 11       	cpse	r24, r1
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
     f74:	0e 94 42 05 	call	0xa84	; 0xa84 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
     f78:	0f 90       	pop	r0
     f7a:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     f7c:	81 e0       	ldi	r24, 0x01	; 1
     f7e:	4d c0       	rjmp	.+154    	; 0x101a <xQueueGenericSend+0x108>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
     f80:	8c 81       	ldd	r24, Y+4	; 0x04
     f82:	9d 81       	ldd	r25, Y+5	; 0x05
     f84:	89 2b       	or	r24, r25
     f86:	21 f4       	brne	.+8      	; 0xf90 <xQueueGenericSend+0x7e>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     f88:	0f 90       	pop	r0
     f8a:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
     f8c:	80 e0       	ldi	r24, 0x00	; 0
     f8e:	45 c0       	rjmp	.+138    	; 0x101a <xQueueGenericSend+0x108>
				}
				else if( xEntryTimeSet == pdFALSE )
     f90:	d1 10       	cpse	r13, r1
     f92:	06 c0       	rjmp	.+12     	; 0xfa0 <xQueueGenericSend+0x8e>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     f94:	ce 01       	movw	r24, r28
     f96:	01 96       	adiw	r24, 0x01	; 1
     f98:	0e 94 50 0f 	call	0x1ea0	; 0x1ea0 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     f9c:	dd 24       	eor	r13, r13
     f9e:	d3 94       	inc	r13
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
     fa0:	0f 90       	pop	r0
     fa2:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     fa4:	0e 94 ac 0c 	call	0x1958	; 0x1958 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     fa8:	0f b6       	in	r0, 0x3f	; 63
     faa:	f8 94       	cli
     fac:	0f 92       	push	r0
     fae:	f8 01       	movw	r30, r16
     fb0:	85 8d       	ldd	r24, Z+29	; 0x1d
     fb2:	8f 3f       	cpi	r24, 0xFF	; 255
     fb4:	09 f4       	brne	.+2      	; 0xfb8 <xQueueGenericSend+0xa6>
     fb6:	15 8e       	std	Z+29, r1	; 0x1d
     fb8:	f8 01       	movw	r30, r16
     fba:	86 8d       	ldd	r24, Z+30	; 0x1e
     fbc:	8f 3f       	cpi	r24, 0xFF	; 255
     fbe:	09 f4       	brne	.+2      	; 0xfc2 <xQueueGenericSend+0xb0>
     fc0:	16 8e       	std	Z+30, r1	; 0x1e
     fc2:	0f 90       	pop	r0
     fc4:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     fc6:	be 01       	movw	r22, r28
     fc8:	6c 5f       	subi	r22, 0xFC	; 252
     fca:	7f 4f       	sbci	r23, 0xFF	; 255
     fcc:	ce 01       	movw	r24, r28
     fce:	01 96       	adiw	r24, 0x01	; 1
     fd0:	0e 94 5b 0f 	call	0x1eb6	; 0x1eb6 <xTaskCheckForTimeOut>
     fd4:	81 11       	cpse	r24, r1
     fd6:	1b c0       	rjmp	.+54     	; 0x100e <xQueueGenericSend+0xfc>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
     fd8:	c8 01       	movw	r24, r16
     fda:	0e 94 4b 06 	call	0xc96	; 0xc96 <prvIsQueueFull>
     fde:	88 23       	and	r24, r24
     fe0:	81 f0       	breq	.+32     	; 0x1002 <xQueueGenericSend+0xf0>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     fe2:	6c 81       	ldd	r22, Y+4	; 0x04
     fe4:	7d 81       	ldd	r23, Y+5	; 0x05
     fe6:	c8 01       	movw	r24, r16
     fe8:	08 96       	adiw	r24, 0x08	; 8
     fea:	0e 94 a3 0e 	call	0x1d46	; 0x1d46 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
     fee:	c8 01       	movw	r24, r16
     ff0:	0e 94 d2 06 	call	0xda4	; 0xda4 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
     ff4:	0e 94 86 0d 	call	0x1b0c	; 0x1b0c <xTaskResumeAll>
     ff8:	81 11       	cpse	r24, r1
     ffa:	9e cf       	rjmp	.-196    	; 0xf38 <xQueueGenericSend+0x26>
				{
					portYIELD_WITHIN_API();
     ffc:	0e 94 42 05 	call	0xa84	; 0xa84 <vPortYield>
    1000:	9b cf       	rjmp	.-202    	; 0xf38 <xQueueGenericSend+0x26>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1002:	c8 01       	movw	r24, r16
    1004:	0e 94 d2 06 	call	0xda4	; 0xda4 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1008:	0e 94 86 0d 	call	0x1b0c	; 0x1b0c <xTaskResumeAll>
    100c:	95 cf       	rjmp	.-214    	; 0xf38 <xQueueGenericSend+0x26>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    100e:	c8 01       	movw	r24, r16
    1010:	0e 94 d2 06 	call	0xda4	; 0xda4 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1014:	0e 94 86 0d 	call	0x1b0c	; 0x1b0c <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1018:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    101a:	0f 90       	pop	r0
    101c:	0f 90       	pop	r0
    101e:	0f 90       	pop	r0
    1020:	0f 90       	pop	r0
    1022:	0f 90       	pop	r0
    1024:	df 91       	pop	r29
    1026:	cf 91       	pop	r28
    1028:	1f 91       	pop	r17
    102a:	0f 91       	pop	r16
    102c:	ff 90       	pop	r15
    102e:	ef 90       	pop	r14
    1030:	df 90       	pop	r13
    1032:	cf 90       	pop	r12
    1034:	08 95       	ret

00001036 <prvInitialiseMutex>:

#if( configUSE_MUTEXES == 1 )

	static void prvInitialiseMutex( Queue_t *pxNewQueue )
	{
		if( pxNewQueue != NULL )
    1036:	00 97       	sbiw	r24, 0x00	; 0
    1038:	69 f0       	breq	.+26     	; 0x1054 <prvInitialiseMutex+0x1e>
    103a:	fc 01       	movw	r30, r24
		{
			/* The queue create function will set all the queue structure members
			correctly for a generic queue, but this function is creating a
			mutex.  Overwrite those members that need to be set differently -
			in particular the information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    103c:	13 82       	std	Z+3, r1	; 0x03
    103e:	12 82       	std	Z+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    1040:	11 82       	std	Z+1, r1	; 0x01
    1042:	10 82       	st	Z, r1

			/* In case this is a recursive mutex. */
			pxNewQueue->u.uxRecursiveCallCount = 0;
    1044:	16 82       	std	Z+6, r1	; 0x06

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    1046:	20 e0       	ldi	r18, 0x00	; 0
    1048:	40 e0       	ldi	r20, 0x00	; 0
    104a:	50 e0       	ldi	r21, 0x00	; 0
    104c:	60 e0       	ldi	r22, 0x00	; 0
    104e:	70 e0       	ldi	r23, 0x00	; 0
    1050:	0e 94 89 07 	call	0xf12	; 0xf12 <xQueueGenericSend>
    1054:	08 95       	ret

00001056 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    1056:	cf 93       	push	r28
    1058:	df 93       	push	r29
	Queue_t *pxNewQueue;
	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;

		pxNewQueue = ( Queue_t * ) xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
    105a:	48 2f       	mov	r20, r24
    105c:	60 e0       	ldi	r22, 0x00	; 0
    105e:	81 e0       	ldi	r24, 0x01	; 1
    1060:	0e 94 5f 07 	call	0xebe	; 0xebe <xQueueGenericCreate>
    1064:	ec 01       	movw	r28, r24
		prvInitialiseMutex( pxNewQueue );
    1066:	0e 94 1b 08 	call	0x1036	; 0x1036 <prvInitialiseMutex>

		return pxNewQueue;
	}
    106a:	ce 01       	movw	r24, r28
    106c:	df 91       	pop	r29
    106e:	cf 91       	pop	r28
    1070:	08 95       	ret

00001072 <xQueueGenericSendFromISR>:
	}
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    1072:	ef 92       	push	r14
    1074:	ff 92       	push	r15
    1076:	0f 93       	push	r16
    1078:	1f 93       	push	r17
    107a:	cf 93       	push	r28
    107c:	df 93       	push	r29
    107e:	8a 01       	movw	r16, r20
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1080:	fc 01       	movw	r30, r24
    1082:	52 8d       	ldd	r21, Z+26	; 0x1a
    1084:	33 8d       	ldd	r19, Z+27	; 0x1b
    1086:	53 17       	cp	r21, r19
    1088:	10 f0       	brcs	.+4      	; 0x108e <xQueueGenericSendFromISR+0x1c>
    108a:	22 30       	cpi	r18, 0x02	; 2
    108c:	f1 f4       	brne	.+60     	; 0x10ca <xQueueGenericSendFromISR+0x58>
    108e:	42 2f       	mov	r20, r18
    1090:	78 01       	movw	r14, r16
    1092:	ec 01       	movw	r28, r24
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    1094:	1e 8d       	ldd	r17, Y+30	; 0x1e
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1096:	0e 94 59 06 	call	0xcb2	; 0xcb2 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    109a:	1f 3f       	cpi	r17, 0xFF	; 255
    109c:	81 f4       	brne	.+32     	; 0x10be <xQueueGenericSendFromISR+0x4c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    109e:	89 89       	ldd	r24, Y+17	; 0x11
    10a0:	88 23       	and	r24, r24
    10a2:	a9 f0       	breq	.+42     	; 0x10ce <xQueueGenericSendFromISR+0x5c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    10a4:	ce 01       	movw	r24, r28
    10a6:	41 96       	adiw	r24, 0x11	; 17
    10a8:	0e 94 ce 0e 	call	0x1d9c	; 0x1d9c <xTaskRemoveFromEventList>
    10ac:	88 23       	and	r24, r24
    10ae:	89 f0       	breq	.+34     	; 0x10d2 <xQueueGenericSendFromISR+0x60>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    10b0:	e1 14       	cp	r14, r1
    10b2:	f1 04       	cpc	r15, r1
    10b4:	81 f0       	breq	.+32     	; 0x10d6 <xQueueGenericSendFromISR+0x64>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    10b6:	81 e0       	ldi	r24, 0x01	; 1
    10b8:	f7 01       	movw	r30, r14
    10ba:	80 83       	st	Z, r24
    10bc:	0d c0       	rjmp	.+26     	; 0x10d8 <xQueueGenericSendFromISR+0x66>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    10be:	ff 24       	eor	r15, r15
    10c0:	f3 94       	inc	r15
    10c2:	f1 0e       	add	r15, r17
    10c4:	fe 8e       	std	Y+30, r15	; 0x1e
			}

			xReturn = pdPASS;
    10c6:	81 e0       	ldi	r24, 0x01	; 1
    10c8:	07 c0       	rjmp	.+14     	; 0x10d8 <xQueueGenericSendFromISR+0x66>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    10ca:	80 e0       	ldi	r24, 0x00	; 0
    10cc:	05 c0       	rjmp	.+10     	; 0x10d8 <xQueueGenericSendFromISR+0x66>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
			}

			xReturn = pdPASS;
    10ce:	81 e0       	ldi	r24, 0x01	; 1
    10d0:	03 c0       	rjmp	.+6      	; 0x10d8 <xQueueGenericSendFromISR+0x66>
    10d2:	81 e0       	ldi	r24, 0x01	; 1
    10d4:	01 c0       	rjmp	.+2      	; 0x10d8 <xQueueGenericSendFromISR+0x66>
    10d6:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    10d8:	df 91       	pop	r29
    10da:	cf 91       	pop	r28
    10dc:	1f 91       	pop	r17
    10de:	0f 91       	pop	r16
    10e0:	ff 90       	pop	r15
    10e2:	ef 90       	pop	r14
    10e4:	08 95       	ret

000010e6 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    10e6:	cf 93       	push	r28
    10e8:	df 93       	push	r29
    10ea:	fc 01       	movw	r30, r24
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    10ec:	82 8d       	ldd	r24, Z+26	; 0x1a

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    10ee:	93 8d       	ldd	r25, Z+27	; 0x1b
    10f0:	89 17       	cp	r24, r25
    10f2:	c0 f4       	brcc	.+48     	; 0x1124 <__stack+0x25>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    10f4:	96 8d       	ldd	r25, Z+30	; 0x1e
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
    10f6:	8f 5f       	subi	r24, 0xFF	; 255
    10f8:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    10fa:	9f 3f       	cpi	r25, 0xFF	; 255
    10fc:	79 f4       	brne	.+30     	; 0x111c <__stack+0x1d>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    10fe:	81 89       	ldd	r24, Z+17	; 0x11
    1100:	88 23       	and	r24, r24
    1102:	91 f0       	breq	.+36     	; 0x1128 <__stack+0x29>
    1104:	eb 01       	movw	r28, r22
    1106:	cf 01       	movw	r24, r30
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1108:	41 96       	adiw	r24, 0x11	; 17
    110a:	0e 94 ce 0e 	call	0x1d9c	; 0x1d9c <xTaskRemoveFromEventList>
    110e:	88 23       	and	r24, r24
    1110:	69 f0       	breq	.+26     	; 0x112c <__stack+0x2d>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1112:	20 97       	sbiw	r28, 0x00	; 0
    1114:	69 f0       	breq	.+26     	; 0x1130 <__stack+0x31>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1116:	81 e0       	ldi	r24, 0x01	; 1
    1118:	88 83       	st	Y, r24
    111a:	0b c0       	rjmp	.+22     	; 0x1132 <__stack+0x33>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    111c:	9f 5f       	subi	r25, 0xFF	; 255
    111e:	96 8f       	std	Z+30, r25	; 0x1e
			}

			xReturn = pdPASS;
    1120:	81 e0       	ldi	r24, 0x01	; 1
    1122:	07 c0       	rjmp	.+14     	; 0x1132 <__stack+0x33>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1124:	80 e0       	ldi	r24, 0x00	; 0
    1126:	05 c0       	rjmp	.+10     	; 0x1132 <__stack+0x33>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
			}

			xReturn = pdPASS;
    1128:	81 e0       	ldi	r24, 0x01	; 1
    112a:	03 c0       	rjmp	.+6      	; 0x1132 <__stack+0x33>
    112c:	81 e0       	ldi	r24, 0x01	; 1
    112e:	01 c0       	rjmp	.+2      	; 0x1132 <__stack+0x33>
    1130:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1132:	df 91       	pop	r29
    1134:	cf 91       	pop	r28
    1136:	08 95       	ret

00001138 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    1138:	8f 92       	push	r8
    113a:	9f 92       	push	r9
    113c:	bf 92       	push	r11
    113e:	cf 92       	push	r12
    1140:	df 92       	push	r13
    1142:	ef 92       	push	r14
    1144:	ff 92       	push	r15
    1146:	0f 93       	push	r16
    1148:	1f 93       	push	r17
    114a:	cf 93       	push	r28
    114c:	df 93       	push	r29
    114e:	00 d0       	rcall	.+0      	; 0x1150 <xQueueGenericReceive+0x18>
    1150:	00 d0       	rcall	.+0      	; 0x1152 <xQueueGenericReceive+0x1a>
    1152:	1f 92       	push	r1
    1154:	cd b7       	in	r28, 0x3d	; 61
    1156:	de b7       	in	r29, 0x3e	; 62
    1158:	8c 01       	movw	r16, r24
    115a:	6b 01       	movw	r12, r22
    115c:	5d 83       	std	Y+5, r21	; 0x05
    115e:	4c 83       	std	Y+4, r20	; 0x04
    1160:	b2 2e       	mov	r11, r18
BaseType_t xEntryTimeSet = pdFALSE;
    1162:	e1 2c       	mov	r14, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1164:	0f b6       	in	r0, 0x3f	; 63
    1166:	f8 94       	cli
    1168:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    116a:	f8 01       	movw	r30, r16
    116c:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    116e:	ff 20       	and	r15, r15
    1170:	91 f1       	breq	.+100    	; 0x11d6 <xQueueGenericReceive+0x9e>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    1172:	86 80       	ldd	r8, Z+6	; 0x06
    1174:	97 80       	ldd	r9, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1176:	b6 01       	movw	r22, r12
    1178:	c8 01       	movw	r24, r16
    117a:	0e 94 b8 06 	call	0xd70	; 0xd70 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    117e:	b1 10       	cpse	r11, r1
    1180:	19 c0       	rjmp	.+50     	; 0x11b4 <xQueueGenericReceive+0x7c>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
    1182:	fa 94       	dec	r15
    1184:	f8 01       	movw	r30, r16
    1186:	f2 8e       	std	Z+26, r15	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1188:	80 81       	ld	r24, Z
    118a:	91 81       	ldd	r25, Z+1	; 0x01
    118c:	89 2b       	or	r24, r25
    118e:	29 f4       	brne	.+10     	; 0x119a <xQueueGenericReceive+0x62>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    1190:	0e 94 4f 10 	call	0x209e	; 0x209e <pvTaskIncrementMutexHeldCount>
    1194:	f8 01       	movw	r30, r16
    1196:	93 83       	std	Z+3, r25	; 0x03
    1198:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    119a:	f8 01       	movw	r30, r16
    119c:	80 85       	ldd	r24, Z+8	; 0x08
    119e:	88 23       	and	r24, r24
    11a0:	b1 f0       	breq	.+44     	; 0x11ce <xQueueGenericReceive+0x96>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    11a2:	c8 01       	movw	r24, r16
    11a4:	08 96       	adiw	r24, 0x08	; 8
    11a6:	0e 94 ce 0e 	call	0x1d9c	; 0x1d9c <xTaskRemoveFromEventList>
    11aa:	88 23       	and	r24, r24
    11ac:	81 f0       	breq	.+32     	; 0x11ce <xQueueGenericReceive+0x96>
						{
							queueYIELD_IF_USING_PREEMPTION();
    11ae:	0e 94 42 05 	call	0xa84	; 0xa84 <vPortYield>
    11b2:	0d c0       	rjmp	.+26     	; 0x11ce <xQueueGenericReceive+0x96>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    11b4:	f8 01       	movw	r30, r16
    11b6:	97 82       	std	Z+7, r9	; 0x07
    11b8:	86 82       	std	Z+6, r8	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    11ba:	81 89       	ldd	r24, Z+17	; 0x11
    11bc:	88 23       	and	r24, r24
    11be:	39 f0       	breq	.+14     	; 0x11ce <xQueueGenericReceive+0x96>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    11c0:	c8 01       	movw	r24, r16
    11c2:	41 96       	adiw	r24, 0x11	; 17
    11c4:	0e 94 ce 0e 	call	0x1d9c	; 0x1d9c <xTaskRemoveFromEventList>
    11c8:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    11ca:	0e 94 42 05 	call	0xa84	; 0xa84 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    11ce:	0f 90       	pop	r0
    11d0:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    11d2:	81 e0       	ldi	r24, 0x01	; 1
    11d4:	61 c0       	rjmp	.+194    	; 0x1298 <xQueueGenericReceive+0x160>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    11d6:	8c 81       	ldd	r24, Y+4	; 0x04
    11d8:	9d 81       	ldd	r25, Y+5	; 0x05
    11da:	89 2b       	or	r24, r25
    11dc:	21 f4       	brne	.+8      	; 0x11e6 <xQueueGenericReceive+0xae>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    11de:	0f 90       	pop	r0
    11e0:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    11e2:	80 e0       	ldi	r24, 0x00	; 0
    11e4:	59 c0       	rjmp	.+178    	; 0x1298 <xQueueGenericReceive+0x160>
				}
				else if( xEntryTimeSet == pdFALSE )
    11e6:	e1 10       	cpse	r14, r1
    11e8:	06 c0       	rjmp	.+12     	; 0x11f6 <xQueueGenericReceive+0xbe>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    11ea:	ce 01       	movw	r24, r28
    11ec:	01 96       	adiw	r24, 0x01	; 1
    11ee:	0e 94 50 0f 	call	0x1ea0	; 0x1ea0 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    11f2:	ee 24       	eor	r14, r14
    11f4:	e3 94       	inc	r14
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    11f6:	0f 90       	pop	r0
    11f8:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    11fa:	0e 94 ac 0c 	call	0x1958	; 0x1958 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    11fe:	0f b6       	in	r0, 0x3f	; 63
    1200:	f8 94       	cli
    1202:	0f 92       	push	r0
    1204:	f8 01       	movw	r30, r16
    1206:	85 8d       	ldd	r24, Z+29	; 0x1d
    1208:	8f 3f       	cpi	r24, 0xFF	; 255
    120a:	09 f4       	brne	.+2      	; 0x120e <xQueueGenericReceive+0xd6>
    120c:	15 8e       	std	Z+29, r1	; 0x1d
    120e:	f8 01       	movw	r30, r16
    1210:	86 8d       	ldd	r24, Z+30	; 0x1e
    1212:	8f 3f       	cpi	r24, 0xFF	; 255
    1214:	09 f4       	brne	.+2      	; 0x1218 <xQueueGenericReceive+0xe0>
    1216:	16 8e       	std	Z+30, r1	; 0x1e
    1218:	0f 90       	pop	r0
    121a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    121c:	be 01       	movw	r22, r28
    121e:	6c 5f       	subi	r22, 0xFC	; 252
    1220:	7f 4f       	sbci	r23, 0xFF	; 255
    1222:	ce 01       	movw	r24, r28
    1224:	01 96       	adiw	r24, 0x01	; 1
    1226:	0e 94 5b 0f 	call	0x1eb6	; 0x1eb6 <xTaskCheckForTimeOut>
    122a:	81 11       	cpse	r24, r1
    122c:	29 c0       	rjmp	.+82     	; 0x1280 <xQueueGenericReceive+0x148>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    122e:	c8 01       	movw	r24, r16
    1230:	0e 94 3e 06 	call	0xc7c	; 0xc7c <prvIsQueueEmpty>
    1234:	88 23       	and	r24, r24
    1236:	f1 f0       	breq	.+60     	; 0x1274 <xQueueGenericReceive+0x13c>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1238:	f8 01       	movw	r30, r16
    123a:	80 81       	ld	r24, Z
    123c:	91 81       	ldd	r25, Z+1	; 0x01
    123e:	89 2b       	or	r24, r25
    1240:	49 f4       	brne	.+18     	; 0x1254 <xQueueGenericReceive+0x11c>
					{
						taskENTER_CRITICAL();
    1242:	0f b6       	in	r0, 0x3f	; 63
    1244:	f8 94       	cli
    1246:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    1248:	82 81       	ldd	r24, Z+2	; 0x02
    124a:	93 81       	ldd	r25, Z+3	; 0x03
    124c:	0e 94 96 0f 	call	0x1f2c	; 0x1f2c <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    1250:	0f 90       	pop	r0
    1252:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1254:	6c 81       	ldd	r22, Y+4	; 0x04
    1256:	7d 81       	ldd	r23, Y+5	; 0x05
    1258:	c8 01       	movw	r24, r16
    125a:	41 96       	adiw	r24, 0x11	; 17
    125c:	0e 94 a3 0e 	call	0x1d46	; 0x1d46 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1260:	c8 01       	movw	r24, r16
    1262:	0e 94 d2 06 	call	0xda4	; 0xda4 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1266:	0e 94 86 0d 	call	0x1b0c	; 0x1b0c <xTaskResumeAll>
    126a:	81 11       	cpse	r24, r1
    126c:	7b cf       	rjmp	.-266    	; 0x1164 <xQueueGenericReceive+0x2c>
				{
					portYIELD_WITHIN_API();
    126e:	0e 94 42 05 	call	0xa84	; 0xa84 <vPortYield>
    1272:	78 cf       	rjmp	.-272    	; 0x1164 <xQueueGenericReceive+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1274:	c8 01       	movw	r24, r16
    1276:	0e 94 d2 06 	call	0xda4	; 0xda4 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    127a:	0e 94 86 0d 	call	0x1b0c	; 0x1b0c <xTaskResumeAll>
    127e:	72 cf       	rjmp	.-284    	; 0x1164 <xQueueGenericReceive+0x2c>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1280:	c8 01       	movw	r24, r16
    1282:	0e 94 d2 06 	call	0xda4	; 0xda4 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1286:	0e 94 86 0d 	call	0x1b0c	; 0x1b0c <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    128a:	c8 01       	movw	r24, r16
    128c:	0e 94 3e 06 	call	0xc7c	; 0xc7c <prvIsQueueEmpty>
    1290:	88 23       	and	r24, r24
    1292:	09 f4       	brne	.+2      	; 0x1296 <xQueueGenericReceive+0x15e>
    1294:	67 cf       	rjmp	.-306    	; 0x1164 <xQueueGenericReceive+0x2c>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    1296:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
    1298:	0f 90       	pop	r0
    129a:	0f 90       	pop	r0
    129c:	0f 90       	pop	r0
    129e:	0f 90       	pop	r0
    12a0:	0f 90       	pop	r0
    12a2:	df 91       	pop	r29
    12a4:	cf 91       	pop	r28
    12a6:	1f 91       	pop	r17
    12a8:	0f 91       	pop	r16
    12aa:	ff 90       	pop	r15
    12ac:	ef 90       	pop	r14
    12ae:	df 90       	pop	r13
    12b0:	cf 90       	pop	r12
    12b2:	bf 90       	pop	r11
    12b4:	9f 90       	pop	r9
    12b6:	8f 90       	pop	r8
    12b8:	08 95       	ret

000012ba <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    12ba:	ef 92       	push	r14
    12bc:	ff 92       	push	r15
    12be:	0f 93       	push	r16
    12c0:	1f 93       	push	r17
    12c2:	cf 93       	push	r28
    12c4:	df 93       	push	r29
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    12c6:	fc 01       	movw	r30, r24
    12c8:	c2 8d       	ldd	r28, Z+26	; 0x1a

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    12ca:	cc 23       	and	r28, r28
    12cc:	f9 f0       	breq	.+62     	; 0x130c <xQueueReceiveFromISR+0x52>
    12ce:	7a 01       	movw	r14, r20
    12d0:	8c 01       	movw	r16, r24
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    12d2:	d5 8d       	ldd	r29, Z+29	; 0x1d

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    12d4:	0e 94 b8 06 	call	0xd70	; 0xd70 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
    12d8:	c1 50       	subi	r28, 0x01	; 1
    12da:	f8 01       	movw	r30, r16
    12dc:	c2 8f       	std	Z+26, r28	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    12de:	df 3f       	cpi	r29, 0xFF	; 255
    12e0:	81 f4       	brne	.+32     	; 0x1302 <xQueueReceiveFromISR+0x48>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    12e2:	80 85       	ldd	r24, Z+8	; 0x08
    12e4:	88 23       	and	r24, r24
    12e6:	a1 f0       	breq	.+40     	; 0x1310 <xQueueReceiveFromISR+0x56>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    12e8:	c8 01       	movw	r24, r16
    12ea:	08 96       	adiw	r24, 0x08	; 8
    12ec:	0e 94 ce 0e 	call	0x1d9c	; 0x1d9c <xTaskRemoveFromEventList>
    12f0:	88 23       	and	r24, r24
    12f2:	81 f0       	breq	.+32     	; 0x1314 <xQueueReceiveFromISR+0x5a>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    12f4:	e1 14       	cp	r14, r1
    12f6:	f1 04       	cpc	r15, r1
    12f8:	79 f0       	breq	.+30     	; 0x1318 <xQueueReceiveFromISR+0x5e>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    12fa:	81 e0       	ldi	r24, 0x01	; 1
    12fc:	f7 01       	movw	r30, r14
    12fe:	80 83       	st	Z, r24
    1300:	0c c0       	rjmp	.+24     	; 0x131a <xQueueReceiveFromISR+0x60>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    1302:	df 5f       	subi	r29, 0xFF	; 255
    1304:	f8 01       	movw	r30, r16
    1306:	d5 8f       	std	Z+29, r29	; 0x1d
			}

			xReturn = pdPASS;
    1308:	81 e0       	ldi	r24, 0x01	; 1
    130a:	07 c0       	rjmp	.+14     	; 0x131a <xQueueReceiveFromISR+0x60>
		}
		else
		{
			xReturn = pdFAIL;
    130c:	80 e0       	ldi	r24, 0x00	; 0
    130e:	05 c0       	rjmp	.+10     	; 0x131a <xQueueReceiveFromISR+0x60>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
			}

			xReturn = pdPASS;
    1310:	81 e0       	ldi	r24, 0x01	; 1
    1312:	03 c0       	rjmp	.+6      	; 0x131a <xQueueReceiveFromISR+0x60>
    1314:	81 e0       	ldi	r24, 0x01	; 1
    1316:	01 c0       	rjmp	.+2      	; 0x131a <xQueueReceiveFromISR+0x60>
    1318:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    131a:	df 91       	pop	r29
    131c:	cf 91       	pop	r28
    131e:	1f 91       	pop	r17
    1320:	0f 91       	pop	r16
    1322:	ff 90       	pop	r15
    1324:	ef 90       	pop	r14
    1326:	08 95       	ret

00001328 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    1328:	0f 93       	push	r16
    132a:	1f 93       	push	r17
    132c:	cf 93       	push	r28
    132e:	df 93       	push	r29
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1330:	fc 01       	movw	r30, r24
    1332:	22 8d       	ldd	r18, Z+26	; 0x1a
    1334:	22 23       	and	r18, r18
    1336:	49 f0       	breq	.+18     	; 0x134a <xQueuePeekFromISR+0x22>
    1338:	ec 01       	movw	r28, r24
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    133a:	06 81       	ldd	r16, Z+6	; 0x06
    133c:	17 81       	ldd	r17, Z+7	; 0x07
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    133e:	0e 94 b8 06 	call	0xd70	; 0xd70 <prvCopyDataFromQueue>
			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    1342:	1f 83       	std	Y+7, r17	; 0x07
    1344:	0e 83       	std	Y+6, r16	; 0x06

			xReturn = pdPASS;
    1346:	81 e0       	ldi	r24, 0x01	; 1
    1348:	01 c0       	rjmp	.+2      	; 0x134c <xQueuePeekFromISR+0x24>
		}
		else
		{
			xReturn = pdFAIL;
    134a:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    134c:	df 91       	pop	r29
    134e:	cf 91       	pop	r28
    1350:	1f 91       	pop	r17
    1352:	0f 91       	pop	r16
    1354:	08 95       	ret

00001356 <uxQueueMessagesWaiting>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    1356:	0f b6       	in	r0, 0x3f	; 63
    1358:	f8 94       	cli
    135a:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    135c:	fc 01       	movw	r30, r24
    135e:	82 8d       	ldd	r24, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    1360:	0f 90       	pop	r0
    1362:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1364:	08 95       	ret

00001366 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    1366:	fc 01       	movw	r30, r24
Queue_t *pxQueue;

	pxQueue = ( Queue_t * ) xQueue;
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1368:	0f b6       	in	r0, 0x3f	; 63
    136a:	f8 94       	cli
    136c:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    136e:	93 8d       	ldd	r25, Z+27	; 0x1b
    1370:	82 8d       	ldd	r24, Z+26	; 0x1a
    1372:	98 1b       	sub	r25, r24
    1374:	89 2f       	mov	r24, r25
	}
	taskEXIT_CRITICAL();
    1376:	0f 90       	pop	r0
    1378:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    137a:	08 95       	ret

0000137c <uxQueueMessagesWaitingFromISR>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    137c:	fc 01       	movw	r30, r24
    137e:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1380:	08 95       	ret

00001382 <vQueueDelete>:

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    1382:	0e 94 2f 06 	call	0xc5e	; 0xc5e <vPortFree>
    1386:	08 95       	ret

00001388 <xQueueIsQueueEmptyFromISR>:
BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1388:	fc 01       	movw	r30, r24
    138a:	82 8d       	ldd	r24, Z+26	; 0x1a
    138c:	81 11       	cpse	r24, r1
    138e:	02 c0       	rjmp	.+4      	; 0x1394 <xQueueIsQueueEmptyFromISR+0xc>
	{
		xReturn = pdTRUE;
    1390:	81 e0       	ldi	r24, 0x01	; 1
    1392:	08 95       	ret
	}
	else
	{
		xReturn = pdFALSE;
    1394:	80 e0       	ldi	r24, 0x00	; 0
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1396:	08 95       	ret

00001398 <xQueueIsQueueFullFromISR>:
BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
    1398:	fc 01       	movw	r30, r24
    139a:	22 8d       	ldd	r18, Z+26	; 0x1a
    139c:	83 8d       	ldd	r24, Z+27	; 0x1b
    139e:	28 13       	cpse	r18, r24
    13a0:	02 c0       	rjmp	.+4      	; 0x13a6 <xQueueIsQueueFullFromISR+0xe>
	{
		xReturn = pdTRUE;
    13a2:	81 e0       	ldi	r24, 0x01	; 1
    13a4:	08 95       	ret
	}
	else
	{
		xReturn = pdFALSE;
    13a6:	80 e0       	ldi	r24, 0x00	; 0
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    13a8:	08 95       	ret

000013aa <xQueueCRSend>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait )
	{
    13aa:	ef 92       	push	r14
    13ac:	ff 92       	push	r15
    13ae:	0f 93       	push	r16
    13b0:	1f 93       	push	r17
    13b2:	cf 93       	push	r28
    13b4:	df 93       	push	r29
    13b6:	ec 01       	movw	r28, r24
    13b8:	7b 01       	movw	r14, r22
    13ba:	8a 01       	movw	r16, r20
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;

		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    13bc:	f8 94       	cli
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    13be:	0e 94 4b 06 	call	0xc96	; 0xc96 <prvIsQueueFull>
    13c2:	88 23       	and	r24, r24
    13c4:	79 f0       	breq	.+30     	; 0x13e4 <xQueueCRSend+0x3a>
			{
				/* The queue is full - do we want to block or just leave without
				posting? */
				if( xTicksToWait > ( TickType_t ) 0 )
    13c6:	01 15       	cp	r16, r1
    13c8:	11 05       	cpc	r17, r1
    13ca:	49 f0       	breq	.+18     	; 0x13de <xQueueCRSend+0x34>
				{
					/* As this is called from a coroutine we cannot block directly, but
					return indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    13cc:	be 01       	movw	r22, r28
    13ce:	68 5f       	subi	r22, 0xF8	; 248
    13d0:	7f 4f       	sbci	r23, 0xFF	; 255
    13d2:	c8 01       	movw	r24, r16
    13d4:	0e 94 b8 01 	call	0x370	; 0x370 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    13d8:	78 94       	sei
					return errQUEUE_BLOCKED;
    13da:	8c ef       	ldi	r24, 0xFC	; 252
    13dc:	1f c0       	rjmp	.+62     	; 0x141c <xQueueCRSend+0x72>
				}
				else
				{
					portENABLE_INTERRUPTS();
    13de:	78 94       	sei
					return errQUEUE_FULL;
    13e0:	80 e0       	ldi	r24, 0x00	; 0
    13e2:	1c c0       	rjmp	.+56     	; 0x141c <xQueueCRSend+0x72>
				}
			}
		}
		portENABLE_INTERRUPTS();
    13e4:	78 94       	sei

		portDISABLE_INTERRUPTS();
    13e6:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    13e8:	9a 8d       	ldd	r25, Y+26	; 0x1a
    13ea:	8b 8d       	ldd	r24, Y+27	; 0x1b
    13ec:	98 17       	cp	r25, r24
    13ee:	80 f4       	brcc	.+32     	; 0x1410 <xQueueCRSend+0x66>
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    13f0:	40 e0       	ldi	r20, 0x00	; 0
    13f2:	b7 01       	movw	r22, r14
    13f4:	ce 01       	movw	r24, r28
    13f6:	0e 94 59 06 	call	0xcb2	; 0xcb2 <prvCopyDataToQueue>
				xReturn = pdPASS;

				/* Were any co-routines waiting for data to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    13fa:	89 89       	ldd	r24, Y+17	; 0x11
    13fc:	88 23       	and	r24, r24
    13fe:	51 f0       	breq	.+20     	; 0x1414 <xQueueCRSend+0x6a>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1400:	ce 01       	movw	r24, r28
    1402:	41 96       	adiw	r24, 0x11	; 17
    1404:	0e 94 53 02 	call	0x4a6	; 0x4a6 <xCoRoutineRemoveFromEventList>
    1408:	81 11       	cpse	r24, r1
    140a:	06 c0       	rjmp	.+12     	; 0x1418 <xQueueCRSend+0x6e>
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
				xReturn = pdPASS;
    140c:	81 e0       	ldi	r24, 0x01	; 1
    140e:	05 c0       	rjmp	.+10     	; 0x141a <xQueueCRSend+0x70>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = errQUEUE_FULL;
    1410:	80 e0       	ldi	r24, 0x00	; 0
    1412:	03 c0       	rjmp	.+6      	; 0x141a <xQueueCRSend+0x70>
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
				xReturn = pdPASS;
    1414:	81 e0       	ldi	r24, 0x01	; 1
    1416:	01 c0       	rjmp	.+2      	; 0x141a <xQueueCRSend+0x70>
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
					{
						/* The co-routine waiting has a higher priority so record
						that a yield might be appropriate. */
						xReturn = errQUEUE_YIELD;
    1418:	8b ef       	ldi	r24, 0xFB	; 251
			else
			{
				xReturn = errQUEUE_FULL;
			}
		}
		portENABLE_INTERRUPTS();
    141a:	78 94       	sei

		return xReturn;
	}
    141c:	df 91       	pop	r29
    141e:	cf 91       	pop	r28
    1420:	1f 91       	pop	r17
    1422:	0f 91       	pop	r16
    1424:	ff 90       	pop	r15
    1426:	ef 90       	pop	r14
    1428:	08 95       	ret

0000142a <xQueueCRReceive>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
	{
    142a:	cf 93       	push	r28
    142c:	df 93       	push	r29
    142e:	ec 01       	movw	r28, r24
    1430:	9b 01       	movw	r18, r22
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;

		/* If the queue is already empty we may have to block.  A critical section
		is required to prevent an interrupt adding something to the queue
		between the check to see if the queue is empty and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    1432:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1434:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1436:	91 11       	cpse	r25, r1
    1438:	0f c0       	rjmp	.+30     	; 0x1458 <xQueueCRReceive+0x2e>
			{
				/* There are no messages in the queue, do we want to block or just
				leave with nothing? */
				if( xTicksToWait > ( TickType_t ) 0 )
    143a:	41 15       	cp	r20, r1
    143c:	51 05       	cpc	r21, r1
    143e:	49 f0       	breq	.+18     	; 0x1452 <xQueueCRReceive+0x28>
				{
					/* As this is a co-routine we cannot block directly, but return
					indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    1440:	be 01       	movw	r22, r28
    1442:	6f 5e       	subi	r22, 0xEF	; 239
    1444:	7f 4f       	sbci	r23, 0xFF	; 255
    1446:	ca 01       	movw	r24, r20
    1448:	0e 94 b8 01 	call	0x370	; 0x370 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    144c:	78 94       	sei
					return errQUEUE_BLOCKED;
    144e:	8c ef       	ldi	r24, 0xFC	; 252
    1450:	32 c0       	rjmp	.+100    	; 0x14b6 <xQueueCRReceive+0x8c>
				}
				else
				{
					portENABLE_INTERRUPTS();
    1452:	78 94       	sei
					return errQUEUE_FULL;
    1454:	80 e0       	ldi	r24, 0x00	; 0
    1456:	2f c0       	rjmp	.+94     	; 0x14b6 <xQueueCRReceive+0x8c>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portENABLE_INTERRUPTS();
    1458:	78 94       	sei

		portDISABLE_INTERRUPTS();
    145a:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    145c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    145e:	88 23       	and	r24, r24
    1460:	21 f1       	breq	.+72     	; 0x14aa <xQueueCRReceive+0x80>
			{
				/* Data is available from the queue. */
				pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    1462:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1464:	50 e0       	ldi	r21, 0x00	; 0
    1466:	8e 81       	ldd	r24, Y+6	; 0x06
    1468:	9f 81       	ldd	r25, Y+7	; 0x07
    146a:	84 0f       	add	r24, r20
    146c:	95 1f       	adc	r25, r21
    146e:	9f 83       	std	Y+7, r25	; 0x07
    1470:	8e 83       	std	Y+6, r24	; 0x06
				if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
    1472:	6a 81       	ldd	r22, Y+2	; 0x02
    1474:	7b 81       	ldd	r23, Y+3	; 0x03
    1476:	86 17       	cp	r24, r22
    1478:	97 07       	cpc	r25, r23
    147a:	20 f0       	brcs	.+8      	; 0x1484 <xQueueCRReceive+0x5a>
				{
					pxQueue->u.pcReadFrom = pxQueue->pcHead;
    147c:	88 81       	ld	r24, Y
    147e:	99 81       	ldd	r25, Y+1	; 0x01
    1480:	9f 83       	std	Y+7, r25	; 0x07
    1482:	8e 83       	std	Y+6, r24	; 0x06
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
    1484:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1486:	81 50       	subi	r24, 0x01	; 1
    1488:	8a 8f       	std	Y+26, r24	; 0x1a
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    148a:	6e 81       	ldd	r22, Y+6	; 0x06
    148c:	7f 81       	ldd	r23, Y+7	; 0x07
    148e:	c9 01       	movw	r24, r18
    1490:	0e 94 1e 16 	call	0x2c3c	; 0x2c3c <memcpy>

				xReturn = pdPASS;

				/* Were any co-routines waiting for space to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1494:	88 85       	ldd	r24, Y+8	; 0x08
    1496:	88 23       	and	r24, r24
    1498:	51 f0       	breq	.+20     	; 0x14ae <xQueueCRReceive+0x84>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    149a:	ce 01       	movw	r24, r28
    149c:	08 96       	adiw	r24, 0x08	; 8
    149e:	0e 94 53 02 	call	0x4a6	; 0x4a6 <xCoRoutineRemoveFromEventList>
    14a2:	81 11       	cpse	r24, r1
    14a4:	06 c0       	rjmp	.+12     	; 0x14b2 <xQueueCRReceive+0x88>
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

				xReturn = pdPASS;
    14a6:	81 e0       	ldi	r24, 0x01	; 1
    14a8:	05 c0       	rjmp	.+10     	; 0x14b4 <xQueueCRReceive+0x8a>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = pdFAIL;
    14aa:	80 e0       	ldi	r24, 0x00	; 0
    14ac:	03 c0       	rjmp	.+6      	; 0x14b4 <xQueueCRReceive+0x8a>
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

				xReturn = pdPASS;
    14ae:	81 e0       	ldi	r24, 0x01	; 1
    14b0:	01 c0       	rjmp	.+2      	; 0x14b4 <xQueueCRReceive+0x8a>
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
					{
						xReturn = errQUEUE_YIELD;
    14b2:	8b ef       	ldi	r24, 0xFB	; 251
			else
			{
				xReturn = pdFAIL;
			}
		}
		portENABLE_INTERRUPTS();
    14b4:	78 94       	sei

		return xReturn;
	}
    14b6:	df 91       	pop	r29
    14b8:	cf 91       	pop	r28
    14ba:	08 95       	ret

000014bc <xQueueCRSendFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken )
	{
    14bc:	0f 93       	push	r16
    14be:	1f 93       	push	r17
    14c0:	cf 93       	push	r28
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;

		/* Cannot block within an ISR so if there is no space on the queue then
		exit without doing anything. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    14c2:	fc 01       	movw	r30, r24
    14c4:	32 8d       	ldd	r19, Z+26	; 0x1a
    14c6:	23 8d       	ldd	r18, Z+27	; 0x1b
    14c8:	32 17       	cp	r19, r18
    14ca:	98 f4       	brcc	.+38     	; 0x14f2 <xQueueCRSendFromISR+0x36>
    14cc:	c4 2f       	mov	r28, r20
    14ce:	8c 01       	movw	r16, r24
		{
			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    14d0:	40 e0       	ldi	r20, 0x00	; 0
    14d2:	0e 94 59 06 	call	0xcb2	; 0xcb2 <prvCopyDataToQueue>

			/* We only want to wake one co-routine per ISR, so check that a
			co-routine has not already been woken. */
			if( xCoRoutinePreviouslyWoken == pdFALSE )
    14d6:	c1 11       	cpse	r28, r1
    14d8:	0e c0       	rjmp	.+28     	; 0x14f6 <xQueueCRSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    14da:	f8 01       	movw	r30, r16
    14dc:	81 89       	ldd	r24, Z+17	; 0x11
    14de:	88 23       	and	r24, r24
    14e0:	61 f0       	breq	.+24     	; 0x14fa <xQueueCRSendFromISR+0x3e>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    14e2:	c8 01       	movw	r24, r16
    14e4:	41 96       	adiw	r24, 0x11	; 17
    14e6:	0e 94 53 02 	call	0x4a6	; 0x4a6 <xCoRoutineRemoveFromEventList>
    14ea:	88 23       	and	r24, r24
    14ec:	41 f0       	breq	.+16     	; 0x14fe <xQueueCRSendFromISR+0x42>
					{
						return pdTRUE;
    14ee:	81 e0       	ldi	r24, 0x01	; 1
    14f0:	07 c0       	rjmp	.+14     	; 0x1500 <xQueueCRSendFromISR+0x44>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xCoRoutinePreviouslyWoken;
    14f2:	84 2f       	mov	r24, r20
    14f4:	05 c0       	rjmp	.+10     	; 0x1500 <xQueueCRSendFromISR+0x44>
    14f6:	8c 2f       	mov	r24, r28
    14f8:	03 c0       	rjmp	.+6      	; 0x1500 <xQueueCRSendFromISR+0x44>
    14fa:	8c 2f       	mov	r24, r28
    14fc:	01 c0       	rjmp	.+2      	; 0x1500 <xQueueCRSendFromISR+0x44>
    14fe:	8c 2f       	mov	r24, r28
	}
    1500:	cf 91       	pop	r28
    1502:	1f 91       	pop	r17
    1504:	0f 91       	pop	r16
    1506:	08 95       	ret

00001508 <xQueueCRReceiveFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWoken )
	{
    1508:	0f 93       	push	r16
    150a:	1f 93       	push	r17
    150c:	cf 93       	push	r28
    150e:	df 93       	push	r29
    1510:	fc 01       	movw	r30, r24
	BaseType_t xReturn;
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;

		/* We cannot block from an ISR, so check there is data available. If
		not then just leave without doing anything. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1512:	82 8d       	ldd	r24, Z+26	; 0x1a
    1514:	88 23       	and	r24, r24
    1516:	69 f1       	breq	.+90     	; 0x1572 <xQueueCRReceiveFromISR+0x6a>
		{
			/* Copy the data from the queue. */
			pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    1518:	24 8d       	ldd	r18, Z+28	; 0x1c
    151a:	30 e0       	ldi	r19, 0x00	; 0
    151c:	a6 81       	ldd	r26, Z+6	; 0x06
    151e:	b7 81       	ldd	r27, Z+7	; 0x07
    1520:	a2 0f       	add	r26, r18
    1522:	b3 1f       	adc	r27, r19
    1524:	b7 83       	std	Z+7, r27	; 0x07
    1526:	a6 83       	std	Z+6, r26	; 0x06
			if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
    1528:	82 81       	ldd	r24, Z+2	; 0x02
    152a:	93 81       	ldd	r25, Z+3	; 0x03
    152c:	a8 17       	cp	r26, r24
    152e:	b9 07       	cpc	r27, r25
    1530:	20 f0       	brcs	.+8      	; 0x153a <xQueueCRReceiveFromISR+0x32>
			{
				pxQueue->u.pcReadFrom = pxQueue->pcHead;
    1532:	80 81       	ld	r24, Z
    1534:	91 81       	ldd	r25, Z+1	; 0x01
    1536:	97 83       	std	Z+7, r25	; 0x07
    1538:	86 83       	std	Z+6, r24	; 0x06
    153a:	8a 01       	movw	r16, r20
    153c:	cb 01       	movw	r24, r22
    153e:	ef 01       	movw	r28, r30
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
			--( pxQueue->uxMessagesWaiting );
    1540:	42 8d       	ldd	r20, Z+26	; 0x1a
    1542:	41 50       	subi	r20, 0x01	; 1
    1544:	42 8f       	std	Z+26, r20	; 0x1a
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1546:	66 81       	ldd	r22, Z+6	; 0x06
    1548:	77 81       	ldd	r23, Z+7	; 0x07
    154a:	a9 01       	movw	r20, r18
    154c:	0e 94 1e 16 	call	0x2c3c	; 0x2c3c <memcpy>

			if( ( *pxCoRoutineWoken ) == pdFALSE )
    1550:	f8 01       	movw	r30, r16
    1552:	80 81       	ld	r24, Z
    1554:	81 11       	cpse	r24, r1
    1556:	0f c0       	rjmp	.+30     	; 0x1576 <xQueueCRReceiveFromISR+0x6e>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1558:	88 85       	ldd	r24, Y+8	; 0x08
    155a:	88 23       	and	r24, r24
    155c:	71 f0       	breq	.+28     	; 0x157a <xQueueCRReceiveFromISR+0x72>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    155e:	ce 01       	movw	r24, r28
    1560:	08 96       	adiw	r24, 0x08	; 8
    1562:	0e 94 53 02 	call	0x4a6	; 0x4a6 <xCoRoutineRemoveFromEventList>
    1566:	88 23       	and	r24, r24
    1568:	51 f0       	breq	.+20     	; 0x157e <xQueueCRReceiveFromISR+0x76>
					{
						*pxCoRoutineWoken = pdTRUE;
    156a:	81 e0       	ldi	r24, 0x01	; 1
    156c:	f8 01       	movw	r30, r16
    156e:	80 83       	st	Z, r24
    1570:	07 c0       	rjmp	.+14     	; 0x1580 <xQueueCRReceiveFromISR+0x78>

			xReturn = pdPASS;
		}
		else
		{
			xReturn = pdFAIL;
    1572:	80 e0       	ldi	r24, 0x00	; 0
    1574:	05 c0       	rjmp	.+10     	; 0x1580 <xQueueCRReceiveFromISR+0x78>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			xReturn = pdPASS;
    1576:	81 e0       	ldi	r24, 0x01	; 1
    1578:	03 c0       	rjmp	.+6      	; 0x1580 <xQueueCRReceiveFromISR+0x78>
    157a:	81 e0       	ldi	r24, 0x01	; 1
    157c:	01 c0       	rjmp	.+2      	; 0x1580 <xQueueCRReceiveFromISR+0x78>
    157e:	81 e0       	ldi	r24, 0x01	; 1
		{
			xReturn = pdFAIL;
		}

		return xReturn;
	}
    1580:	df 91       	pop	r29
    1582:	cf 91       	pop	r28
    1584:	1f 91       	pop	r17
    1586:	0f 91       	pop	r16
    1588:	08 95       	ret

0000158a <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    158a:	e0 91 75 0d 	lds	r30, 0x0D75	; 0x800d75 <pxDelayedTaskList>
    158e:	f0 91 76 0d 	lds	r31, 0x0D76	; 0x800d76 <pxDelayedTaskList+0x1>
    1592:	80 81       	ld	r24, Z
    1594:	81 11       	cpse	r24, r1
    1596:	07 c0       	rjmp	.+14     	; 0x15a6 <prvResetNextTaskUnblockTime+0x1c>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    1598:	8f ef       	ldi	r24, 0xFF	; 255
    159a:	9f ef       	ldi	r25, 0xFF	; 255
    159c:	90 93 60 0d 	sts	0x0D60, r25	; 0x800d60 <xNextTaskUnblockTime+0x1>
    15a0:	80 93 5f 0d 	sts	0x0D5F, r24	; 0x800d5f <xNextTaskUnblockTime>
    15a4:	08 95       	ret
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    15a6:	e0 91 75 0d 	lds	r30, 0x0D75	; 0x800d75 <pxDelayedTaskList>
    15aa:	f0 91 76 0d 	lds	r31, 0x0D76	; 0x800d76 <pxDelayedTaskList+0x1>
    15ae:	05 80       	ldd	r0, Z+5	; 0x05
    15b0:	f6 81       	ldd	r31, Z+6	; 0x06
    15b2:	e0 2d       	mov	r30, r0
    15b4:	06 80       	ldd	r0, Z+6	; 0x06
    15b6:	f7 81       	ldd	r31, Z+7	; 0x07
    15b8:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    15ba:	82 81       	ldd	r24, Z+2	; 0x02
    15bc:	93 81       	ldd	r25, Z+3	; 0x03
    15be:	90 93 60 0d 	sts	0x0D60, r25	; 0x800d60 <xNextTaskUnblockTime+0x1>
    15c2:	80 93 5f 0d 	sts	0x0D5F, r24	; 0x800d5f <xNextTaskUnblockTime>
    15c6:	08 95       	ret

000015c8 <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    15c8:	6f 92       	push	r6
    15ca:	7f 92       	push	r7
    15cc:	8f 92       	push	r8
    15ce:	9f 92       	push	r9
    15d0:	af 92       	push	r10
    15d2:	bf 92       	push	r11
    15d4:	cf 92       	push	r12
    15d6:	df 92       	push	r13
    15d8:	ef 92       	push	r14
    15da:	0f 93       	push	r16
    15dc:	1f 93       	push	r17
    15de:	cf 93       	push	r28
    15e0:	df 93       	push	r29
    15e2:	cd b7       	in	r28, 0x3d	; 61
    15e4:	de b7       	in	r29, 0x3e	; 62
    15e6:	4c 01       	movw	r8, r24
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
    15e8:	f5 01       	movw	r30, r10
    15ea:	87 89       	ldd	r24, Z+23	; 0x17
    15ec:	90 8d       	ldd	r25, Z+24	; 0x18
    15ee:	21 50       	subi	r18, 0x01	; 1
    15f0:	31 09       	sbc	r19, r1
    15f2:	3c 01       	movw	r6, r24
    15f4:	62 0e       	add	r6, r18
    15f6:	73 1e       	adc	r7, r19
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    15f8:	20 e0       	ldi	r18, 0x00	; 0
    15fa:	0f c0       	rjmp	.+30     	; 0x161a <prvInitialiseNewTask+0x52>
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    15fc:	82 2f       	mov	r24, r18
    15fe:	90 e0       	ldi	r25, 0x00	; 0
    1600:	fb 01       	movw	r30, r22
    1602:	e8 0f       	add	r30, r24
    1604:	f9 1f       	adc	r31, r25
    1606:	30 81       	ld	r19, Z
    1608:	d5 01       	movw	r26, r10
    160a:	a8 0f       	add	r26, r24
    160c:	b9 1f       	adc	r27, r25
    160e:	59 96       	adiw	r26, 0x19	; 25
    1610:	3c 93       	st	X, r19

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    1612:	80 81       	ld	r24, Z
    1614:	88 23       	and	r24, r24
    1616:	19 f0       	breq	.+6      	; 0x161e <prvInitialiseNewTask+0x56>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    1618:	2f 5f       	subi	r18, 0xFF	; 255
    161a:	28 30       	cpi	r18, 0x08	; 8
    161c:	78 f3       	brcs	.-34     	; 0x15fc <prvInitialiseNewTask+0x34>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    161e:	f5 01       	movw	r30, r10
    1620:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    1622:	f3 e0       	ldi	r31, 0x03	; 3
    1624:	fe 15       	cp	r31, r14
    1626:	20 f4       	brcc	.+8      	; 0x1630 <prvInitialiseNewTask+0x68>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    1628:	0f 2e       	mov	r0, r31
    162a:	f3 e0       	ldi	r31, 0x03	; 3
    162c:	ef 2e       	mov	r14, r31
    162e:	f0 2d       	mov	r31, r0
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    1630:	f5 01       	movw	r30, r10
    1632:	e6 8a       	std	Z+22, r14	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
    1634:	e1 a2       	std	Z+33, r14	; 0x21
		pxNewTCB->uxMutexesHeld = 0;
    1636:	12 a2       	std	Z+34, r1	; 0x22
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    1638:	c5 01       	movw	r24, r10
    163a:	02 96       	adiw	r24, 0x02	; 2
    163c:	0e 94 20 04 	call	0x840	; 0x840 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    1640:	c5 01       	movw	r24, r10
    1642:	0c 96       	adiw	r24, 0x0c	; 12
    1644:	0e 94 20 04 	call	0x840	; 0x840 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    1648:	f5 01       	movw	r30, r10
    164a:	b1 86       	std	Z+9, r11	; 0x09
    164c:	a0 86       	std	Z+8, r10	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    164e:	84 e0       	ldi	r24, 0x04	; 4
    1650:	90 e0       	ldi	r25, 0x00	; 0
    1652:	8e 19       	sub	r24, r14
    1654:	91 09       	sbc	r25, r1
    1656:	95 87       	std	Z+13, r25	; 0x0d
    1658:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    165a:	b3 8a       	std	Z+19, r11	; 0x13
    165c:	a2 8a       	std	Z+18, r10	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    165e:	13 a2       	std	Z+35, r1	; 0x23
    1660:	14 a2       	std	Z+36, r1	; 0x24
    1662:	15 a2       	std	Z+37, r1	; 0x25
    1664:	16 a2       	std	Z+38, r1	; 0x26
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    1666:	17 a2       	std	Z+39, r1	; 0x27
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    1668:	a8 01       	movw	r20, r16
    166a:	b4 01       	movw	r22, r8
    166c:	c3 01       	movw	r24, r6
    166e:	0e 94 a6 04 	call	0x94c	; 0x94c <pxPortInitialiseStack>
    1672:	f5 01       	movw	r30, r10
    1674:	91 83       	std	Z+1, r25	; 0x01
    1676:	80 83       	st	Z, r24
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( ( void * ) pxCreatedTask != NULL )
    1678:	c1 14       	cp	r12, r1
    167a:	d1 04       	cpc	r13, r1
    167c:	19 f0       	breq	.+6      	; 0x1684 <prvInitialiseNewTask+0xbc>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    167e:	f6 01       	movw	r30, r12
    1680:	b1 82       	std	Z+1, r11	; 0x01
    1682:	a0 82       	st	Z, r10
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    1684:	df 91       	pop	r29
    1686:	cf 91       	pop	r28
    1688:	1f 91       	pop	r17
    168a:	0f 91       	pop	r16
    168c:	ef 90       	pop	r14
    168e:	df 90       	pop	r13
    1690:	cf 90       	pop	r12
    1692:	bf 90       	pop	r11
    1694:	af 90       	pop	r10
    1696:	9f 90       	pop	r9
    1698:	8f 90       	pop	r8
    169a:	7f 90       	pop	r7
    169c:	6f 90       	pop	r6
    169e:	08 95       	ret

000016a0 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    16a0:	cf 93       	push	r28
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    16a2:	c0 e0       	ldi	r28, 0x00	; 0
    16a4:	10 c0       	rjmp	.+32     	; 0x16c6 <prvInitialiseTaskLists+0x26>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    16a6:	8c 2f       	mov	r24, r28
    16a8:	90 e0       	ldi	r25, 0x00	; 0
    16aa:	9c 01       	movw	r18, r24
    16ac:	22 0f       	add	r18, r18
    16ae:	33 1f       	adc	r19, r19
    16b0:	22 0f       	add	r18, r18
    16b2:	33 1f       	adc	r19, r19
    16b4:	22 0f       	add	r18, r18
    16b6:	33 1f       	adc	r19, r19
    16b8:	82 0f       	add	r24, r18
    16ba:	93 1f       	adc	r25, r19
    16bc:	87 57       	subi	r24, 0x77	; 119
    16be:	92 4f       	sbci	r25, 0xF2	; 242
    16c0:	0e 94 12 04 	call	0x824	; 0x824 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    16c4:	cf 5f       	subi	r28, 0xFF	; 255
    16c6:	c4 30       	cpi	r28, 0x04	; 4
    16c8:	70 f3       	brcs	.-36     	; 0x16a6 <prvInitialiseTaskLists+0x6>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    16ca:	80 e8       	ldi	r24, 0x80	; 128
    16cc:	9d e0       	ldi	r25, 0x0D	; 13
    16ce:	0e 94 12 04 	call	0x824	; 0x824 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    16d2:	87 e7       	ldi	r24, 0x77	; 119
    16d4:	9d e0       	ldi	r25, 0x0D	; 13
    16d6:	0e 94 12 04 	call	0x824	; 0x824 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    16da:	8a e6       	ldi	r24, 0x6A	; 106
    16dc:	9d e0       	ldi	r25, 0x0D	; 13
    16de:	0e 94 12 04 	call	0x824	; 0x824 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    16e2:	80 e8       	ldi	r24, 0x80	; 128
    16e4:	9d e0       	ldi	r25, 0x0D	; 13
    16e6:	90 93 76 0d 	sts	0x0D76, r25	; 0x800d76 <pxDelayedTaskList+0x1>
    16ea:	80 93 75 0d 	sts	0x0D75, r24	; 0x800d75 <pxDelayedTaskList>
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    16ee:	87 e7       	ldi	r24, 0x77	; 119
    16f0:	9d e0       	ldi	r25, 0x0D	; 13
    16f2:	90 93 74 0d 	sts	0x0D74, r25	; 0x800d74 <pxOverflowDelayedTaskList+0x1>
    16f6:	80 93 73 0d 	sts	0x0D73, r24	; 0x800d73 <pxOverflowDelayedTaskList>
}
    16fa:	cf 91       	pop	r28
    16fc:	08 95       	ret

000016fe <prvAddNewTaskToReadyList>:
	}
}
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
    16fe:	cf 93       	push	r28
    1700:	df 93       	push	r29
    1702:	ec 01       	movw	r28, r24
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    1704:	0f b6       	in	r0, 0x3f	; 63
    1706:	f8 94       	cli
    1708:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    170a:	80 91 69 0d 	lds	r24, 0x0D69	; 0x800d69 <uxCurrentNumberOfTasks>
    170e:	8f 5f       	subi	r24, 0xFF	; 255
    1710:	80 93 69 0d 	sts	0x0D69, r24	; 0x800d69 <uxCurrentNumberOfTasks>
		if( pxCurrentTCB == NULL )
    1714:	80 91 ad 0d 	lds	r24, 0x0DAD	; 0x800dad <pxCurrentTCB>
    1718:	90 91 ae 0d 	lds	r25, 0x0DAE	; 0x800dae <pxCurrentTCB+0x1>
    171c:	89 2b       	or	r24, r25
    171e:	59 f4       	brne	.+22     	; 0x1736 <prvAddNewTaskToReadyList+0x38>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    1720:	d0 93 ae 0d 	sts	0x0DAE, r29	; 0x800dae <pxCurrentTCB+0x1>
    1724:	c0 93 ad 0d 	sts	0x0DAD, r28	; 0x800dad <pxCurrentTCB>

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    1728:	80 91 69 0d 	lds	r24, 0x0D69	; 0x800d69 <uxCurrentNumberOfTasks>
    172c:	81 30       	cpi	r24, 0x01	; 1
    172e:	99 f4       	brne	.+38     	; 0x1756 <prvAddNewTaskToReadyList+0x58>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
    1730:	0e 94 50 0b 	call	0x16a0	; 0x16a0 <prvInitialiseTaskLists>
    1734:	10 c0       	rjmp	.+32     	; 0x1756 <prvAddNewTaskToReadyList+0x58>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    1736:	80 91 65 0d 	lds	r24, 0x0D65	; 0x800d65 <xSchedulerRunning>
    173a:	81 11       	cpse	r24, r1
    173c:	0c c0       	rjmp	.+24     	; 0x1756 <prvAddNewTaskToReadyList+0x58>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    173e:	e0 91 ad 0d 	lds	r30, 0x0DAD	; 0x800dad <pxCurrentTCB>
    1742:	f0 91 ae 0d 	lds	r31, 0x0DAE	; 0x800dae <pxCurrentTCB+0x1>
    1746:	96 89       	ldd	r25, Z+22	; 0x16
    1748:	8e 89       	ldd	r24, Y+22	; 0x16
    174a:	89 17       	cp	r24, r25
    174c:	20 f0       	brcs	.+8      	; 0x1756 <prvAddNewTaskToReadyList+0x58>
				{
					pxCurrentTCB = pxNewTCB;
    174e:	d0 93 ae 0d 	sts	0x0DAE, r29	; 0x800dae <pxCurrentTCB+0x1>
    1752:	c0 93 ad 0d 	sts	0x0DAD, r28	; 0x800dad <pxCurrentTCB>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    1756:	80 91 61 0d 	lds	r24, 0x0D61	; 0x800d61 <uxTaskNumber>
    175a:	8f 5f       	subi	r24, 0xFF	; 255
    175c:	80 93 61 0d 	sts	0x0D61, r24	; 0x800d61 <uxTaskNumber>
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    1760:	8e 89       	ldd	r24, Y+22	; 0x16
    1762:	90 91 66 0d 	lds	r25, 0x0D66	; 0x800d66 <uxTopReadyPriority>
    1766:	98 17       	cp	r25, r24
    1768:	10 f4       	brcc	.+4      	; 0x176e <prvAddNewTaskToReadyList+0x70>
    176a:	80 93 66 0d 	sts	0x0D66, r24	; 0x800d66 <uxTopReadyPriority>
    176e:	90 e0       	ldi	r25, 0x00	; 0
    1770:	9c 01       	movw	r18, r24
    1772:	22 0f       	add	r18, r18
    1774:	33 1f       	adc	r19, r19
    1776:	22 0f       	add	r18, r18
    1778:	33 1f       	adc	r19, r19
    177a:	22 0f       	add	r18, r18
    177c:	33 1f       	adc	r19, r19
    177e:	82 0f       	add	r24, r18
    1780:	93 1f       	adc	r25, r19
    1782:	be 01       	movw	r22, r28
    1784:	6e 5f       	subi	r22, 0xFE	; 254
    1786:	7f 4f       	sbci	r23, 0xFF	; 255
    1788:	87 57       	subi	r24, 0x77	; 119
    178a:	92 4f       	sbci	r25, 0xF2	; 242
    178c:	0e 94 24 04 	call	0x848	; 0x848 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    1790:	0f 90       	pop	r0
    1792:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    1794:	80 91 65 0d 	lds	r24, 0x0D65	; 0x800d65 <xSchedulerRunning>
    1798:	88 23       	and	r24, r24
    179a:	51 f0       	breq	.+20     	; 0x17b0 <prvAddNewTaskToReadyList+0xb2>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    179c:	e0 91 ad 0d 	lds	r30, 0x0DAD	; 0x800dad <pxCurrentTCB>
    17a0:	f0 91 ae 0d 	lds	r31, 0x0DAE	; 0x800dae <pxCurrentTCB+0x1>
    17a4:	96 89       	ldd	r25, Z+22	; 0x16
    17a6:	8e 89       	ldd	r24, Y+22	; 0x16
    17a8:	98 17       	cp	r25, r24
    17aa:	10 f4       	brcc	.+4      	; 0x17b0 <prvAddNewTaskToReadyList+0xb2>
		{
			taskYIELD_IF_USING_PREEMPTION();
    17ac:	0e 94 42 05 	call	0xa84	; 0xa84 <vPortYield>
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    17b0:	df 91       	pop	r29
    17b2:	cf 91       	pop	r28
    17b4:	08 95       	ret

000017b6 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    17b6:	0f 93       	push	r16
    17b8:	1f 93       	push	r17
    17ba:	cf 93       	push	r28
    17bc:	df 93       	push	r29
    17be:	ec 01       	movw	r28, r24
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    17c0:	00 91 67 0d 	lds	r16, 0x0D67	; 0x800d67 <xTickCount>
    17c4:	10 91 68 0d 	lds	r17, 0x0D68	; 0x800d68 <xTickCount+0x1>
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    17c8:	80 91 ad 0d 	lds	r24, 0x0DAD	; 0x800dad <pxCurrentTCB>
    17cc:	90 91 ae 0d 	lds	r25, 0x0DAE	; 0x800dae <pxCurrentTCB+0x1>
    17d0:	02 96       	adiw	r24, 0x02	; 2
    17d2:	0e 94 76 04 	call	0x8ec	; 0x8ec <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
		/* Calculate the time at which the task should be woken if the event
		does not occur.  This may overflow but this doesn't matter, the kernel
		will manage it correctly. */
		xTimeToWake = xConstTickCount + xTicksToWait;
    17d6:	c0 0f       	add	r28, r16
    17d8:	d1 1f       	adc	r29, r17

		/* The list item will be inserted in wake time order. */
		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    17da:	e0 91 ad 0d 	lds	r30, 0x0DAD	; 0x800dad <pxCurrentTCB>
    17de:	f0 91 ae 0d 	lds	r31, 0x0DAE	; 0x800dae <pxCurrentTCB+0x1>
    17e2:	d3 83       	std	Z+3, r29	; 0x03
    17e4:	c2 83       	std	Z+2, r28	; 0x02

		if( xTimeToWake < xConstTickCount )
    17e6:	c0 17       	cp	r28, r16
    17e8:	d1 07       	cpc	r29, r17
    17ea:	68 f4       	brcc	.+26     	; 0x1806 <prvAddCurrentTaskToDelayedList+0x50>
		{
			/* Wake time has overflowed.  Place this item in the overflow list. */
			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    17ec:	60 91 ad 0d 	lds	r22, 0x0DAD	; 0x800dad <pxCurrentTCB>
    17f0:	70 91 ae 0d 	lds	r23, 0x0DAE	; 0x800dae <pxCurrentTCB+0x1>
    17f4:	80 91 73 0d 	lds	r24, 0x0D73	; 0x800d73 <pxOverflowDelayedTaskList>
    17f8:	90 91 74 0d 	lds	r25, 0x0D74	; 0x800d74 <pxOverflowDelayedTaskList+0x1>
    17fc:	6e 5f       	subi	r22, 0xFE	; 254
    17fe:	7f 4f       	sbci	r23, 0xFF	; 255
    1800:	0e 94 45 04 	call	0x88a	; 0x88a <vListInsert>
    1804:	17 c0       	rjmp	.+46     	; 0x1834 <prvAddCurrentTaskToDelayedList+0x7e>
		}
		else
		{
			/* The wake time has not overflowed, so the current block list is used. */
			vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    1806:	60 91 ad 0d 	lds	r22, 0x0DAD	; 0x800dad <pxCurrentTCB>
    180a:	70 91 ae 0d 	lds	r23, 0x0DAE	; 0x800dae <pxCurrentTCB+0x1>
    180e:	80 91 75 0d 	lds	r24, 0x0D75	; 0x800d75 <pxDelayedTaskList>
    1812:	90 91 76 0d 	lds	r25, 0x0D76	; 0x800d76 <pxDelayedTaskList+0x1>
    1816:	6e 5f       	subi	r22, 0xFE	; 254
    1818:	7f 4f       	sbci	r23, 0xFF	; 255
    181a:	0e 94 45 04 	call	0x88a	; 0x88a <vListInsert>

			/* If the task entering the blocked state was placed at the head of the
			list of blocked tasks then xNextTaskUnblockTime needs to be updated
			too. */
			if( xTimeToWake < xNextTaskUnblockTime )
    181e:	80 91 5f 0d 	lds	r24, 0x0D5F	; 0x800d5f <xNextTaskUnblockTime>
    1822:	90 91 60 0d 	lds	r25, 0x0D60	; 0x800d60 <xNextTaskUnblockTime+0x1>
    1826:	c8 17       	cp	r28, r24
    1828:	d9 07       	cpc	r29, r25
    182a:	20 f4       	brcc	.+8      	; 0x1834 <prvAddCurrentTaskToDelayedList+0x7e>
			{
				xNextTaskUnblockTime = xTimeToWake;
    182c:	d0 93 60 0d 	sts	0x0D60, r29	; 0x800d60 <xNextTaskUnblockTime+0x1>
    1830:	c0 93 5f 0d 	sts	0x0D5F, r28	; 0x800d5f <xNextTaskUnblockTime>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    1834:	df 91       	pop	r29
    1836:	cf 91       	pop	r28
    1838:	1f 91       	pop	r17
    183a:	0f 91       	pop	r16
    183c:	08 95       	ret

0000183e <prvIdleTask>:

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    183e:	80 91 89 0d 	lds	r24, 0x0D89	; 0x800d89 <pxReadyTasksLists>
    1842:	82 30       	cpi	r24, 0x02	; 2
    1844:	10 f0       	brcs	.+4      	; 0x184a <prvIdleTask+0xc>
			{
				taskYIELD();
    1846:	0e 94 42 05 	call	0xa84	; 0xa84 <vPortYield>
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
    184a:	0e 94 37 14 	call	0x286e	; 0x286e <vApplicationIdleHook>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
    184e:	f7 cf       	rjmp	.-18     	; 0x183e <prvIdleTask>

00001850 <xTaskCreate>:
							const char * const pcName,
							const uint16_t usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
    1850:	2f 92       	push	r2
    1852:	3f 92       	push	r3
    1854:	4f 92       	push	r4
    1856:	5f 92       	push	r5
    1858:	6f 92       	push	r6
    185a:	7f 92       	push	r7
    185c:	8f 92       	push	r8
    185e:	9f 92       	push	r9
    1860:	af 92       	push	r10
    1862:	bf 92       	push	r11
    1864:	cf 92       	push	r12
    1866:	df 92       	push	r13
    1868:	ef 92       	push	r14
    186a:	ff 92       	push	r15
    186c:	0f 93       	push	r16
    186e:	1f 93       	push	r17
    1870:	cf 93       	push	r28
    1872:	df 93       	push	r29
    1874:	3c 01       	movw	r6, r24
    1876:	1b 01       	movw	r2, r22
    1878:	5a 01       	movw	r10, r20
    187a:	29 01       	movw	r4, r18
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    187c:	ca 01       	movw	r24, r20
    187e:	0e 94 fa 05 	call	0xbf4	; 0xbf4 <pvPortMalloc>
    1882:	6c 01       	movw	r12, r24

			if( pxStack != NULL )
    1884:	89 2b       	or	r24, r25
    1886:	71 f0       	breq	.+28     	; 0x18a4 <xTaskCreate+0x54>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
    1888:	88 e2       	ldi	r24, 0x28	; 40
    188a:	90 e0       	ldi	r25, 0x00	; 0
    188c:	0e 94 fa 05 	call	0xbf4	; 0xbf4 <pvPortMalloc>
    1890:	ec 01       	movw	r28, r24

				if( pxNewTCB != NULL )
    1892:	89 2b       	or	r24, r25
    1894:	19 f0       	breq	.+6      	; 0x189c <xTaskCreate+0x4c>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    1896:	d8 8e       	std	Y+24, r13	; 0x18
    1898:	cf 8a       	std	Y+23, r12	; 0x17
    189a:	06 c0       	rjmp	.+12     	; 0x18a8 <xTaskCreate+0x58>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    189c:	c6 01       	movw	r24, r12
    189e:	0e 94 2f 06 	call	0xc5e	; 0xc5e <vPortFree>
    18a2:	02 c0       	rjmp	.+4      	; 0x18a8 <xTaskCreate+0x58>
				}
			}
			else
			{
				pxNewTCB = NULL;
    18a4:	c0 e0       	ldi	r28, 0x00	; 0
    18a6:	d0 e0       	ldi	r29, 0x00	; 0
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
    18a8:	20 97       	sbiw	r28, 0x00	; 0
    18aa:	91 f0       	breq	.+36     	; 0x18d0 <xTaskCreate+0x80>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    18ac:	95 01       	movw	r18, r10
    18ae:	40 e0       	ldi	r20, 0x00	; 0
    18b0:	50 e0       	ldi	r21, 0x00	; 0
    18b2:	81 2c       	mov	r8, r1
    18b4:	91 2c       	mov	r9, r1
    18b6:	5e 01       	movw	r10, r28
    18b8:	67 01       	movw	r12, r14
    18ba:	e0 2e       	mov	r14, r16
    18bc:	82 01       	movw	r16, r4
    18be:	b1 01       	movw	r22, r2
    18c0:	c3 01       	movw	r24, r6
    18c2:	0e 94 e4 0a 	call	0x15c8	; 0x15c8 <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
    18c6:	ce 01       	movw	r24, r28
    18c8:	0e 94 7f 0b 	call	0x16fe	; 0x16fe <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
    18cc:	81 e0       	ldi	r24, 0x01	; 1
    18ce:	01 c0       	rjmp	.+2      	; 0x18d2 <xTaskCreate+0x82>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    18d0:	8f ef       	ldi	r24, 0xFF	; 255
		}

		return xReturn;
	}
    18d2:	df 91       	pop	r29
    18d4:	cf 91       	pop	r28
    18d6:	1f 91       	pop	r17
    18d8:	0f 91       	pop	r16
    18da:	ff 90       	pop	r15
    18dc:	ef 90       	pop	r14
    18de:	df 90       	pop	r13
    18e0:	cf 90       	pop	r12
    18e2:	bf 90       	pop	r11
    18e4:	af 90       	pop	r10
    18e6:	9f 90       	pop	r9
    18e8:	8f 90       	pop	r8
    18ea:	7f 90       	pop	r7
    18ec:	6f 90       	pop	r6
    18ee:	5f 90       	pop	r5
    18f0:	4f 90       	pop	r4
    18f2:	3f 90       	pop	r3
    18f4:	2f 90       	pop	r2
    18f6:	08 95       	ret

000018f8 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    18f8:	ef 92       	push	r14
    18fa:	ff 92       	push	r15
    18fc:	0f 93       	push	r16
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    18fe:	0f 2e       	mov	r0, r31
    1900:	fd e5       	ldi	r31, 0x5D	; 93
    1902:	ef 2e       	mov	r14, r31
    1904:	fd e0       	ldi	r31, 0x0D	; 13
    1906:	ff 2e       	mov	r15, r31
    1908:	f0 2d       	mov	r31, r0
    190a:	00 e0       	ldi	r16, 0x00	; 0
    190c:	20 e0       	ldi	r18, 0x00	; 0
    190e:	30 e0       	ldi	r19, 0x00	; 0
    1910:	45 e5       	ldi	r20, 0x55	; 85
    1912:	50 e0       	ldi	r21, 0x00	; 0
    1914:	60 e0       	ldi	r22, 0x00	; 0
    1916:	71 e0       	ldi	r23, 0x01	; 1
    1918:	8f e1       	ldi	r24, 0x1F	; 31
    191a:	9c e0       	ldi	r25, 0x0C	; 12
    191c:	0e 94 28 0c 	call	0x1850	; 0x1850 <xTaskCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    1920:	81 30       	cpi	r24, 0x01	; 1
    1922:	81 f4       	brne	.+32     	; 0x1944 <vTaskStartScheduler+0x4c>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    1924:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    1926:	8f ef       	ldi	r24, 0xFF	; 255
    1928:	9f ef       	ldi	r25, 0xFF	; 255
    192a:	90 93 60 0d 	sts	0x0D60, r25	; 0x800d60 <xNextTaskUnblockTime+0x1>
    192e:	80 93 5f 0d 	sts	0x0D5F, r24	; 0x800d5f <xNextTaskUnblockTime>
		xSchedulerRunning = pdTRUE;
    1932:	81 e0       	ldi	r24, 0x01	; 1
    1934:	80 93 65 0d 	sts	0x0D65, r24	; 0x800d65 <xSchedulerRunning>
		xTickCount = ( TickType_t ) 0U;
    1938:	10 92 68 0d 	sts	0x0D68, r1	; 0x800d68 <xTickCount+0x1>
    193c:	10 92 67 0d 	sts	0x0D67, r1	; 0x800d67 <xTickCount>
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    1940:	0e 94 12 05 	call	0xa24	; 0xa24 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    1944:	0f 91       	pop	r16
    1946:	ff 90       	pop	r15
    1948:	ef 90       	pop	r14
    194a:	08 95       	ret

0000194c <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    194c:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    194e:	10 92 65 0d 	sts	0x0D65, r1	; 0x800d65 <xSchedulerRunning>
	vPortEndScheduler();
    1952:	0e 94 41 05 	call	0xa82	; 0xa82 <vPortEndScheduler>
    1956:	08 95       	ret

00001958 <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    1958:	80 91 5c 0d 	lds	r24, 0x0D5C	; 0x800d5c <uxSchedulerSuspended>
    195c:	8f 5f       	subi	r24, 0xFF	; 255
    195e:	80 93 5c 0d 	sts	0x0D5C, r24	; 0x800d5c <uxSchedulerSuspended>
    1962:	08 95       	ret

00001964 <xTaskGetTickCount>:
TickType_t xTaskGetTickCount( void )
{
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    1964:	0f b6       	in	r0, 0x3f	; 63
    1966:	f8 94       	cli
    1968:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    196a:	80 91 67 0d 	lds	r24, 0x0D67	; 0x800d67 <xTickCount>
    196e:	90 91 68 0d 	lds	r25, 0x0D68	; 0x800d68 <xTickCount+0x1>
	}
	portTICK_TYPE_EXIT_CRITICAL();
    1972:	0f 90       	pop	r0
    1974:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    1976:	08 95       	ret

00001978 <xTaskGetTickCountFromISR>:
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
	{
		xReturn = xTickCount;
    1978:	80 91 67 0d 	lds	r24, 0x0D67	; 0x800d67 <xTickCount>
    197c:	90 91 68 0d 	lds	r25, 0x0D68	; 0x800d68 <xTickCount+0x1>
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1980:	08 95       	ret

00001982 <uxTaskGetNumberOfTasks>:

UBaseType_t uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    1982:	80 91 69 0d 	lds	r24, 0x0D69	; 0x800d69 <uxCurrentNumberOfTasks>
}
    1986:	08 95       	ret

00001988 <pcTaskGetName>:
{
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    1988:	00 97       	sbiw	r24, 0x00	; 0
    198a:	21 f4       	brne	.+8      	; 0x1994 <pcTaskGetName+0xc>
    198c:	80 91 ad 0d 	lds	r24, 0x0DAD	; 0x800dad <pxCurrentTCB>
    1990:	90 91 ae 0d 	lds	r25, 0x0DAE	; 0x800dae <pxCurrentTCB+0x1>
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
}
    1994:	49 96       	adiw	r24, 0x19	; 25
    1996:	08 95       	ret

00001998 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    1998:	df 92       	push	r13
    199a:	ef 92       	push	r14
    199c:	ff 92       	push	r15
    199e:	0f 93       	push	r16
    19a0:	1f 93       	push	r17
    19a2:	cf 93       	push	r28
    19a4:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    19a6:	80 91 5c 0d 	lds	r24, 0x0D5C	; 0x800d5c <uxSchedulerSuspended>
    19aa:	81 11       	cpse	r24, r1
    19ac:	97 c0       	rjmp	.+302    	; 0x1adc <xTaskIncrementTick+0x144>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + 1;
    19ae:	e0 90 67 0d 	lds	r14, 0x0D67	; 0x800d67 <xTickCount>
    19b2:	f0 90 68 0d 	lds	r15, 0x0D68	; 0x800d68 <xTickCount+0x1>
    19b6:	8f ef       	ldi	r24, 0xFF	; 255
    19b8:	e8 1a       	sub	r14, r24
    19ba:	f8 0a       	sbc	r15, r24

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    19bc:	f0 92 68 0d 	sts	0x0D68, r15	; 0x800d68 <xTickCount+0x1>
    19c0:	e0 92 67 0d 	sts	0x0D67, r14	; 0x800d67 <xTickCount>

		if( xConstTickCount == ( TickType_t ) 0U )
    19c4:	e1 14       	cp	r14, r1
    19c6:	f1 04       	cpc	r15, r1
    19c8:	b9 f4       	brne	.+46     	; 0x19f8 <xTaskIncrementTick+0x60>
		{
			taskSWITCH_DELAYED_LISTS();
    19ca:	80 91 75 0d 	lds	r24, 0x0D75	; 0x800d75 <pxDelayedTaskList>
    19ce:	90 91 76 0d 	lds	r25, 0x0D76	; 0x800d76 <pxDelayedTaskList+0x1>
    19d2:	20 91 73 0d 	lds	r18, 0x0D73	; 0x800d73 <pxOverflowDelayedTaskList>
    19d6:	30 91 74 0d 	lds	r19, 0x0D74	; 0x800d74 <pxOverflowDelayedTaskList+0x1>
    19da:	30 93 76 0d 	sts	0x0D76, r19	; 0x800d76 <pxDelayedTaskList+0x1>
    19de:	20 93 75 0d 	sts	0x0D75, r18	; 0x800d75 <pxDelayedTaskList>
    19e2:	90 93 74 0d 	sts	0x0D74, r25	; 0x800d74 <pxOverflowDelayedTaskList+0x1>
    19e6:	80 93 73 0d 	sts	0x0D73, r24	; 0x800d73 <pxOverflowDelayedTaskList>
    19ea:	80 91 62 0d 	lds	r24, 0x0D62	; 0x800d62 <xNumOfOverflows>
    19ee:	8f 5f       	subi	r24, 0xFF	; 255
    19f0:	80 93 62 0d 	sts	0x0D62, r24	; 0x800d62 <xNumOfOverflows>
    19f4:	0e 94 c5 0a 	call	0x158a	; 0x158a <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    19f8:	80 91 5f 0d 	lds	r24, 0x0D5F	; 0x800d5f <xNextTaskUnblockTime>
    19fc:	90 91 60 0d 	lds	r25, 0x0D60	; 0x800d60 <xNextTaskUnblockTime+0x1>
    1a00:	e8 16       	cp	r14, r24
    1a02:	f9 06       	cpc	r15, r25
    1a04:	28 f4       	brcc	.+10     	; 0x1a10 <xTaskIncrementTick+0x78>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    1a06:	d1 2c       	mov	r13, r1
    1a08:	53 c0       	rjmp	.+166    	; 0x1ab0 <xTaskIncrementTick+0x118>
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
						{
							xSwitchRequired = pdTRUE;
    1a0a:	dd 24       	eor	r13, r13
    1a0c:	d3 94       	inc	r13
    1a0e:	01 c0       	rjmp	.+2      	; 0x1a12 <xTaskIncrementTick+0x7a>
    1a10:	d1 2c       	mov	r13, r1
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    1a12:	e0 91 75 0d 	lds	r30, 0x0D75	; 0x800d75 <pxDelayedTaskList>
    1a16:	f0 91 76 0d 	lds	r31, 0x0D76	; 0x800d76 <pxDelayedTaskList+0x1>
    1a1a:	80 81       	ld	r24, Z
    1a1c:	81 11       	cpse	r24, r1
    1a1e:	07 c0       	rjmp	.+14     	; 0x1a2e <xTaskIncrementTick+0x96>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1a20:	8f ef       	ldi	r24, 0xFF	; 255
    1a22:	9f ef       	ldi	r25, 0xFF	; 255
    1a24:	90 93 60 0d 	sts	0x0D60, r25	; 0x800d60 <xNextTaskUnblockTime+0x1>
    1a28:	80 93 5f 0d 	sts	0x0D5F, r24	; 0x800d5f <xNextTaskUnblockTime>
					break;
    1a2c:	41 c0       	rjmp	.+130    	; 0x1ab0 <xTaskIncrementTick+0x118>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    1a2e:	e0 91 75 0d 	lds	r30, 0x0D75	; 0x800d75 <pxDelayedTaskList>
    1a32:	f0 91 76 0d 	lds	r31, 0x0D76	; 0x800d76 <pxDelayedTaskList+0x1>
    1a36:	05 80       	ldd	r0, Z+5	; 0x05
    1a38:	f6 81       	ldd	r31, Z+6	; 0x06
    1a3a:	e0 2d       	mov	r30, r0
    1a3c:	c6 81       	ldd	r28, Z+6	; 0x06
    1a3e:	d7 81       	ldd	r29, Z+7	; 0x07
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    1a40:	8a 81       	ldd	r24, Y+2	; 0x02
    1a42:	9b 81       	ldd	r25, Y+3	; 0x03

					if( xConstTickCount < xItemValue )
    1a44:	e8 16       	cp	r14, r24
    1a46:	f9 06       	cpc	r15, r25
    1a48:	28 f4       	brcc	.+10     	; 0x1a54 <xTaskIncrementTick+0xbc>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    1a4a:	90 93 60 0d 	sts	0x0D60, r25	; 0x800d60 <xNextTaskUnblockTime+0x1>
    1a4e:	80 93 5f 0d 	sts	0x0D5F, r24	; 0x800d5f <xNextTaskUnblockTime>
						break;
    1a52:	2e c0       	rjmp	.+92     	; 0x1ab0 <xTaskIncrementTick+0x118>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1a54:	8e 01       	movw	r16, r28
    1a56:	0e 5f       	subi	r16, 0xFE	; 254
    1a58:	1f 4f       	sbci	r17, 0xFF	; 255
    1a5a:	c8 01       	movw	r24, r16
    1a5c:	0e 94 76 04 	call	0x8ec	; 0x8ec <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    1a60:	8c 89       	ldd	r24, Y+20	; 0x14
    1a62:	9d 89       	ldd	r25, Y+21	; 0x15
    1a64:	89 2b       	or	r24, r25
    1a66:	21 f0       	breq	.+8      	; 0x1a70 <xTaskIncrementTick+0xd8>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    1a68:	ce 01       	movw	r24, r28
    1a6a:	0c 96       	adiw	r24, 0x0c	; 12
    1a6c:	0e 94 76 04 	call	0x8ec	; 0x8ec <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    1a70:	8e 89       	ldd	r24, Y+22	; 0x16
    1a72:	90 91 66 0d 	lds	r25, 0x0D66	; 0x800d66 <uxTopReadyPriority>
    1a76:	98 17       	cp	r25, r24
    1a78:	10 f4       	brcc	.+4      	; 0x1a7e <xTaskIncrementTick+0xe6>
    1a7a:	80 93 66 0d 	sts	0x0D66, r24	; 0x800d66 <uxTopReadyPriority>
    1a7e:	90 e0       	ldi	r25, 0x00	; 0
    1a80:	9c 01       	movw	r18, r24
    1a82:	22 0f       	add	r18, r18
    1a84:	33 1f       	adc	r19, r19
    1a86:	22 0f       	add	r18, r18
    1a88:	33 1f       	adc	r19, r19
    1a8a:	22 0f       	add	r18, r18
    1a8c:	33 1f       	adc	r19, r19
    1a8e:	82 0f       	add	r24, r18
    1a90:	93 1f       	adc	r25, r19
    1a92:	b8 01       	movw	r22, r16
    1a94:	87 57       	subi	r24, 0x77	; 119
    1a96:	92 4f       	sbci	r25, 0xF2	; 242
    1a98:	0e 94 24 04 	call	0x848	; 0x848 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1a9c:	9e 89       	ldd	r25, Y+22	; 0x16
    1a9e:	e0 91 ad 0d 	lds	r30, 0x0DAD	; 0x800dad <pxCurrentTCB>
    1aa2:	f0 91 ae 0d 	lds	r31, 0x0DAE	; 0x800dae <pxCurrentTCB+0x1>
    1aa6:	86 89       	ldd	r24, Z+22	; 0x16
    1aa8:	98 17       	cp	r25, r24
    1aaa:	08 f0       	brcs	.+2      	; 0x1aae <xTaskIncrementTick+0x116>
    1aac:	ae cf       	rjmp	.-164    	; 0x1a0a <xTaskIncrementTick+0x72>
    1aae:	b1 cf       	rjmp	.-158    	; 0x1a12 <xTaskIncrementTick+0x7a>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    1ab0:	e0 91 ad 0d 	lds	r30, 0x0DAD	; 0x800dad <pxCurrentTCB>
    1ab4:	f0 91 ae 0d 	lds	r31, 0x0DAE	; 0x800dae <pxCurrentTCB+0x1>
    1ab8:	86 89       	ldd	r24, Z+22	; 0x16
    1aba:	90 e0       	ldi	r25, 0x00	; 0
    1abc:	fc 01       	movw	r30, r24
    1abe:	ee 0f       	add	r30, r30
    1ac0:	ff 1f       	adc	r31, r31
    1ac2:	ee 0f       	add	r30, r30
    1ac4:	ff 1f       	adc	r31, r31
    1ac6:	ee 0f       	add	r30, r30
    1ac8:	ff 1f       	adc	r31, r31
    1aca:	8e 0f       	add	r24, r30
    1acc:	9f 1f       	adc	r25, r31
    1ace:	fc 01       	movw	r30, r24
    1ad0:	e7 57       	subi	r30, 0x77	; 119
    1ad2:	f2 4f       	sbci	r31, 0xF2	; 242
    1ad4:	80 81       	ld	r24, Z
    1ad6:	82 30       	cpi	r24, 0x02	; 2
    1ad8:	40 f4       	brcc	.+16     	; 0x1aea <xTaskIncrementTick+0x152>
    1ada:	09 c0       	rjmp	.+18     	; 0x1aee <xTaskIncrementTick+0x156>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    1adc:	80 91 64 0d 	lds	r24, 0x0D64	; 0x800d64 <uxPendedTicks>
    1ae0:	8f 5f       	subi	r24, 0xFF	; 255
    1ae2:	80 93 64 0d 	sts	0x0D64, r24	; 0x800d64 <uxPendedTicks>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    1ae6:	d1 2c       	mov	r13, r1
    1ae8:	02 c0       	rjmp	.+4      	; 0x1aee <xTaskIncrementTick+0x156>
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
			{
				xSwitchRequired = pdTRUE;
    1aea:	dd 24       	eor	r13, r13
    1aec:	d3 94       	inc	r13
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    1aee:	80 91 63 0d 	lds	r24, 0x0D63	; 0x800d63 <xYieldPending>
    1af2:	88 23       	and	r24, r24
    1af4:	11 f0       	breq	.+4      	; 0x1afa <xTaskIncrementTick+0x162>
		{
			xSwitchRequired = pdTRUE;
    1af6:	dd 24       	eor	r13, r13
    1af8:	d3 94       	inc	r13
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
    1afa:	8d 2d       	mov	r24, r13
    1afc:	df 91       	pop	r29
    1afe:	cf 91       	pop	r28
    1b00:	1f 91       	pop	r17
    1b02:	0f 91       	pop	r16
    1b04:	ff 90       	pop	r15
    1b06:	ef 90       	pop	r14
    1b08:	df 90       	pop	r13
    1b0a:	08 95       	ret

00001b0c <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    1b0c:	0f 93       	push	r16
    1b0e:	1f 93       	push	r17
    1b10:	cf 93       	push	r28
    1b12:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    1b14:	0f b6       	in	r0, 0x3f	; 63
    1b16:	f8 94       	cli
    1b18:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    1b1a:	80 91 5c 0d 	lds	r24, 0x0D5C	; 0x800d5c <uxSchedulerSuspended>
    1b1e:	81 50       	subi	r24, 0x01	; 1
    1b20:	80 93 5c 0d 	sts	0x0D5C, r24	; 0x800d5c <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1b24:	80 91 5c 0d 	lds	r24, 0x0D5C	; 0x800d5c <uxSchedulerSuspended>
    1b28:	81 11       	cpse	r24, r1
    1b2a:	58 c0       	rjmp	.+176    	; 0x1bdc <xTaskResumeAll+0xd0>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    1b2c:	80 91 69 0d 	lds	r24, 0x0D69	; 0x800d69 <uxCurrentNumberOfTasks>
    1b30:	81 11       	cpse	r24, r1
    1b32:	33 c0       	rjmp	.+102    	; 0x1b9a <xTaskResumeAll+0x8e>
    1b34:	56 c0       	rjmp	.+172    	; 0x1be2 <xTaskResumeAll+0xd6>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    1b36:	e0 91 6f 0d 	lds	r30, 0x0D6F	; 0x800d6f <xPendingReadyList+0x5>
    1b3a:	f0 91 70 0d 	lds	r31, 0x0D70	; 0x800d70 <xPendingReadyList+0x6>
    1b3e:	c6 81       	ldd	r28, Z+6	; 0x06
    1b40:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    1b42:	ce 01       	movw	r24, r28
    1b44:	0c 96       	adiw	r24, 0x0c	; 12
    1b46:	0e 94 76 04 	call	0x8ec	; 0x8ec <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1b4a:	8e 01       	movw	r16, r28
    1b4c:	0e 5f       	subi	r16, 0xFE	; 254
    1b4e:	1f 4f       	sbci	r17, 0xFF	; 255
    1b50:	c8 01       	movw	r24, r16
    1b52:	0e 94 76 04 	call	0x8ec	; 0x8ec <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    1b56:	8e 89       	ldd	r24, Y+22	; 0x16
    1b58:	90 91 66 0d 	lds	r25, 0x0D66	; 0x800d66 <uxTopReadyPriority>
    1b5c:	98 17       	cp	r25, r24
    1b5e:	10 f4       	brcc	.+4      	; 0x1b64 <xTaskResumeAll+0x58>
    1b60:	80 93 66 0d 	sts	0x0D66, r24	; 0x800d66 <uxTopReadyPriority>
    1b64:	90 e0       	ldi	r25, 0x00	; 0
    1b66:	9c 01       	movw	r18, r24
    1b68:	22 0f       	add	r18, r18
    1b6a:	33 1f       	adc	r19, r19
    1b6c:	22 0f       	add	r18, r18
    1b6e:	33 1f       	adc	r19, r19
    1b70:	22 0f       	add	r18, r18
    1b72:	33 1f       	adc	r19, r19
    1b74:	82 0f       	add	r24, r18
    1b76:	93 1f       	adc	r25, r19
    1b78:	b8 01       	movw	r22, r16
    1b7a:	87 57       	subi	r24, 0x77	; 119
    1b7c:	92 4f       	sbci	r25, 0xF2	; 242
    1b7e:	0e 94 24 04 	call	0x848	; 0x848 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1b82:	9e 89       	ldd	r25, Y+22	; 0x16
    1b84:	e0 91 ad 0d 	lds	r30, 0x0DAD	; 0x800dad <pxCurrentTCB>
    1b88:	f0 91 ae 0d 	lds	r31, 0x0DAE	; 0x800dae <pxCurrentTCB+0x1>
    1b8c:	86 89       	ldd	r24, Z+22	; 0x16
    1b8e:	98 17       	cp	r25, r24
    1b90:	30 f0       	brcs	.+12     	; 0x1b9e <xTaskResumeAll+0x92>
					{
						xYieldPending = pdTRUE;
    1b92:	81 e0       	ldi	r24, 0x01	; 1
    1b94:	80 93 63 0d 	sts	0x0D63, r24	; 0x800d63 <xYieldPending>
    1b98:	02 c0       	rjmp	.+4      	; 0x1b9e <xTaskResumeAll+0x92>
    1b9a:	c0 e0       	ldi	r28, 0x00	; 0
    1b9c:	d0 e0       	ldi	r29, 0x00	; 0
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    1b9e:	80 91 6a 0d 	lds	r24, 0x0D6A	; 0x800d6a <xPendingReadyList>
    1ba2:	81 11       	cpse	r24, r1
    1ba4:	c8 cf       	rjmp	.-112    	; 0x1b36 <xTaskResumeAll+0x2a>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    1ba6:	cd 2b       	or	r28, r29
    1ba8:	11 f0       	breq	.+4      	; 0x1bae <xTaskResumeAll+0xa2>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    1baa:	0e 94 c5 0a 	call	0x158a	; 0x158a <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    1bae:	c0 91 64 0d 	lds	r28, 0x0D64	; 0x800d64 <uxPendedTicks>

					if( uxPendedCounts > ( UBaseType_t ) 0U )
    1bb2:	cc 23       	and	r28, r28
    1bb4:	59 f0       	breq	.+22     	; 0x1bcc <xTaskResumeAll+0xc0>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    1bb6:	0e 94 cc 0c 	call	0x1998	; 0x1998 <xTaskIncrementTick>
    1bba:	88 23       	and	r24, r24
    1bbc:	19 f0       	breq	.+6      	; 0x1bc4 <xTaskResumeAll+0xb8>
							{
								xYieldPending = pdTRUE;
    1bbe:	81 e0       	ldi	r24, 0x01	; 1
    1bc0:	80 93 63 0d 	sts	0x0D63, r24	; 0x800d63 <xYieldPending>
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
    1bc4:	c1 50       	subi	r28, 0x01	; 1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    1bc6:	b9 f7       	brne	.-18     	; 0x1bb6 <xTaskResumeAll+0xaa>

						uxPendedTicks = 0;
    1bc8:	10 92 64 0d 	sts	0x0D64, r1	; 0x800d64 <uxPendedTicks>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    1bcc:	80 91 63 0d 	lds	r24, 0x0D63	; 0x800d63 <xYieldPending>
    1bd0:	88 23       	and	r24, r24
    1bd2:	31 f0       	breq	.+12     	; 0x1be0 <xTaskResumeAll+0xd4>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    1bd4:	0e 94 42 05 	call	0xa84	; 0xa84 <vPortYield>

				if( xYieldPending != pdFALSE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    1bd8:	81 e0       	ldi	r24, 0x01	; 1
    1bda:	03 c0       	rjmp	.+6      	; 0x1be2 <xTaskResumeAll+0xd6>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB = NULL;
BaseType_t xAlreadyYielded = pdFALSE;
    1bdc:	80 e0       	ldi	r24, 0x00	; 0
    1bde:	01 c0       	rjmp	.+2      	; 0x1be2 <xTaskResumeAll+0xd6>
    1be0:	80 e0       	ldi	r24, 0x00	; 0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    1be2:	0f 90       	pop	r0
    1be4:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    1be6:	df 91       	pop	r29
    1be8:	cf 91       	pop	r28
    1bea:	1f 91       	pop	r17
    1bec:	0f 91       	pop	r16
    1bee:	08 95       	ret

00001bf0 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    1bf0:	0f 93       	push	r16
    1bf2:	1f 93       	push	r17
    1bf4:	cf 93       	push	r28
    1bf6:	df 93       	push	r29
    1bf8:	8c 01       	movw	r16, r24
    1bfa:	eb 01       	movw	r28, r22

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    1bfc:	0e 94 ac 0c 	call	0x1958	; 0x1958 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    1c00:	40 91 67 0d 	lds	r20, 0x0D67	; 0x800d67 <xTickCount>
    1c04:	50 91 68 0d 	lds	r21, 0x0D68	; 0x800d68 <xTickCount+0x1>

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    1c08:	f8 01       	movw	r30, r16
    1c0a:	20 81       	ld	r18, Z
    1c0c:	31 81       	ldd	r19, Z+1	; 0x01
    1c0e:	c9 01       	movw	r24, r18
    1c10:	8c 0f       	add	r24, r28
    1c12:	9d 1f       	adc	r25, r29

			if( xConstTickCount < *pxPreviousWakeTime )
    1c14:	42 17       	cp	r20, r18
    1c16:	53 07       	cpc	r21, r19
    1c18:	40 f4       	brcc	.+16     	; 0x1c2a <vTaskDelayUntil+0x3a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    1c1a:	82 17       	cp	r24, r18
    1c1c:	93 07       	cpc	r25, r19
    1c1e:	68 f4       	brcc	.+26     	; 0x1c3a <vTaskDelayUntil+0x4a>
    1c20:	48 17       	cp	r20, r24
    1c22:	59 07       	cpc	r21, r25
    1c24:	60 f0       	brcs	.+24     	; 0x1c3e <vTaskDelayUntil+0x4e>
#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    1c26:	20 e0       	ldi	r18, 0x00	; 0
    1c28:	0f c0       	rjmp	.+30     	; 0x1c48 <vTaskDelayUntil+0x58>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    1c2a:	82 17       	cp	r24, r18
    1c2c:	93 07       	cpc	r25, r19
    1c2e:	48 f0       	brcs	.+18     	; 0x1c42 <vTaskDelayUntil+0x52>
    1c30:	48 17       	cp	r20, r24
    1c32:	59 07       	cpc	r21, r25
    1c34:	40 f0       	brcs	.+16     	; 0x1c46 <vTaskDelayUntil+0x56>
#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    1c36:	20 e0       	ldi	r18, 0x00	; 0
    1c38:	07 c0       	rjmp	.+14     	; 0x1c48 <vTaskDelayUntil+0x58>
    1c3a:	20 e0       	ldi	r18, 0x00	; 0
    1c3c:	05 c0       	rjmp	.+10     	; 0x1c48 <vTaskDelayUntil+0x58>
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
				{
					xShouldDelay = pdTRUE;
    1c3e:	21 e0       	ldi	r18, 0x01	; 1
    1c40:	03 c0       	rjmp	.+6      	; 0x1c48 <vTaskDelayUntil+0x58>
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
				{
					xShouldDelay = pdTRUE;
    1c42:	21 e0       	ldi	r18, 0x01	; 1
    1c44:	01 c0       	rjmp	.+2      	; 0x1c48 <vTaskDelayUntil+0x58>
    1c46:	21 e0       	ldi	r18, 0x01	; 1
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    1c48:	f8 01       	movw	r30, r16
    1c4a:	91 83       	std	Z+1, r25	; 0x01
    1c4c:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    1c4e:	22 23       	and	r18, r18
    1c50:	29 f0       	breq	.+10     	; 0x1c5c <vTaskDelayUntil+0x6c>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    1c52:	60 e0       	ldi	r22, 0x00	; 0
    1c54:	84 1b       	sub	r24, r20
    1c56:	95 0b       	sbc	r25, r21
    1c58:	0e 94 db 0b 	call	0x17b6	; 0x17b6 <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    1c5c:	0e 94 86 0d 	call	0x1b0c	; 0x1b0c <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1c60:	81 11       	cpse	r24, r1
    1c62:	02 c0       	rjmp	.+4      	; 0x1c68 <vTaskDelayUntil+0x78>
		{
			portYIELD_WITHIN_API();
    1c64:	0e 94 42 05 	call	0xa84	; 0xa84 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    1c68:	df 91       	pop	r29
    1c6a:	cf 91       	pop	r28
    1c6c:	1f 91       	pop	r17
    1c6e:	0f 91       	pop	r16
    1c70:	08 95       	ret

00001c72 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    1c72:	cf 93       	push	r28
    1c74:	df 93       	push	r29
    1c76:	ec 01       	movw	r28, r24
	BaseType_t xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    1c78:	89 2b       	or	r24, r25
    1c7a:	49 f0       	breq	.+18     	; 0x1c8e <vTaskDelay+0x1c>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    1c7c:	0e 94 ac 0c 	call	0x1958	; 0x1958 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    1c80:	60 e0       	ldi	r22, 0x00	; 0
    1c82:	ce 01       	movw	r24, r28
    1c84:	0e 94 db 0b 	call	0x17b6	; 0x17b6 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    1c88:	0e 94 86 0d 	call	0x1b0c	; 0x1b0c <xTaskResumeAll>
    1c8c:	01 c0       	rjmp	.+2      	; 0x1c90 <vTaskDelay+0x1e>

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
	BaseType_t xAlreadyYielded = pdFALSE;
    1c8e:	80 e0       	ldi	r24, 0x00	; 0
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1c90:	81 11       	cpse	r24, r1
    1c92:	02 c0       	rjmp	.+4      	; 0x1c98 <vTaskDelay+0x26>
		{
			portYIELD_WITHIN_API();
    1c94:	0e 94 42 05 	call	0xa84	; 0xa84 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    1c98:	df 91       	pop	r29
    1c9a:	cf 91       	pop	r28
    1c9c:	08 95       	ret

00001c9e <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    1c9e:	80 91 5c 0d 	lds	r24, 0x0D5C	; 0x800d5c <uxSchedulerSuspended>
    1ca2:	88 23       	and	r24, r24
    1ca4:	21 f0       	breq	.+8      	; 0x1cae <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    1ca6:	81 e0       	ldi	r24, 0x01	; 1
    1ca8:	80 93 63 0d 	sts	0x0D63, r24	; 0x800d63 <xYieldPending>
    1cac:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
    1cae:	10 92 63 0d 	sts	0x0D63, r1	; 0x800d63 <xYieldPending>
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    1cb2:	20 91 66 0d 	lds	r18, 0x0D66	; 0x800d66 <uxTopReadyPriority>
    1cb6:	01 c0       	rjmp	.+2      	; 0x1cba <vTaskSwitchContext+0x1c>
    1cb8:	21 50       	subi	r18, 0x01	; 1
    1cba:	82 2f       	mov	r24, r18
    1cbc:	90 e0       	ldi	r25, 0x00	; 0
    1cbe:	fc 01       	movw	r30, r24
    1cc0:	ee 0f       	add	r30, r30
    1cc2:	ff 1f       	adc	r31, r31
    1cc4:	ee 0f       	add	r30, r30
    1cc6:	ff 1f       	adc	r31, r31
    1cc8:	ee 0f       	add	r30, r30
    1cca:	ff 1f       	adc	r31, r31
    1ccc:	e8 0f       	add	r30, r24
    1cce:	f9 1f       	adc	r31, r25
    1cd0:	e7 57       	subi	r30, 0x77	; 119
    1cd2:	f2 4f       	sbci	r31, 0xF2	; 242
    1cd4:	30 81       	ld	r19, Z
    1cd6:	33 23       	and	r19, r19
    1cd8:	79 f3       	breq	.-34     	; 0x1cb8 <vTaskSwitchContext+0x1a>
    1cda:	ac 01       	movw	r20, r24
    1cdc:	44 0f       	add	r20, r20
    1cde:	55 1f       	adc	r21, r21
    1ce0:	44 0f       	add	r20, r20
    1ce2:	55 1f       	adc	r21, r21
    1ce4:	44 0f       	add	r20, r20
    1ce6:	55 1f       	adc	r21, r21
    1ce8:	48 0f       	add	r20, r24
    1cea:	59 1f       	adc	r21, r25
    1cec:	df 01       	movw	r26, r30
    1cee:	01 80       	ldd	r0, Z+1	; 0x01
    1cf0:	f2 81       	ldd	r31, Z+2	; 0x02
    1cf2:	e0 2d       	mov	r30, r0
    1cf4:	02 80       	ldd	r0, Z+2	; 0x02
    1cf6:	f3 81       	ldd	r31, Z+3	; 0x03
    1cf8:	e0 2d       	mov	r30, r0
    1cfa:	12 96       	adiw	r26, 0x02	; 2
    1cfc:	fc 93       	st	X, r31
    1cfe:	ee 93       	st	-X, r30
    1d00:	11 97       	sbiw	r26, 0x01	; 1
    1d02:	44 57       	subi	r20, 0x74	; 116
    1d04:	52 4f       	sbci	r21, 0xF2	; 242
    1d06:	e4 17       	cp	r30, r20
    1d08:	f5 07       	cpc	r31, r21
    1d0a:	29 f4       	brne	.+10     	; 0x1d16 <vTaskSwitchContext+0x78>
    1d0c:	42 81       	ldd	r20, Z+2	; 0x02
    1d0e:	53 81       	ldd	r21, Z+3	; 0x03
    1d10:	fd 01       	movw	r30, r26
    1d12:	52 83       	std	Z+2, r21	; 0x02
    1d14:	41 83       	std	Z+1, r20	; 0x01
    1d16:	fc 01       	movw	r30, r24
    1d18:	ee 0f       	add	r30, r30
    1d1a:	ff 1f       	adc	r31, r31
    1d1c:	ee 0f       	add	r30, r30
    1d1e:	ff 1f       	adc	r31, r31
    1d20:	ee 0f       	add	r30, r30
    1d22:	ff 1f       	adc	r31, r31
    1d24:	8e 0f       	add	r24, r30
    1d26:	9f 1f       	adc	r25, r31
    1d28:	fc 01       	movw	r30, r24
    1d2a:	e7 57       	subi	r30, 0x77	; 119
    1d2c:	f2 4f       	sbci	r31, 0xF2	; 242
    1d2e:	01 80       	ldd	r0, Z+1	; 0x01
    1d30:	f2 81       	ldd	r31, Z+2	; 0x02
    1d32:	e0 2d       	mov	r30, r0
    1d34:	86 81       	ldd	r24, Z+6	; 0x06
    1d36:	97 81       	ldd	r25, Z+7	; 0x07
    1d38:	90 93 ae 0d 	sts	0x0DAE, r25	; 0x800dae <pxCurrentTCB+0x1>
    1d3c:	80 93 ad 0d 	sts	0x0DAD, r24	; 0x800dad <pxCurrentTCB>
    1d40:	20 93 66 0d 	sts	0x0D66, r18	; 0x800d66 <uxTopReadyPriority>
    1d44:	08 95       	ret

00001d46 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    1d46:	cf 93       	push	r28
    1d48:	df 93       	push	r29
    1d4a:	eb 01       	movw	r28, r22

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    1d4c:	60 91 ad 0d 	lds	r22, 0x0DAD	; 0x800dad <pxCurrentTCB>
    1d50:	70 91 ae 0d 	lds	r23, 0x0DAE	; 0x800dae <pxCurrentTCB+0x1>
    1d54:	64 5f       	subi	r22, 0xF4	; 244
    1d56:	7f 4f       	sbci	r23, 0xFF	; 255
    1d58:	0e 94 45 04 	call	0x88a	; 0x88a <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    1d5c:	61 e0       	ldi	r22, 0x01	; 1
    1d5e:	ce 01       	movw	r24, r28
    1d60:	0e 94 db 0b 	call	0x17b6	; 0x17b6 <prvAddCurrentTaskToDelayedList>
}
    1d64:	df 91       	pop	r29
    1d66:	cf 91       	pop	r28
    1d68:	08 95       	ret

00001d6a <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    1d6a:	cf 93       	push	r28
    1d6c:	df 93       	push	r29
    1d6e:	ea 01       	movw	r28, r20
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    1d70:	e0 91 ad 0d 	lds	r30, 0x0DAD	; 0x800dad <pxCurrentTCB>
    1d74:	f0 91 ae 0d 	lds	r31, 0x0DAE	; 0x800dae <pxCurrentTCB+0x1>
    1d78:	70 68       	ori	r23, 0x80	; 128
    1d7a:	75 87       	std	Z+13, r23	; 0x0d
    1d7c:	64 87       	std	Z+12, r22	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    1d7e:	60 91 ad 0d 	lds	r22, 0x0DAD	; 0x800dad <pxCurrentTCB>
    1d82:	70 91 ae 0d 	lds	r23, 0x0DAE	; 0x800dae <pxCurrentTCB+0x1>
    1d86:	64 5f       	subi	r22, 0xF4	; 244
    1d88:	7f 4f       	sbci	r23, 0xFF	; 255
    1d8a:	0e 94 24 04 	call	0x848	; 0x848 <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    1d8e:	61 e0       	ldi	r22, 0x01	; 1
    1d90:	ce 01       	movw	r24, r28
    1d92:	0e 94 db 0b 	call	0x17b6	; 0x17b6 <prvAddCurrentTaskToDelayedList>
}
    1d96:	df 91       	pop	r29
    1d98:	cf 91       	pop	r28
    1d9a:	08 95       	ret

00001d9c <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    1d9c:	0f 93       	push	r16
    1d9e:	1f 93       	push	r17
    1da0:	cf 93       	push	r28
    1da2:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1da4:	dc 01       	movw	r26, r24
    1da6:	15 96       	adiw	r26, 0x05	; 5
    1da8:	ed 91       	ld	r30, X+
    1daa:	fc 91       	ld	r31, X
    1dac:	16 97       	sbiw	r26, 0x06	; 6
    1dae:	c6 81       	ldd	r28, Z+6	; 0x06
    1db0:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    1db2:	8e 01       	movw	r16, r28
    1db4:	04 5f       	subi	r16, 0xF4	; 244
    1db6:	1f 4f       	sbci	r17, 0xFF	; 255
    1db8:	c8 01       	movw	r24, r16
    1dba:	0e 94 76 04 	call	0x8ec	; 0x8ec <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1dbe:	80 91 5c 0d 	lds	r24, 0x0D5C	; 0x800d5c <uxSchedulerSuspended>
    1dc2:	81 11       	cpse	r24, r1
    1dc4:	1c c0       	rjmp	.+56     	; 0x1dfe <xTaskRemoveFromEventList+0x62>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    1dc6:	0a 50       	subi	r16, 0x0A	; 10
    1dc8:	11 09       	sbc	r17, r1
    1dca:	c8 01       	movw	r24, r16
    1dcc:	0e 94 76 04 	call	0x8ec	; 0x8ec <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    1dd0:	8e 89       	ldd	r24, Y+22	; 0x16
    1dd2:	90 91 66 0d 	lds	r25, 0x0D66	; 0x800d66 <uxTopReadyPriority>
    1dd6:	98 17       	cp	r25, r24
    1dd8:	10 f4       	brcc	.+4      	; 0x1dde <xTaskRemoveFromEventList+0x42>
    1dda:	80 93 66 0d 	sts	0x0D66, r24	; 0x800d66 <uxTopReadyPriority>
    1dde:	90 e0       	ldi	r25, 0x00	; 0
    1de0:	9c 01       	movw	r18, r24
    1de2:	22 0f       	add	r18, r18
    1de4:	33 1f       	adc	r19, r19
    1de6:	22 0f       	add	r18, r18
    1de8:	33 1f       	adc	r19, r19
    1dea:	22 0f       	add	r18, r18
    1dec:	33 1f       	adc	r19, r19
    1dee:	82 0f       	add	r24, r18
    1df0:	93 1f       	adc	r25, r19
    1df2:	b8 01       	movw	r22, r16
    1df4:	87 57       	subi	r24, 0x77	; 119
    1df6:	92 4f       	sbci	r25, 0xF2	; 242
    1df8:	0e 94 24 04 	call	0x848	; 0x848 <vListInsertEnd>
    1dfc:	05 c0       	rjmp	.+10     	; 0x1e08 <xTaskRemoveFromEventList+0x6c>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    1dfe:	b8 01       	movw	r22, r16
    1e00:	8a e6       	ldi	r24, 0x6A	; 106
    1e02:	9d e0       	ldi	r25, 0x0D	; 13
    1e04:	0e 94 24 04 	call	0x848	; 0x848 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    1e08:	9e 89       	ldd	r25, Y+22	; 0x16
    1e0a:	e0 91 ad 0d 	lds	r30, 0x0DAD	; 0x800dad <pxCurrentTCB>
    1e0e:	f0 91 ae 0d 	lds	r31, 0x0DAE	; 0x800dae <pxCurrentTCB+0x1>
    1e12:	86 89       	ldd	r24, Z+22	; 0x16
    1e14:	89 17       	cp	r24, r25
    1e16:	20 f4       	brcc	.+8      	; 0x1e20 <xTaskRemoveFromEventList+0x84>
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    1e18:	81 e0       	ldi	r24, 0x01	; 1
    1e1a:	80 93 63 0d 	sts	0x0D63, r24	; 0x800d63 <xYieldPending>
    1e1e:	01 c0       	rjmp	.+2      	; 0x1e22 <xTaskRemoveFromEventList+0x86>
	}
	else
	{
		xReturn = pdFALSE;
    1e20:	80 e0       	ldi	r24, 0x00	; 0
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
}
    1e22:	df 91       	pop	r29
    1e24:	cf 91       	pop	r28
    1e26:	1f 91       	pop	r17
    1e28:	0f 91       	pop	r16
    1e2a:	08 95       	ret

00001e2c <xTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    1e2c:	0f 93       	push	r16
    1e2e:	1f 93       	push	r17
    1e30:	cf 93       	push	r28
    1e32:	df 93       	push	r29
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    1e34:	70 68       	ori	r23, 0x80	; 128
    1e36:	fc 01       	movw	r30, r24
    1e38:	71 83       	std	Z+1, r23	; 0x01
    1e3a:	60 83       	st	Z, r22

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
    1e3c:	c6 81       	ldd	r28, Z+6	; 0x06
    1e3e:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    1e40:	0e 94 76 04 	call	0x8ec	; 0x8ec <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    1e44:	8e 01       	movw	r16, r28
    1e46:	0e 5f       	subi	r16, 0xFE	; 254
    1e48:	1f 4f       	sbci	r17, 0xFF	; 255
    1e4a:	c8 01       	movw	r24, r16
    1e4c:	0e 94 76 04 	call	0x8ec	; 0x8ec <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    1e50:	8e 89       	ldd	r24, Y+22	; 0x16
    1e52:	90 91 66 0d 	lds	r25, 0x0D66	; 0x800d66 <uxTopReadyPriority>
    1e56:	98 17       	cp	r25, r24
    1e58:	10 f4       	brcc	.+4      	; 0x1e5e <xTaskRemoveFromUnorderedEventList+0x32>
    1e5a:	80 93 66 0d 	sts	0x0D66, r24	; 0x800d66 <uxTopReadyPriority>
    1e5e:	90 e0       	ldi	r25, 0x00	; 0
    1e60:	9c 01       	movw	r18, r24
    1e62:	22 0f       	add	r18, r18
    1e64:	33 1f       	adc	r19, r19
    1e66:	22 0f       	add	r18, r18
    1e68:	33 1f       	adc	r19, r19
    1e6a:	22 0f       	add	r18, r18
    1e6c:	33 1f       	adc	r19, r19
    1e6e:	82 0f       	add	r24, r18
    1e70:	93 1f       	adc	r25, r19
    1e72:	b8 01       	movw	r22, r16
    1e74:	87 57       	subi	r24, 0x77	; 119
    1e76:	92 4f       	sbci	r25, 0xF2	; 242
    1e78:	0e 94 24 04 	call	0x848	; 0x848 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    1e7c:	9e 89       	ldd	r25, Y+22	; 0x16
    1e7e:	e0 91 ad 0d 	lds	r30, 0x0DAD	; 0x800dad <pxCurrentTCB>
    1e82:	f0 91 ae 0d 	lds	r31, 0x0DAE	; 0x800dae <pxCurrentTCB+0x1>
    1e86:	86 89       	ldd	r24, Z+22	; 0x16
    1e88:	89 17       	cp	r24, r25
    1e8a:	20 f4       	brcc	.+8      	; 0x1e94 <xTaskRemoveFromUnorderedEventList+0x68>
		switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    1e8c:	81 e0       	ldi	r24, 0x01	; 1
    1e8e:	80 93 63 0d 	sts	0x0D63, r24	; 0x800d63 <xYieldPending>
    1e92:	01 c0       	rjmp	.+2      	; 0x1e96 <xTaskRemoveFromUnorderedEventList+0x6a>
	}
	else
	{
		xReturn = pdFALSE;
    1e94:	80 e0       	ldi	r24, 0x00	; 0
	}

	return xReturn;
}
    1e96:	df 91       	pop	r29
    1e98:	cf 91       	pop	r28
    1e9a:	1f 91       	pop	r17
    1e9c:	0f 91       	pop	r16
    1e9e:	08 95       	ret

00001ea0 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    1ea0:	20 91 62 0d 	lds	r18, 0x0D62	; 0x800d62 <xNumOfOverflows>
    1ea4:	fc 01       	movw	r30, r24
    1ea6:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    1ea8:	20 91 67 0d 	lds	r18, 0x0D67	; 0x800d67 <xTickCount>
    1eac:	30 91 68 0d 	lds	r19, 0x0D68	; 0x800d68 <xTickCount+0x1>
    1eb0:	32 83       	std	Z+2, r19	; 0x02
    1eb2:	21 83       	std	Z+1, r18	; 0x01
    1eb4:	08 95       	ret

00001eb6 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    1eb6:	cf 93       	push	r28
    1eb8:	df 93       	push	r29
    1eba:	fc 01       	movw	r30, r24
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    1ebc:	0f b6       	in	r0, 0x3f	; 63
    1ebe:	f8 94       	cli
    1ec0:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    1ec2:	40 91 67 0d 	lds	r20, 0x0D67	; 0x800d67 <xTickCount>
    1ec6:	50 91 68 0d 	lds	r21, 0x0D68	; 0x800d68 <xTickCount+0x1>
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    1eca:	90 81       	ld	r25, Z
    1ecc:	80 91 62 0d 	lds	r24, 0x0D62	; 0x800d62 <xNumOfOverflows>
    1ed0:	98 17       	cp	r25, r24
    1ed2:	29 f0       	breq	.+10     	; 0x1ede <xTaskCheckForTimeOut+0x28>
    1ed4:	81 81       	ldd	r24, Z+1	; 0x01
    1ed6:	92 81       	ldd	r25, Z+2	; 0x02
    1ed8:	48 17       	cp	r20, r24
    1eda:	59 07       	cpc	r21, r25
    1edc:	b0 f4       	brcc	.+44     	; 0x1f0a <xTaskCheckForTimeOut+0x54>
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    1ede:	21 81       	ldd	r18, Z+1	; 0x01
    1ee0:	32 81       	ldd	r19, Z+2	; 0x02
    1ee2:	ca 01       	movw	r24, r20
    1ee4:	82 1b       	sub	r24, r18
    1ee6:	93 0b       	sbc	r25, r19
    1ee8:	eb 01       	movw	r28, r22
    1eea:	a8 81       	ld	r26, Y
    1eec:	b9 81       	ldd	r27, Y+1	; 0x01
    1eee:	8a 17       	cp	r24, r26
    1ef0:	9b 07       	cpc	r25, r27
    1ef2:	68 f4       	brcc	.+26     	; 0x1f0e <xTaskCheckForTimeOut+0x58>
    1ef4:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
    1ef6:	24 1b       	sub	r18, r20
    1ef8:	35 0b       	sbc	r19, r21
    1efa:	2a 0f       	add	r18, r26
    1efc:	3b 1f       	adc	r19, r27
    1efe:	39 83       	std	Y+1, r19	; 0x01
    1f00:	28 83       	st	Y, r18
			vTaskSetTimeOutState( pxTimeOut );
    1f02:	0e 94 50 0f 	call	0x1ea0	; 0x1ea0 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    1f06:	80 e0       	ldi	r24, 0x00	; 0
    1f08:	03 c0       	rjmp	.+6      	; 0x1f10 <xTaskCheckForTimeOut+0x5a>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    1f0a:	81 e0       	ldi	r24, 0x01	; 1
    1f0c:	01 c0       	rjmp	.+2      	; 0x1f10 <xTaskCheckForTimeOut+0x5a>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    1f0e:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    1f10:	0f 90       	pop	r0
    1f12:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    1f14:	df 91       	pop	r29
    1f16:	cf 91       	pop	r28
    1f18:	08 95       	ret

00001f1a <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    1f1a:	81 e0       	ldi	r24, 0x01	; 1
    1f1c:	80 93 63 0d 	sts	0x0D63, r24	; 0x800d63 <xYieldPending>
    1f20:	08 95       	ret

00001f22 <xTaskGetCurrentTaskHandle>:
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    1f22:	80 91 ad 0d 	lds	r24, 0x0DAD	; 0x800dad <pxCurrentTCB>
    1f26:	90 91 ae 0d 	lds	r25, 0x0DAE	; 0x800dae <pxCurrentTCB+0x1>

		return xReturn;
	}
    1f2a:	08 95       	ret

00001f2c <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
    1f2c:	0f 93       	push	r16
    1f2e:	1f 93       	push	r17
    1f30:	cf 93       	push	r28
    1f32:	df 93       	push	r29
    1f34:	fc 01       	movw	r30, r24
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
    1f36:	89 2b       	or	r24, r25
    1f38:	09 f4       	brne	.+2      	; 0x1f3c <vTaskPriorityInherit+0x10>
    1f3a:	55 c0       	rjmp	.+170    	; 0x1fe6 <vTaskPriorityInherit+0xba>
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    1f3c:	26 89       	ldd	r18, Z+22	; 0x16
    1f3e:	a0 91 ad 0d 	lds	r26, 0x0DAD	; 0x800dad <pxCurrentTCB>
    1f42:	b0 91 ae 0d 	lds	r27, 0x0DAE	; 0x800dae <pxCurrentTCB+0x1>
    1f46:	56 96       	adiw	r26, 0x16	; 22
    1f48:	8c 91       	ld	r24, X
    1f4a:	28 17       	cp	r18, r24
    1f4c:	08 f0       	brcs	.+2      	; 0x1f50 <vTaskPriorityInherit+0x24>
    1f4e:	4b c0       	rjmp	.+150    	; 0x1fe6 <vTaskPriorityInherit+0xba>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not	being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    1f50:	84 85       	ldd	r24, Z+12	; 0x0c
    1f52:	95 85       	ldd	r25, Z+13	; 0x0d
    1f54:	99 23       	and	r25, r25
    1f56:	64 f0       	brlt	.+24     	; 0x1f70 <vTaskPriorityInherit+0x44>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1f58:	a0 91 ad 0d 	lds	r26, 0x0DAD	; 0x800dad <pxCurrentTCB>
    1f5c:	b0 91 ae 0d 	lds	r27, 0x0DAE	; 0x800dae <pxCurrentTCB+0x1>
    1f60:	56 96       	adiw	r26, 0x16	; 22
    1f62:	3c 91       	ld	r19, X
    1f64:	84 e0       	ldi	r24, 0x04	; 4
    1f66:	90 e0       	ldi	r25, 0x00	; 0
    1f68:	83 1b       	sub	r24, r19
    1f6a:	91 09       	sbc	r25, r1
    1f6c:	95 87       	std	Z+13, r25	; 0x0d
    1f6e:	84 87       	std	Z+12, r24	; 0x0c
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
    1f70:	82 85       	ldd	r24, Z+10	; 0x0a
    1f72:	93 85       	ldd	r25, Z+11	; 0x0b
    1f74:	30 e0       	ldi	r19, 0x00	; 0
    1f76:	a9 01       	movw	r20, r18
    1f78:	44 0f       	add	r20, r20
    1f7a:	55 1f       	adc	r21, r21
    1f7c:	44 0f       	add	r20, r20
    1f7e:	55 1f       	adc	r21, r21
    1f80:	44 0f       	add	r20, r20
    1f82:	55 1f       	adc	r21, r21
    1f84:	24 0f       	add	r18, r20
    1f86:	35 1f       	adc	r19, r21
    1f88:	27 57       	subi	r18, 0x77	; 119
    1f8a:	32 4f       	sbci	r19, 0xF2	; 242
    1f8c:	82 17       	cp	r24, r18
    1f8e:	93 07       	cpc	r25, r19
    1f90:	19 f5       	brne	.+70     	; 0x1fd8 <vTaskPriorityInherit+0xac>
    1f92:	8f 01       	movw	r16, r30
				{
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    1f94:	ef 01       	movw	r28, r30
    1f96:	22 96       	adiw	r28, 0x02	; 2
    1f98:	ce 01       	movw	r24, r28
    1f9a:	0e 94 76 04 	call	0x8ec	; 0x8ec <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    1f9e:	e0 91 ad 0d 	lds	r30, 0x0DAD	; 0x800dad <pxCurrentTCB>
    1fa2:	f0 91 ae 0d 	lds	r31, 0x0DAE	; 0x800dae <pxCurrentTCB+0x1>
    1fa6:	86 89       	ldd	r24, Z+22	; 0x16
    1fa8:	f8 01       	movw	r30, r16
    1faa:	86 8b       	std	Z+22, r24	; 0x16
					prvAddTaskToReadyList( pxTCB );
    1fac:	90 91 66 0d 	lds	r25, 0x0D66	; 0x800d66 <uxTopReadyPriority>
    1fb0:	98 17       	cp	r25, r24
    1fb2:	10 f4       	brcc	.+4      	; 0x1fb8 <vTaskPriorityInherit+0x8c>
    1fb4:	80 93 66 0d 	sts	0x0D66, r24	; 0x800d66 <uxTopReadyPriority>
    1fb8:	90 e0       	ldi	r25, 0x00	; 0
    1fba:	9c 01       	movw	r18, r24
    1fbc:	22 0f       	add	r18, r18
    1fbe:	33 1f       	adc	r19, r19
    1fc0:	22 0f       	add	r18, r18
    1fc2:	33 1f       	adc	r19, r19
    1fc4:	22 0f       	add	r18, r18
    1fc6:	33 1f       	adc	r19, r19
    1fc8:	82 0f       	add	r24, r18
    1fca:	93 1f       	adc	r25, r19
    1fcc:	be 01       	movw	r22, r28
    1fce:	87 57       	subi	r24, 0x77	; 119
    1fd0:	92 4f       	sbci	r25, 0xF2	; 242
    1fd2:	0e 94 24 04 	call	0x848	; 0x848 <vListInsertEnd>
    1fd6:	07 c0       	rjmp	.+14     	; 0x1fe6 <vTaskPriorityInherit+0xba>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    1fd8:	a0 91 ad 0d 	lds	r26, 0x0DAD	; 0x800dad <pxCurrentTCB>
    1fdc:	b0 91 ae 0d 	lds	r27, 0x0DAE	; 0x800dae <pxCurrentTCB+0x1>
    1fe0:	56 96       	adiw	r26, 0x16	; 22
    1fe2:	8c 91       	ld	r24, X
    1fe4:	86 8b       	std	Z+22, r24	; 0x16
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    1fe6:	df 91       	pop	r29
    1fe8:	cf 91       	pop	r28
    1fea:	1f 91       	pop	r17
    1fec:	0f 91       	pop	r16
    1fee:	08 95       	ret

00001ff0 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    1ff0:	0f 93       	push	r16
    1ff2:	1f 93       	push	r17
    1ff4:	cf 93       	push	r28
    1ff6:	df 93       	push	r29
    1ff8:	fc 01       	movw	r30, r24
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;

		if( pxMutexHolder != NULL )
    1ffa:	89 2b       	or	r24, r25
    1ffc:	79 f1       	breq	.+94     	; 0x205c <xTaskPriorityDisinherit+0x6c>
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );

			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
    1ffe:	82 a1       	ldd	r24, Z+34	; 0x22
    2000:	81 50       	subi	r24, 0x01	; 1
    2002:	82 a3       	std	Z+34, r24	; 0x22

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    2004:	26 89       	ldd	r18, Z+22	; 0x16
    2006:	91 a1       	ldd	r25, Z+33	; 0x21
    2008:	29 17       	cp	r18, r25
    200a:	51 f1       	breq	.+84     	; 0x2060 <xTaskPriorityDisinherit+0x70>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    200c:	81 11       	cpse	r24, r1
    200e:	2a c0       	rjmp	.+84     	; 0x2064 <xTaskPriorityDisinherit+0x74>
    2010:	ef 01       	movw	r28, r30
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding	task then it must be the running state task.  Remove
					the	holding task from the ready	list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    2012:	8f 01       	movw	r16, r30
    2014:	0e 5f       	subi	r16, 0xFE	; 254
    2016:	1f 4f       	sbci	r17, 0xFF	; 255
    2018:	c8 01       	movw	r24, r16
    201a:	0e 94 76 04 	call	0x8ec	; 0x8ec <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    201e:	89 a1       	ldd	r24, Y+33	; 0x21
    2020:	8e 8b       	std	Y+22, r24	; 0x16

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2022:	24 e0       	ldi	r18, 0x04	; 4
    2024:	30 e0       	ldi	r19, 0x00	; 0
    2026:	28 1b       	sub	r18, r24
    2028:	31 09       	sbc	r19, r1
    202a:	3d 87       	std	Y+13, r19	; 0x0d
    202c:	2c 87       	std	Y+12, r18	; 0x0c
					prvAddTaskToReadyList( pxTCB );
    202e:	90 91 66 0d 	lds	r25, 0x0D66	; 0x800d66 <uxTopReadyPriority>
    2032:	98 17       	cp	r25, r24
    2034:	10 f4       	brcc	.+4      	; 0x203a <xTaskPriorityDisinherit+0x4a>
    2036:	80 93 66 0d 	sts	0x0D66, r24	; 0x800d66 <uxTopReadyPriority>
    203a:	90 e0       	ldi	r25, 0x00	; 0
    203c:	9c 01       	movw	r18, r24
    203e:	22 0f       	add	r18, r18
    2040:	33 1f       	adc	r19, r19
    2042:	22 0f       	add	r18, r18
    2044:	33 1f       	adc	r19, r19
    2046:	22 0f       	add	r18, r18
    2048:	33 1f       	adc	r19, r19
    204a:	82 0f       	add	r24, r18
    204c:	93 1f       	adc	r25, r19
    204e:	b8 01       	movw	r22, r16
    2050:	87 57       	subi	r24, 0x77	; 119
    2052:	92 4f       	sbci	r25, 0xF2	; 242
    2054:	0e 94 24 04 	call	0x848	; 0x848 <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
    2058:	81 e0       	ldi	r24, 0x01	; 1
    205a:	05 c0       	rjmp	.+10     	; 0x2066 <xTaskPriorityDisinherit+0x76>
#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;
    205c:	80 e0       	ldi	r24, 0x00	; 0
    205e:	03 c0       	rjmp	.+6      	; 0x2066 <xTaskPriorityDisinherit+0x76>
    2060:	80 e0       	ldi	r24, 0x00	; 0
    2062:	01 c0       	rjmp	.+2      	; 0x2066 <xTaskPriorityDisinherit+0x76>
    2064:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
    2066:	df 91       	pop	r29
    2068:	cf 91       	pop	r28
    206a:	1f 91       	pop	r17
    206c:	0f 91       	pop	r16
    206e:	08 95       	ret

00002070 <uxTaskResetEventItemValue>:

TickType_t uxTaskResetEventItemValue( void )
{
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    2070:	e0 91 ad 0d 	lds	r30, 0x0DAD	; 0x800dad <pxCurrentTCB>
    2074:	f0 91 ae 0d 	lds	r31, 0x0DAE	; 0x800dae <pxCurrentTCB+0x1>
    2078:	84 85       	ldd	r24, Z+12	; 0x0c
    207a:	95 85       	ldd	r25, Z+13	; 0x0d

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    207c:	e0 91 ad 0d 	lds	r30, 0x0DAD	; 0x800dad <pxCurrentTCB>
    2080:	f0 91 ae 0d 	lds	r31, 0x0DAE	; 0x800dae <pxCurrentTCB+0x1>
    2084:	a0 91 ad 0d 	lds	r26, 0x0DAD	; 0x800dad <pxCurrentTCB>
    2088:	b0 91 ae 0d 	lds	r27, 0x0DAE	; 0x800dae <pxCurrentTCB+0x1>
    208c:	56 96       	adiw	r26, 0x16	; 22
    208e:	4c 91       	ld	r20, X
    2090:	24 e0       	ldi	r18, 0x04	; 4
    2092:	30 e0       	ldi	r19, 0x00	; 0
    2094:	24 1b       	sub	r18, r20
    2096:	31 09       	sbc	r19, r1
    2098:	35 87       	std	Z+13, r19	; 0x0d
    209a:	24 87       	std	Z+12, r18	; 0x0c

	return uxReturn;
}
    209c:	08 95       	ret

0000209e <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    209e:	80 91 ad 0d 	lds	r24, 0x0DAD	; 0x800dad <pxCurrentTCB>
    20a2:	90 91 ae 0d 	lds	r25, 0x0DAE	; 0x800dae <pxCurrentTCB+0x1>
    20a6:	89 2b       	or	r24, r25
    20a8:	39 f0       	breq	.+14     	; 0x20b8 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    20aa:	e0 91 ad 0d 	lds	r30, 0x0DAD	; 0x800dad <pxCurrentTCB>
    20ae:	f0 91 ae 0d 	lds	r31, 0x0DAE	; 0x800dae <pxCurrentTCB+0x1>
    20b2:	82 a1       	ldd	r24, Z+34	; 0x22
    20b4:	8f 5f       	subi	r24, 0xFF	; 255
    20b6:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    20b8:	80 91 ad 0d 	lds	r24, 0x0DAD	; 0x800dad <pxCurrentTCB>
    20bc:	90 91 ae 0d 	lds	r25, 0x0DAE	; 0x800dae <pxCurrentTCB+0x1>
	}
    20c0:	08 95       	ret

000020c2 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    20c2:	0f 93       	push	r16
    20c4:	1f 93       	push	r17
    20c6:	cf 93       	push	r28
    20c8:	c8 2f       	mov	r28, r24
    20ca:	cb 01       	movw	r24, r22
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    20cc:	0f b6       	in	r0, 0x3f	; 63
    20ce:	f8 94       	cli
    20d0:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    20d2:	e0 91 ad 0d 	lds	r30, 0x0DAD	; 0x800dad <pxCurrentTCB>
    20d6:	f0 91 ae 0d 	lds	r31, 0x0DAE	; 0x800dae <pxCurrentTCB+0x1>
    20da:	43 a1       	ldd	r20, Z+35	; 0x23
    20dc:	54 a1       	ldd	r21, Z+36	; 0x24
    20de:	65 a1       	ldd	r22, Z+37	; 0x25
    20e0:	76 a1       	ldd	r23, Z+38	; 0x26
    20e2:	45 2b       	or	r20, r21
    20e4:	46 2b       	or	r20, r22
    20e6:	47 2b       	or	r20, r23
    20e8:	69 f4       	brne	.+26     	; 0x2104 <ulTaskNotifyTake+0x42>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    20ea:	e0 91 ad 0d 	lds	r30, 0x0DAD	; 0x800dad <pxCurrentTCB>
    20ee:	f0 91 ae 0d 	lds	r31, 0x0DAE	; 0x800dae <pxCurrentTCB+0x1>
    20f2:	21 e0       	ldi	r18, 0x01	; 1
    20f4:	27 a3       	std	Z+39, r18	; 0x27

				if( xTicksToWait > ( TickType_t ) 0 )
    20f6:	00 97       	sbiw	r24, 0x00	; 0
    20f8:	29 f0       	breq	.+10     	; 0x2104 <ulTaskNotifyTake+0x42>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    20fa:	61 e0       	ldi	r22, 0x01	; 1
    20fc:	0e 94 db 0b 	call	0x17b6	; 0x17b6 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    2100:	0e 94 42 05 	call	0xa84	; 0xa84 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    2104:	0f 90       	pop	r0
    2106:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    2108:	0f b6       	in	r0, 0x3f	; 63
    210a:	f8 94       	cli
    210c:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    210e:	e0 91 ad 0d 	lds	r30, 0x0DAD	; 0x800dad <pxCurrentTCB>
    2112:	f0 91 ae 0d 	lds	r31, 0x0DAE	; 0x800dae <pxCurrentTCB+0x1>
    2116:	63 a1       	ldd	r22, Z+35	; 0x23
    2118:	74 a1       	ldd	r23, Z+36	; 0x24
    211a:	85 a1       	ldd	r24, Z+37	; 0x25
    211c:	96 a1       	ldd	r25, Z+38	; 0x26

			if( ulReturn != 0UL )
    211e:	61 15       	cp	r22, r1
    2120:	71 05       	cpc	r23, r1
    2122:	81 05       	cpc	r24, r1
    2124:	91 05       	cpc	r25, r1
    2126:	c9 f0       	breq	.+50     	; 0x215a <ulTaskNotifyTake+0x98>
			{
				if( xClearCountOnExit != pdFALSE )
    2128:	cc 23       	and	r28, r28
    212a:	49 f0       	breq	.+18     	; 0x213e <ulTaskNotifyTake+0x7c>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    212c:	e0 91 ad 0d 	lds	r30, 0x0DAD	; 0x800dad <pxCurrentTCB>
    2130:	f0 91 ae 0d 	lds	r31, 0x0DAE	; 0x800dae <pxCurrentTCB+0x1>
    2134:	13 a2       	std	Z+35, r1	; 0x23
    2136:	14 a2       	std	Z+36, r1	; 0x24
    2138:	15 a2       	std	Z+37, r1	; 0x25
    213a:	16 a2       	std	Z+38, r1	; 0x26
    213c:	0e c0       	rjmp	.+28     	; 0x215a <ulTaskNotifyTake+0x98>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - 1;
    213e:	e0 91 ad 0d 	lds	r30, 0x0DAD	; 0x800dad <pxCurrentTCB>
    2142:	f0 91 ae 0d 	lds	r31, 0x0DAE	; 0x800dae <pxCurrentTCB+0x1>
    2146:	8b 01       	movw	r16, r22
    2148:	9c 01       	movw	r18, r24
    214a:	01 50       	subi	r16, 0x01	; 1
    214c:	11 09       	sbc	r17, r1
    214e:	21 09       	sbc	r18, r1
    2150:	31 09       	sbc	r19, r1
    2152:	03 a3       	std	Z+35, r16	; 0x23
    2154:	14 a3       	std	Z+36, r17	; 0x24
    2156:	25 a3       	std	Z+37, r18	; 0x25
    2158:	36 a3       	std	Z+38, r19	; 0x26
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    215a:	e0 91 ad 0d 	lds	r30, 0x0DAD	; 0x800dad <pxCurrentTCB>
    215e:	f0 91 ae 0d 	lds	r31, 0x0DAE	; 0x800dae <pxCurrentTCB+0x1>
    2162:	17 a2       	std	Z+39, r1	; 0x27
		}
		taskEXIT_CRITICAL();
    2164:	0f 90       	pop	r0
    2166:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
	}
    2168:	cf 91       	pop	r28
    216a:	1f 91       	pop	r17
    216c:	0f 91       	pop	r16
    216e:	08 95       	ret

00002170 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    2170:	4f 92       	push	r4
    2172:	5f 92       	push	r5
    2174:	6f 92       	push	r6
    2176:	7f 92       	push	r7
    2178:	8f 92       	push	r8
    217a:	9f 92       	push	r9
    217c:	af 92       	push	r10
    217e:	bf 92       	push	r11
    2180:	ef 92       	push	r14
    2182:	ff 92       	push	r15
    2184:	0f 93       	push	r16
    2186:	1f 93       	push	r17
    2188:	49 01       	movw	r8, r18
    218a:	5a 01       	movw	r10, r20
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    218c:	0f b6       	in	r0, 0x3f	; 63
    218e:	f8 94       	cli
    2190:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    2192:	e0 91 ad 0d 	lds	r30, 0x0DAD	; 0x800dad <pxCurrentTCB>
    2196:	f0 91 ae 0d 	lds	r31, 0x0DAE	; 0x800dae <pxCurrentTCB+0x1>
    219a:	27 a1       	ldd	r18, Z+39	; 0x27
    219c:	22 30       	cpi	r18, 0x02	; 2
    219e:	29 f1       	breq	.+74     	; 0x21ea <xTaskNotifyWait+0x7a>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    21a0:	e0 91 ad 0d 	lds	r30, 0x0DAD	; 0x800dad <pxCurrentTCB>
    21a4:	f0 91 ae 0d 	lds	r31, 0x0DAE	; 0x800dae <pxCurrentTCB+0x1>
    21a8:	43 a0       	ldd	r4, Z+35	; 0x23
    21aa:	54 a0       	ldd	r5, Z+36	; 0x24
    21ac:	65 a0       	ldd	r6, Z+37	; 0x25
    21ae:	76 a0       	ldd	r7, Z+38	; 0x26
    21b0:	dc 01       	movw	r26, r24
    21b2:	cb 01       	movw	r24, r22
    21b4:	80 95       	com	r24
    21b6:	90 95       	com	r25
    21b8:	a0 95       	com	r26
    21ba:	b0 95       	com	r27
    21bc:	84 21       	and	r24, r4
    21be:	95 21       	and	r25, r5
    21c0:	a6 21       	and	r26, r6
    21c2:	b7 21       	and	r27, r7
    21c4:	83 a3       	std	Z+35, r24	; 0x23
    21c6:	94 a3       	std	Z+36, r25	; 0x24
    21c8:	a5 a3       	std	Z+37, r26	; 0x25
    21ca:	b6 a3       	std	Z+38, r27	; 0x26

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    21cc:	e0 91 ad 0d 	lds	r30, 0x0DAD	; 0x800dad <pxCurrentTCB>
    21d0:	f0 91 ae 0d 	lds	r31, 0x0DAE	; 0x800dae <pxCurrentTCB+0x1>
    21d4:	81 e0       	ldi	r24, 0x01	; 1
    21d6:	87 a3       	std	Z+39, r24	; 0x27

				if( xTicksToWait > ( TickType_t ) 0 )
    21d8:	e1 14       	cp	r14, r1
    21da:	f1 04       	cpc	r15, r1
    21dc:	31 f0       	breq	.+12     	; 0x21ea <xTaskNotifyWait+0x7a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    21de:	61 e0       	ldi	r22, 0x01	; 1
    21e0:	c7 01       	movw	r24, r14
    21e2:	0e 94 db 0b 	call	0x17b6	; 0x17b6 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    21e6:	0e 94 42 05 	call	0xa84	; 0xa84 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    21ea:	0f 90       	pop	r0
    21ec:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    21ee:	0f b6       	in	r0, 0x3f	; 63
    21f0:	f8 94       	cli
    21f2:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    21f4:	01 15       	cp	r16, r1
    21f6:	11 05       	cpc	r17, r1
    21f8:	69 f0       	breq	.+26     	; 0x2214 <xTaskNotifyWait+0xa4>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    21fa:	e0 91 ad 0d 	lds	r30, 0x0DAD	; 0x800dad <pxCurrentTCB>
    21fe:	f0 91 ae 0d 	lds	r31, 0x0DAE	; 0x800dae <pxCurrentTCB+0x1>
    2202:	83 a1       	ldd	r24, Z+35	; 0x23
    2204:	94 a1       	ldd	r25, Z+36	; 0x24
    2206:	a5 a1       	ldd	r26, Z+37	; 0x25
    2208:	b6 a1       	ldd	r27, Z+38	; 0x26
    220a:	f8 01       	movw	r30, r16
    220c:	80 83       	st	Z, r24
    220e:	91 83       	std	Z+1, r25	; 0x01
    2210:	a2 83       	std	Z+2, r26	; 0x02
    2212:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState == taskWAITING_NOTIFICATION )
    2214:	e0 91 ad 0d 	lds	r30, 0x0DAD	; 0x800dad <pxCurrentTCB>
    2218:	f0 91 ae 0d 	lds	r31, 0x0DAE	; 0x800dae <pxCurrentTCB+0x1>
    221c:	87 a1       	ldd	r24, Z+39	; 0x27
    221e:	81 30       	cpi	r24, 0x01	; 1
    2220:	b1 f0       	breq	.+44     	; 0x224e <xTaskNotifyWait+0xde>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    2222:	e0 91 ad 0d 	lds	r30, 0x0DAD	; 0x800dad <pxCurrentTCB>
    2226:	f0 91 ae 0d 	lds	r31, 0x0DAE	; 0x800dae <pxCurrentTCB+0x1>
    222a:	83 a1       	ldd	r24, Z+35	; 0x23
    222c:	94 a1       	ldd	r25, Z+36	; 0x24
    222e:	a5 a1       	ldd	r26, Z+37	; 0x25
    2230:	b6 a1       	ldd	r27, Z+38	; 0x26
    2232:	80 94       	com	r8
    2234:	90 94       	com	r9
    2236:	a0 94       	com	r10
    2238:	b0 94       	com	r11
    223a:	88 22       	and	r8, r24
    223c:	99 22       	and	r9, r25
    223e:	aa 22       	and	r10, r26
    2240:	bb 22       	and	r11, r27
    2242:	83 a2       	std	Z+35, r8	; 0x23
    2244:	94 a2       	std	Z+36, r9	; 0x24
    2246:	a5 a2       	std	Z+37, r10	; 0x25
    2248:	b6 a2       	std	Z+38, r11	; 0x26
				xReturn = pdTRUE;
    224a:	81 e0       	ldi	r24, 0x01	; 1
    224c:	01 c0       	rjmp	.+2      	; 0x2250 <xTaskNotifyWait+0xe0>
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState == taskWAITING_NOTIFICATION )
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    224e:	80 e0       	ldi	r24, 0x00	; 0
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
				xReturn = pdTRUE;
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    2250:	e0 91 ad 0d 	lds	r30, 0x0DAD	; 0x800dad <pxCurrentTCB>
    2254:	f0 91 ae 0d 	lds	r31, 0x0DAE	; 0x800dae <pxCurrentTCB+0x1>
    2258:	17 a2       	std	Z+39, r1	; 0x27
		}
		taskEXIT_CRITICAL();
    225a:	0f 90       	pop	r0
    225c:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    225e:	1f 91       	pop	r17
    2260:	0f 91       	pop	r16
    2262:	ff 90       	pop	r15
    2264:	ef 90       	pop	r14
    2266:	bf 90       	pop	r11
    2268:	af 90       	pop	r10
    226a:	9f 90       	pop	r9
    226c:	8f 90       	pop	r8
    226e:	7f 90       	pop	r7
    2270:	6f 90       	pop	r6
    2272:	5f 90       	pop	r5
    2274:	4f 90       	pop	r4
    2276:	08 95       	ret

00002278 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    2278:	ef 92       	push	r14
    227a:	ff 92       	push	r15
    227c:	0f 93       	push	r16
    227e:	1f 93       	push	r17
    2280:	cf 93       	push	r28
    2282:	df 93       	push	r29
    2284:	fc 01       	movw	r30, r24
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = ( TCB_t * ) xTaskToNotify;

		taskENTER_CRITICAL();
    2286:	0f b6       	in	r0, 0x3f	; 63
    2288:	f8 94       	cli
    228a:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    228c:	01 15       	cp	r16, r1
    228e:	11 05       	cpc	r17, r1
    2290:	49 f0       	breq	.+18     	; 0x22a4 <xTaskGenericNotify+0x2c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    2292:	83 a1       	ldd	r24, Z+35	; 0x23
    2294:	94 a1       	ldd	r25, Z+36	; 0x24
    2296:	a5 a1       	ldd	r26, Z+37	; 0x25
    2298:	b6 a1       	ldd	r27, Z+38	; 0x26
    229a:	e8 01       	movw	r28, r16
    229c:	88 83       	st	Y, r24
    229e:	99 83       	std	Y+1, r25	; 0x01
    22a0:	aa 83       	std	Y+2, r26	; 0x02
    22a2:	bb 83       	std	Y+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    22a4:	87 a1       	ldd	r24, Z+39	; 0x27

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    22a6:	92 e0       	ldi	r25, 0x02	; 2
    22a8:	97 a3       	std	Z+39, r25	; 0x27

			switch( eAction )
    22aa:	22 30       	cpi	r18, 0x02	; 2
    22ac:	b9 f0       	breq	.+46     	; 0x22dc <xTaskGenericNotify+0x64>
    22ae:	18 f4       	brcc	.+6      	; 0x22b6 <xTaskGenericNotify+0x3e>
    22b0:	21 30       	cpi	r18, 0x01	; 1
    22b2:	31 f0       	breq	.+12     	; 0x22c0 <xTaskGenericNotify+0x48>
    22b4:	2f c0       	rjmp	.+94     	; 0x2314 <xTaskGenericNotify+0x9c>
    22b6:	23 30       	cpi	r18, 0x03	; 3
    22b8:	f9 f0       	breq	.+62     	; 0x22f8 <xTaskGenericNotify+0x80>
    22ba:	24 30       	cpi	r18, 0x04	; 4
    22bc:	19 f1       	breq	.+70     	; 0x2304 <xTaskGenericNotify+0x8c>
    22be:	2a c0       	rjmp	.+84     	; 0x2314 <xTaskGenericNotify+0x9c>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    22c0:	03 a1       	ldd	r16, Z+35	; 0x23
    22c2:	14 a1       	ldd	r17, Z+36	; 0x24
    22c4:	25 a1       	ldd	r18, Z+37	; 0x25
    22c6:	36 a1       	ldd	r19, Z+38	; 0x26
    22c8:	40 2b       	or	r20, r16
    22ca:	51 2b       	or	r21, r17
    22cc:	62 2b       	or	r22, r18
    22ce:	73 2b       	or	r23, r19
    22d0:	43 a3       	std	Z+35, r20	; 0x23
    22d2:	54 a3       	std	Z+36, r21	; 0x24
    22d4:	65 a3       	std	Z+37, r22	; 0x25
    22d6:	76 a3       	std	Z+38, r23	; 0x26
#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    22d8:	11 e0       	ldi	r17, 0x01	; 1

			switch( eAction )
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
					break;
    22da:	1f c0       	rjmp	.+62     	; 0x231a <xTaskGenericNotify+0xa2>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    22dc:	43 a1       	ldd	r20, Z+35	; 0x23
    22de:	54 a1       	ldd	r21, Z+36	; 0x24
    22e0:	65 a1       	ldd	r22, Z+37	; 0x25
    22e2:	76 a1       	ldd	r23, Z+38	; 0x26
    22e4:	4f 5f       	subi	r20, 0xFF	; 255
    22e6:	5f 4f       	sbci	r21, 0xFF	; 255
    22e8:	6f 4f       	sbci	r22, 0xFF	; 255
    22ea:	7f 4f       	sbci	r23, 0xFF	; 255
    22ec:	43 a3       	std	Z+35, r20	; 0x23
    22ee:	54 a3       	std	Z+36, r21	; 0x24
    22f0:	65 a3       	std	Z+37, r22	; 0x25
    22f2:	76 a3       	std	Z+38, r23	; 0x26
#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    22f4:	11 e0       	ldi	r17, 0x01	; 1
					pxTCB->ulNotifiedValue |= ulValue;
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
					break;
    22f6:	11 c0       	rjmp	.+34     	; 0x231a <xTaskGenericNotify+0xa2>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    22f8:	43 a3       	std	Z+35, r20	; 0x23
    22fa:	54 a3       	std	Z+36, r21	; 0x24
    22fc:	65 a3       	std	Z+37, r22	; 0x25
    22fe:	76 a3       	std	Z+38, r23	; 0x26
#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    2300:	11 e0       	ldi	r17, 0x01	; 1
					( pxTCB->ulNotifiedValue )++;
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
					break;
    2302:	0b c0       	rjmp	.+22     	; 0x231a <xTaskGenericNotify+0xa2>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    2304:	82 30       	cpi	r24, 0x02	; 2
    2306:	41 f0       	breq	.+16     	; 0x2318 <xTaskGenericNotify+0xa0>
					{
						pxTCB->ulNotifiedValue = ulValue;
    2308:	43 a3       	std	Z+35, r20	; 0x23
    230a:	54 a3       	std	Z+36, r21	; 0x24
    230c:	65 a3       	std	Z+37, r22	; 0x25
    230e:	76 a3       	std	Z+38, r23	; 0x26
#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    2310:	11 e0       	ldi	r17, 0x01	; 1
    2312:	03 c0       	rjmp	.+6      	; 0x231a <xTaskGenericNotify+0xa2>
    2314:	11 e0       	ldi	r17, 0x01	; 1
    2316:	01 c0       	rjmp	.+2      	; 0x231a <xTaskGenericNotify+0xa2>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    2318:	10 e0       	ldi	r17, 0x00	; 0

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    231a:	81 30       	cpi	r24, 0x01	; 1
    231c:	41 f5       	brne	.+80     	; 0x236e <xTaskGenericNotify+0xf6>
    231e:	ef 01       	movw	r28, r30
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    2320:	7f 01       	movw	r14, r30
    2322:	82 e0       	ldi	r24, 0x02	; 2
    2324:	e8 0e       	add	r14, r24
    2326:	f1 1c       	adc	r15, r1
    2328:	c7 01       	movw	r24, r14
    232a:	0e 94 76 04 	call	0x8ec	; 0x8ec <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    232e:	8e 89       	ldd	r24, Y+22	; 0x16
    2330:	90 91 66 0d 	lds	r25, 0x0D66	; 0x800d66 <uxTopReadyPriority>
    2334:	98 17       	cp	r25, r24
    2336:	10 f4       	brcc	.+4      	; 0x233c <xTaskGenericNotify+0xc4>
    2338:	80 93 66 0d 	sts	0x0D66, r24	; 0x800d66 <uxTopReadyPriority>
    233c:	90 e0       	ldi	r25, 0x00	; 0
    233e:	9c 01       	movw	r18, r24
    2340:	22 0f       	add	r18, r18
    2342:	33 1f       	adc	r19, r19
    2344:	22 0f       	add	r18, r18
    2346:	33 1f       	adc	r19, r19
    2348:	22 0f       	add	r18, r18
    234a:	33 1f       	adc	r19, r19
    234c:	82 0f       	add	r24, r18
    234e:	93 1f       	adc	r25, r19
    2350:	b7 01       	movw	r22, r14
    2352:	87 57       	subi	r24, 0x77	; 119
    2354:	92 4f       	sbci	r25, 0xF2	; 242
    2356:	0e 94 24 04 	call	0x848	; 0x848 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    235a:	9e 89       	ldd	r25, Y+22	; 0x16
    235c:	e0 91 ad 0d 	lds	r30, 0x0DAD	; 0x800dad <pxCurrentTCB>
    2360:	f0 91 ae 0d 	lds	r31, 0x0DAE	; 0x800dae <pxCurrentTCB+0x1>
    2364:	86 89       	ldd	r24, Z+22	; 0x16
    2366:	89 17       	cp	r24, r25
    2368:	10 f4       	brcc	.+4      	; 0x236e <xTaskGenericNotify+0xf6>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    236a:	0e 94 42 05 	call	0xa84	; 0xa84 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    236e:	0f 90       	pop	r0
    2370:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    2372:	81 2f       	mov	r24, r17
    2374:	df 91       	pop	r29
    2376:	cf 91       	pop	r28
    2378:	1f 91       	pop	r17
    237a:	0f 91       	pop	r16
    237c:	ff 90       	pop	r15
    237e:	ef 90       	pop	r14
    2380:	08 95       	ret

00002382 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    2382:	cf 92       	push	r12
    2384:	df 92       	push	r13
    2386:	ef 92       	push	r14
    2388:	ff 92       	push	r15
    238a:	0f 93       	push	r16
    238c:	1f 93       	push	r17
    238e:	cf 93       	push	r28
    2390:	df 93       	push	r29
    2392:	fc 01       	movw	r30, r24

		pxTCB = ( TCB_t * ) xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			if( pulPreviousNotificationValue != NULL )
    2394:	01 15       	cp	r16, r1
    2396:	11 05       	cpc	r17, r1
    2398:	49 f0       	breq	.+18     	; 0x23ac <xTaskGenericNotifyFromISR+0x2a>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    239a:	83 a1       	ldd	r24, Z+35	; 0x23
    239c:	94 a1       	ldd	r25, Z+36	; 0x24
    239e:	a5 a1       	ldd	r26, Z+37	; 0x25
    23a0:	b6 a1       	ldd	r27, Z+38	; 0x26
    23a2:	e8 01       	movw	r28, r16
    23a4:	88 83       	st	Y, r24
    23a6:	99 83       	std	Y+1, r25	; 0x01
    23a8:	aa 83       	std	Y+2, r26	; 0x02
    23aa:	bb 83       	std	Y+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    23ac:	87 a1       	ldd	r24, Z+39	; 0x27
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    23ae:	92 e0       	ldi	r25, 0x02	; 2
    23b0:	97 a3       	std	Z+39, r25	; 0x27

			switch( eAction )
    23b2:	22 30       	cpi	r18, 0x02	; 2
    23b4:	b9 f0       	breq	.+46     	; 0x23e4 <xTaskGenericNotifyFromISR+0x62>
    23b6:	18 f4       	brcc	.+6      	; 0x23be <xTaskGenericNotifyFromISR+0x3c>
    23b8:	21 30       	cpi	r18, 0x01	; 1
    23ba:	31 f0       	breq	.+12     	; 0x23c8 <xTaskGenericNotifyFromISR+0x46>
    23bc:	2f c0       	rjmp	.+94     	; 0x241c <xTaskGenericNotifyFromISR+0x9a>
    23be:	23 30       	cpi	r18, 0x03	; 3
    23c0:	f9 f0       	breq	.+62     	; 0x2400 <xTaskGenericNotifyFromISR+0x7e>
    23c2:	24 30       	cpi	r18, 0x04	; 4
    23c4:	19 f1       	breq	.+70     	; 0x240c <xTaskGenericNotifyFromISR+0x8a>
    23c6:	2a c0       	rjmp	.+84     	; 0x241c <xTaskGenericNotifyFromISR+0x9a>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    23c8:	03 a1       	ldd	r16, Z+35	; 0x23
    23ca:	14 a1       	ldd	r17, Z+36	; 0x24
    23cc:	25 a1       	ldd	r18, Z+37	; 0x25
    23ce:	36 a1       	ldd	r19, Z+38	; 0x26
    23d0:	40 2b       	or	r20, r16
    23d2:	51 2b       	or	r21, r17
    23d4:	62 2b       	or	r22, r18
    23d6:	73 2b       	or	r23, r19
    23d8:	43 a3       	std	Z+35, r20	; 0x23
    23da:	54 a3       	std	Z+36, r21	; 0x24
    23dc:	65 a3       	std	Z+37, r22	; 0x25
    23de:	76 a3       	std	Z+38, r23	; 0x26

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    23e0:	11 e0       	ldi	r17, 0x01	; 1

			switch( eAction )
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
					break;
    23e2:	1f c0       	rjmp	.+62     	; 0x2422 <xTaskGenericNotifyFromISR+0xa0>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    23e4:	43 a1       	ldd	r20, Z+35	; 0x23
    23e6:	54 a1       	ldd	r21, Z+36	; 0x24
    23e8:	65 a1       	ldd	r22, Z+37	; 0x25
    23ea:	76 a1       	ldd	r23, Z+38	; 0x26
    23ec:	4f 5f       	subi	r20, 0xFF	; 255
    23ee:	5f 4f       	sbci	r21, 0xFF	; 255
    23f0:	6f 4f       	sbci	r22, 0xFF	; 255
    23f2:	7f 4f       	sbci	r23, 0xFF	; 255
    23f4:	43 a3       	std	Z+35, r20	; 0x23
    23f6:	54 a3       	std	Z+36, r21	; 0x24
    23f8:	65 a3       	std	Z+37, r22	; 0x25
    23fa:	76 a3       	std	Z+38, r23	; 0x26

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    23fc:	11 e0       	ldi	r17, 0x01	; 1
					pxTCB->ulNotifiedValue |= ulValue;
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
					break;
    23fe:	11 c0       	rjmp	.+34     	; 0x2422 <xTaskGenericNotifyFromISR+0xa0>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    2400:	43 a3       	std	Z+35, r20	; 0x23
    2402:	54 a3       	std	Z+36, r21	; 0x24
    2404:	65 a3       	std	Z+37, r22	; 0x25
    2406:	76 a3       	std	Z+38, r23	; 0x26

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    2408:	11 e0       	ldi	r17, 0x01	; 1
					( pxTCB->ulNotifiedValue )++;
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
					break;
    240a:	0b c0       	rjmp	.+22     	; 0x2422 <xTaskGenericNotifyFromISR+0xa0>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    240c:	82 30       	cpi	r24, 0x02	; 2
    240e:	41 f0       	breq	.+16     	; 0x2420 <xTaskGenericNotifyFromISR+0x9e>
					{
						pxTCB->ulNotifiedValue = ulValue;
    2410:	43 a3       	std	Z+35, r20	; 0x23
    2412:	54 a3       	std	Z+36, r21	; 0x24
    2414:	65 a3       	std	Z+37, r22	; 0x25
    2416:	76 a3       	std	Z+38, r23	; 0x26

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    2418:	11 e0       	ldi	r17, 0x01	; 1
    241a:	03 c0       	rjmp	.+6      	; 0x2422 <xTaskGenericNotifyFromISR+0xa0>
    241c:	11 e0       	ldi	r17, 0x01	; 1
    241e:	01 c0       	rjmp	.+2      	; 0x2422 <xTaskGenericNotifyFromISR+0xa0>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    2420:	10 e0       	ldi	r17, 0x00	; 0

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    2422:	81 30       	cpi	r24, 0x01	; 1
    2424:	e1 f5       	brne	.+120    	; 0x249e <xTaskGenericNotifyFromISR+0x11c>
    2426:	ef 01       	movw	r28, r30
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2428:	80 91 5c 0d 	lds	r24, 0x0D5C	; 0x800d5c <uxSchedulerSuspended>
    242c:	81 11       	cpse	r24, r1
    242e:	1e c0       	rjmp	.+60     	; 0x246c <xTaskGenericNotifyFromISR+0xea>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    2430:	6f 01       	movw	r12, r30
    2432:	e2 e0       	ldi	r30, 0x02	; 2
    2434:	ce 0e       	add	r12, r30
    2436:	d1 1c       	adc	r13, r1
    2438:	c6 01       	movw	r24, r12
    243a:	0e 94 76 04 	call	0x8ec	; 0x8ec <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    243e:	8e 89       	ldd	r24, Y+22	; 0x16
    2440:	90 91 66 0d 	lds	r25, 0x0D66	; 0x800d66 <uxTopReadyPriority>
    2444:	98 17       	cp	r25, r24
    2446:	10 f4       	brcc	.+4      	; 0x244c <xTaskGenericNotifyFromISR+0xca>
    2448:	80 93 66 0d 	sts	0x0D66, r24	; 0x800d66 <uxTopReadyPriority>
    244c:	90 e0       	ldi	r25, 0x00	; 0
    244e:	9c 01       	movw	r18, r24
    2450:	22 0f       	add	r18, r18
    2452:	33 1f       	adc	r19, r19
    2454:	22 0f       	add	r18, r18
    2456:	33 1f       	adc	r19, r19
    2458:	22 0f       	add	r18, r18
    245a:	33 1f       	adc	r19, r19
    245c:	82 0f       	add	r24, r18
    245e:	93 1f       	adc	r25, r19
    2460:	b6 01       	movw	r22, r12
    2462:	87 57       	subi	r24, 0x77	; 119
    2464:	92 4f       	sbci	r25, 0xF2	; 242
    2466:	0e 94 24 04 	call	0x848	; 0x848 <vListInsertEnd>
    246a:	07 c0       	rjmp	.+14     	; 0x247a <xTaskGenericNotifyFromISR+0xf8>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    246c:	bf 01       	movw	r22, r30
    246e:	64 5f       	subi	r22, 0xF4	; 244
    2470:	7f 4f       	sbci	r23, 0xFF	; 255
    2472:	8a e6       	ldi	r24, 0x6A	; 106
    2474:	9d e0       	ldi	r25, 0x0D	; 13
    2476:	0e 94 24 04 	call	0x848	; 0x848 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    247a:	9e 89       	ldd	r25, Y+22	; 0x16
    247c:	e0 91 ad 0d 	lds	r30, 0x0DAD	; 0x800dad <pxCurrentTCB>
    2480:	f0 91 ae 0d 	lds	r31, 0x0DAE	; 0x800dae <pxCurrentTCB+0x1>
    2484:	86 89       	ldd	r24, Z+22	; 0x16
    2486:	89 17       	cp	r24, r25
    2488:	50 f4       	brcc	.+20     	; 0x249e <xTaskGenericNotifyFromISR+0x11c>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    248a:	e1 14       	cp	r14, r1
    248c:	f1 04       	cpc	r15, r1
    248e:	21 f0       	breq	.+8      	; 0x2498 <xTaskGenericNotifyFromISR+0x116>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    2490:	81 e0       	ldi	r24, 0x01	; 1
    2492:	e7 01       	movw	r28, r14
    2494:	88 83       	st	Y, r24
    2496:	03 c0       	rjmp	.+6      	; 0x249e <xTaskGenericNotifyFromISR+0x11c>
					else
					{
						/* Mark that a yield is pending in case the user is not
						using the "xHigherPriorityTaskWoken" parameter to an ISR
						safe FreeRTOS function. */
						xYieldPending = pdTRUE;
    2498:	81 e0       	ldi	r24, 0x01	; 1
    249a:	80 93 63 0d 	sts	0x0D63, r24	; 0x800d63 <xYieldPending>
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
	}
    249e:	81 2f       	mov	r24, r17
    24a0:	df 91       	pop	r29
    24a2:	cf 91       	pop	r28
    24a4:	1f 91       	pop	r17
    24a6:	0f 91       	pop	r16
    24a8:	ff 90       	pop	r15
    24aa:	ef 90       	pop	r14
    24ac:	df 90       	pop	r13
    24ae:	cf 90       	pop	r12
    24b0:	08 95       	ret

000024b2 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    24b2:	ef 92       	push	r14
    24b4:	ff 92       	push	r15
    24b6:	0f 93       	push	r16
    24b8:	1f 93       	push	r17
    24ba:	cf 93       	push	r28
    24bc:	df 93       	push	r29
    24be:	fc 01       	movw	r30, r24

		pxTCB = ( TCB_t * ) xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    24c0:	27 a1       	ldd	r18, Z+39	; 0x27
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    24c2:	82 e0       	ldi	r24, 0x02	; 2
    24c4:	87 a3       	std	Z+39, r24	; 0x27

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    24c6:	83 a1       	ldd	r24, Z+35	; 0x23
    24c8:	94 a1       	ldd	r25, Z+36	; 0x24
    24ca:	a5 a1       	ldd	r26, Z+37	; 0x25
    24cc:	b6 a1       	ldd	r27, Z+38	; 0x26
    24ce:	01 96       	adiw	r24, 0x01	; 1
    24d0:	a1 1d       	adc	r26, r1
    24d2:	b1 1d       	adc	r27, r1
    24d4:	83 a3       	std	Z+35, r24	; 0x23
    24d6:	94 a3       	std	Z+36, r25	; 0x24
    24d8:	a5 a3       	std	Z+37, r26	; 0x25
    24da:	b6 a3       	std	Z+38, r27	; 0x26

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    24dc:	21 30       	cpi	r18, 0x01	; 1
    24de:	e9 f5       	brne	.+122    	; 0x255a <vTaskNotifyGiveFromISR+0xa8>
    24e0:	8b 01       	movw	r16, r22
    24e2:	ef 01       	movw	r28, r30
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    24e4:	80 91 5c 0d 	lds	r24, 0x0D5C	; 0x800d5c <uxSchedulerSuspended>
    24e8:	81 11       	cpse	r24, r1
    24ea:	1e c0       	rjmp	.+60     	; 0x2528 <vTaskNotifyGiveFromISR+0x76>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    24ec:	7f 01       	movw	r14, r30
    24ee:	82 e0       	ldi	r24, 0x02	; 2
    24f0:	e8 0e       	add	r14, r24
    24f2:	f1 1c       	adc	r15, r1
    24f4:	c7 01       	movw	r24, r14
    24f6:	0e 94 76 04 	call	0x8ec	; 0x8ec <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    24fa:	8e 89       	ldd	r24, Y+22	; 0x16
    24fc:	90 91 66 0d 	lds	r25, 0x0D66	; 0x800d66 <uxTopReadyPriority>
    2500:	98 17       	cp	r25, r24
    2502:	10 f4       	brcc	.+4      	; 0x2508 <vTaskNotifyGiveFromISR+0x56>
    2504:	80 93 66 0d 	sts	0x0D66, r24	; 0x800d66 <uxTopReadyPriority>
    2508:	90 e0       	ldi	r25, 0x00	; 0
    250a:	9c 01       	movw	r18, r24
    250c:	22 0f       	add	r18, r18
    250e:	33 1f       	adc	r19, r19
    2510:	22 0f       	add	r18, r18
    2512:	33 1f       	adc	r19, r19
    2514:	22 0f       	add	r18, r18
    2516:	33 1f       	adc	r19, r19
    2518:	82 0f       	add	r24, r18
    251a:	93 1f       	adc	r25, r19
    251c:	b7 01       	movw	r22, r14
    251e:	87 57       	subi	r24, 0x77	; 119
    2520:	92 4f       	sbci	r25, 0xF2	; 242
    2522:	0e 94 24 04 	call	0x848	; 0x848 <vListInsertEnd>
    2526:	07 c0       	rjmp	.+14     	; 0x2536 <vTaskNotifyGiveFromISR+0x84>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    2528:	bf 01       	movw	r22, r30
    252a:	64 5f       	subi	r22, 0xF4	; 244
    252c:	7f 4f       	sbci	r23, 0xFF	; 255
    252e:	8a e6       	ldi	r24, 0x6A	; 106
    2530:	9d e0       	ldi	r25, 0x0D	; 13
    2532:	0e 94 24 04 	call	0x848	; 0x848 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    2536:	9e 89       	ldd	r25, Y+22	; 0x16
    2538:	e0 91 ad 0d 	lds	r30, 0x0DAD	; 0x800dad <pxCurrentTCB>
    253c:	f0 91 ae 0d 	lds	r31, 0x0DAE	; 0x800dae <pxCurrentTCB+0x1>
    2540:	86 89       	ldd	r24, Z+22	; 0x16
    2542:	89 17       	cp	r24, r25
    2544:	50 f4       	brcc	.+20     	; 0x255a <vTaskNotifyGiveFromISR+0xa8>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    2546:	01 15       	cp	r16, r1
    2548:	11 05       	cpc	r17, r1
    254a:	21 f0       	breq	.+8      	; 0x2554 <vTaskNotifyGiveFromISR+0xa2>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    254c:	81 e0       	ldi	r24, 0x01	; 1
    254e:	f8 01       	movw	r30, r16
    2550:	80 83       	st	Z, r24
    2552:	03 c0       	rjmp	.+6      	; 0x255a <vTaskNotifyGiveFromISR+0xa8>
					else
					{
						/* Mark that a yield is pending in case the user is not
						using the "xHigherPriorityTaskWoken" parameter in an ISR
						safe FreeRTOS function. */
						xYieldPending = pdTRUE;
    2554:	81 e0       	ldi	r24, 0x01	; 1
    2556:	80 93 63 0d 	sts	0x0D63, r24	; 0x800d63 <xYieldPending>
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    255a:	df 91       	pop	r29
    255c:	cf 91       	pop	r28
    255e:	1f 91       	pop	r17
    2560:	0f 91       	pop	r16
    2562:	ff 90       	pop	r15
    2564:	ef 90       	pop	r14
    2566:	08 95       	ret

00002568 <xTaskNotifyStateClear>:
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    2568:	00 97       	sbiw	r24, 0x00	; 0
    256a:	21 f4       	brne	.+8      	; 0x2574 <xTaskNotifyStateClear+0xc>
    256c:	80 91 ad 0d 	lds	r24, 0x0DAD	; 0x800dad <pxCurrentTCB>
    2570:	90 91 ae 0d 	lds	r25, 0x0DAE	; 0x800dae <pxCurrentTCB+0x1>

		taskENTER_CRITICAL();
    2574:	0f b6       	in	r0, 0x3f	; 63
    2576:	f8 94       	cli
    2578:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    257a:	fc 01       	movw	r30, r24
    257c:	27 a1       	ldd	r18, Z+39	; 0x27
    257e:	22 30       	cpi	r18, 0x02	; 2
    2580:	19 f4       	brne	.+6      	; 0x2588 <xTaskNotifyStateClear+0x20>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    2582:	17 a2       	std	Z+39, r1	; 0x27
				xReturn = pdPASS;
    2584:	81 e0       	ldi	r24, 0x01	; 1
    2586:	01 c0       	rjmp	.+2      	; 0x258a <xTaskNotifyStateClear+0x22>
			}
			else
			{
				xReturn = pdFAIL;
    2588:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		taskEXIT_CRITICAL();
    258a:	0f 90       	pop	r0
    258c:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    258e:	08 95       	ret

00002590 <vBluetoothTransmitServiceUART1>:
	( void ) pvParameters;
	
	for( ;; ) {
		/* Waits for bufferSendUART1 to fill, then pops first byte of data and
		   copies it to UART1 data register UDR1 effectively transmitting it. */ 
		xQueueReceive( bufferBluetoothSendUART1, &UDR1, portMAX_DELAY );
    2590:	20 e0       	ldi	r18, 0x00	; 0
    2592:	4f ef       	ldi	r20, 0xFF	; 255
    2594:	5f ef       	ldi	r21, 0xFF	; 255
    2596:	6c e9       	ldi	r22, 0x9C	; 156
    2598:	70 e0       	ldi	r23, 0x00	; 0
    259a:	80 91 b5 0d 	lds	r24, 0x0DB5	; 0x800db5 <bufferBluetoothSendUART1>
    259e:	90 91 b6 0d 	lds	r25, 0x0DB6	; 0x800db6 <bufferBluetoothSendUART1+0x1>
    25a2:	0e 94 9c 08 	call	0x1138	; 0x1138 <xQueueGenericReceive>
		while(!( UCSR1A & (1<<UDRE1)));		// Wait for transmit to finish
    25a6:	80 91 9b 00 	lds	r24, 0x009B	; 0x80009b <__TEXT_REGION_LENGTH__+0x7e009b>
    25aa:	85 ff       	sbrs	r24, 5
    25ac:	fc cf       	rjmp	.-8      	; 0x25a6 <vBluetoothTransmitServiceUART1+0x16>
    25ae:	f0 cf       	rjmp	.-32     	; 0x2590 <vBluetoothTransmitServiceUART1>

000025b0 <vRoombaTransmitServiceUART0>:
	( void ) pvParameters;
	
	for( ;; ) {
		/* Waits for bufferSendUART0 to fill, then pops first byte of data and
		   copies it to UART0 data register UDR0 effectively transmitting it. */ 
		xQueueReceive( bufferRoombaSendUART0, &UDR0, portMAX_DELAY );
    25b0:	20 e0       	ldi	r18, 0x00	; 0
    25b2:	4f ef       	ldi	r20, 0xFF	; 255
    25b4:	5f ef       	ldi	r21, 0xFF	; 255
    25b6:	6c e2       	ldi	r22, 0x2C	; 44
    25b8:	70 e0       	ldi	r23, 0x00	; 0
    25ba:	80 91 b3 0d 	lds	r24, 0x0DB3	; 0x800db3 <bufferRoombaSendUART0>
    25be:	90 91 b4 0d 	lds	r25, 0x0DB4	; 0x800db4 <bufferRoombaSendUART0+0x1>
    25c2:	0e 94 9c 08 	call	0x1138	; 0x1138 <xQueueGenericReceive>
		while(!( UCSR0A & (1<<UDRE0)));		// Wait for transmit to finish
    25c6:	5d 9b       	sbis	0x0b, 5	; 11
    25c8:	fe cf       	rjmp	.-4      	; 0x25c6 <vRoombaTransmitServiceUART0+0x16>
    25ca:	f2 cf       	rjmp	.-28     	; 0x25b0 <vRoombaTransmitServiceUART0>

000025cc <error>:
		error(ERROR_BT_RECEIVE);
	}
	return byte;
}

static void error( uint8_t byte ) {
    25cc:	cf 93       	push	r28
    25ce:	df 93       	push	r29
    25d0:	1f 92       	push	r1
    25d2:	cd b7       	in	r28, 0x3d	; 61
    25d4:	de b7       	in	r29, 0x3e	; 62
    25d6:	89 83       	std	Y+1, r24	; 0x01
	/* Receives an error and pushes it on globalError queue. */
	xQueueSendToBack( globalError, &byte, 0 );
    25d8:	20 e0       	ldi	r18, 0x00	; 0
    25da:	40 e0       	ldi	r20, 0x00	; 0
    25dc:	50 e0       	ldi	r21, 0x00	; 0
    25de:	be 01       	movw	r22, r28
    25e0:	6f 5f       	subi	r22, 0xFF	; 255
    25e2:	7f 4f       	sbci	r23, 0xFF	; 255
    25e4:	80 91 b7 0d 	lds	r24, 0x0DB7	; 0x800db7 <globalError>
    25e8:	90 91 b8 0d 	lds	r25, 0x0DB8	; 0x800db8 <globalError+0x1>
    25ec:	0e 94 89 07 	call	0xf12	; 0xf12 <xQueueGenericSend>
}
    25f0:	0f 90       	pop	r0
    25f2:	df 91       	pop	r29
    25f4:	cf 91       	pop	r28
    25f6:	08 95       	ret

000025f8 <getByteFromRoomba>:
	if( errQUEUE_FULL == xQueueSendToBack( bufferRoombaSendUART0, &byte, pdMS_TO_TICKS(30) ) ) {
		error(ERROR_ROOMBA_SEND);
	}
}

static uint8_t getByteFromRoomba( void ) {
    25f8:	cf 93       	push	r28
    25fa:	df 93       	push	r29
    25fc:	1f 92       	push	r1
    25fe:	cd b7       	in	r28, 0x3d	; 61
    2600:	de b7       	in	r29, 0x3e	; 62
	/* Gets byte from UART0 receive queue. */
	uint8_t byte;
	if( errQUEUE_EMPTY == xQueueReceive( bufferRoombaReceiveUART0, &byte, pdMS_TO_TICKS(30) ) ) {
    2602:	20 e0       	ldi	r18, 0x00	; 0
    2604:	43 e0       	ldi	r20, 0x03	; 3
    2606:	50 e0       	ldi	r21, 0x00	; 0
    2608:	be 01       	movw	r22, r28
    260a:	6f 5f       	subi	r22, 0xFF	; 255
    260c:	7f 4f       	sbci	r23, 0xFF	; 255
    260e:	80 91 d6 0d 	lds	r24, 0x0DD6	; 0x800dd6 <bufferRoombaReceiveUART0>
    2612:	90 91 d7 0d 	lds	r25, 0x0DD7	; 0x800dd7 <bufferRoombaReceiveUART0+0x1>
    2616:	0e 94 9c 08 	call	0x1138	; 0x1138 <xQueueGenericReceive>
    261a:	81 11       	cpse	r24, r1
    261c:	03 c0       	rjmp	.+6      	; 0x2624 <getByteFromRoomba+0x2c>
		error(ERROR_BT_RECEIVE);
    261e:	86 e0       	ldi	r24, 0x06	; 6
    2620:	0e 94 e6 12 	call	0x25cc	; 0x25cc <error>
	}
	return byte;
}
    2624:	89 81       	ldd	r24, Y+1	; 0x01
    2626:	0f 90       	pop	r0
    2628:	df 91       	pop	r29
    262a:	cf 91       	pop	r28
    262c:	08 95       	ret

0000262e <getByteFromBT>:
	if( errQUEUE_FULL == xQueueSendToBack( bufferBluetoothSendUART1, &byte, pdMS_TO_TICKS(30) ) ) {
		error(ERROR_BT_SEND);
	}
}

static uint8_t getByteFromBT( void ) {
    262e:	cf 93       	push	r28
    2630:	df 93       	push	r29
    2632:	1f 92       	push	r1
    2634:	cd b7       	in	r28, 0x3d	; 61
    2636:	de b7       	in	r29, 0x3e	; 62
	/* Gets byte from UART1 receive queue. */
	uint8_t byte;
	if( errQUEUE_EMPTY == xQueueReceive( bufferBluetoothReceiveUART1, &byte, pdMS_TO_TICKS(30) ) ) {
    2638:	20 e0       	ldi	r18, 0x00	; 0
    263a:	43 e0       	ldi	r20, 0x03	; 3
    263c:	50 e0       	ldi	r21, 0x00	; 0
    263e:	be 01       	movw	r22, r28
    2640:	6f 5f       	subi	r22, 0xFF	; 255
    2642:	7f 4f       	sbci	r23, 0xFF	; 255
    2644:	80 91 b9 0d 	lds	r24, 0x0DB9	; 0x800db9 <bufferBluetoothReceiveUART1>
    2648:	90 91 ba 0d 	lds	r25, 0x0DBA	; 0x800dba <bufferBluetoothReceiveUART1+0x1>
    264c:	0e 94 9c 08 	call	0x1138	; 0x1138 <xQueueGenericReceive>
    2650:	81 11       	cpse	r24, r1
    2652:	03 c0       	rjmp	.+6      	; 0x265a <getByteFromBT+0x2c>
		error(ERROR_BT_RECEIVE);
    2654:	86 e0       	ldi	r24, 0x06	; 6
    2656:	0e 94 e6 12 	call	0x25cc	; 0x25cc <error>
	}
	return byte;
}
    265a:	89 81       	ldd	r24, Y+1	; 0x01
    265c:	0f 90       	pop	r0
    265e:	df 91       	pop	r29
    2660:	cf 91       	pop	r28
    2662:	08 95       	ret

00002664 <sendByteToRoomba>:
	for(uint8_t i = 0; message[i] != '\0'; ++i) {
		xQueueSendToBack( queue, message+i, pdMS_TO_TICKS(30) );
	}
}

static void sendByteToRoomba( uint8_t byte ) {
    2664:	cf 93       	push	r28
    2666:	df 93       	push	r29
    2668:	1f 92       	push	r1
    266a:	cd b7       	in	r28, 0x3d	; 61
    266c:	de b7       	in	r29, 0x3e	; 62
    266e:	89 83       	std	Y+1, r24	; 0x01
	/* Pushes byte on UART0 send queue. */
	if( errQUEUE_FULL == xQueueSendToBack( bufferRoombaSendUART0, &byte, pdMS_TO_TICKS(30) ) ) {
    2670:	20 e0       	ldi	r18, 0x00	; 0
    2672:	43 e0       	ldi	r20, 0x03	; 3
    2674:	50 e0       	ldi	r21, 0x00	; 0
    2676:	be 01       	movw	r22, r28
    2678:	6f 5f       	subi	r22, 0xFF	; 255
    267a:	7f 4f       	sbci	r23, 0xFF	; 255
    267c:	80 91 b3 0d 	lds	r24, 0x0DB3	; 0x800db3 <bufferRoombaSendUART0>
    2680:	90 91 b4 0d 	lds	r25, 0x0DB4	; 0x800db4 <bufferRoombaSendUART0+0x1>
    2684:	0e 94 89 07 	call	0xf12	; 0xf12 <xQueueGenericSend>
    2688:	81 11       	cpse	r24, r1
    268a:	03 c0       	rjmp	.+6      	; 0x2692 <sendByteToRoomba+0x2e>
		error(ERROR_ROOMBA_SEND);
    268c:	83 e0       	ldi	r24, 0x03	; 3
    268e:	0e 94 e6 12 	call	0x25cc	; 0x25cc <error>
	}
}
    2692:	0f 90       	pop	r0
    2694:	df 91       	pop	r29
    2696:	cf 91       	pop	r28
    2698:	08 95       	ret

0000269a <vBluetoothReceiveServiceUART1>:
		while(!( UCSR1A & (1<<UDRE1)));		// Wait for transmit to finish
	}
}


static void vBluetoothReceiveServiceUART1( void *pvParameters ) {
    269a:	cf 93       	push	r28
    269c:	df 93       	push	r29
    269e:	1f 92       	push	r1
    26a0:	cd b7       	in	r28, 0x3d	; 61
    26a2:	de b7       	in	r29, 0x3e	; 62
	( void ) pvParameters;
	
	for( ;; ) {
		
		/* Wait until opcode is received from Bluetooth. */
		xQueueReceive( bufferBluetoothReceiveUART1, &opcode, portMAX_DELAY );
    26a4:	20 e0       	ldi	r18, 0x00	; 0
    26a6:	4f ef       	ldi	r20, 0xFF	; 255
    26a8:	5f ef       	ldi	r21, 0xFF	; 255
    26aa:	be 01       	movw	r22, r28
    26ac:	6f 5f       	subi	r22, 0xFF	; 255
    26ae:	7f 4f       	sbci	r23, 0xFF	; 255
    26b0:	80 91 b9 0d 	lds	r24, 0x0DB9	; 0x800db9 <bufferBluetoothReceiveUART1>
    26b4:	90 91 ba 0d 	lds	r25, 0x0DBA	; 0x800dba <bufferBluetoothReceiveUART1+0x1>
    26b8:	0e 94 9c 08 	call	0x1138	; 0x1138 <xQueueGenericReceive>

		/* If opcode is meant for Roomba pass it to serial along with any accompanying data bytes. */
		if( opcode >= SCI_START_OPCODE && opcode <= SCI_FORCE_SEEKING_DOCK_OPCODE ) {
    26bc:	89 81       	ldd	r24, Y+1	; 0x01
    26be:	90 e8       	ldi	r25, 0x80	; 128
    26c0:	98 0f       	add	r25, r24
    26c2:	90 31       	cpi	r25, 0x10	; 16
    26c4:	78 f7       	brcc	.-34     	; 0x26a4 <vBluetoothReceiveServiceUART1+0xa>
			
			/* Set number of accompanying data bytes according to Roomba SCI specification. */
			switch( opcode ) {
    26c6:	48 2f       	mov	r20, r24
    26c8:	50 e0       	ldi	r21, 0x00	; 0
    26ca:	fa 01       	movw	r30, r20
    26cc:	e1 58       	subi	r30, 0x81	; 129
    26ce:	f1 09       	sbc	r31, r1
    26d0:	ee 30       	cpi	r30, 0x0E	; 14
    26d2:	f1 05       	cpc	r31, r1
    26d4:	20 f4       	brcc	.+8      	; 0x26de <vBluetoothReceiveServiceUART1+0x44>
    26d6:	ea 5b       	subi	r30, 0xBA	; 186
    26d8:	ff 4f       	sbci	r31, 0xFF	; 255
    26da:	0c 94 18 16 	jmp	0x2c30	; 0x2c30 <__tablejump2__>
				case SCI_POWER_OPCODE:
				case SCI_SPOT_OPCODE:
				case SCI_CLEAN_OPCODE:
				case SCI_MAX_OPCODE:
				case SCI_FORCE_SEEKING_DOCK_OPCODE:
					numberOfDataBytes = 0;
    26de:	10 e0       	ldi	r17, 0x00	; 0
    26e0:	05 c0       	rjmp	.+10     	; 0x26ec <vBluetoothReceiveServiceUART1+0x52>
				case SCI_SENSORS_OPCODE: // Special case - returns data
					numberOfDataBytes = 1;
					break;
				case SCI_LEDS_OPCODE:
				case SCI_SONG_OPCODE: // Special case - variable length, 3 byte header
					numberOfDataBytes = 3;
    26e2:	13 e0       	ldi	r17, 0x03	; 3
					break;
    26e4:	03 c0       	rjmp	.+6      	; 0x26ec <vBluetoothReceiveServiceUART1+0x52>
				case SCI_DRIVE_OPCODE:
					numberOfDataBytes = 4;
    26e6:	14 e0       	ldi	r17, 0x04	; 4
					break;
    26e8:	01 c0       	rjmp	.+2      	; 0x26ec <vBluetoothReceiveServiceUART1+0x52>
					break;
				case SCI_BAUD_OPCODE:
				case SCI_MOTORS_OPCODE:
				case SCI_PLAY_OPCODE:
				case SCI_SENSORS_OPCODE: // Special case - returns data
					numberOfDataBytes = 1;
    26ea:	11 e0       	ldi	r17, 0x01	; 1
					numberOfDataBytes = 0;
					break;
			}

			/* Send opcode byte to Roomba. */
			sendByteToRoomba( opcode );
    26ec:	0e 94 32 13 	call	0x2664	; 0x2664 <sendByteToRoomba>

			/* Handle standard Roomba opcodes. */
			if( opcode != SCI_SENSORS_OPCODE && opcode != SCI_SONG_OPCODE ) {
    26f0:	89 81       	ldd	r24, Y+1	; 0x01
    26f2:	8e 38       	cpi	r24, 0x8E	; 142
    26f4:	69 f0       	breq	.+26     	; 0x2710 <vBluetoothReceiveServiceUART1+0x76>
    26f6:	8c 38       	cpi	r24, 0x8C	; 140
    26f8:	31 f4       	brne	.+12     	; 0x2706 <vBluetoothReceiveServiceUART1+0x6c>
    26fa:	0a c0       	rjmp	.+20     	; 0x2710 <vBluetoothReceiveServiceUART1+0x76>

				/* Send data bytes from BT to Roomba. */
				while( numberOfDataBytes-- ) {
					sendByteToRoomba( getByteFromBT() );
    26fc:	0e 94 17 13 	call	0x262e	; 0x262e <getByteFromBT>
    2700:	0e 94 32 13 	call	0x2664	; 0x2664 <sendByteToRoomba>

			/* Handle standard Roomba opcodes. */
			if( opcode != SCI_SENSORS_OPCODE && opcode != SCI_SONG_OPCODE ) {

				/* Send data bytes from BT to Roomba. */
				while( numberOfDataBytes-- ) {
    2704:	10 2f       	mov	r17, r16
    2706:	0f ef       	ldi	r16, 0xFF	; 255
    2708:	01 0f       	add	r16, r17
    270a:	11 11       	cpse	r17, r1
    270c:	f7 cf       	rjmp	.-18     	; 0x26fc <vBluetoothReceiveServiceUART1+0x62>
    270e:	ca cf       	rjmp	.-108    	; 0x26a4 <vBluetoothReceiveServiceUART1+0xa>
					sendByteToRoomba( getByteFromBT() );
				}
			}

			/* Handle special case: request sensor data from Roomba. */
			else if( opcode == SCI_SENSORS_OPCODE ) {
    2710:	8e 38       	cpi	r24, 0x8E	; 142
    2712:	11 f5       	brne	.+68     	; 0x2758 <vBluetoothReceiveServiceUART1+0xbe>

				/* Receive SCI sensors data byte from Bluetooth and send it to Roomba. */
				data = getByteFromBT();
    2714:	0e 94 17 13 	call	0x262e	; 0x262e <getByteFromBT>
    2718:	18 2f       	mov	r17, r24
				sendByteToRoomba( data );
    271a:	0e 94 32 13 	call	0x2664	; 0x2664 <sendByteToRoomba>

				/* Set number of expected data bytes to receive from Roomba according to SCI sensors data byte. */
				switch (data) {
    271e:	11 30       	cpi	r17, 0x01	; 1
    2720:	61 f0       	breq	.+24     	; 0x273a <vBluetoothReceiveServiceUART1+0xa0>
    2722:	28 f0       	brcs	.+10     	; 0x272e <vBluetoothReceiveServiceUART1+0x94>
    2724:	12 30       	cpi	r17, 0x02	; 2
    2726:	29 f0       	breq	.+10     	; 0x2732 <vBluetoothReceiveServiceUART1+0x98>
    2728:	13 30       	cpi	r17, 0x03	; 3
    272a:	39 f0       	breq	.+14     	; 0x273a <vBluetoothReceiveServiceUART1+0xa0>
    272c:	04 c0       	rjmp	.+8      	; 0x2736 <vBluetoothReceiveServiceUART1+0x9c>
					case SCI_SENSORS_PACKET0:
						numberOfDataBytes = SCI_SENSORS_PACKET0_BYTES;
    272e:	0a e1       	ldi	r16, 0x1A	; 26
    2730:	05 c0       	rjmp	.+10     	; 0x273c <vBluetoothReceiveServiceUART1+0xa2>
						break;
					case SCI_SENSORS_PACKET1:
						numberOfDataBytes = SCI_SENSORS_PACKET1_BYTES;
						break;
					case SCI_SENSORS_PACKET2:
						numberOfDataBytes = SCI_SENSORS_PACKET2_BYTES;
    2732:	06 e0       	ldi	r16, 0x06	; 6
						break;
    2734:	03 c0       	rjmp	.+6      	; 0x273c <vBluetoothReceiveServiceUART1+0xa2>
					case SCI_SENSORS_PACKET3:
						numberOfDataBytes = SCI_SENSORS_PACKET3_BYTES;
						break;
					default:
						numberOfDataBytes = 0;
    2736:	00 e0       	ldi	r16, 0x00	; 0
						break;
    2738:	01 c0       	rjmp	.+2      	; 0x273c <vBluetoothReceiveServiceUART1+0xa2>
				switch (data) {
					case SCI_SENSORS_PACKET0:
						numberOfDataBytes = SCI_SENSORS_PACKET0_BYTES;
						break;
					case SCI_SENSORS_PACKET1:
						numberOfDataBytes = SCI_SENSORS_PACKET1_BYTES;
    273a:	0a e0       	ldi	r16, 0x0A	; 10
						numberOfDataBytes = 0;
						break;
				}

				/* Receive and store sensor data bytes from Roomba into sensorData[] (as first n bytes). */
				for( uint8_t i = 0; i < numberOfDataBytes; ++i ) {
    273c:	10 e0       	ldi	r17, 0x00	; 0
    273e:	09 c0       	rjmp	.+18     	; 0x2752 <vBluetoothReceiveServiceUART1+0xb8>
					sensorData[i] = getByteFromRoomba();
    2740:	e1 2e       	mov	r14, r17
    2742:	f1 2c       	mov	r15, r1
    2744:	0e 94 fc 12 	call	0x25f8	; 0x25f8 <getByteFromRoomba>
    2748:	f7 01       	movw	r30, r14
    274a:	e5 54       	subi	r30, 0x45	; 69
    274c:	f2 4f       	sbci	r31, 0xF2	; 242
    274e:	80 83       	st	Z, r24
						numberOfDataBytes = 0;
						break;
				}

				/* Receive and store sensor data bytes from Roomba into sensorData[] (as first n bytes). */
				for( uint8_t i = 0; i < numberOfDataBytes; ++i ) {
    2750:	1f 5f       	subi	r17, 0xFF	; 255
    2752:	10 17       	cp	r17, r16
    2754:	a8 f3       	brcs	.-22     	; 0x2740 <vBluetoothReceiveServiceUART1+0xa6>
    2756:	a6 cf       	rjmp	.-180    	; 0x26a4 <vBluetoothReceiveServiceUART1+0xa>
					sensorData[i] = getByteFromRoomba();
				}
			}

			/* Handle special case: send new song to Roomba. */
			else if( opcode == SCI_SONG_OPCODE ) {
    2758:	8c 38       	cpi	r24, 0x8C	; 140
    275a:	09 f0       	breq	.+2      	; 0x275e <vBluetoothReceiveServiceUART1+0xc4>
    275c:	a3 cf       	rjmp	.-186    	; 0x26a4 <vBluetoothReceiveServiceUART1+0xa>
				
				/* Receive SCI song number byte from Bluetooth and send it to Roomba. */
				sendByteToRoomba( getByteFromBT() );
    275e:	0e 94 17 13 	call	0x262e	; 0x262e <getByteFromBT>
    2762:	0e 94 32 13 	call	0x2664	; 0x2664 <sendByteToRoomba>

				/* Receive SCI song length byte from Bluetooth and send it to Roomba. */
				data = getByteFromBT();
    2766:	0e 94 17 13 	call	0x262e	; 0x262e <getByteFromBT>
    276a:	08 2f       	mov	r16, r24
				sendByteToRoomba( data );
    276c:	0e 94 32 13 	call	0x2664	; 0x2664 <sendByteToRoomba>

				/* Song length is specified in notes. Each note consists of 2 bytes (note number and note duration). */
				numberOfDataBytes = 2 * data;
    2770:	00 0f       	add	r16, r16

				/* Send notes to Roomba. */
				for( uint8_t i = 0; i < numberOfDataBytes; ++i ) {
    2772:	10 e0       	ldi	r17, 0x00	; 0
    2774:	05 c0       	rjmp	.+10     	; 0x2780 <vBluetoothReceiveServiceUART1+0xe6>
					sendByteToRoomba( getByteFromBT() );
    2776:	0e 94 17 13 	call	0x262e	; 0x262e <getByteFromBT>
    277a:	0e 94 32 13 	call	0x2664	; 0x2664 <sendByteToRoomba>

				/* Song length is specified in notes. Each note consists of 2 bytes (note number and note duration). */
				numberOfDataBytes = 2 * data;

				/* Send notes to Roomba. */
				for( uint8_t i = 0; i < numberOfDataBytes; ++i ) {
    277e:	1f 5f       	subi	r17, 0xFF	; 255
    2780:	10 17       	cp	r17, r16
    2782:	c8 f3       	brcs	.-14     	; 0x2776 <vBluetoothReceiveServiceUART1+0xdc>
    2784:	8f cf       	rjmp	.-226    	; 0x26a4 <vBluetoothReceiveServiceUART1+0xa>

00002786 <main>:
/*************************************************************/
/*                           MAIN                            */
/*************************************************************/


int main( void ) {
    2786:	ef 92       	push	r14
    2788:	ff 92       	push	r15
    278a:	0f 93       	push	r16

	/* MCU pins direction setup. */
	DDRB |= (1 << PB0);
    278c:	87 b3       	in	r24, 0x17	; 23
    278e:	81 60       	ori	r24, 0x01	; 1
    2790:	87 bb       	out	0x17, r24	; 23
	DDRB |= (1 << PB1);
    2792:	87 b3       	in	r24, 0x17	; 23
    2794:	82 60       	ori	r24, 0x02	; 2
    2796:	87 bb       	out	0x17, r24	; 23

	/* Set baud rate UART0. */
	UBRR0H = (uint8_t)(UBRR_UART0>>8);
    2798:	10 92 90 00 	sts	0x0090, r1	; 0x800090 <__TEXT_REGION_LENGTH__+0x7e0090>
	UBRR0L = (uint8_t)UBRR_UART0;
    279c:	85 e0       	ldi	r24, 0x05	; 5
    279e:	89 b9       	out	0x09, r24	; 9

	/* Set baud rate UART1. */
	UBRR1H = (uint8_t)(UBRR_UART1>>8);
    27a0:	10 92 98 00 	sts	0x0098, r1	; 0x800098 <__TEXT_REGION_LENGTH__+0x7e0098>
	UBRR1L = (uint8_t)UBRR_UART1;
    27a4:	87 e4       	ldi	r24, 0x47	; 71
    27a6:	80 93 99 00 	sts	0x0099, r24	; 0x800099 <__TEXT_REGION_LENGTH__+0x7e0099>

	/* Enable receiver and transmitter UART0. */
	UCSR0B = (1<<RXEN0)|(1<<TXEN0);
    27aa:	88 e1       	ldi	r24, 0x18	; 24
    27ac:	8a b9       	out	0x0a, r24	; 10

	/* Enable receiver and transmitter UART1. */
	UCSR1B = (1<<RXEN1)|(1<<TXEN1);
    27ae:	ea e9       	ldi	r30, 0x9A	; 154
    27b0:	f0 e0       	ldi	r31, 0x00	; 0
    27b2:	80 83       	st	Z, r24

	/* Enable interrupts. */
	UCSR0B |= (1 << RXCIE0);
    27b4:	8a b1       	in	r24, 0x0a	; 10
    27b6:	80 68       	ori	r24, 0x80	; 128
    27b8:	8a b9       	out	0x0a, r24	; 10
	UCSR1B |= (1 << RXCIE1);
    27ba:	80 81       	ld	r24, Z
    27bc:	80 68       	ori	r24, 0x80	; 128
    27be:	80 83       	st	Z, r24
	sei();
    27c0:	78 94       	sei

	/* Create queues. */
	bufferRoombaSendUART0		= xQueueCreate( 32, sizeof( uint8_t ) );
    27c2:	40 e0       	ldi	r20, 0x00	; 0
    27c4:	61 e0       	ldi	r22, 0x01	; 1
    27c6:	80 e2       	ldi	r24, 0x20	; 32
    27c8:	0e 94 5f 07 	call	0xebe	; 0xebe <xQueueGenericCreate>
    27cc:	90 93 b4 0d 	sts	0x0DB4, r25	; 0x800db4 <bufferRoombaSendUART0+0x1>
    27d0:	80 93 b3 0d 	sts	0x0DB3, r24	; 0x800db3 <bufferRoombaSendUART0>
	bufferRoombaReceiveUART0	= xQueueCreate( 32, sizeof( uint8_t ) );
    27d4:	40 e0       	ldi	r20, 0x00	; 0
    27d6:	61 e0       	ldi	r22, 0x01	; 1
    27d8:	80 e2       	ldi	r24, 0x20	; 32
    27da:	0e 94 5f 07 	call	0xebe	; 0xebe <xQueueGenericCreate>
    27de:	90 93 d7 0d 	sts	0x0DD7, r25	; 0x800dd7 <bufferRoombaReceiveUART0+0x1>
    27e2:	80 93 d6 0d 	sts	0x0DD6, r24	; 0x800dd6 <bufferRoombaReceiveUART0>
	bufferBluetoothSendUART1	= xQueueCreate( 32, sizeof( uint8_t ) );
    27e6:	40 e0       	ldi	r20, 0x00	; 0
    27e8:	61 e0       	ldi	r22, 0x01	; 1
    27ea:	80 e2       	ldi	r24, 0x20	; 32
    27ec:	0e 94 5f 07 	call	0xebe	; 0xebe <xQueueGenericCreate>
    27f0:	90 93 b6 0d 	sts	0x0DB6, r25	; 0x800db6 <bufferBluetoothSendUART1+0x1>
    27f4:	80 93 b5 0d 	sts	0x0DB5, r24	; 0x800db5 <bufferBluetoothSendUART1>
	bufferBluetoothReceiveUART1 = xQueueCreate( 32, sizeof( uint8_t ) );
    27f8:	40 e0       	ldi	r20, 0x00	; 0
    27fa:	61 e0       	ldi	r22, 0x01	; 1
    27fc:	80 e2       	ldi	r24, 0x20	; 32
    27fe:	0e 94 5f 07 	call	0xebe	; 0xebe <xQueueGenericCreate>
    2802:	90 93 ba 0d 	sts	0x0DBA, r25	; 0x800dba <bufferBluetoothReceiveUART1+0x1>
    2806:	80 93 b9 0d 	sts	0x0DB9, r24	; 0x800db9 <bufferBluetoothReceiveUART1>
	globalError					= xQueueCreate(  1, sizeof( uint8_t ) );
    280a:	40 e0       	ldi	r20, 0x00	; 0
    280c:	61 e0       	ldi	r22, 0x01	; 1
    280e:	81 e0       	ldi	r24, 0x01	; 1
    2810:	0e 94 5f 07 	call	0xebe	; 0xebe <xQueueGenericCreate>
    2814:	90 93 b8 0d 	sts	0x0DB8, r25	; 0x800db8 <globalError+0x1>
    2818:	80 93 b7 0d 	sts	0x0DB7, r24	; 0x800db7 <globalError>

	/* Create the tasks. */
	//xTaskCreate( vCyclicalTask,                  "Cyclic",  configMINIMAL_STACK_SIZE, NULL, mainLOW_PRIORITY,    NULL );
	xTaskCreate( vRoombaTransmitServiceUART0,    "UART0Tx", configMINIMAL_STACK_SIZE, NULL, mainNORMAL_PRIORITY, NULL );
    281c:	e1 2c       	mov	r14, r1
    281e:	f1 2c       	mov	r15, r1
    2820:	02 e0       	ldi	r16, 0x02	; 2
    2822:	20 e0       	ldi	r18, 0x00	; 0
    2824:	30 e0       	ldi	r19, 0x00	; 0
    2826:	45 e5       	ldi	r20, 0x55	; 85
    2828:	50 e0       	ldi	r21, 0x00	; 0
    282a:	65 e0       	ldi	r22, 0x05	; 5
    282c:	71 e0       	ldi	r23, 0x01	; 1
    282e:	88 ed       	ldi	r24, 0xD8	; 216
    2830:	92 e1       	ldi	r25, 0x12	; 18
    2832:	0e 94 28 0c 	call	0x1850	; 0x1850 <xTaskCreate>
	xTaskCreate( vBluetoothTransmitServiceUART1, "UART1Tx", configMINIMAL_STACK_SIZE, NULL, mainNORMAL_PRIORITY, NULL );
    2836:	20 e0       	ldi	r18, 0x00	; 0
    2838:	30 e0       	ldi	r19, 0x00	; 0
    283a:	45 e5       	ldi	r20, 0x55	; 85
    283c:	50 e0       	ldi	r21, 0x00	; 0
    283e:	6d e0       	ldi	r22, 0x0D	; 13
    2840:	71 e0       	ldi	r23, 0x01	; 1
    2842:	88 ec       	ldi	r24, 0xC8	; 200
    2844:	92 e1       	ldi	r25, 0x12	; 18
    2846:	0e 94 28 0c 	call	0x1850	; 0x1850 <xTaskCreate>
	xTaskCreate( vBluetoothReceiveServiceUART1,	 "UART1Rx", configMINIMAL_STACK_SIZE, NULL, mainNORMAL_PRIORITY, NULL );
    284a:	20 e0       	ldi	r18, 0x00	; 0
    284c:	30 e0       	ldi	r19, 0x00	; 0
    284e:	45 e5       	ldi	r20, 0x55	; 85
    2850:	50 e0       	ldi	r21, 0x00	; 0
    2852:	65 e1       	ldi	r22, 0x15	; 21
    2854:	71 e0       	ldi	r23, 0x01	; 1
    2856:	8d e4       	ldi	r24, 0x4D	; 77
    2858:	93 e1       	ldi	r25, 0x13	; 19
    285a:	0e 94 28 0c 	call	0x1850	; 0x1850 <xTaskCreate>
	//xTaskCreate( vErrorHandler,                  "Error",   configMINIMAL_STACK_SIZE, NULL, mainHIGH_PRIORITY,   NULL );

	vTaskStartScheduler();
    285e:	0e 94 7c 0c 	call	0x18f8	; 0x18f8 <vTaskStartScheduler>

	return 0;
}
    2862:	80 e0       	ldi	r24, 0x00	; 0
    2864:	90 e0       	ldi	r25, 0x00	; 0
    2866:	0f 91       	pop	r16
    2868:	ff 90       	pop	r15
    286a:	ef 90       	pop	r14
    286c:	08 95       	ret

0000286e <vApplicationIdleHook>:
		
	}
}


void vApplicationIdleHook( void ) {
    286e:	08 95       	ret

00002870 <__vector_18>:
/*************************************************************/
/*                INTERRUPT SERVICE ROUTINES                 */
/*************************************************************/


ISR(USART0_RX_vect) {
    2870:	1f 92       	push	r1
    2872:	0f 92       	push	r0
    2874:	0f b6       	in	r0, 0x3f	; 63
    2876:	0f 92       	push	r0
    2878:	11 24       	eor	r1, r1
    287a:	2f 93       	push	r18
    287c:	3f 93       	push	r19
    287e:	4f 93       	push	r20
    2880:	5f 93       	push	r21
    2882:	6f 93       	push	r22
    2884:	7f 93       	push	r23
    2886:	8f 93       	push	r24
    2888:	9f 93       	push	r25
    288a:	af 93       	push	r26
    288c:	bf 93       	push	r27
    288e:	ef 93       	push	r30
    2890:	ff 93       	push	r31
	/* UART0 receive complete ISR. 
	   Pushes received byte from UDR0 register on bufferRoombaReceiveUART0 queue. */
	xQueueSendToBackFromISR( bufferRoombaReceiveUART0, &UDR0, NULL);
    2892:	20 e0       	ldi	r18, 0x00	; 0
    2894:	40 e0       	ldi	r20, 0x00	; 0
    2896:	50 e0       	ldi	r21, 0x00	; 0
    2898:	6c e2       	ldi	r22, 0x2C	; 44
    289a:	70 e0       	ldi	r23, 0x00	; 0
    289c:	80 91 d6 0d 	lds	r24, 0x0DD6	; 0x800dd6 <bufferRoombaReceiveUART0>
    28a0:	90 91 d7 0d 	lds	r25, 0x0DD7	; 0x800dd7 <bufferRoombaReceiveUART0+0x1>
    28a4:	0e 94 39 08 	call	0x1072	; 0x1072 <xQueueGenericSendFromISR>
}
    28a8:	ff 91       	pop	r31
    28aa:	ef 91       	pop	r30
    28ac:	bf 91       	pop	r27
    28ae:	af 91       	pop	r26
    28b0:	9f 91       	pop	r25
    28b2:	8f 91       	pop	r24
    28b4:	7f 91       	pop	r23
    28b6:	6f 91       	pop	r22
    28b8:	5f 91       	pop	r21
    28ba:	4f 91       	pop	r20
    28bc:	3f 91       	pop	r19
    28be:	2f 91       	pop	r18
    28c0:	0f 90       	pop	r0
    28c2:	0f be       	out	0x3f, r0	; 63
    28c4:	0f 90       	pop	r0
    28c6:	1f 90       	pop	r1
    28c8:	18 95       	reti

000028ca <__vector_30>:

ISR(USART1_RX_vect) {
    28ca:	1f 92       	push	r1
    28cc:	0f 92       	push	r0
    28ce:	0f b6       	in	r0, 0x3f	; 63
    28d0:	0f 92       	push	r0
    28d2:	11 24       	eor	r1, r1
    28d4:	2f 93       	push	r18
    28d6:	3f 93       	push	r19
    28d8:	4f 93       	push	r20
    28da:	5f 93       	push	r21
    28dc:	6f 93       	push	r22
    28de:	7f 93       	push	r23
    28e0:	8f 93       	push	r24
    28e2:	9f 93       	push	r25
    28e4:	af 93       	push	r26
    28e6:	bf 93       	push	r27
    28e8:	ef 93       	push	r30
    28ea:	ff 93       	push	r31
/* UART1 receive complete ISR. 
	   Pushes received byte from UDR1 register on bufferBluetoothReceiveUART1 queue. */
	xQueueSendToBackFromISR( bufferBluetoothReceiveUART1, &UDR1, NULL);
    28ec:	20 e0       	ldi	r18, 0x00	; 0
    28ee:	40 e0       	ldi	r20, 0x00	; 0
    28f0:	50 e0       	ldi	r21, 0x00	; 0
    28f2:	6c e9       	ldi	r22, 0x9C	; 156
    28f4:	70 e0       	ldi	r23, 0x00	; 0
    28f6:	80 91 b9 0d 	lds	r24, 0x0DB9	; 0x800db9 <bufferBluetoothReceiveUART1>
    28fa:	90 91 ba 0d 	lds	r25, 0x0DBA	; 0x800dba <bufferBluetoothReceiveUART1+0x1>
    28fe:	0e 94 39 08 	call	0x1072	; 0x1072 <xQueueGenericSendFromISR>
}
    2902:	ff 91       	pop	r31
    2904:	ef 91       	pop	r30
    2906:	bf 91       	pop	r27
    2908:	af 91       	pop	r26
    290a:	9f 91       	pop	r25
    290c:	8f 91       	pop	r24
    290e:	7f 91       	pop	r23
    2910:	6f 91       	pop	r22
    2912:	5f 91       	pop	r21
    2914:	4f 91       	pop	r20
    2916:	3f 91       	pop	r19
    2918:	2f 91       	pop	r18
    291a:	0f 90       	pop	r0
    291c:	0f be       	out	0x3f, r0	; 63
    291e:	0f 90       	pop	r0
    2920:	1f 90       	pop	r1
    2922:	18 95       	reti

00002924 <USART_Init>:
#define UBRR_UART0 (uint16_t)(F_CPU/(16*BAUD_UART0)-1)
#define UBRR_UART1 (uint16_t)(F_CPU/(16*BAUD_UART1)-1)

void USART_Init(void) {
	/* Set baud rate UART0 */
	UBRR0H = (uint8_t)(UBRR_UART0>>8);
    2924:	10 92 90 00 	sts	0x0090, r1	; 0x800090 <__TEXT_REGION_LENGTH__+0x7e0090>
	UBRR0L = (uint8_t)UBRR_UART0;
    2928:	85 e0       	ldi	r24, 0x05	; 5
    292a:	89 b9       	out	0x09, r24	; 9
	/* Set baud rate UART1 */
	UBRR1H = (uint8_t)(UBRR_UART1>>8);
    292c:	10 92 98 00 	sts	0x0098, r1	; 0x800098 <__TEXT_REGION_LENGTH__+0x7e0098>
	UBRR1L = (uint8_t)UBRR_UART1;
    2930:	87 e4       	ldi	r24, 0x47	; 71
    2932:	80 93 99 00 	sts	0x0099, r24	; 0x800099 <__TEXT_REGION_LENGTH__+0x7e0099>

	/* Enable receiver and transmitter UART0 */
	UCSR0B = (1<<RXEN0)|(1<<TXEN0);
    2936:	88 e1       	ldi	r24, 0x18	; 24
    2938:	8a b9       	out	0x0a, r24	; 10
	/* Enable receiver and transmitter UART1 */
	UCSR1B = (1<<RXEN1)|(1<<TXEN1);
    293a:	80 93 9a 00 	sts	0x009A, r24	; 0x80009a <__TEXT_REGION_LENGTH__+0x7e009a>
    293e:	08 95       	ret

00002940 <USART_SendByte>:
	/* Wait for empty transmit buffer */
	//while ( !( UCSR0A & (1<<UDRE0)) );
	while(!UDRE0);

	/* Put data into buffer, sends the data */
	UDR0 = data;
    2940:	8c b9       	out	0x0c, r24	; 12
    2942:	08 95       	ret

00002944 <USART0_SendChar>:

	/* Wait for empty transmit buffer */
	while(!UDRE0);

	/* Put data into buffer, sends the data */
	UDR0 = c;
    2944:	8c b9       	out	0x0c, r24	; 12
    2946:	08 95       	ret

00002948 <USART0_SendString>:
}

// Max 256 characters
void USART0_SendString(unsigned char *str) {
    2948:	ac 01       	movw	r20, r24

	for(uint8_t i = 0; str[i] != '\0'; ++i) {
    294a:	90 e0       	ldi	r25, 0x00	; 0
    294c:	04 c0       	rjmp	.+8      	; 0x2956 <USART0_SendString+0xe>
		while(!( UCSR0A & (1<<UDRE0)));		// Wait for empty transmit buffer
    294e:	5d 9b       	sbis	0x0b, 5	; 11
    2950:	fe cf       	rjmp	.-4      	; 0x294e <USART0_SendString+0x6>
		UDR0 = str[i];						// Put character into buffer and send
    2952:	2c b9       	out	0x0c, r18	; 12
}

// Max 256 characters
void USART0_SendString(unsigned char *str) {

	for(uint8_t i = 0; str[i] != '\0'; ++i) {
    2954:	9f 5f       	subi	r25, 0xFF	; 255
    2956:	fa 01       	movw	r30, r20
    2958:	e9 0f       	add	r30, r25
    295a:	f1 1d       	adc	r31, r1
    295c:	20 81       	ld	r18, Z
    295e:	21 11       	cpse	r18, r1
    2960:	f6 cf       	rjmp	.-20     	; 0x294e <USART0_SendString+0x6>
		while(!( UCSR0A & (1<<UDRE0)));		// Wait for empty transmit buffer
		UDR0 = str[i];						// Put character into buffer and send
	}
}
    2962:	08 95       	ret

00002964 <USART_ReceiveByte>:

// Wait until a byte has been received and return received data
uint8_t USART_ReceiveByte() {
	while((UCSR0A &(1<<RXC)) == 0);
    2964:	5f 9b       	sbis	0x0b, 7	; 11
    2966:	fe cf       	rjmp	.-4      	; 0x2964 <USART_ReceiveByte>
	return UDR0;
    2968:	8c b1       	in	r24, 0x0c	; 12
    296a:	08 95       	ret

0000296c <makeMessage>:
#include "message.h"
#include "msgHeaders.h"

void makeMessage(Message* message, uint8_t type, uint8_t id, uint8_t* data) {
    296c:	fc 01       	movw	r30, r24
	message->type = type;
    296e:	60 83       	st	Z, r22
	message->id = id;
    2970:	41 83       	std	Z+1, r20	; 0x01
	message->data = data;
    2972:	33 83       	std	Z+3, r19	; 0x03
    2974:	22 83       	std	Z+2, r18	; 0x02
    2976:	08 95       	ret

00002978 <getMessage>:
}

void getMessage(Message* message, uint8_t* buffer) {
    2978:	cf 93       	push	r28
    297a:	df 93       	push	r29
    297c:	ec 01       	movw	r28, r24
    297e:	db 01       	movw	r26, r22
	uint8_t c = 0;
	buffer[c++] = START;
    2980:	8b e7       	ldi	r24, 0x7B	; 123
    2982:	8c 93       	st	X, r24
	buffer[c++] = message->type;
    2984:	88 81       	ld	r24, Y
    2986:	11 96       	adiw	r26, 0x01	; 1
    2988:	8c 93       	st	X, r24
    298a:	11 97       	sbiw	r26, 0x01	; 1
	buffer[c++] = message->id;
    298c:	89 81       	ldd	r24, Y+1	; 0x01
    298e:	12 96       	adiw	r26, 0x02	; 2
    2990:	8c 93       	st	X, r24
    2992:	12 97       	sbiw	r26, 0x02	; 2
	switch(message->type) {
    2994:	88 81       	ld	r24, Y
    2996:	81 34       	cpi	r24, 0x41	; 65
    2998:	49 f0       	breq	.+18     	; 0x29ac <getMessage+0x34>
    299a:	13 c0       	rjmp	.+38     	; 0x29c2 <getMessage+0x4a>
		case TEXT:
			for(int i = 0; message->data[i] != 0; ++i) {
				buffer[c++] = message->data[i];
    299c:	fd 01       	movw	r30, r26
    299e:	e9 0f       	add	r30, r25
    29a0:	f1 1d       	adc	r31, r1
    29a2:	40 83       	st	Z, r20
	buffer[c++] = START;
	buffer[c++] = message->type;
	buffer[c++] = message->id;
	switch(message->type) {
		case TEXT:
			for(int i = 0; message->data[i] != 0; ++i) {
    29a4:	2f 5f       	subi	r18, 0xFF	; 255
    29a6:	3f 4f       	sbci	r19, 0xFF	; 255
				buffer[c++] = message->data[i];
    29a8:	9f 5f       	subi	r25, 0xFF	; 255
    29aa:	03 c0       	rjmp	.+6      	; 0x29b2 <getMessage+0x3a>
void getMessage(Message* message, uint8_t* buffer) {
	uint8_t c = 0;
	buffer[c++] = START;
	buffer[c++] = message->type;
	buffer[c++] = message->id;
	switch(message->type) {
    29ac:	20 e0       	ldi	r18, 0x00	; 0
    29ae:	30 e0       	ldi	r19, 0x00	; 0
    29b0:	93 e0       	ldi	r25, 0x03	; 3
		case TEXT:
			for(int i = 0; message->data[i] != 0; ++i) {
    29b2:	ea 81       	ldd	r30, Y+2	; 0x02
    29b4:	fb 81       	ldd	r31, Y+3	; 0x03
    29b6:	e2 0f       	add	r30, r18
    29b8:	f3 1f       	adc	r31, r19
    29ba:	40 81       	ld	r20, Z
    29bc:	41 11       	cpse	r20, r1
    29be:	ee cf       	rjmp	.-36     	; 0x299c <getMessage+0x24>
    29c0:	07 c0       	rjmp	.+14     	; 0x29d0 <getMessage+0x58>
			}
			break;
		case LIGHT_SENSOR:
		case SOUND_SENSOR:
		default:
			buffer[c++] = *(message->data);
    29c2:	ea 81       	ldd	r30, Y+2	; 0x02
    29c4:	fb 81       	ldd	r31, Y+3	; 0x03
    29c6:	80 81       	ld	r24, Z
    29c8:	13 96       	adiw	r26, 0x03	; 3
    29ca:	8c 93       	st	X, r24
    29cc:	13 97       	sbiw	r26, 0x03	; 3
    29ce:	94 e0       	ldi	r25, 0x04	; 4
			break;
	}
	buffer[c++] = END;
    29d0:	81 e0       	ldi	r24, 0x01	; 1
    29d2:	89 0f       	add	r24, r25
    29d4:	fd 01       	movw	r30, r26
    29d6:	e9 0f       	add	r30, r25
    29d8:	f1 1d       	adc	r31, r1
    29da:	9d e7       	ldi	r25, 0x7D	; 125
    29dc:	90 83       	st	Z, r25
	buffer[c] = 0;
    29de:	a8 0f       	add	r26, r24
    29e0:	b1 1d       	adc	r27, r1
    29e2:	1c 92       	st	X, r1
}
    29e4:	df 91       	pop	r29
    29e6:	cf 91       	pop	r28
    29e8:	08 95       	ret

000029ea <xSerialPortInitMinimal>:
	UCSR0B = ucInByte;										\
}
/*-----------------------------------------------------------*/

xComPortHandle xSerialPortInitMinimal( unsigned long ulWantedBaud, unsigned portBASE_TYPE uxQueueLength )
{
    29ea:	cf 92       	push	r12
    29ec:	df 92       	push	r13
    29ee:	ef 92       	push	r14
    29f0:	ff 92       	push	r15
    29f2:	cf 93       	push	r28
    29f4:	6b 01       	movw	r12, r22
    29f6:	7c 01       	movw	r14, r24
    29f8:	c4 2f       	mov	r28, r20
unsigned long ulBaudRateCounter;
unsigned char ucByte;

	portENTER_CRITICAL();
    29fa:	0f b6       	in	r0, 0x3f	; 63
    29fc:	f8 94       	cli
    29fe:	0f 92       	push	r0
	{
		/* Create the queues used by the com test task. */
		xRxedChars = xQueueCreate( uxQueueLength, ( unsigned portBASE_TYPE ) sizeof( signed char ) );
    2a00:	40 e0       	ldi	r20, 0x00	; 0
    2a02:	61 e0       	ldi	r22, 0x01	; 1
    2a04:	8c 2f       	mov	r24, r28
    2a06:	0e 94 5f 07 	call	0xebe	; 0xebe <xQueueGenericCreate>
    2a0a:	90 93 b2 0d 	sts	0x0DB2, r25	; 0x800db2 <xRxedChars+0x1>
    2a0e:	80 93 b1 0d 	sts	0x0DB1, r24	; 0x800db1 <xRxedChars>
		xCharsForTx = xQueueCreate( uxQueueLength, ( unsigned portBASE_TYPE ) sizeof( signed char ) );
    2a12:	40 e0       	ldi	r20, 0x00	; 0
    2a14:	61 e0       	ldi	r22, 0x01	; 1
    2a16:	8c 2f       	mov	r24, r28
    2a18:	0e 94 5f 07 	call	0xebe	; 0xebe <xQueueGenericCreate>
    2a1c:	90 93 b0 0d 	sts	0x0DB0, r25	; 0x800db0 <xCharsForTx+0x1>
    2a20:	80 93 af 0d 	sts	0x0DAF, r24	; 0x800daf <xCharsForTx>

		/* Calculate the baud rate register value from the equation in the
		data sheet. */
		ulBaudRateCounter = ( configCPU_CLOCK_HZ / ( serBAUD_DIV_CONSTANT * ulWantedBaud ) ) - ( unsigned long ) 1;
    2a24:	d7 01       	movw	r26, r14
    2a26:	c6 01       	movw	r24, r12
    2a28:	88 0f       	add	r24, r24
    2a2a:	99 1f       	adc	r25, r25
    2a2c:	aa 1f       	adc	r26, r26
    2a2e:	bb 1f       	adc	r27, r27
    2a30:	88 0f       	add	r24, r24
    2a32:	99 1f       	adc	r25, r25
    2a34:	aa 1f       	adc	r26, r26
    2a36:	bb 1f       	adc	r27, r27
    2a38:	9c 01       	movw	r18, r24
    2a3a:	ad 01       	movw	r20, r26
    2a3c:	22 0f       	add	r18, r18
    2a3e:	33 1f       	adc	r19, r19
    2a40:	44 1f       	adc	r20, r20
    2a42:	55 1f       	adc	r21, r21
    2a44:	22 0f       	add	r18, r18
    2a46:	33 1f       	adc	r19, r19
    2a48:	44 1f       	adc	r20, r20
    2a4a:	55 1f       	adc	r21, r21
    2a4c:	60 e0       	ldi	r22, 0x00	; 0
    2a4e:	70 ec       	ldi	r23, 0xC0	; 192
    2a50:	88 ea       	ldi	r24, 0xA8	; 168
    2a52:	90 e0       	ldi	r25, 0x00	; 0
    2a54:	0e 94 f6 15 	call	0x2bec	; 0x2bec <__udivmodsi4>
    2a58:	da 01       	movw	r26, r20
    2a5a:	c9 01       	movw	r24, r18
    2a5c:	01 97       	sbiw	r24, 0x01	; 1
    2a5e:	a1 09       	sbc	r26, r1
    2a60:	b1 09       	sbc	r27, r1

		/* Set the baud rate. */	
		ucByte = ( unsigned char ) ( ulBaudRateCounter & ( unsigned long ) 0xff );	
		UBRR0L = ucByte;
    2a62:	89 b9       	out	0x09, r24	; 9

		ulBaudRateCounter >>= ( unsigned long ) 8;
    2a64:	89 2f       	mov	r24, r25
    2a66:	9a 2f       	mov	r25, r26
    2a68:	ab 2f       	mov	r26, r27
    2a6a:	bb 27       	eor	r27, r27
		ucByte = ( unsigned char ) ( ulBaudRateCounter & ( unsigned long ) 0xff );	
		UBRR0H = ucByte;
    2a6c:	80 93 90 00 	sts	0x0090, r24	; 0x800090 <__TEXT_REGION_LENGTH__+0x7e0090>

		/* Enable the Rx interrupt.  The Tx interrupt will get enabled
		later. Also enable the Rx and Tx. */
		UCSR0B = ( serRX_INT_ENABLE | serRX_ENABLE | serTX_ENABLE );
    2a70:	88 e9       	ldi	r24, 0x98	; 152
    2a72:	8a b9       	out	0x0a, r24	; 10

		/* Set the data bits to 8. */
		UCSR0C = ( serUCSRC_SELECT | serEIGHT_DATA_BITS );
    2a74:	86 e8       	ldi	r24, 0x86	; 134
    2a76:	80 93 95 00 	sts	0x0095, r24	; 0x800095 <__TEXT_REGION_LENGTH__+0x7e0095>
	}
	portEXIT_CRITICAL();
    2a7a:	0f 90       	pop	r0
    2a7c:	0f be       	out	0x3f, r0	; 63
	
	/* Unlike other ports, this serial code does not allow for more than one
	com port.  We therefore don't return a pointer to a port structure and can
	instead just return NULL. */
	return NULL;
}
    2a7e:	80 e0       	ldi	r24, 0x00	; 0
    2a80:	90 e0       	ldi	r25, 0x00	; 0
    2a82:	cf 91       	pop	r28
    2a84:	ff 90       	pop	r15
    2a86:	ef 90       	pop	r14
    2a88:	df 90       	pop	r13
    2a8a:	cf 90       	pop	r12
    2a8c:	08 95       	ret

00002a8e <xSerialGetChar>:
	/* Only one port is supported. */
	( void ) pxPort;

	/* Get the next character from the buffer.  Return false if no characters
	are available, or arrive before xBlockTime expires. */
	if( xQueueReceive( xRxedChars, pcRxedChar, xBlockTime ) )
    2a8e:	20 e0       	ldi	r18, 0x00	; 0
    2a90:	80 91 b1 0d 	lds	r24, 0x0DB1	; 0x800db1 <xRxedChars>
    2a94:	90 91 b2 0d 	lds	r25, 0x0DB2	; 0x800db2 <xRxedChars+0x1>
    2a98:	0e 94 9c 08 	call	0x1138	; 0x1138 <xQueueGenericReceive>
    2a9c:	81 11       	cpse	r24, r1
	{
		return pdTRUE;
    2a9e:	81 e0       	ldi	r24, 0x01	; 1
	}
	else
	{
		return pdFALSE;
	}
}
    2aa0:	08 95       	ret

00002aa2 <xSerialPutChar>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xSerialPutChar( xComPortHandle pxPort, signed char cOutChar, TickType_t xBlockTime )
{
    2aa2:	cf 93       	push	r28
    2aa4:	df 93       	push	r29
    2aa6:	1f 92       	push	r1
    2aa8:	cd b7       	in	r28, 0x3d	; 61
    2aaa:	de b7       	in	r29, 0x3e	; 62
    2aac:	69 83       	std	Y+1, r22	; 0x01
	/* Only one port is supported. */
	( void ) pxPort;

	/* Return false if after the block time there is no room on the Tx queue. */
	if( xQueueSend( xCharsForTx, &cOutChar, xBlockTime ) != pdPASS )
    2aae:	20 e0       	ldi	r18, 0x00	; 0
    2ab0:	be 01       	movw	r22, r28
    2ab2:	6f 5f       	subi	r22, 0xFF	; 255
    2ab4:	7f 4f       	sbci	r23, 0xFF	; 255
    2ab6:	80 91 af 0d 	lds	r24, 0x0DAF	; 0x800daf <xCharsForTx>
    2aba:	90 91 b0 0d 	lds	r25, 0x0DB0	; 0x800db0 <xCharsForTx+0x1>
    2abe:	0e 94 89 07 	call	0xf12	; 0xf12 <xQueueGenericSend>
    2ac2:	81 30       	cpi	r24, 0x01	; 1
    2ac4:	21 f4       	brne	.+8      	; 0x2ace <xSerialPutChar+0x2c>
	{
		return pdFAIL;
	}

	vInterruptOn();
    2ac6:	9a b1       	in	r25, 0x0a	; 10
    2ac8:	90 62       	ori	r25, 0x20	; 32
    2aca:	9a b9       	out	0x0a, r25	; 10

	return pdPASS;
    2acc:	01 c0       	rjmp	.+2      	; 0x2ad0 <xSerialPutChar+0x2e>
	( void ) pxPort;

	/* Return false if after the block time there is no room on the Tx queue. */
	if( xQueueSend( xCharsForTx, &cOutChar, xBlockTime ) != pdPASS )
	{
		return pdFAIL;
    2ace:	80 e0       	ldi	r24, 0x00	; 0
	}

	vInterruptOn();

	return pdPASS;
}
    2ad0:	0f 90       	pop	r0
    2ad2:	df 91       	pop	r29
    2ad4:	cf 91       	pop	r28
    2ad6:	08 95       	ret

00002ad8 <vSerialClose>:
	( void ) xPort;

	/* Turn off the interrupts.  We may also want to delete the queues and/or
	re-install the original ISR. */

	portENTER_CRITICAL();
    2ad8:	0f b6       	in	r0, 0x3f	; 63
    2ada:	f8 94       	cli
    2adc:	0f 92       	push	r0
	{
		vInterruptOff();
    2ade:	8a b1       	in	r24, 0x0a	; 10
    2ae0:	8f 7d       	andi	r24, 0xDF	; 223
    2ae2:	8a b9       	out	0x0a, r24	; 10
		ucByte = UCSR0B;
    2ae4:	8a b1       	in	r24, 0x0a	; 10
		ucByte &= ~serRX_INT_ENABLE;
    2ae6:	8f 77       	andi	r24, 0x7F	; 127
		UCSR0B = ucByte;
    2ae8:	8a b9       	out	0x0a, r24	; 10
	}
	portEXIT_CRITICAL();
    2aea:	0f 90       	pop	r0
    2aec:	0f be       	out	0x3f, r0	; 63
    2aee:	08 95       	ret

00002af0 <SIG_UART_RECV>:
}
/*-----------------------------------------------------------*/

SIGNAL( SIG_UART_RECV )
{
    2af0:	1f 92       	push	r1
    2af2:	0f 92       	push	r0
    2af4:	0f b6       	in	r0, 0x3f	; 63
    2af6:	0f 92       	push	r0
    2af8:	11 24       	eor	r1, r1
    2afa:	2f 93       	push	r18
    2afc:	3f 93       	push	r19
    2afe:	4f 93       	push	r20
    2b00:	5f 93       	push	r21
    2b02:	6f 93       	push	r22
    2b04:	7f 93       	push	r23
    2b06:	8f 93       	push	r24
    2b08:	9f 93       	push	r25
    2b0a:	af 93       	push	r26
    2b0c:	bf 93       	push	r27
    2b0e:	ef 93       	push	r30
    2b10:	ff 93       	push	r31
    2b12:	cf 93       	push	r28
    2b14:	df 93       	push	r29
    2b16:	00 d0       	rcall	.+0      	; 0x2b18 <SIG_UART_RECV+0x28>
    2b18:	cd b7       	in	r28, 0x3d	; 61
    2b1a:	de b7       	in	r29, 0x3e	; 62
signed char cChar;
signed portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
    2b1c:	1a 82       	std	Y+2, r1	; 0x02

	/* Get the character and post it on the queue of Rxed characters.
	If the post causes a task to wake force a context switch as the woken task
	may have a higher priority than the task we have interrupted. */
	cChar = UDR0;
    2b1e:	8c b1       	in	r24, 0x0c	; 12
    2b20:	89 83       	std	Y+1, r24	; 0x01

	xQueueSendFromISR( xRxedChars, &cChar, &xHigherPriorityTaskWoken );
    2b22:	20 e0       	ldi	r18, 0x00	; 0
    2b24:	ae 01       	movw	r20, r28
    2b26:	4e 5f       	subi	r20, 0xFE	; 254
    2b28:	5f 4f       	sbci	r21, 0xFF	; 255
    2b2a:	be 01       	movw	r22, r28
    2b2c:	6f 5f       	subi	r22, 0xFF	; 255
    2b2e:	7f 4f       	sbci	r23, 0xFF	; 255
    2b30:	80 91 b1 0d 	lds	r24, 0x0DB1	; 0x800db1 <xRxedChars>
    2b34:	90 91 b2 0d 	lds	r25, 0x0DB2	; 0x800db2 <xRxedChars+0x1>
    2b38:	0e 94 39 08 	call	0x1072	; 0x1072 <xQueueGenericSendFromISR>

	if( xHigherPriorityTaskWoken != pdFALSE )
    2b3c:	8a 81       	ldd	r24, Y+2	; 0x02
    2b3e:	81 11       	cpse	r24, r1
	{
		taskYIELD();
    2b40:	0e 94 42 05 	call	0xa84	; 0xa84 <vPortYield>
	}
}
    2b44:	0f 90       	pop	r0
    2b46:	0f 90       	pop	r0
    2b48:	df 91       	pop	r29
    2b4a:	cf 91       	pop	r28
    2b4c:	ff 91       	pop	r31
    2b4e:	ef 91       	pop	r30
    2b50:	bf 91       	pop	r27
    2b52:	af 91       	pop	r26
    2b54:	9f 91       	pop	r25
    2b56:	8f 91       	pop	r24
    2b58:	7f 91       	pop	r23
    2b5a:	6f 91       	pop	r22
    2b5c:	5f 91       	pop	r21
    2b5e:	4f 91       	pop	r20
    2b60:	3f 91       	pop	r19
    2b62:	2f 91       	pop	r18
    2b64:	0f 90       	pop	r0
    2b66:	0f be       	out	0x3f, r0	; 63
    2b68:	0f 90       	pop	r0
    2b6a:	1f 90       	pop	r1
    2b6c:	18 95       	reti

00002b6e <SIG_UART_DATA>:
/*-----------------------------------------------------------*/

SIGNAL( SIG_UART_DATA )
{
    2b6e:	1f 92       	push	r1
    2b70:	0f 92       	push	r0
    2b72:	0f b6       	in	r0, 0x3f	; 63
    2b74:	0f 92       	push	r0
    2b76:	11 24       	eor	r1, r1
    2b78:	2f 93       	push	r18
    2b7a:	3f 93       	push	r19
    2b7c:	4f 93       	push	r20
    2b7e:	5f 93       	push	r21
    2b80:	6f 93       	push	r22
    2b82:	7f 93       	push	r23
    2b84:	8f 93       	push	r24
    2b86:	9f 93       	push	r25
    2b88:	af 93       	push	r26
    2b8a:	bf 93       	push	r27
    2b8c:	ef 93       	push	r30
    2b8e:	ff 93       	push	r31
    2b90:	cf 93       	push	r28
    2b92:	df 93       	push	r29
    2b94:	00 d0       	rcall	.+0      	; 0x2b96 <SIG_UART_DATA+0x28>
    2b96:	cd b7       	in	r28, 0x3d	; 61
    2b98:	de b7       	in	r29, 0x3e	; 62
signed char cChar, cTaskWoken;

	if( xQueueReceiveFromISR( xCharsForTx, &cChar, &cTaskWoken ) == pdTRUE )
    2b9a:	ae 01       	movw	r20, r28
    2b9c:	4e 5f       	subi	r20, 0xFE	; 254
    2b9e:	5f 4f       	sbci	r21, 0xFF	; 255
    2ba0:	be 01       	movw	r22, r28
    2ba2:	6f 5f       	subi	r22, 0xFF	; 255
    2ba4:	7f 4f       	sbci	r23, 0xFF	; 255
    2ba6:	80 91 af 0d 	lds	r24, 0x0DAF	; 0x800daf <xCharsForTx>
    2baa:	90 91 b0 0d 	lds	r25, 0x0DB0	; 0x800db0 <xCharsForTx+0x1>
    2bae:	0e 94 5d 09 	call	0x12ba	; 0x12ba <xQueueReceiveFromISR>
    2bb2:	81 30       	cpi	r24, 0x01	; 1
    2bb4:	19 f4       	brne	.+6      	; 0x2bbc <SIG_UART_DATA+0x4e>
	{
		/* Send the next character queued for Tx. */
		UDR0 = cChar;
    2bb6:	89 81       	ldd	r24, Y+1	; 0x01
    2bb8:	8c b9       	out	0x0c, r24	; 12
    2bba:	03 c0       	rjmp	.+6      	; 0x2bc2 <SIG_UART_DATA+0x54>
	}
	else
	{
		/* Queue empty, nothing to send. */
		vInterruptOff();
    2bbc:	8a b1       	in	r24, 0x0a	; 10
    2bbe:	8f 7d       	andi	r24, 0xDF	; 223
    2bc0:	8a b9       	out	0x0a, r24	; 10
	}
}
    2bc2:	0f 90       	pop	r0
    2bc4:	0f 90       	pop	r0
    2bc6:	df 91       	pop	r29
    2bc8:	cf 91       	pop	r28
    2bca:	ff 91       	pop	r31
    2bcc:	ef 91       	pop	r30
    2bce:	bf 91       	pop	r27
    2bd0:	af 91       	pop	r26
    2bd2:	9f 91       	pop	r25
    2bd4:	8f 91       	pop	r24
    2bd6:	7f 91       	pop	r23
    2bd8:	6f 91       	pop	r22
    2bda:	5f 91       	pop	r21
    2bdc:	4f 91       	pop	r20
    2bde:	3f 91       	pop	r19
    2be0:	2f 91       	pop	r18
    2be2:	0f 90       	pop	r0
    2be4:	0f be       	out	0x3f, r0	; 63
    2be6:	0f 90       	pop	r0
    2be8:	1f 90       	pop	r1
    2bea:	18 95       	reti

00002bec <__udivmodsi4>:
    2bec:	a1 e2       	ldi	r26, 0x21	; 33
    2bee:	1a 2e       	mov	r1, r26
    2bf0:	aa 1b       	sub	r26, r26
    2bf2:	bb 1b       	sub	r27, r27
    2bf4:	fd 01       	movw	r30, r26
    2bf6:	0d c0       	rjmp	.+26     	; 0x2c12 <__udivmodsi4_ep>

00002bf8 <__udivmodsi4_loop>:
    2bf8:	aa 1f       	adc	r26, r26
    2bfa:	bb 1f       	adc	r27, r27
    2bfc:	ee 1f       	adc	r30, r30
    2bfe:	ff 1f       	adc	r31, r31
    2c00:	a2 17       	cp	r26, r18
    2c02:	b3 07       	cpc	r27, r19
    2c04:	e4 07       	cpc	r30, r20
    2c06:	f5 07       	cpc	r31, r21
    2c08:	20 f0       	brcs	.+8      	; 0x2c12 <__udivmodsi4_ep>
    2c0a:	a2 1b       	sub	r26, r18
    2c0c:	b3 0b       	sbc	r27, r19
    2c0e:	e4 0b       	sbc	r30, r20
    2c10:	f5 0b       	sbc	r31, r21

00002c12 <__udivmodsi4_ep>:
    2c12:	66 1f       	adc	r22, r22
    2c14:	77 1f       	adc	r23, r23
    2c16:	88 1f       	adc	r24, r24
    2c18:	99 1f       	adc	r25, r25
    2c1a:	1a 94       	dec	r1
    2c1c:	69 f7       	brne	.-38     	; 0x2bf8 <__udivmodsi4_loop>
    2c1e:	60 95       	com	r22
    2c20:	70 95       	com	r23
    2c22:	80 95       	com	r24
    2c24:	90 95       	com	r25
    2c26:	9b 01       	movw	r18, r22
    2c28:	ac 01       	movw	r20, r24
    2c2a:	bd 01       	movw	r22, r26
    2c2c:	cf 01       	movw	r24, r30
    2c2e:	08 95       	ret

00002c30 <__tablejump2__>:
    2c30:	ee 0f       	add	r30, r30
    2c32:	ff 1f       	adc	r31, r31
    2c34:	05 90       	lpm	r0, Z+
    2c36:	f4 91       	lpm	r31, Z
    2c38:	e0 2d       	mov	r30, r0
    2c3a:	09 94       	ijmp

00002c3c <memcpy>:
    2c3c:	fb 01       	movw	r30, r22
    2c3e:	dc 01       	movw	r26, r24
    2c40:	02 c0       	rjmp	.+4      	; 0x2c46 <memcpy+0xa>
    2c42:	01 90       	ld	r0, Z+
    2c44:	0d 92       	st	X+, r0
    2c46:	41 50       	subi	r20, 0x01	; 1
    2c48:	50 40       	sbci	r21, 0x00	; 0
    2c4a:	d8 f7       	brcc	.-10     	; 0x2c42 <memcpy+0x6>
    2c4c:	08 95       	ret

00002c4e <_exit>:
    2c4e:	f8 94       	cli

00002c50 <__stop_program>:
    2c50:	ff cf       	rjmp	.-2      	; 0x2c50 <__stop_program>
